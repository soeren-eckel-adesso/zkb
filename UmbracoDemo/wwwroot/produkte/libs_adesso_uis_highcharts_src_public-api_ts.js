"use strict";
(self["webpackChunkweb_adesso_demo"] = self["webpackChunkweb_adesso_demo"] || []).push([["libs_adesso_uis_highcharts_src_public-api_ts"],{

/***/ 78157:
/*!*****************************************************************************************!*\
  !*** ./libs/@adesso/uis/highcharts/src/components/line/highcharts-line-ui.component.ts ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HighchartsLineUiComponent": () => (/* binding */ HighchartsLineUiComponent)
/* harmony export */ });
/* harmony import */ var angular_highcharts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! angular-highcharts */ 34120);
/* harmony import */ var _adesso_util_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adesso/util-environment */ 56489);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 30839);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 94650);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ 36895);







function HighchartsLineUiComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](1, "div", 1);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const chart_r1 = ctx.ngIf;
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("chart", chart_r1);
  }
}
class HighchartsLineUiComponent {
  environmentService;
  chartHeight = "240px";
  set height(value) {
    if (value) {
      this.chartHeight = value;
    }
  }
  set instrument(value) {
    if (value) {
      this.instrumentModel = value;
      if (this.instrumentModel?.derivativeData?.commonLevels?.cap) {
        this.underlyingName = "CAP";
        this.barriereValue = this.instrumentModel?.derivativeData?.commonLevels?.cap?.value;
      }
      if (this.instrumentModel?.derivativeData?.underlyings[0]?.levels?.stopLoss?.value) {
        this.underlyingName = "Knock-Out Barriere";
        this.barriereValue = this.instrumentModel?.derivativeData?.underlyings[0]?.levels?.stopLoss?.value;
      }
      this.renderChart();
    }
  }
  underlyingName = "";
  barriereValue = 0;
  chart$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.ReplaySubject();
  chartSeriesData;
  underlyingChartSeriesData = [];
  instrumentName;
  instrumentModel;
  constructor(environmentService) {
    this.environmentService = environmentService;
  }
  set chartData(value) {
    if (value) {
      this.chartSeriesData = value;
      this.renderChart();
    }
  }
  set underlyingChartData(value) {
    if (value) {
      this.underlyingChartSeriesData = value;
      this.renderChart();
    }
  }
  set name(value) {
    if (value) {
      this.instrumentName = value;
      this.renderChart();
    }
  }
  renderChart() {
    if (this.environmentService.isServerRendering || !this.instrumentName || !this.chartSeriesData) {
      return;
    }
    let color = "";
    if (this.chartSeriesData && this.chartSeriesData.length > 2) {
      if (this.chartSeriesData[0][1] <= this.chartSeriesData[this.chartSeriesData.length - 1][1]) {
        color = "green";
        if (this.environmentService.environment?.colorPositive) {
          color = this.environmentService.environment?.colorPositive;
        }
      }
      if (this.chartSeriesData[0][1] >= this.chartSeriesData[this.chartSeriesData.length - 1][1]) {
        color = "red";
        if (this.environmentService.environment?.colorNegative) {
          color = this.environmentService.environment?.colorNegative;
        }
      }
    }
    this.chart$.next(new angular_highcharts__WEBPACK_IMPORTED_MODULE_3__.Chart({
      chart: {
        type: "line",
        height: this.chartHeight,
        animation: false
      },
      title: {
        text: ""
      },
      credits: {
        enabled: false
      },
      series: [{
        color: "#006CFF",
        name: this.instrumentName,
        type: "line",
        data: this.chartSeriesData
      }, {
        color: "#003CB4",
        name: this.instrumentModel?.derivativeData?.underlyings[0].name,
        type: "line",
        data: this.underlyingChartSeriesData,
        yAxis: 1
      }, {
        color: "#00BEC8",
        name: this.underlyingName,
        type: "line",
        data: undefined,
        yAxis: 1
      }],
      legend: {
        enabled: true,
        align: "left",
        symbolWidth: 25,
        symbolHeight: 1,
        symbolPadding: 5,
        symbolRadius: 0
      },
      plotOptions: {
        series: {
          animation: {
            duration: 0
          }
        }
      },
      xAxis: {
        type: "datetime"
      },
      yAxis: [{
        title: {
          text: ""
        },
        labels: {
          style: {
            color: "#006CFF"
          }
        }
      }, {
        title: {
          text: ""
        },
        labels: {
          style: {
            color: "#003CB4"
          }
        },
        plotLines: [{
          color: "#00BEC8",
          width: 2,
          value: this.barriereValue
        }],
        opposite: true,
        min: this.underlyingChartSeriesData.length === 0 || Math.min(...this.underlyingChartSeriesData.map(u => u[1])) < this.barriereValue ? undefined : this.barriereValue,
        max: this.underlyingChartSeriesData.length === 0 || Math.max(...this.underlyingChartSeriesData.map(u => u[1])) > this.barriereValue ? undefined : this.barriereValue
      }]
    }));
  }
  static ɵfac = function HighchartsLineUiComponent_Factory(t) {
    return new (t || HighchartsLineUiComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_adesso_util_environment__WEBPACK_IMPORTED_MODULE_0__.EnvironmentService));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
    type: HighchartsLineUiComponent,
    selectors: [["ui-chart-line"]],
    inputs: {
      height: "height",
      instrument: "instrument",
      chartData: "chartData",
      underlyingChartData: "underlyingChartData",
      name: "name"
    },
    decls: 2,
    vars: 3,
    consts: [[4, "ngIf"], [3, "chart"]],
    template: function HighchartsLineUiComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](0, HighchartsLineUiComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵpipeBind1"](1, 1, ctx.chart$));
      }
    },
    dependencies: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.NgIf, angular_highcharts__WEBPACK_IMPORTED_MODULE_3__.ChartDirective, _angular_common__WEBPACK_IMPORTED_MODULE_4__.AsyncPipe],
    encapsulation: 2,
    changeDetection: 0
  });
}

/***/ }),

/***/ 38224:
/*!***************************************************************************************!*\
  !*** ./libs/@adesso/uis/highcharts/src/components/pie/highcharts-pie-ui.component.ts ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HighchartsPieUiComponent": () => (/* binding */ HighchartsPieUiComponent)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ 94650);
/* harmony import */ var angular_highcharts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! angular-highcharts */ 34120);
/* harmony import */ var _base_util_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @base/util-format */ 84094);
/* harmony import */ var _adesso_util_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adesso/util-environment */ 56489);
/* harmony import */ var _base_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @base/util-logger */ 39858);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ 36895);











function HighchartsPieUiComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵelement"](1, "div", 1);
    _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵproperty"]("chart", ctx_r0.chart);
  }
}
class HighchartsPieUiComponent {
  formatService;
  environmentService;
  logger;
  hoverIdChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
  chart;
  defaultChartColors = [{
    from: "#5991C8",
    to: "#063C73"
  }, {
    from: "#2C2C30",
    to: "#0A0A0A"
  }, {
    from: "#78D565",
    to: "#49A636"
  }, {
    from: "#D98547",
    to: "#B05C29"
  }, {
    from: "#666BCF",
    to: "#4348AC"
  }, {
    from: "#D94A68",
    to: "#BE374D"
  }, {
    from: "#D0BF40",
    to: "#B2A122"
  }, {
    from: "#207D7C",
    to: "#146766"
  }, {
    from: "#E34A4A",
    to: "#D13838"
  }, {
    from: "#83D9D2",
    to: "#71C8C1"
  }, {
    from: "#AAD834",
    to: "#7A9926"
  }];
  chartItems;
  chartColors;
  constructor(formatService, environmentService, logger) {
    this.formatService = formatService;
    this.environmentService = environmentService;
    this.logger = logger;
    this.chartColors = this.defaultChartColors;
  }
  set items(value) {
    this.chartItems = value;
    this.renderChart();
  }
  set colors(value) {
    this.chartColors = value ? value : this.defaultChartColors;
    this.renderChart();
  }
  getColor(index) {
    let colorIndex = index;
    while (colorIndex >= this.chartColors.length) {
      colorIndex = colorIndex - this.chartColors.length;
    }
    return this.chartColors[colorIndex];
  }
  renderChart() {
    this.chart = undefined;
    if (this.environmentService.isServerRendering || !this.chartItems) {
      return;
    }
    const seriesData = [];
    let index = 0;
    this.chartItems.forEach(x => {
      const color = this.getColor(index);
      seriesData.push({
        name: x.name,
        id: index,
        y: +x.portion.toFixed(2),
        color: {
          radialGradient: {
            cx: 0.5,
            cy: 0.5,
            r: 0.9
          },
          stops: [[0, color.from], [1, color.to] // darken
          ]
        }
      });

      index = index + 1;
    });
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const that = this;
    this.chart = new angular_highcharts__WEBPACK_IMPORTED_MODULE_4__.Chart({
      chart: {
        type: "pie",
        height: "240px",
        plotBackgroundColor: undefined,
        plotBorderWidth: undefined,
        plotShadow: false,
        backgroundColor: undefined
      },
      title: {
        text: ""
      },
      credits: {
        enabled: false
      },
      accessibility: {
        point: {
          valueSuffix: "%"
        }
      },
      plotOptions: {
        pie: {
          allowPointSelect: true,
          cursor: "pointer",
          dataLabels: {
            enabled: false,
            format: "<b>{point.name}</b>: {point.percentage:.1f} %",
            connectorColor: "silver"
          }
        }
      },
      tooltip: {
        formatter() {
          return this.point.name + ": " + that.formatService.asPercentage(this.y);
        }
      },
      series: [{
        name: "",
        type: "pie",
        innerSize: "0%",
        data: seriesData,
        point: {
          events: {
            mouseOver: point => {
              if (point && point.target && point.target.id) {
                this.hoverIdChanged.emit(point.target.id);
              } else {
                this.hoverIdChanged.emit(0);
              }
            },
            mouseOut: () => {
              this.hoverIdChanged.emit(undefined);
            }
          }
        }
      }],
      legend: {
        enabled: false
      },
      xAxis: {
        type: "datetime"
      },
      yAxis: {
        title: {
          text: ""
        }
      }
    });
  }
  static ɵfac = function HighchartsPieUiComponent_Factory(t) {
    return new (t || HighchartsPieUiComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdirectiveInject"](_base_util_format__WEBPACK_IMPORTED_MODULE_0__.FormatUtil), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdirectiveInject"](_adesso_util_environment__WEBPACK_IMPORTED_MODULE_1__.EnvironmentService), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdirectiveInject"](_base_util_logger__WEBPACK_IMPORTED_MODULE_2__.LoggerUtil));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineComponent"]({
    type: HighchartsPieUiComponent,
    selectors: [["ui-chart-pie"]],
    inputs: {
      items: "items",
      colors: "colors"
    },
    outputs: {
      hoverIdChanged: "hoverIdChanged"
    },
    decls: 2,
    vars: 2,
    consts: [[4, "ngIf"], [3, "chart"]],
    template: function HighchartsPieUiComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵtemplate"](0, HighchartsPieUiComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵtext"](1);
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵproperty"]("ngIf", ctx.chart);
        _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵadvance"](1);
        _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵtextInterpolate1"]("\n", ctx.logger.uiUpdate("HighchartsPieUiComponent"), "\n");
      }
    },
    dependencies: [_angular_common__WEBPACK_IMPORTED_MODULE_5__.NgIf, angular_highcharts__WEBPACK_IMPORTED_MODULE_4__.ChartDirective],
    encapsulation: 2,
    changeDetection: 0
  });
}

/***/ }),

/***/ 90025:
/*!*****************************************************************!*\
  !*** ./libs/@adesso/uis/highcharts/src/highcharts-ui.module.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HighchartsUiModule": () => (/* binding */ HighchartsUiModule)
/* harmony export */ });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ 36895);
/* harmony import */ var angular_highcharts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! angular-highcharts */ 34120);
/* harmony import */ var _ngx_translate_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ngx-translate/core */ 42466);
/* harmony import */ var _base_util_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @base/util-format */ 84094);
/* harmony import */ var _adesso_util_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adesso/util-environment */ 56489);
/* harmony import */ var _components_pie_highcharts_pie_ui_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/pie/highcharts-pie-ui.component */ 38224);
/* harmony import */ var _components_line_highcharts_line_ui_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/line/highcharts-line-ui.component */ 78157);
/* harmony import */ var _base_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @base/util-logger */ 39858);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/core */ 94650);










class HighchartsUiModule {
  componentFactoryResolver;
  // @ts-ignore
  constructor(componentFactoryResolver) {
    this.componentFactoryResolver = componentFactoryResolver;
  }
  resolveLineChartComponent() {
    return _components_line_highcharts_line_ui_component__WEBPACK_IMPORTED_MODULE_3__.HighchartsLineUiComponent;
  }
  resolvePieChartComponent() {
    return _components_pie_highcharts_pie_ui_component__WEBPACK_IMPORTED_MODULE_2__.HighchartsPieUiComponent;
  }
  static ɵfac = function HighchartsUiModule_Factory(t) {
    return new (t || HighchartsUiModule)(_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_5__.ComponentFactoryResolver));
  };
  static ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineNgModule"]({
    type: HighchartsUiModule
  });
  static ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineInjector"]({
    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_6__.CommonModule, angular_highcharts__WEBPACK_IMPORTED_MODULE_7__.ChartModule, _ngx_translate_core__WEBPACK_IMPORTED_MODULE_8__.TranslateModule, _base_util_format__WEBPACK_IMPORTED_MODULE_0__.FormatUtilModule, _adesso_util_environment__WEBPACK_IMPORTED_MODULE_1__.EnvironmentUtilModule, _base_util_logger__WEBPACK_IMPORTED_MODULE_4__.LoggerUtilModule]
  });
}
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵsetNgModuleScope"](HighchartsUiModule, {
    declarations: [_components_line_highcharts_line_ui_component__WEBPACK_IMPORTED_MODULE_3__.HighchartsLineUiComponent, _components_pie_highcharts_pie_ui_component__WEBPACK_IMPORTED_MODULE_2__.HighchartsPieUiComponent],
    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_6__.CommonModule, angular_highcharts__WEBPACK_IMPORTED_MODULE_7__.ChartModule, _ngx_translate_core__WEBPACK_IMPORTED_MODULE_8__.TranslateModule, _base_util_format__WEBPACK_IMPORTED_MODULE_0__.FormatUtilModule, _adesso_util_environment__WEBPACK_IMPORTED_MODULE_1__.EnvironmentUtilModule, _base_util_logger__WEBPACK_IMPORTED_MODULE_4__.LoggerUtilModule],
    exports: [_components_line_highcharts_line_ui_component__WEBPACK_IMPORTED_MODULE_3__.HighchartsLineUiComponent, _components_pie_highcharts_pie_ui_component__WEBPACK_IMPORTED_MODULE_2__.HighchartsPieUiComponent]
  });
})();

/***/ }),

/***/ 43322:
/*!*******************************************************!*\
  !*** ./libs/@adesso/uis/highcharts/src/public-api.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HighchartsLineUiComponent": () => (/* reexport safe */ _components_line_highcharts_line_ui_component__WEBPACK_IMPORTED_MODULE_0__.HighchartsLineUiComponent),
/* harmony export */   "HighchartsPieUiComponent": () => (/* reexport safe */ _components_pie_highcharts_pie_ui_component__WEBPACK_IMPORTED_MODULE_1__.HighchartsPieUiComponent),
/* harmony export */   "HighchartsUiModule": () => (/* reexport safe */ _highcharts_ui_module__WEBPACK_IMPORTED_MODULE_2__.HighchartsUiModule)
/* harmony export */ });
/* harmony import */ var _components_line_highcharts_line_ui_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/line/highcharts-line-ui.component */ 78157);
/* harmony import */ var _components_pie_highcharts_pie_ui_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/pie/highcharts-pie-ui.component */ 38224);
/* harmony import */ var _highcharts_ui_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./highcharts-ui.module */ 90025);




/***/ }),

/***/ 21700:
/*!*****************************************************!*\
  !*** ./node_modules/highcharts/highcharts-gantt.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highcharts Gantt JS v9.3.3 (2022-02-01)

 (c) 2017-2021 Lars Cabrera, Torstein Honsi, Jon Arild Nygard & Oystein Moseng

 License: www.highcharts.com/license
*/


(function (X, N) {
   true && module.exports ? (N["default"] = N, module.exports = X.document ? N(X) : N) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return N(X);
  }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);
})("undefined" !== typeof window ? window : this, function (X) {
  function N(E, a, B, H) {
    E.hasOwnProperty(a) || (E[a] = H.apply(null, B));
  }
  var a = {};
  N(a, "Core/Globals.js", [], function () {
    var E = "undefined" !== typeof X ? X : "undefined" !== typeof window ? window : {},
      a;
    (function (a) {
      a.SVG_NS = "http://www.w3.org/2000/svg";
      a.product = "Highcharts";
      a.version = "9.3.3";
      a.win = E;
      a.doc = a.win.document;
      a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, "svg").createSVGRect;
      a.userAgent = a.win.navigator && a.win.navigator.userAgent || "";
      a.isChrome = -1 !== a.userAgent.indexOf("Chrome");
      a.isFirefox = -1 !== a.userAgent.indexOf("Firefox");
      a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;
      a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf("Safari");
      a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);
      a.isWebKit = -1 !== a.userAgent.indexOf("AppleWebKit");
      a.deg2rad = 2 * Math.PI / 360;
      a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split("Firefox/")[1], 10);
      a.hasTouch = !!a.win.TouchEvent;
      a.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
      a.noop = function () {};
      a.supportsPassiveEvents = function () {
        var E = !1;
        if (!a.isMS) {
          var t = Object.defineProperty({}, "passive", {
            get: function () {
              E = !0;
            }
          });
          a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener("testPassive", a.noop, t), a.win.removeEventListener("testPassive", a.noop, t));
        }
        return E;
      }();
      a.charts = [];
      a.dateFormats = {};
      a.seriesTypes = {};
      a.symbolSizes = {};
      a.chartCount = 0;
    })(a || (a = {}));
    "";
    return a;
  });
  N(a, "Core/Utilities.js", [a["Core/Globals.js"]], function (a) {
    function E(D, b, k, d) {
      var C = b ? "Highcharts error" : "Highcharts warning";
      32 === D && (D = C + ": Deprecated member");
      var r = m(D),
        e = r ? C + " #" + D + ": www.highcharts.com/errors/" + D + "/" : D.toString();
      if ("undefined" !== typeof d) {
        var P = "";
        r && (e += "?");
        G(d, function (k, u) {
          P += "\n - " + u + ": " + k;
          r && (e += encodeURI(u) + "=" + encodeURI(k));
        });
        e += P;
      }
      M(a, "displayError", {
        chart: k,
        code: D,
        message: e,
        params: d
      }, function () {
        if (b) throw Error(e);
        w.console && -1 === E.messages.indexOf(e) && console.warn(e);
      });
      E.messages.push(e);
    }
    function B(D, b) {
      var k = {};
      G(D, function (d, C) {
        if (I(D[C], !0) && !D.nodeType && b[C]) d = B(D[C], b[C]), Object.keys(d).length && (k[C] = d);else if (I(D[C]) || D[C] !== b[C]) k[C] = D[C];
      });
      return k;
    }
    function H(D, b) {
      return parseInt(D, b || 10);
    }
    function y(D) {
      return "string" === typeof D;
    }
    function F(D) {
      D = Object.prototype.toString.call(D);
      return "[object Array]" === D || "[object Array Iterator]" === D;
    }
    function I(D, b) {
      return !!D && "object" === typeof D && (!b || !F(D));
    }
    function x(D) {
      return I(D) && "number" === typeof D.nodeType;
    }
    function q(D) {
      var b = D && D.constructor;
      return !(!I(D, !0) || x(D) || !b || !b.name || "Object" === b.name);
    }
    function m(b) {
      return "number" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;
    }
    function h(b) {
      return "undefined" !== typeof b && null !== b;
    }
    function c(b, d, k) {
      var D;
      y(d) ? h(k) ? b.setAttribute(d, k) : b && b.getAttribute && ((D = b.getAttribute(d)) || "class" !== d || (D = b.getAttribute(d + "Name"))) : G(d, function (k, D) {
        h(k) ? b.setAttribute(D, k) : b.removeAttribute(D);
      });
      return D;
    }
    function n(b, d) {
      var k;
      b || (b = {});
      for (k in d) b[k] = d[k];
      return b;
    }
    function z() {
      for (var b = arguments, d = b.length, k = 0; k < d; k++) {
        var e = b[k];
        if ("undefined" !== typeof e && null !== e) return e;
      }
    }
    function g(b, d) {
      a.isMS && !a.svg && d && "undefined" !== typeof d.opacity && (d.filter = "alpha(opacity=" + 100 * d.opacity + ")");
      n(b.style, d);
    }
    function f(b, d) {
      return 1E14 < b ? b : parseFloat(b.toPrecision(d || 14));
    }
    function e(b, d, k) {
      var D = a.getStyle || e;
      if ("width" === d) return d = Math.min(b.offsetWidth, b.scrollWidth), k = b.getBoundingClientRect && b.getBoundingClientRect().width, k < d && k >= d - 1 && (d = Math.floor(k)), Math.max(0, d - (D(b, "padding-left", !0) || 0) - (D(b, "padding-right", !0) || 0));
      if ("height" === d) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - (D(b, "padding-top", !0) || 0) - (D(b, "padding-bottom", !0) || 0));
      w.getComputedStyle || E(27, !0);
      if (b = w.getComputedStyle(b, void 0)) {
        var C = b.getPropertyValue(d);
        z(k, "opacity" !== d) && (C = H(C));
      }
      return C;
    }
    function G(b, d, k) {
      for (var D in b) Object.hasOwnProperty.call(b, D) && d.call(k || b[D], b[D], D, b);
    }
    function J(b, d, k) {
      function D(d, k) {
        var u = b.removeEventListener || a.removeEventListenerPolyfill;
        u && u.call(b, d, k, !1);
      }
      function C(k) {
        var r;
        if (b.nodeName) {
          if (d) {
            var u = {};
            u[d] = !0;
          } else u = k;
          G(u, function (u, b) {
            if (k[b]) for (r = k[b].length; r--;) D(b, k[b][r].fn);
          });
        }
      }
      var r = "function" === typeof b && b.prototype || b;
      if (Object.hasOwnProperty.call(r, "hcEvents")) {
        var e = r.hcEvents;
        d ? (r = e[d] || [], k ? (e[d] = r.filter(function (b) {
          return k !== b.fn;
        }), D(d, k)) : (C(e), e[d] = [])) : (C(e), delete r.hcEvents);
      }
    }
    function M(b, d, k, e) {
      k = k || {};
      if (l.createEvent && (b.dispatchEvent || b.fireEvent && b !== a)) {
        var D = l.createEvent("Events");
        D.initEvent(d, !0, !0);
        k = n(D, k);
        b.dispatchEvent ? b.dispatchEvent(k) : b.fireEvent(d, k);
      } else if (b.hcEvents) {
        k.target || n(k, {
          preventDefault: function () {
            k.defaultPrevented = !0;
          },
          target: b,
          type: d
        });
        D = [];
        for (var r = b, C = !1; r.hcEvents;) Object.hasOwnProperty.call(r, "hcEvents") && r.hcEvents[d] && (D.length && (C = !0), D.unshift.apply(D, r.hcEvents[d])), r = Object.getPrototypeOf(r);
        C && D.sort(function (b, d) {
          return b.order - d.order;
        });
        D.forEach(function (d) {
          !1 === d.fn.call(b, k) && k.preventDefault();
        });
      }
      e && !k.defaultPrevented && e.call(b, k);
    }
    var p = a.charts,
      l = a.doc,
      w = a.win;
    (E || (E = {})).messages = [];
    Math.easeInOutSine = function (b) {
      return -.5 * (Math.cos(Math.PI * b) - 1);
    };
    var b = Array.prototype.find ? function (b, d) {
      return b.find(d);
    } : function (b, d) {
      var k,
        D = b.length;
      for (k = 0; k < D; k++) if (d(b[k], k)) return b[k];
    };
    G({
      map: "map",
      each: "forEach",
      grep: "filter",
      reduce: "reduce",
      some: "some"
    }, function (b, d) {
      a[d] = function (k) {
        var D;
        E(32, !1, void 0, (D = {}, D["Highcharts." + d] = "use Array." + b, D));
        return Array.prototype[b].apply(k, [].slice.call(arguments, 1));
      };
    });
    var v,
      d = function () {
        var b = Math.random().toString(36).substring(2, 9) + "-",
          d = 0;
        return function () {
          return "highcharts-" + (v ? "" : b) + d++;
        };
      }();
    w.jQuery && (w.jQuery.fn.highcharts = function () {
      var b = [].slice.call(arguments);
      if (this[0]) return b[0] ? (new a[y(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : p[c(this[0], "data-highcharts-chart")];
    });
    b = {
      addEvent: function (b, d, k, e) {
        void 0 === e && (e = {});
        var D = "function" === typeof b && b.prototype || b;
        Object.hasOwnProperty.call(D, "hcEvents") || (D.hcEvents = {});
        D = D.hcEvents;
        a.Point && b instanceof a.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
        var r = b.addEventListener || a.addEventListenerPolyfill;
        r && r.call(b, d, k, a.supportsPassiveEvents ? {
          passive: void 0 === e.passive ? -1 !== d.indexOf("touch") : e.passive,
          capture: !1
        } : !1);
        D[d] || (D[d] = []);
        D[d].push({
          fn: k,
          order: "number" === typeof e.order ? e.order : Infinity
        });
        D[d].sort(function (b, d) {
          return b.order - d.order;
        });
        return function () {
          J(b, d, k);
        };
      },
      arrayMax: function (b) {
        for (var d = b.length, k = b[0]; d--;) b[d] > k && (k = b[d]);
        return k;
      },
      arrayMin: function (b) {
        for (var d = b.length, k = b[0]; d--;) b[d] < k && (k = b[d]);
        return k;
      },
      attr: c,
      clamp: function (b, d, k) {
        return b > d ? b < k ? b : k : d;
      },
      cleanRecursively: B,
      clearTimeout: function (b) {
        h(b) && clearTimeout(b);
      },
      correctFloat: f,
      createElement: function (b, d, k, e, p) {
        b = l.createElement(b);
        d && n(b, d);
        p && g(b, {
          padding: "0",
          border: "none",
          margin: "0"
        });
        k && g(b, k);
        e && e.appendChild(b);
        return b;
      },
      css: g,
      defined: h,
      destroyObjectProperties: function (b, d) {
        G(b, function (k, e) {
          k && k !== d && k.destroy && k.destroy();
          delete b[e];
        });
      },
      discardElement: function (b) {
        b && b.parentElement && b.parentElement.removeChild(b);
      },
      erase: function (b, d) {
        for (var k = b.length; k--;) if (b[k] === d) {
          b.splice(k, 1);
          break;
        }
      },
      error: E,
      extend: n,
      extendClass: function (b, d) {
        var k = function () {};
        k.prototype = new b();
        n(k.prototype, d);
        return k;
      },
      find: b,
      fireEvent: M,
      getMagnitude: function (b) {
        return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
      },
      getNestedProperty: function (b, d) {
        for (b = b.split("."); b.length && h(d);) {
          var k = b.shift();
          if ("undefined" === typeof k || "__proto__" === k) return;
          d = d[k];
          if (!h(d) || "function" === typeof d || "number" === typeof d.nodeType || d === w) return;
        }
        return d;
      },
      getStyle: e,
      inArray: function (b, d, k) {
        E(32, !1, void 0, {
          "Highcharts.inArray": "use Array.indexOf"
        });
        return d.indexOf(b, k);
      },
      isArray: F,
      isClass: q,
      isDOMElement: x,
      isFunction: function (b) {
        return "function" === typeof b;
      },
      isNumber: m,
      isObject: I,
      isString: y,
      keys: function (b) {
        E(32, !1, void 0, {
          "Highcharts.keys": "use Object.keys"
        });
        return Object.keys(b);
      },
      merge: function () {
        var b,
          d = arguments,
          k = {},
          e = function (b, d) {
            "object" !== typeof b && (b = {});
            G(d, function (k, r) {
              "__proto__" !== r && "constructor" !== r && (!I(k, !0) || q(k) || x(k) ? b[r] = d[r] : b[r] = e(b[r] || {}, k));
            });
            return b;
          };
        !0 === d[0] && (k = d[1], d = Array.prototype.slice.call(d, 2));
        var l = d.length;
        for (b = 0; b < l; b++) k = e(k, d[b]);
        return k;
      },
      normalizeTickInterval: function (b, d, k, e, l) {
        var r = b;
        k = z(k, 1);
        var D = b / k;
        d || (d = l ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === e && (1 === k ? d = d.filter(function (b) {
          return 0 === b % 1;
        }) : .1 >= k && (d = [1 / k])));
        for (e = 0; e < d.length && !(r = d[e], l && r * k >= b || !l && D <= (d[e] + (d[e + 1] || d[e])) / 2); e++);
        return r = f(r * k, -Math.round(Math.log(.001) / Math.LN10));
      },
      objectEach: G,
      offset: function (b) {
        var d = l.documentElement;
        b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {
          top: 0,
          left: 0,
          width: 0,
          height: 0
        };
        return {
          top: b.top + (w.pageYOffset || d.scrollTop) - (d.clientTop || 0),
          left: b.left + (w.pageXOffset || d.scrollLeft) - (d.clientLeft || 0),
          width: b.width,
          height: b.height
        };
      },
      pad: function (b, d, k) {
        return Array((d || 2) + 1 - String(b).replace("-", "").length).join(k || "0") + b;
      },
      pick: z,
      pInt: H,
      relativeLength: function (b, d, k) {
        return /%$/.test(b) ? d * parseFloat(b) / 100 + (k || 0) : parseFloat(b);
      },
      removeEvent: J,
      splat: function (b) {
        return F(b) ? b : [b];
      },
      stableSort: function (b, d) {
        var k = b.length,
          e,
          l;
        for (l = 0; l < k; l++) b[l].safeI = l;
        b.sort(function (b, k) {
          e = d(b, k);
          return 0 === e ? b.safeI - k.safeI : e;
        });
        for (l = 0; l < k; l++) delete b[l].safeI;
      },
      syncTimeout: function (b, d, k) {
        if (0 < d) return setTimeout(b, d, k);
        b.call(0, k);
        return -1;
      },
      timeUnits: {
        millisecond: 1,
        second: 1E3,
        minute: 6E4,
        hour: 36E5,
        day: 864E5,
        week: 6048E5,
        month: 24192E5,
        year: 314496E5
      },
      uniqueKey: d,
      useSerialIds: function (b) {
        return v = z(b, v);
      },
      wrap: function (b, d, k) {
        var e = b[d];
        b[d] = function () {
          var b = Array.prototype.slice.call(arguments),
            d = arguments,
            l = this;
          l.proceed = function () {
            e.apply(l, arguments.length ? arguments : d);
          };
          b.unshift(e);
          b = k.apply(this, b);
          l.proceed = null;
          return b;
        };
      }
    };
    "";
    return b;
  });
  N(a, "Core/Chart/ChartDefaults.js", [], function () {
    return {
      panning: {
        enabled: !1,
        type: "x"
      },
      styledMode: !1,
      borderRadius: 0,
      colorCount: 10,
      defaultSeriesType: "line",
      ignoreHiddenSeries: !0,
      spacing: [10, 10, 15, 10],
      resetZoomButton: {
        theme: {
          zIndex: 6
        },
        position: {
          align: "right",
          x: -10,
          y: 10
        }
      },
      zoomBySingleTouch: !1,
      width: null,
      height: null,
      borderColor: "#335cad",
      backgroundColor: "#ffffff",
      plotBorderColor: "#cccccc"
    };
  });
  N(a, "Core/Color/Color.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, t) {
    var E = t.isNumber,
      H = t.merge,
      y = t.pInt;
    t = function () {
      function t(E) {
        this.rgba = [NaN, NaN, NaN, NaN];
        this.input = E;
        var x = a.Color;
        if (x && x !== t) return new x(E);
        if (!(this instanceof t)) return new t(E);
        this.init(E);
      }
      t.parse = function (a) {
        return a ? new t(a) : t.None;
      };
      t.prototype.init = function (a) {
        var x;
        if ("object" === typeof a && "undefined" !== typeof a.stops) this.stops = a.stops.map(function (c) {
          return new t(c[1]);
        });else if ("string" === typeof a) {
          this.input = a = t.names[a.toLowerCase()] || a;
          if ("#" === a.charAt(0)) {
            var q = a.length;
            var m = parseInt(a.substr(1), 16);
            7 === q ? x = [(m & 16711680) >> 16, (m & 65280) >> 8, m & 255, 1] : 4 === q && (x = [(m & 3840) >> 4 | (m & 3840) >> 8, (m & 240) >> 4 | m & 240, (m & 15) << 4 | m & 15, 1]);
          }
          if (!x) for (m = t.parsers.length; m-- && !x;) {
            var h = t.parsers[m];
            (q = h.regex.exec(a)) && (x = h.parse(q));
          }
        }
        x && (this.rgba = x);
      };
      t.prototype.get = function (a) {
        var x = this.input,
          q = this.rgba;
        if ("object" === typeof x && "undefined" !== typeof this.stops) {
          var m = H(x);
          m.stops = [].slice.call(m.stops);
          this.stops.forEach(function (h, c) {
            m.stops[c] = [m.stops[c][0], h.get(a)];
          });
          return m;
        }
        return q && E(q[0]) ? "rgb" === a || !a && 1 === q[3] ? "rgb(" + q[0] + "," + q[1] + "," + q[2] + ")" : "a" === a ? "" + q[3] : "rgba(" + q.join(",") + ")" : x;
      };
      t.prototype.brighten = function (a) {
        var x = this.rgba;
        if (this.stops) this.stops.forEach(function (m) {
          m.brighten(a);
        });else if (E(a) && 0 !== a) for (var q = 0; 3 > q; q++) x[q] += y(255 * a), 0 > x[q] && (x[q] = 0), 255 < x[q] && (x[q] = 255);
        return this;
      };
      t.prototype.setOpacity = function (a) {
        this.rgba[3] = a;
        return this;
      };
      t.prototype.tweenTo = function (a, x) {
        var q = this.rgba,
          m = a.rgba;
        if (!E(q[0]) || !E(m[0])) return a.input || "none";
        a = 1 !== m[3] || 1 !== q[3];
        return (a ? "rgba(" : "rgb(") + Math.round(m[0] + (q[0] - m[0]) * (1 - x)) + "," + Math.round(m[1] + (q[1] - m[1]) * (1 - x)) + "," + Math.round(m[2] + (q[2] - m[2]) * (1 - x)) + (a ? "," + (m[3] + (q[3] - m[3]) * (1 - x)) : "") + ")";
      };
      t.names = {
        white: "#ffffff",
        black: "#000000"
      };
      t.parsers = [{
        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        parse: function (a) {
          return [y(a[1]), y(a[2]), y(a[3]), parseFloat(a[4], 10)];
        }
      }, {
        regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
        parse: function (a) {
          return [y(a[1]), y(a[2]), y(a[3]), 1];
        }
      }];
      t.None = new t("");
      return t;
    }();
    "";
    return t;
  });
  N(a, "Core/Color/Palettes.js", [], function () {
    return {
      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ")
    };
  });
  N(a, "Core/Time.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, t) {
    var E = a.win,
      H = t.defined,
      y = t.error,
      F = t.extend,
      I = t.isObject,
      x = t.merge,
      q = t.objectEach,
      m = t.pad,
      h = t.pick,
      c = t.splat,
      n = t.timeUnits,
      z = a.isSafari && E.Intl && E.Intl.DateTimeFormat.prototype.formatRange,
      g = a.isSafari && E.Intl && !E.Intl.DateTimeFormat.prototype.formatRange;
    t = function () {
      function f(e) {
        this.options = {};
        this.variableTimezone = this.useUTC = !1;
        this.Date = E.Date;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.update(e);
      }
      f.prototype.get = function (e, f) {
        if (this.variableTimezone || this.timezoneOffset) {
          var g = f.getTime(),
            c = g - this.getTimezoneOffset(f);
          f.setTime(c);
          e = f["getUTC" + e]();
          f.setTime(g);
          return e;
        }
        return this.useUTC ? f["getUTC" + e]() : f["get" + e]();
      };
      f.prototype.set = function (e, f, g) {
        if (this.variableTimezone || this.timezoneOffset) {
          if ("Milliseconds" === e || "Seconds" === e || "Minutes" === e && 0 === this.getTimezoneOffset(f) % 36E5) return f["setUTC" + e](g);
          var c = this.getTimezoneOffset(f);
          c = f.getTime() - c;
          f.setTime(c);
          f["setUTC" + e](g);
          e = this.getTimezoneOffset(f);
          c = f.getTime() + e;
          return f.setTime(c);
        }
        return this.useUTC || z && "FullYear" === e ? f["setUTC" + e](g) : f["set" + e](g);
      };
      f.prototype.update = function (e) {
        var f = h(e && e.useUTC, !0);
        this.options = e = x(!0, this.options || {}, e);
        this.Date = e.Date || E.Date || Date;
        this.timezoneOffset = (this.useUTC = f) && e.timezoneOffset;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.variableTimezone = f && !(!e.getTimezoneOffset && !e.timezone);
      };
      f.prototype.makeTime = function (e, f, c, n, p, l) {
        if (this.useUTC) {
          var w = this.Date.UTC.apply(0, arguments);
          var b = this.getTimezoneOffset(w);
          w += b;
          var v = this.getTimezoneOffset(w);
          b !== v ? w += v - b : b - 36E5 !== this.getTimezoneOffset(w - 36E5) || g || (w -= 36E5);
        } else w = new this.Date(e, f, h(c, 1), h(n, 0), h(p, 0), h(l, 0)).getTime();
        return w;
      };
      f.prototype.timezoneOffsetFunction = function () {
        var e = this,
          f = this.options,
          g = f.getTimezoneOffset,
          c = f.moment || E.moment;
        if (!this.useUTC) return function (e) {
          return 6E4 * new Date(e.toString()).getTimezoneOffset();
        };
        if (f.timezone) {
          if (c) return function (e) {
            return 6E4 * -c.tz(e, f.timezone).utcOffset();
          };
          y(25);
        }
        return this.useUTC && g ? function (e) {
          return 6E4 * g(e.valueOf());
        } : function () {
          return 6E4 * (e.timezoneOffset || 0);
        };
      };
      f.prototype.dateFormat = function (e, f, g) {
        if (!H(f) || isNaN(f)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || "";
        e = h(e, "%Y-%m-%d %H:%M:%S");
        var c = this,
          p = new this.Date(f),
          l = this.get("Hours", p),
          w = this.get("Day", p),
          b = this.get("Date", p),
          v = this.get("Month", p),
          d = this.get("FullYear", p),
          D = a.defaultOptions.lang,
          C = D && D.weekdays,
          k = D && D.shortWeekdays;
        p = F({
          a: k ? k[w] : C[w].substr(0, 3),
          A: C[w],
          d: m(b),
          e: m(b, 2, " "),
          w: w,
          b: D.shortMonths[v],
          B: D.months[v],
          m: m(v + 1),
          o: v + 1,
          y: d.toString().substr(2, 2),
          Y: d,
          H: m(l),
          k: l,
          I: m(l % 12 || 12),
          l: l % 12 || 12,
          M: m(this.get("Minutes", p)),
          p: 12 > l ? "AM" : "PM",
          P: 12 > l ? "am" : "pm",
          S: m(p.getSeconds()),
          L: m(Math.floor(f % 1E3), 3)
        }, a.dateFormats);
        q(p, function (b, d) {
          for (; -1 !== e.indexOf("%" + d);) e = e.replace("%" + d, "function" === typeof b ? b.call(c, f) : b);
        });
        return g ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;
      };
      f.prototype.resolveDTLFormat = function (e) {
        return I(e, !0) ? e : (e = c(e), {
          main: e[0],
          from: e[1],
          to: e[2]
        });
      };
      f.prototype.getTimeTicks = function (e, f, g, c) {
        var p = this,
          l = [],
          w = {},
          b = new p.Date(f),
          v = e.unitRange,
          d = e.count || 1,
          D;
        c = h(c, 1);
        if (H(f)) {
          p.set("Milliseconds", b, v >= n.second ? 0 : d * Math.floor(p.get("Milliseconds", b) / d));
          v >= n.second && p.set("Seconds", b, v >= n.minute ? 0 : d * Math.floor(p.get("Seconds", b) / d));
          v >= n.minute && p.set("Minutes", b, v >= n.hour ? 0 : d * Math.floor(p.get("Minutes", b) / d));
          v >= n.hour && p.set("Hours", b, v >= n.day ? 0 : d * Math.floor(p.get("Hours", b) / d));
          v >= n.day && p.set("Date", b, v >= n.month ? 1 : Math.max(1, d * Math.floor(p.get("Date", b) / d)));
          if (v >= n.month) {
            p.set("Month", b, v >= n.year ? 0 : d * Math.floor(p.get("Month", b) / d));
            var C = p.get("FullYear", b);
          }
          v >= n.year && p.set("FullYear", b, C - C % d);
          v === n.week && (C = p.get("Day", b), p.set("Date", b, p.get("Date", b) - C + c + (C < c ? -7 : 0)));
          C = p.get("FullYear", b);
          c = p.get("Month", b);
          var k = p.get("Date", b),
            K = p.get("Hours", b);
          f = b.getTime();
          !p.variableTimezone && p.useUTC || !H(g) || (D = g - f > 4 * n.month || p.getTimezoneOffset(f) !== p.getTimezoneOffset(g));
          f = b.getTime();
          for (b = 1; f < g;) l.push(f), f = v === n.year ? p.makeTime(C + b * d, 0) : v === n.month ? p.makeTime(C, c + b * d) : !D || v !== n.day && v !== n.week ? D && v === n.hour && 1 < d ? p.makeTime(C, c, k, K + b * d) : f + v * d : p.makeTime(C, c, k + b * d * (v === n.day ? 1 : 7)), b++;
          l.push(f);
          v <= n.hour && 1E4 > l.length && l.forEach(function (b) {
            0 === b % 18E5 && "000000000" === p.dateFormat("%H%M%S%L", b) && (w[b] = "day");
          });
        }
        l.info = F(e, {
          higherRanks: w,
          totalRange: v * d
        });
        return l;
      };
      f.prototype.getDateFormat = function (e, f, c, g) {
        var p = this.dateFormat("%m-%d %H:%M:%S.%L", f),
          l = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          },
          w = "millisecond";
        for (b in n) {
          if (e === n.week && +this.dateFormat("%w", f) === c && "00:00:00.000" === p.substr(6)) {
            var b = "week";
            break;
          }
          if (n[b] > e) {
            b = w;
            break;
          }
          if (l[b] && p.substr(l[b]) !== "01-01 00:00:00.000".substr(l[b])) break;
          "week" !== b && (w = b);
        }
        if (b) var v = this.resolveDTLFormat(g[b]).main;
        return v;
      };
      return f;
    }();
    "";
    return t;
  });
  N(a, "Core/DefaultOptions.js", [a["Core/Chart/ChartDefaults.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palettes.js"], a["Core/Time.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F) {
    t = t.parse;
    var E = F.merge,
      x = {
        colors: H.colors,
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
          loading: "Loading...",
          months: "January February March April May June July August September October November December".split(" "),
          shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
          weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
          decimalPoint: ".",
          numericSymbols: "kMGTPE".split(""),
          resetZoom: "Reset zoom",
          resetZoomTitle: "Reset zoom level 1:1",
          thousandsSep: " "
        },
        global: {},
        time: {
          Date: void 0,
          getTimezoneOffset: void 0,
          timezone: void 0,
          timezoneOffset: 0,
          useUTC: !0
        },
        chart: a,
        title: {
          text: "Chart title",
          align: "center",
          margin: 15,
          widthAdjust: -44
        },
        subtitle: {
          text: "",
          align: "center",
          widthAdjust: -44
        },
        caption: {
          margin: 15,
          text: "",
          align: "left",
          verticalAlign: "bottom"
        },
        plotOptions: {},
        labels: {
          style: {
            position: "absolute",
            color: "#333333"
          }
        },
        legend: {
          enabled: !0,
          align: "center",
          alignColumns: !0,
          className: "highcharts-no-tooltip",
          layout: "horizontal",
          labelFormatter: function () {
            return this.name;
          },
          borderColor: "#999999",
          borderRadius: 0,
          navigation: {
            activeColor: "#003399",
            inactiveColor: "#cccccc"
          },
          itemStyle: {
            color: "#333333",
            cursor: "pointer",
            fontSize: "12px",
            fontWeight: "bold",
            textOverflow: "ellipsis"
          },
          itemHoverStyle: {
            color: "#000000"
          },
          itemHiddenStyle: {
            color: "#cccccc"
          },
          shadow: !1,
          itemCheckboxStyle: {
            position: "absolute",
            width: "13px",
            height: "13px"
          },
          squareSymbol: !0,
          symbolPadding: 5,
          verticalAlign: "bottom",
          x: 0,
          y: 0,
          title: {
            style: {
              fontWeight: "bold"
            }
          }
        },
        loading: {
          labelStyle: {
            fontWeight: "bold",
            position: "relative",
            top: "45%"
          },
          style: {
            position: "absolute",
            backgroundColor: "#ffffff",
            opacity: .5,
            textAlign: "center"
          }
        },
        tooltip: {
          enabled: !0,
          animation: B.svg,
          borderRadius: 3,
          dateTimeLabelFormats: {
            millisecond: "%A, %b %e, %H:%M:%S.%L",
            second: "%A, %b %e, %H:%M:%S",
            minute: "%A, %b %e, %H:%M",
            hour: "%A, %b %e, %H:%M",
            day: "%A, %b %e, %Y",
            week: "Week from %A, %b %e, %Y",
            month: "%B %Y",
            year: "%Y"
          },
          footerFormat: "",
          headerShape: "callout",
          hideDelay: 500,
          padding: 8,
          shape: "callout",
          shared: !1,
          snap: B.isTouchDevice ? 25 : 10,
          headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
          pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
          backgroundColor: t("#f7f7f7").setOpacity(.85).get(),
          borderWidth: 1,
          shadow: !0,
          stickOnContact: !1,
          style: {
            color: "#333333",
            cursor: "default",
            fontSize: "12px",
            whiteSpace: "nowrap"
          },
          useHTML: !1
        },
        credits: {
          enabled: !0,
          href: "https://www.highcharts.com?credits",
          position: {
            align: "right",
            x: -10,
            verticalAlign: "bottom",
            y: -5
          },
          style: {
            cursor: "pointer",
            color: "#999999",
            fontSize: "9px"
          },
          text: "Highcharts.com"
        }
      };
    x.chart.styledMode = !1;
    "";
    var q = new y(E(x.global, x.time));
    a = {
      defaultOptions: x,
      defaultTime: q,
      getOptions: function () {
        return x;
      },
      setOptions: function (m) {
        E(!0, x, m);
        if (m.time || m.global) B.time ? B.time.update(E(x.global, x.time, m.global, m.time)) : B.time = q;
        return x;
      }
    };
    "";
    return a;
  });
  N(a, "Core/Animation/Fx.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = a.parse,
      y = t.win,
      F = B.isNumber,
      I = B.objectEach;
    return function () {
      function a(q, m, h) {
        this.pos = NaN;
        this.options = m;
        this.elem = q;
        this.prop = h;
      }
      a.prototype.dSetter = function () {
        var q = this.paths,
          m = q && q[0];
        q = q && q[1];
        var h = this.now || 0,
          c = [];
        if (1 !== h && m && q) {
          if (m.length === q.length && 1 > h) for (var n = 0; n < q.length; n++) {
            for (var z = m[n], g = q[n], f = [], e = 0; e < g.length; e++) {
              var G = z[e],
                J = g[e];
              F(G) && F(J) && ("A" !== g[0] || 4 !== e && 5 !== e) ? f[e] = G + h * (J - G) : f[e] = J;
            }
            c.push(f);
          } else c = q;
        } else c = this.toD || [];
        this.elem.attr("d", c, void 0, !0);
      };
      a.prototype.update = function () {
        var q = this.elem,
          m = this.prop,
          h = this.now,
          c = this.options.step;
        if (this[m + "Setter"]) this[m + "Setter"]();else q.attr ? q.element && q.attr(m, h, null, !0) : q.style[m] = h + this.unit;
        c && c.call(q, h, this);
      };
      a.prototype.run = function (q, m, h) {
        var c = this,
          n = c.options,
          z = function (e) {
            return z.stopped ? !1 : c.step(e);
          },
          g = y.requestAnimationFrame || function (e) {
            setTimeout(e, 13);
          },
          f = function () {
            for (var e = 0; e < a.timers.length; e++) a.timers[e]() || a.timers.splice(e--, 1);
            a.timers.length && g(f);
          };
        q !== m || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = q, this.end = m, this.unit = h, this.now = this.start, this.pos = 0, z.elem = this.elem, z.prop = this.prop, z() && 1 === a.timers.push(z) && g(f)) : (delete n.curAnim[this.prop], n.complete && 0 === Object.keys(n.curAnim).length && n.complete.call(this.elem));
      };
      a.prototype.step = function (q) {
        var m = +new Date(),
          h = this.options,
          c = this.elem,
          n = h.complete,
          z = h.duration,
          g = h.curAnim;
        if (c.attr && !c.element) q = !1;else if (q || m >= z + this.startTime) {
          this.now = this.end;
          this.pos = 1;
          this.update();
          var f = g[this.prop] = !0;
          I(g, function (e) {
            !0 !== e && (f = !1);
          });
          f && n && n.call(c);
          q = !1;
        } else this.pos = h.easing((m - this.startTime) / z), this.now = this.start + (this.end - this.start) * this.pos, this.update(), q = !0;
        return q;
      };
      a.prototype.initPath = function (q, m, h) {
        function c(e, l) {
          for (; e.length < M;) {
            var p = e[0],
              b = l[M - e.length];
            b && "M" === p[0] && (e[0] = "C" === b[0] ? ["C", p[1], p[2], p[1], p[2], p[1], p[2]] : ["L", p[1], p[2]]);
            e.unshift(p);
            f && (p = e.pop(), e.push(e[e.length - 1], p));
          }
        }
        function n(p, l) {
          for (; p.length < M;) if (l = p[Math.floor(p.length / e) - 1].slice(), "C" === l[0] && (l[1] = l[5], l[2] = l[6]), f) {
            var w = p[Math.floor(p.length / e)].slice();
            p.splice(p.length / 2, 0, l, w);
          } else p.push(l);
        }
        var z = q.startX,
          g = q.endX;
        h = h.slice();
        var f = q.isArea,
          e = f ? 2 : 1;
        m = m && m.slice();
        if (!m) return [h, h];
        if (z && g && g.length) {
          for (q = 0; q < z.length; q++) if (z[q] === g[0]) {
            var G = q;
            break;
          } else if (z[0] === g[g.length - z.length + q]) {
            G = q;
            var J = !0;
            break;
          } else if (z[z.length - 1] === g[g.length - z.length + q]) {
            G = z.length - q;
            break;
          }
          "undefined" === typeof G && (m = []);
        }
        if (m.length && F(G)) {
          var M = h.length + G * e;
          J ? (c(m, h), n(h, m)) : (c(h, m), n(m, h));
        }
        return [m, h];
      };
      a.prototype.fillSetter = function () {
        a.prototype.strokeSetter.apply(this, arguments);
      };
      a.prototype.strokeSetter = function () {
        this.elem.attr(this.prop, E(this.start).tweenTo(E(this.end), this.pos), void 0, !0);
      };
      a.timers = [];
      return a;
    }();
  });
  N(a, "Core/Animation/AnimationUtilities.js", [a["Core/Animation/Fx.js"], a["Core/Utilities.js"]], function (a, t) {
    function E(c) {
      return q(c) ? m({
        duration: 500,
        defer: 0
      }, c) : {
        duration: c ? 500 : 0,
        defer: 0
      };
    }
    function H(c, h) {
      for (var g = a.timers.length; g--;) a.timers[g].elem !== c || h && h !== a.timers[g].prop || (a.timers[g].stopped = !0);
    }
    var y = t.defined,
      F = t.getStyle,
      I = t.isArray,
      x = t.isNumber,
      q = t.isObject,
      m = t.merge,
      h = t.objectEach,
      c = t.pick;
    return {
      animate: function (c, z, g) {
        var f,
          e = "",
          n,
          J;
        if (!q(g)) {
          var M = arguments;
          g = {
            duration: M[2],
            easing: M[3],
            complete: M[4]
          };
        }
        x(g.duration) || (g.duration = 400);
        g.easing = "function" === typeof g.easing ? g.easing : Math[g.easing] || Math.easeInOutSine;
        g.curAnim = m(z);
        h(z, function (p, l) {
          H(c, l);
          J = new a(c, g, l);
          n = void 0;
          "d" === l && I(z.d) ? (J.paths = J.initPath(c, c.pathArray, z.d), J.toD = z.d, f = 0, n = 1) : c.attr ? f = c.attr(l) : (f = parseFloat(F(c, l)) || 0, "opacity" !== l && (e = "px"));
          n || (n = p);
          "string" === typeof n && n.match("px") && (n = n.replace(/px/g, ""));
          J.run(f, n, e);
        });
      },
      animObject: E,
      getDeferredAnimation: function (c, h, g) {
        var f = E(h),
          e = 0,
          n = 0;
        (g ? [g] : c.series).forEach(function (c) {
          c = E(c.options.animation);
          e = h && y(h.defer) ? f.defer : Math.max(e, c.duration + c.defer);
          n = Math.min(f.duration, c.duration);
        });
        c.renderer.forExport && (e = 0);
        return {
          defer: Math.max(0, e - n),
          duration: Math.min(e, n)
        };
      },
      setAnimation: function (n, h) {
        h.renderer.globalAnimation = c(n, h.options.chart.animation, !0);
      },
      stop: H
    };
  });
  N(a, "Core/Renderer/HTML/AST.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, t) {
    var E = a.SVG_NS,
      H = t.attr,
      y = t.createElement,
      F = t.error,
      I = t.isFunction,
      x = t.isString,
      q = t.objectEach,
      m = t.splat,
      h = (t = a.win.trustedTypes) && I(t.createPolicy) && t.createPolicy("highcharts", {
        createHTML: function (c) {
          return c;
        }
      }),
      c = h ? h.createHTML("") : "";
    try {
      var n = !!new DOMParser().parseFromString(c, "text/html");
    } catch (z) {
      n = !1;
    }
    I = function () {
      function z(c) {
        this.nodes = "string" === typeof c ? this.parseMarkup(c) : c;
      }
      z.filterUserAttributes = function (c) {
        q(c, function (f, e) {
          var g = !0;
          -1 === z.allowedAttributes.indexOf(e) && (g = !1);
          -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(e) && (g = x(f) && z.allowedReferences.some(function (e) {
            return 0 === f.indexOf(e);
          }));
          g || (F("Highcharts warning: Invalid attribute '" + e + "' in config"), delete c[e]);
        });
        return c;
      };
      z.setElementHTML = function (c, f) {
        c.innerHTML = z.emptyHTML;
        f && new z(f).addToDOM(c);
      };
      z.prototype.addToDOM = function (c) {
        function f(e, c) {
          var g;
          m(e).forEach(function (e) {
            var p = e.tagName,
              l = e.textContent ? a.doc.createTextNode(e.textContent) : void 0;
            if (p) if ("#text" === p) var w = l;else if (-1 !== z.allowedTags.indexOf(p)) {
              p = a.doc.createElementNS("svg" === p ? E : c.namespaceURI || E, p);
              var b = e.attributes || {};
              q(e, function (e, d) {
                "tagName" !== d && "attributes" !== d && "children" !== d && "textContent" !== d && (b[d] = e);
              });
              H(p, z.filterUserAttributes(b));
              l && p.appendChild(l);
              f(e.children || [], p);
              w = p;
            } else F("Highcharts warning: Invalid tagName " + p + " in config");
            w && c.appendChild(w);
            g = w;
          });
          return g;
        }
        return f(this.nodes, c);
      };
      z.prototype.parseMarkup = function (c) {
        var f = [];
        c = c.trim();
        if (n) c = new DOMParser().parseFromString(h ? h.createHTML(c) : c, "text/html");else {
          var e = y("div");
          e.innerHTML = c;
          c = {
            body: e
          };
        }
        var g = function (e, c) {
          var p = e.nodeName.toLowerCase(),
            l = {
              tagName: p
            };
          "#text" === p && (l.textContent = e.textContent || "");
          if (p = e.attributes) {
            var f = {};
            [].forEach.call(p, function (b) {
              f[b.name] = b.value;
            });
            l.attributes = f;
          }
          if (e.childNodes.length) {
            var b = [];
            [].forEach.call(e.childNodes, function (e) {
              g(e, b);
            });
            b.length && (l.children = b);
          }
          c.push(l);
        };
        [].forEach.call(c.body.childNodes, function (e) {
          return g(e, f);
        });
        return f;
      };
      z.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex".split(" ");
      z.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
      z.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
      z.emptyHTML = c;
      return z;
    }();
    "";
    return I;
  });
  N(a, "Core/FormatUtilities.js", [a["Core/DefaultOptions.js"], a["Core/Utilities.js"]], function (a, t) {
    function E(m, h, c, n) {
      m = +m || 0;
      h = +h;
      var z = H.lang,
        g = (m.toString().split(".")[1] || "").split("e")[0].length,
        f = m.toString().split("e"),
        e = h;
      if (-1 === h) h = Math.min(g, 20);else if (!I(h)) h = 2;else if (h && f[1] && 0 > f[1]) {
        var G = h + +f[1];
        0 <= G ? (f[0] = (+f[0]).toExponential(G).split("e")[0], h = G) : (f[0] = f[0].split(".")[0] || 0, m = 20 > h ? (f[0] * Math.pow(10, f[1])).toFixed(h) : 0, f[1] = 0);
      }
      G = (Math.abs(f[1] ? f[0] : m) + Math.pow(10, -Math.max(h, g) - 1)).toFixed(h);
      g = String(q(G));
      var J = 3 < g.length ? g.length % 3 : 0;
      c = x(c, z.decimalPoint);
      n = x(n, z.thousandsSep);
      m = (0 > m ? "-" : "") + (J ? g.substr(0, J) + n : "");
      m = 0 > +f[1] && !e ? "0" : m + g.substr(J).replace(/(\d{3})(?=\d)/g, "$1" + n);
      h && (m += c + G.slice(-h));
      f[1] && 0 !== +m && (m += "e" + f[1]);
      return m;
    }
    var H = a.defaultOptions,
      y = a.defaultTime,
      F = t.getNestedProperty,
      I = t.isNumber,
      x = t.pick,
      q = t.pInt;
    return {
      dateFormat: function (m, h, c) {
        return y.dateFormat(m, h, c);
      },
      format: function (m, h, c) {
        var n = "{",
          z = !1,
          g = /f$/,
          f = /\.([0-9])/,
          e = H.lang,
          G = c && c.time || y;
        c = c && c.numberFormatter || E;
        for (var J = []; m;) {
          var M = m.indexOf(n);
          if (-1 === M) break;
          var p = m.slice(0, M);
          if (z) {
            p = p.split(":");
            n = F(p.shift() || "", h);
            if (p.length && "number" === typeof n) if (p = p.join(":"), g.test(p)) {
              var l = parseInt((p.match(f) || ["", "-1"])[1], 10);
              null !== n && (n = c(n, l, e.decimalPoint, -1 < p.indexOf(",") ? e.thousandsSep : ""));
            } else n = G.dateFormat(p, n);
            J.push(n);
          } else J.push(p);
          m = m.slice(M + 1);
          n = (z = !z) ? "}" : "{";
        }
        J.push(m);
        return J.join("");
      },
      numberFormat: E
    };
  });
  N(a, "Core/Renderer/RendererUtilities.js", [a["Core/Utilities.js"]], function (a) {
    var E = a.clamp,
      B = a.pick,
      H = a.stableSort,
      y;
    (function (a) {
      function t(a, q, m) {
        var h = a,
          c = h.reducedLen || q,
          n = function (e, c) {
            return (c.rank || 0) - (e.rank || 0);
          },
          z = function (e, c) {
            return e.target - c.target;
          },
          g,
          f = !0,
          e = [],
          G = 0;
        for (g = a.length; g--;) G += a[g].size;
        if (G > c) {
          H(a, n);
          for (G = g = 0; G <= c;) G += a[g].size, g++;
          e = a.splice(g - 1, a.length);
        }
        H(a, z);
        for (a = a.map(function (e) {
          return {
            size: e.size,
            targets: [e.target],
            align: B(e.align, .5)
          };
        }); f;) {
          for (g = a.length; g--;) c = a[g], n = (Math.min.apply(0, c.targets) + Math.max.apply(0, c.targets)) / 2, c.pos = E(n - c.size * c.align, 0, q - c.size);
          g = a.length;
          for (f = !1; g--;) 0 < g && a[g - 1].pos + a[g - 1].size > a[g].pos && (a[g - 1].size += a[g].size, a[g - 1].targets = a[g - 1].targets.concat(a[g].targets), a[g - 1].align = .5, a[g - 1].pos + a[g - 1].size > q && (a[g - 1].pos = q - a[g - 1].size), a.splice(g, 1), f = !0);
        }
        h.push.apply(h, e);
        g = 0;
        a.some(function (e) {
          var c = 0;
          return (e.targets || []).some(function () {
            h[g].pos = e.pos + c;
            if ("undefined" !== typeof m && Math.abs(h[g].pos - h[g].target) > m) return h.slice(0, g + 1).forEach(function (e) {
              return delete e.pos;
            }), h.reducedLen = (h.reducedLen || q) - .1 * q, h.reducedLen > .1 * q && t(h, q, m), !0;
            c += h[g].size;
            g++;
            return !1;
          });
        });
        H(h, z);
        return h;
      }
      a.distribute = t;
    })(y || (y = {}));
    return y;
  });
  N(a, "Core/Renderer/SVG/SVGElement.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Renderer/HTML/AST.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, t, B, H, y) {
    var E = a.animate,
      I = a.animObject,
      x = a.stop,
      q = H.deg2rad,
      m = H.doc,
      h = H.noop,
      c = H.svg,
      n = H.SVG_NS,
      z = H.win,
      g = y.addEvent,
      f = y.attr,
      e = y.createElement,
      G = y.css,
      J = y.defined,
      M = y.erase,
      p = y.extend,
      l = y.fireEvent,
      w = y.isArray,
      b = y.isFunction,
      v = y.isNumber,
      d = y.isString,
      D = y.merge,
      C = y.objectEach,
      k = y.pick,
      K = y.pInt,
      O = y.syncTimeout,
      r = y.uniqueKey;
    a = function () {
      function A() {
        this.element = void 0;
        this.onEvents = {};
        this.opacity = 1;
        this.renderer = void 0;
        this.SVG_NS = n;
        this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
      }
      A.prototype._defaultGetter = function (b) {
        b = k(this[b + "Value"], this[b], this.element ? this.element.getAttribute(b) : null, 0);
        /^[\-0-9\.]+$/.test(b) && (b = parseFloat(b));
        return b;
      };
      A.prototype._defaultSetter = function (b, d, u) {
        u.setAttribute(d, b);
      };
      A.prototype.add = function (b) {
        var d = this.renderer,
          u = this.element;
        b && (this.parentGroup = b);
        this.parentInverted = b && b.inverted;
        "undefined" !== typeof this.textStr && "text" === this.element.nodeName && d.buildText(this);
        this.added = !0;
        if (!b || b.handleZ || this.zIndex) var L = this.zIndexSetter();
        L || (b ? b.element : d.box).appendChild(u);
        if (this.onAdd) this.onAdd();
        return this;
      };
      A.prototype.addClass = function (b, d) {
        var u = d ? "" : this.attr("class") || "";
        b = (b || "").split(/ /g).reduce(function (b, d) {
          -1 === u.indexOf(d) && b.push(d);
          return b;
        }, u ? [u] : []).join(" ");
        b !== u && this.attr("class", b);
        return this;
      };
      A.prototype.afterSetters = function () {
        this.doTransform && (this.updateTransform(), this.doTransform = !1);
      };
      A.prototype.align = function (b, e, u) {
        var L = {},
          r = this.renderer,
          l = r.alignedObjects,
          c,
          f,
          p;
        if (b) {
          if (this.alignOptions = b, this.alignByTranslate = e, !u || d(u)) this.alignTo = c = u || "renderer", M(l, this), l.push(this), u = void 0;
        } else b = this.alignOptions, e = this.alignByTranslate, c = this.alignTo;
        u = k(u, r[c], "scrollablePlotBox" === c ? r.plotBox : void 0, r);
        c = b.align;
        var v = b.verticalAlign;
        r = (u.x || 0) + (b.x || 0);
        l = (u.y || 0) + (b.y || 0);
        "right" === c ? f = 1 : "center" === c && (f = 2);
        f && (r += (u.width - (b.width || 0)) / f);
        L[e ? "translateX" : "x"] = Math.round(r);
        "bottom" === v ? p = 1 : "middle" === v && (p = 2);
        p && (l += (u.height - (b.height || 0)) / p);
        L[e ? "translateY" : "y"] = Math.round(l);
        this[this.placed ? "animate" : "attr"](L);
        this.placed = !0;
        this.alignAttr = L;
        return this;
      };
      A.prototype.alignSetter = function (b) {
        var d = {
          left: "start",
          center: "middle",
          right: "end"
        };
        d[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", d[b]));
      };
      A.prototype.animate = function (b, d, u) {
        var L = this,
          e = I(k(d, this.renderer.globalAnimation, !0));
        d = e.defer;
        k(m.hidden, m.msHidden, m.webkitHidden, !1) && (e.duration = 0);
        0 !== e.duration ? (u && (e.complete = u), O(function () {
          L.element && E(L, b, e);
        }, d)) : (this.attr(b, void 0, u), C(b, function (b, d) {
          e.step && e.step.call(this, b, {
            prop: d,
            pos: 1,
            elem: this
          });
        }, this));
        return this;
      };
      A.prototype.applyTextOutline = function (b) {
        var d = this.element;
        -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(d.style.fill)));
        var u = b.split(" ");
        b = u[u.length - 1];
        if ((u = u[0]) && "none" !== u && H.svg) {
          this.fakeTS = !0;
          this.ySetter = this.xSetter;
          u = u.replace(/(^[\d\.]+)(.*?)$/g, function (b, d, u) {
            return 2 * Number(d) + u;
          });
          this.removeTextOutline();
          var L = m.createElementNS(n, "tspan");
          f(L, {
            "class": "highcharts-text-outline",
            fill: b,
            stroke: b,
            "stroke-width": u,
            "stroke-linejoin": "round"
          });
          [].forEach.call(d.childNodes, function (b) {
            var d = b.cloneNode(!0);
            d.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (b) {
              return d.removeAttribute(b);
            });
            L.appendChild(d);
          });
          var k = m.createElementNS(n, "tspan");
          k.textContent = "\u200b";
          ["x", "y"].forEach(function (b) {
            var u = d.getAttribute(b);
            u && k.setAttribute(b, u);
          });
          L.appendChild(k);
          d.insertBefore(L, d.firstChild);
        }
      };
      A.prototype.attr = function (b, d, u, L) {
        var k = this.element,
          e = this.symbolCustomAttribs,
          r,
          l = this,
          c,
          f;
        if ("string" === typeof b && "undefined" !== typeof d) {
          var p = b;
          b = {};
          b[p] = d;
        }
        "string" === typeof b ? l = (this[b + "Getter"] || this._defaultGetter).call(this, b, k) : (C(b, function (d, u) {
          c = !1;
          L || x(this, u);
          this.symbolName && -1 !== e.indexOf(u) && (r || (this.symbolAttr(b), r = !0), c = !0);
          !this.rotation || "x" !== u && "y" !== u || (this.doTransform = !0);
          c || (f = this[u + "Setter"] || this._defaultSetter, f.call(this, d, u, k), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(u) && this.updateShadows(u, d, f));
        }, this), this.afterSetters());
        u && u.call(this);
        return l;
      };
      A.prototype.clip = function (b) {
        return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
      };
      A.prototype.crisp = function (b, d) {
        d = d || b.strokeWidth || 0;
        var u = Math.round(d) % 2 / 2;
        b.x = Math.floor(b.x || this.x || 0) + u;
        b.y = Math.floor(b.y || this.y || 0) + u;
        b.width = Math.floor((b.width || this.width || 0) - 2 * u);
        b.height = Math.floor((b.height || this.height || 0) - 2 * u);
        J(b.strokeWidth) && (b.strokeWidth = d);
        return b;
      };
      A.prototype.complexColor = function (b, d, u) {
        var L = this.renderer,
          k,
          e,
          c,
          f,
          p,
          v,
          A,
          g,
          n,
          P,
          K = [],
          h;
        l(this.renderer, "complexColor", {
          args: arguments
        }, function () {
          b.radialGradient ? e = "radialGradient" : b.linearGradient && (e = "linearGradient");
          if (e) {
            c = b[e];
            p = L.gradients;
            v = b.stops;
            n = u.radialReference;
            w(c) && (b[e] = c = {
              x1: c[0],
              y1: c[1],
              x2: c[2],
              y2: c[3],
              gradientUnits: "userSpaceOnUse"
            });
            "radialGradient" === e && n && !J(c.gradientUnits) && (f = c, c = D(c, L.getRadialAttr(n, f), {
              gradientUnits: "userSpaceOnUse"
            }));
            C(c, function (b, d) {
              "id" !== d && K.push(d, b);
            });
            C(v, function (b) {
              K.push(b);
            });
            K = K.join(",");
            if (p[K]) P = p[K].attr("id");else {
              c.id = P = r();
              var l = p[K] = L.createElement(e).attr(c).add(L.defs);
              l.radAttr = f;
              l.stops = [];
              v.forEach(function (b) {
                0 === b[1].indexOf("rgba") ? (k = B.parse(b[1]), A = k.get("rgb"), g = k.get("a")) : (A = b[1], g = 1);
                b = L.createElement("stop").attr({
                  offset: b[0],
                  "stop-color": A,
                  "stop-opacity": g
                }).add(l);
                l.stops.push(b);
              });
            }
            h = "url(" + L.url + "#" + P + ")";
            u.setAttribute(d, h);
            u.gradient = K;
            b.toString = function () {
              return h;
            };
          }
        });
      };
      A.prototype.css = function (b) {
        var d = this.styles,
          u = {},
          L = this.element,
          k = ["textOutline", "textOverflow", "width"],
          e = "",
          r = !d;
        b && b.color && (b.fill = b.color);
        d && C(b, function (b, k) {
          d && d[k] !== b && (u[k] = b, r = !0);
        });
        if (r) {
          d && (b = p(d, u));
          if (b) if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === L.nodeName.toLowerCase() && b.width) var l = this.textWidth = K(b.width);
          this.styles = b;
          l && !c && this.renderer.forExport && delete b.width;
          if (L.namespaceURI === this.SVG_NS) {
            var v = function (b, d) {
              return "-" + d.toLowerCase();
            };
            C(b, function (b, d) {
              -1 === k.indexOf(d) && (e += d.replace(/([A-Z])/g, v) + ":" + b + ";");
            });
            e && f(L, "style", e);
          } else G(L, b);
          this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));
        }
        return this;
      };
      A.prototype.dashstyleSetter = function (b) {
        var d = this["stroke-width"];
        "inherit" === d && (d = 1);
        if (b = b && b.toLowerCase()) {
          var u = b.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
          for (b = u.length; b--;) u[b] = "" + K(u[b]) * k(d, NaN);
          b = u.join(",").replace(/NaN/g, "none");
          this.element.setAttribute("stroke-dasharray", b);
        }
      };
      A.prototype.destroy = function () {
        var b = this,
          d = b.element || {},
          u = b.renderer,
          k = d.ownerSVGElement,
          e = u.isSVG && "SPAN" === d.nodeName && b.parentGroup || void 0;
        d.onclick = d.onmouseout = d.onmouseover = d.onmousemove = d.point = null;
        x(b);
        if (b.clipPath && k) {
          var r = b.clipPath;
          [].forEach.call(k.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
            -1 < b.getAttribute("clip-path").indexOf(r.element.id) && b.removeAttribute("clip-path");
          });
          b.clipPath = r.destroy();
        }
        if (b.stops) {
          for (k = 0; k < b.stops.length; k++) b.stops[k].destroy();
          b.stops.length = 0;
          b.stops = void 0;
        }
        b.safeRemoveChild(d);
        for (u.styledMode || b.destroyShadows(); e && e.div && 0 === e.div.childNodes.length;) d = e.parentGroup, b.safeRemoveChild(e.div), delete e.div, e = d;
        b.alignTo && M(u.alignedObjects, b);
        C(b, function (d, u) {
          b[u] && b[u].parentGroup === b && b[u].destroy && b[u].destroy();
          delete b[u];
        });
      };
      A.prototype.destroyShadows = function () {
        (this.shadows || []).forEach(function (b) {
          this.safeRemoveChild(b);
        }, this);
        this.shadows = void 0;
      };
      A.prototype.destroyTextPath = function (b, d) {
        var u = b.getElementsByTagName("text")[0];
        if (u) {
          if (u.removeAttribute("dx"), u.removeAttribute("dy"), d.element.setAttribute("id", ""), this.textPathWrapper && u.getElementsByTagName("textPath").length) {
            for (b = this.textPathWrapper.element.childNodes; b.length;) u.appendChild(b[0]);
            u.removeChild(this.textPathWrapper.element);
          }
        } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");
        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
      };
      A.prototype.dSetter = function (b, d, u) {
        w(b) && ("string" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, d, u) {
          return d && d.join ? (u ? b + " " : "") + d.join(" ") : (d || "").toString();
        }, ""));
        /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
        this[d] !== b && (u.setAttribute(d, b), this[d] = b);
      };
      A.prototype.fadeOut = function (b) {
        var d = this;
        d.animate({
          opacity: 0
        }, {
          duration: k(b, 150),
          complete: function () {
            d.attr({
              y: -9999
            }).hide();
          }
        });
      };
      A.prototype.fillSetter = function (b, d, u) {
        "string" === typeof b ? u.setAttribute(d, b) : b && this.complexColor(b, d, u);
      };
      A.prototype.getBBox = function (d, e) {
        var u = this.renderer,
          L = this.element,
          r = this.styles,
          l = this.textStr,
          c = u.cache,
          f = u.cacheKeys,
          v = L.namespaceURI === this.SVG_NS;
        e = k(e, this.rotation, 0);
        var D = u.styledMode ? L && A.prototype.getStyle.call(L, "font-size") : r && r.fontSize,
          w;
        if (J(l)) {
          var C = l.toString();
          -1 === C.indexOf("<") && (C = C.replace(/[0-9]/g, "0"));
          C += ["", e, D, this.textWidth, r && r.textOverflow, r && r.fontWeight].join();
        }
        C && !d && (w = c[C]);
        if (!w) {
          if (v || u.forExport) {
            try {
              var g = this.fakeTS && function (b) {
                var d = L.querySelector(".highcharts-text-outline");
                d && G(d, {
                  display: b
                });
              };
              b(g) && g("none");
              w = L.getBBox ? p({}, L.getBBox()) : {
                width: L.offsetWidth,
                height: L.offsetHeight
              };
              b(g) && g("");
            } catch (W) {
              "";
            }
            if (!w || 0 > w.width) w = {
              width: 0,
              height: 0
            };
          } else w = this.htmlGetBBox();
          u.isSVG && (d = w.width, u = w.height, v && (w.height = u = {
            "11px,17": 14,
            "13px,20": 16
          }[(D || "") + "," + Math.round(u)] || u), e && (v = e * q, w.width = Math.abs(u * Math.sin(v)) + Math.abs(d * Math.cos(v)), w.height = Math.abs(u * Math.cos(v)) + Math.abs(d * Math.sin(v))));
          if (C && ("" === l || 0 < w.height)) {
            for (; 250 < f.length;) delete c[f.shift()];
            c[C] || f.push(C);
            c[C] = w;
          }
        }
        return w;
      };
      A.prototype.getStyle = function (b) {
        return z.getComputedStyle(this.element || this, "").getPropertyValue(b);
      };
      A.prototype.hasClass = function (b) {
        return -1 !== ("" + this.attr("class")).split(" ").indexOf(b);
      };
      A.prototype.hide = function (b) {
        b ? this.attr({
          y: -9999
        }) : this.attr({
          visibility: "hidden"
        });
        return this;
      };
      A.prototype.htmlGetBBox = function () {
        return {
          height: 0,
          width: 0,
          x: 0,
          y: 0
        };
      };
      A.prototype.init = function (b, d) {
        this.element = "span" === d ? e(d) : m.createElementNS(this.SVG_NS, d);
        this.renderer = b;
        l(this, "afterInit");
      };
      A.prototype.invert = function (b) {
        this.inverted = b;
        this.updateTransform();
        return this;
      };
      A.prototype.on = function (b, d) {
        var u = this.onEvents;
        if (u[b]) u[b]();
        u[b] = g(this.element, b, d);
        return this;
      };
      A.prototype.opacitySetter = function (b, d, u) {
        this.opacity = b = Number(Number(b).toFixed(3));
        u.setAttribute(d, b);
      };
      A.prototype.removeClass = function (b) {
        return this.attr("class", ("" + this.attr("class")).replace(d(b) ? new RegExp("(^| )" + b + "( |$)") : b, " ").replace(/ +/g, " ").trim());
      };
      A.prototype.removeTextOutline = function () {
        var b = this.element.querySelector("tspan.highcharts-text-outline");
        b && this.safeRemoveChild(b);
      };
      A.prototype.safeRemoveChild = function (b) {
        var d = b.parentNode;
        d && d.removeChild(b);
      };
      A.prototype.setRadialReference = function (b) {
        var d = this.element.gradient && this.renderer.gradients[this.element.gradient];
        this.element.radialReference = b;
        d && d.radAttr && d.animate(this.renderer.getRadialAttr(b, d.radAttr));
        return this;
      };
      A.prototype.setTextPath = function (b, d) {
        var u = this.element,
          k = this.text ? this.text.element : u,
          e = {
            textAnchor: "text-anchor"
          },
          l = !1,
          c = this.textPathWrapper,
          f = !c;
        d = D(!0, {
          enabled: !0,
          attributes: {
            dy: -5,
            startOffset: "50%",
            textAnchor: "middle"
          }
        }, d);
        var p = t.filterUserAttributes(d.attributes);
        if (b && d && d.enabled) {
          c && null === c.element.parentNode ? (f = !0, c = c.destroy()) : c && this.removeTextOutline.call(c.parentGroup);
          this.options && this.options.padding && (p.dx = -this.options.padding);
          c || (this.textPathWrapper = c = this.renderer.createElement("textPath"), l = !0);
          var w = c.element;
          (d = b.element.getAttribute("id")) || b.element.setAttribute("id", d = r());
          if (f) for (k.setAttribute("y", 0), v(p.dx) && k.setAttribute("x", -p.dx), b = [].slice.call(k.childNodes), f = 0; f < b.length; f++) {
            var A = b[f];
            A.nodeType !== z.Node.TEXT_NODE && "tspan" !== A.nodeName || w.appendChild(A);
          }
          l && c && c.add({
            element: k
          });
          w.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + d);
          J(p.dy) && (w.parentNode.setAttribute("dy", p.dy), delete p.dy);
          J(p.dx) && (w.parentNode.setAttribute("dx", p.dx), delete p.dx);
          C(p, function (b, d) {
            w.setAttribute(e[d] || d, b);
          });
          u.removeAttribute("transform");
          this.removeTextOutline.call(c);
          this.text && !this.renderer.styledMode && this.attr({
            fill: "none",
            "stroke-width": 0
          });
          this.applyTextOutline = this.updateTransform = h;
        } else c && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(u, b), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));
        return this;
      };
      A.prototype.shadow = function (b, d, u) {
        var k = [],
          e = this.element,
          r = this.oldShadowOptions,
          c = {
            color: "#000000",
            offsetX: this.parentInverted ? -1 : 1,
            offsetY: this.parentInverted ? -1 : 1,
            opacity: .15,
            width: 3
          },
          l = !1,
          v;
        !0 === b ? v = c : "object" === typeof b && (v = p(c, b));
        v && (v && r && C(v, function (b, d) {
          b !== r[d] && (l = !0);
        }), l && this.destroyShadows(), this.oldShadowOptions = v);
        if (!v) this.destroyShadows();else if (!this.shadows) {
          var w = v.opacity / v.width;
          var D = this.parentInverted ? "translate(" + v.offsetY + ", " + v.offsetX + ")" : "translate(" + v.offsetX + ", " + v.offsetY + ")";
          for (c = 1; c <= v.width; c++) {
            var A = e.cloneNode(!1);
            var g = 2 * v.width + 1 - 2 * c;
            f(A, {
              stroke: b.color || "#000000",
              "stroke-opacity": w * c,
              "stroke-width": g,
              transform: D,
              fill: "none"
            });
            A.setAttribute("class", (A.getAttribute("class") || "") + " highcharts-shadow");
            u && (f(A, "height", Math.max(f(A, "height") - g, 0)), A.cutHeight = g);
            d ? d.element.appendChild(A) : e.parentNode && e.parentNode.insertBefore(A, e);
            k.push(A);
          }
          this.shadows = k;
        }
        return this;
      };
      A.prototype.show = function (b) {
        return this.attr({
          visibility: b ? "inherit" : "visible"
        });
      };
      A.prototype.strokeSetter = function (b, d, u) {
        this[d] = b;
        this.stroke && this["stroke-width"] ? (A.prototype.fillSetter.call(this, this.stroke, "stroke", u), u.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === d && 0 === b && this.hasStroke ? (u.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (u.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
      };
      A.prototype.strokeWidth = function () {
        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
        var b = this.getStyle("stroke-width"),
          d = 0;
        if (b.indexOf("px") === b.length - 2) d = K(b);else if ("" !== b) {
          var u = m.createElementNS(n, "rect");
          f(u, {
            width: b,
            "stroke-width": 0
          });
          this.element.parentNode.appendChild(u);
          d = u.getBBox().width;
          u.parentNode.removeChild(u);
        }
        return d;
      };
      A.prototype.symbolAttr = function (b) {
        var d = this;
        "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (u) {
          d[u] = k(b[u], d[u]);
        });
        d.attr({
          d: d.renderer.symbols[d.symbolName](d.x, d.y, d.width, d.height, d)
        });
      };
      A.prototype.textSetter = function (b) {
        b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
      };
      A.prototype.titleSetter = function (b) {
        var d = this.element,
          u = d.getElementsByTagName("title")[0] || m.createElementNS(this.SVG_NS, "title");
        d.insertBefore ? d.insertBefore(u, d.firstChild) : d.appendChild(u);
        u.textContent = String(k(b, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
      };
      A.prototype.toFront = function () {
        var b = this.element;
        b.parentNode.appendChild(b);
        return this;
      };
      A.prototype.translate = function (b, d) {
        return this.attr({
          translateX: b,
          translateY: d
        });
      };
      A.prototype.updateShadows = function (b, d, u) {
        var k = this.shadows;
        if (k) for (var e = k.length; e--;) u.call(k[e], "height" === b ? Math.max(d - (k[e].cutHeight || 0), 0) : "d" === b ? this.d : d, b, k[e]);
      };
      A.prototype.updateTransform = function () {
        var b = this.scaleX,
          d = this.scaleY,
          u = this.inverted,
          e = this.rotation,
          r = this.matrix,
          c = this.element,
          l = this.translateX || 0,
          f = this.translateY || 0;
        u && (l += this.width, f += this.height);
        l = ["translate(" + l + "," + f + ")"];
        J(r) && l.push("matrix(" + r.join(",") + ")");
        u ? l.push("rotate(90) scale(-1,1)") : e && l.push("rotate(" + e + " " + k(this.rotationOriginX, c.getAttribute("x"), 0) + " " + k(this.rotationOriginY, c.getAttribute("y") || 0) + ")");
        (J(b) || J(d)) && l.push("scale(" + k(b, 1) + " " + k(d, 1) + ")");
        l.length && c.setAttribute("transform", l.join(" "));
      };
      A.prototype.visibilitySetter = function (b, d, u) {
        "inherit" === b ? u.removeAttribute(d) : this[d] !== b && u.setAttribute(d, b);
        this[d] = b;
      };
      A.prototype.xGetter = function (b) {
        "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
        return this._defaultGetter(b);
      };
      A.prototype.zIndexSetter = function (b, d) {
        var u = this.renderer,
          k = this.parentGroup,
          e = (k || u).element || u.box,
          r = this.element;
        u = e === u.box;
        var c = !1;
        var l = this.added;
        var f;
        J(b) ? (r.setAttribute("data-z-index", b), b = +b, this[d] === b && (l = !1)) : J(this[d]) && r.removeAttribute("data-z-index");
        this[d] = b;
        if (l) {
          (b = this.zIndex) && k && (k.handleZ = !0);
          d = e.childNodes;
          for (f = d.length - 1; 0 <= f && !c; f--) {
            k = d[f];
            l = k.getAttribute("data-z-index");
            var p = !J(l);
            if (k !== r) if (0 > b && p && !u && !f) e.insertBefore(r, d[f]), c = !0;else if (K(l) <= b || p && (!J(b) || 0 <= b)) e.insertBefore(r, d[f + 1] || null), c = !0;
          }
          c || (e.insertBefore(r, d[u ? 3 : 0] || null), c = !0);
        }
        return c;
      };
      return A;
    }();
    a.prototype["stroke-widthSetter"] = a.prototype.strokeSetter;
    a.prototype.yGetter = a.prototype.xGetter;
    a.prototype.matrixSetter = a.prototype.rotationOriginXSetter = a.prototype.rotationOriginYSetter = a.prototype.rotationSetter = a.prototype.scaleXSetter = a.prototype.scaleYSetter = a.prototype.translateXSetter = a.prototype.translateYSetter = a.prototype.verticalAlignSetter = function (b, d) {
      this[d] = b;
      this.doTransform = !0;
    };
    "";
    return a;
  });
  N(a, "Core/Renderer/RendererRegistry.js", [a["Core/Globals.js"]], function (a) {
    var E;
    (function (E) {
      E.rendererTypes = {};
      var t;
      E.getRendererType = function (a) {
        void 0 === a && (a = t);
        return E.rendererTypes[a] || E.rendererTypes[t];
      };
      E.registerRendererType = function (y, F, I) {
        E.rendererTypes[y] = F;
        if (!t || I) t = y, a.Renderer = F;
      };
    })(E || (E = {}));
    return E;
  });
  N(a, "Core/Renderer/SVG/SVGLabel.js", [a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, t) {
    var E = this && this.__extends || function () {
        var a = function (h, c) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (c, h) {
            c.__proto__ = h;
          } || function (c, h) {
            for (var g in h) h.hasOwnProperty(g) && (c[g] = h[g]);
          };
          return a(h, c);
        };
        return function (h, c) {
          function n() {
            this.constructor = h;
          }
          a(h, c);
          h.prototype = null === c ? Object.create(c) : (n.prototype = c.prototype, new n());
        };
      }(),
      H = t.defined,
      y = t.extend,
      F = t.isNumber,
      I = t.merge,
      x = t.pick,
      q = t.removeEvent;
    return function (m) {
      function h(c, n, a, g, f, e, G, J, M, p) {
        var l = m.call(this) || this;
        l.paddingLeftSetter = l.paddingSetter;
        l.paddingRightSetter = l.paddingSetter;
        l.init(c, "g");
        l.textStr = n;
        l.x = a;
        l.y = g;
        l.anchorX = e;
        l.anchorY = G;
        l.baseline = M;
        l.className = p;
        l.addClass("button" === p ? "highcharts-no-tooltip" : "highcharts-label");
        p && l.addClass("highcharts-" + p);
        l.text = c.text(void 0, 0, 0, J).attr({
          zIndex: 1
        });
        var w;
        "string" === typeof f && ((w = /^url\((.*?)\)$/.test(f)) || l.renderer.symbols[f]) && (l.symbolKey = f);
        l.bBox = h.emptyBBox;
        l.padding = 3;
        l.baselineOffset = 0;
        l.needsBox = c.styledMode || w;
        l.deferredAttr = {};
        l.alignFactor = 0;
        return l;
      }
      E(h, m);
      h.prototype.alignSetter = function (c) {
        c = {
          left: 0,
          center: .5,
          right: 1
        }[c];
        c !== this.alignFactor && (this.alignFactor = c, this.bBox && F(this.xSetting) && this.attr({
          x: this.xSetting
        }));
      };
      h.prototype.anchorXSetter = function (c, n) {
        this.anchorX = c;
        this.boxAttr(n, Math.round(c) - this.getCrispAdjust() - this.xSetting);
      };
      h.prototype.anchorYSetter = function (c, n) {
        this.anchorY = c;
        this.boxAttr(n, c - this.ySetting);
      };
      h.prototype.boxAttr = function (c, n) {
        this.box ? this.box.attr(c, n) : this.deferredAttr[c] = n;
      };
      h.prototype.css = function (c) {
        if (c) {
          var n = {};
          c = I(c);
          h.textProps.forEach(function (g) {
            "undefined" !== typeof c[g] && (n[g] = c[g], delete c[g]);
          });
          this.text.css(n);
          var z = ("width" in n);
          "fontSize" in n || "fontWeight" in n ? this.updateTextPadding() : z && this.updateBoxSize();
        }
        return a.prototype.css.call(this, c);
      };
      h.prototype.destroy = function () {
        q(this.element, "mouseenter");
        q(this.element, "mouseleave");
        this.text && this.text.destroy();
        this.box && (this.box = this.box.destroy());
        a.prototype.destroy.call(this);
      };
      h.prototype.fillSetter = function (c, n) {
        c && (this.needsBox = !0);
        this.fill = c;
        this.boxAttr(n, c);
      };
      h.prototype.getBBox = function () {
        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
        var c = this.padding,
          n = x(this.paddingLeft, c);
        return {
          width: this.width,
          height: this.height,
          x: this.bBox.x - n,
          y: this.bBox.y - c
        };
      };
      h.prototype.getCrispAdjust = function () {
        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
      };
      h.prototype.heightSetter = function (c) {
        this.heightSetting = c;
      };
      h.prototype.onAdd = function () {
        var c = this.textStr;
        this.text.add(this);
        this.attr({
          text: H(c) ? c : "",
          x: this.x,
          y: this.y
        });
        this.box && H(this.anchorX) && this.attr({
          anchorX: this.anchorX,
          anchorY: this.anchorY
        });
      };
      h.prototype.paddingSetter = function (c, n) {
        F(c) ? c !== this[n] && (this[n] = c, this.updateTextPadding()) : this[n] = void 0;
      };
      h.prototype.rSetter = function (c, n) {
        this.boxAttr(n, c);
      };
      h.prototype.shadow = function (c) {
        c && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(c));
        return this;
      };
      h.prototype.strokeSetter = function (c, n) {
        this.stroke = c;
        this.boxAttr(n, c);
      };
      h.prototype["stroke-widthSetter"] = function (c, n) {
        c && (this.needsBox = !0);
        this["stroke-width"] = c;
        this.boxAttr(n, c);
      };
      h.prototype["text-alignSetter"] = function (c) {
        this.textAlign = c;
      };
      h.prototype.textSetter = function (c) {
        "undefined" !== typeof c && this.text.attr({
          text: c
        });
        this.updateTextPadding();
      };
      h.prototype.updateBoxSize = function () {
        var c = this.text.element.style,
          n = {},
          a = this.padding,
          g = this.bBox = F(this.widthSetting) && F(this.heightSetting) && !this.textAlign || !H(this.text.textStr) ? h.emptyBBox : this.text.getBBox();
        this.width = this.getPaddedWidth();
        this.height = (this.heightSetting || g.height || 0) + 2 * a;
        c = this.renderer.fontMetrics(c && c.fontSize, this.text);
        this.baselineOffset = a + Math.min((this.text.firstLineMetrics || c).b, g.height || Infinity);
        this.heightSetting && (this.baselineOffset += (this.heightSetting - c.h) / 2);
        this.needsBox && (this.box || (a = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), a.add(this)), a = this.getCrispAdjust(), n.x = a, n.y = (this.baseline ? -this.baselineOffset : 0) + a, n.width = Math.round(this.width), n.height = Math.round(this.height), this.box.attr(y(n, this.deferredAttr)), this.deferredAttr = {});
      };
      h.prototype.updateTextPadding = function () {
        var c = this.text;
        this.updateBoxSize();
        var n = this.baseline ? 0 : this.baselineOffset,
          h = x(this.paddingLeft, this.padding);
        H(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (h += {
          center: .5,
          right: 1
        }[this.textAlign] * (this.widthSetting - this.bBox.width));
        if (h !== c.x || n !== c.y) c.attr("x", h), c.hasBoxWidthChanged && (this.bBox = c.getBBox(!0)), "undefined" !== typeof n && c.attr("y", n);
        c.x = h;
        c.y = n;
      };
      h.prototype.widthSetter = function (c) {
        this.widthSetting = F(c) ? c : void 0;
      };
      h.prototype.getPaddedWidth = function () {
        var c = this.padding,
          n = x(this.paddingLeft, c);
        c = x(this.paddingRight, c);
        return (this.widthSetting || this.bBox.width || 0) + n + c;
      };
      h.prototype.xSetter = function (c) {
        this.x = c;
        this.alignFactor && (c -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
        this.xSetting = Math.round(c);
        this.attr("translateX", this.xSetting);
      };
      h.prototype.ySetter = function (c) {
        this.ySetting = this.y = Math.round(c);
        this.attr("translateY", this.ySetting);
      };
      h.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      };
      h.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
      return h;
    }(a);
  });
  N(a, "Core/Renderer/SVG/Symbols.js", [a["Core/Utilities.js"]], function (a) {
    function E(a, q, m, h, c) {
      var n = [];
      if (c) {
        var z = c.start || 0,
          g = I(c.r, m);
        m = I(c.r, h || m);
        var f = (c.end || 0) - .001;
        h = c.innerR;
        var e = I(c.open, .001 > Math.abs((c.end || 0) - z - 2 * Math.PI)),
          G = Math.cos(z),
          J = Math.sin(z),
          M = Math.cos(f),
          p = Math.sin(f);
        z = I(c.longArc, .001 > f - z - Math.PI ? 0 : 1);
        n.push(["M", a + g * G, q + m * J], ["A", g, m, 0, z, I(c.clockwise, 1), a + g * M, q + m * p]);
        y(h) && n.push(e ? ["M", a + h * M, q + h * p] : ["L", a + h * M, q + h * p], ["A", h, h, 0, z, y(c.clockwise) ? 1 - c.clockwise : 0, a + h * G, q + h * J]);
        e || n.push(["Z"]);
      }
      return n;
    }
    function B(a, q, m, h, c) {
      return c && c.r ? H(a, q, m, h, c) : [["M", a, q], ["L", a + m, q], ["L", a + m, q + h], ["L", a, q + h], ["Z"]];
    }
    function H(a, q, m, h, c) {
      c = c && c.r || 0;
      return [["M", a + c, q], ["L", a + m - c, q], ["C", a + m, q, a + m, q, a + m, q + c], ["L", a + m, q + h - c], ["C", a + m, q + h, a + m, q + h, a + m - c, q + h], ["L", a + c, q + h], ["C", a, q + h, a, q + h, a, q + h - c], ["L", a, q + c], ["C", a, q, a, q, a + c, q]];
    }
    var y = a.defined,
      F = a.isNumber,
      I = a.pick;
    return {
      arc: E,
      callout: function (a, q, m, h, c) {
        var n = Math.min(c && c.r || 0, m, h),
          z = n + 6,
          g = c && c.anchorX;
        c = c && c.anchorY || 0;
        var f = H(a, q, m, h, {
          r: n
        });
        if (!F(g)) return f;
        a + g >= m ? c > q + z && c < q + h - z ? f.splice(3, 1, ["L", a + m, c - 6], ["L", a + m + 6, c], ["L", a + m, c + 6], ["L", a + m, q + h - n]) : f.splice(3, 1, ["L", a + m, h / 2], ["L", g, c], ["L", a + m, h / 2], ["L", a + m, q + h - n]) : 0 >= a + g ? c > q + z && c < q + h - z ? f.splice(7, 1, ["L", a, c + 6], ["L", a - 6, c], ["L", a, c - 6], ["L", a, q + n]) : f.splice(7, 1, ["L", a, h / 2], ["L", g, c], ["L", a, h / 2], ["L", a, q + n]) : c && c > h && g > a + z && g < a + m - z ? f.splice(5, 1, ["L", g + 6, q + h], ["L", g, q + h + 6], ["L", g - 6, q + h], ["L", a + n, q + h]) : c && 0 > c && g > a + z && g < a + m - z && f.splice(1, 1, ["L", g - 6, q], ["L", g, q - 6], ["L", g + 6, q], ["L", m - n, q]);
        return f;
      },
      circle: function (a, q, m, h) {
        return E(a + m / 2, q + h / 2, m / 2, h / 2, {
          start: .5 * Math.PI,
          end: 2.5 * Math.PI,
          open: !1
        });
      },
      diamond: function (a, q, m, h) {
        return [["M", a + m / 2, q], ["L", a + m, q + h / 2], ["L", a + m / 2, q + h], ["L", a, q + h / 2], ["Z"]];
      },
      rect: B,
      roundedRect: H,
      square: B,
      triangle: function (a, q, m, h) {
        return [["M", a + m / 2, q], ["L", a + m, q + h], ["L", a, q + h], ["Z"]];
      },
      "triangle-down": function (a, q, m, h) {
        return [["M", a, q], ["L", a + m, q], ["L", a + m / 2, q + h], ["Z"]];
      }
    };
  });
  N(a, "Core/Renderer/SVG/TextBuilder.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = t.doc,
      y = t.SVG_NS,
      F = t.win,
      I = B.attr,
      x = B.isString,
      q = B.objectEach,
      m = B.pick;
    return function () {
      function h(c) {
        var a = c.styles;
        this.renderer = c.renderer;
        this.svgElement = c;
        this.width = c.textWidth;
        this.textLineHeight = a && a.lineHeight;
        this.textOutline = a && a.textOutline;
        this.ellipsis = !(!a || "ellipsis" !== a.textOverflow);
        this.noWrap = !(!a || "nowrap" !== a.whiteSpace);
        this.fontSize = a && a.fontSize;
      }
      h.prototype.buildSVG = function () {
        var c = this.svgElement,
          n = c.element,
          h = c.renderer,
          g = m(c.textStr, "").toString(),
          f = -1 !== g.indexOf("<"),
          e = n.childNodes;
        h = this.width && !c.added && h.box;
        var G = /<br.*?>/g,
          J = [g, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();
        if (J !== c.textCache) {
          c.textCache = J;
          delete c.actualWidth;
          for (J = e.length; J--;) n.removeChild(e[J]);
          f || this.ellipsis || this.width || -1 !== g.indexOf(" ") && (!this.noWrap || G.test(g)) ? "" !== g && (h && h.appendChild(n), g = new a(g), this.modifyTree(g.nodes), g.addToDOM(c.element), this.modifyDOM(), this.ellipsis && -1 !== (n.textContent || "").indexOf("\u2026") && c.attr("title", this.unescapeEntities(c.textStr || "", ["&lt;", "&gt;"])), h && h.removeChild(n)) : n.appendChild(E.createTextNode(this.unescapeEntities(g)));
          x(this.textOutline) && c.applyTextOutline && c.applyTextOutline(this.textOutline);
        }
      };
      h.prototype.modifyDOM = function () {
        var c = this,
          a = this.svgElement,
          h = I(a.element, "x");
        a.firstLineMetrics = void 0;
        for (var g; g = a.element.firstChild;) if (/^[\s\u200B]*$/.test(g.textContent || " ")) a.element.removeChild(g);else break;
        [].forEach.call(a.element.querySelectorAll("tspan.highcharts-br"), function (e, f) {
          e.nextSibling && e.previousSibling && (0 === f && 1 === e.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(void 0, e.previousSibling)), I(e, {
            dy: c.getLineHeight(e.nextSibling),
            x: h
          }));
        });
        var f = this.width || 0;
        if (f) {
          var e = function (e, g) {
              var p = e.textContent || "",
                l = p.replace(/([^\^])-/g, "$1- ").split(" "),
                w = !c.noWrap && (1 < l.length || 1 < a.element.childNodes.length),
                b = c.getLineHeight(g),
                v = 0,
                d = a.actualWidth;
              if (c.ellipsis) p && c.truncate(e, p, void 0, 0, Math.max(0, f - parseInt(c.fontSize || 12, 10)), function (b, d) {
                return b.substring(0, d) + "\u2026";
              });else if (w) {
                p = [];
                for (w = []; g.firstChild && g.firstChild !== e;) w.push(g.firstChild), g.removeChild(g.firstChild);
                for (; l.length;) l.length && !c.noWrap && 0 < v && (p.push(e.textContent || ""), e.textContent = l.join(" ").replace(/- /g, "-")), c.truncate(e, void 0, l, 0 === v ? d || 0 : 0, f, function (b, d) {
                  return l.slice(0, d).join(" ").replace(/- /g, "-");
                }), d = a.actualWidth, v++;
                w.forEach(function (b) {
                  g.insertBefore(b, e);
                });
                p.forEach(function (d) {
                  g.insertBefore(E.createTextNode(d), e);
                  d = E.createElementNS(y, "tspan");
                  d.textContent = "\u200b";
                  I(d, {
                    dy: b,
                    x: h
                  });
                  g.insertBefore(d, e);
                });
              }
            },
            G = function (c) {
              [].slice.call(c.childNodes).forEach(function (f) {
                f.nodeType === F.Node.TEXT_NODE ? e(f, c) : (-1 !== f.className.baseVal.indexOf("highcharts-br") && (a.actualWidth = 0), G(f));
              });
            };
          G(a.element);
        }
      };
      h.prototype.getLineHeight = function (c) {
        var a;
        c = c.nodeType === F.Node.TEXT_NODE ? c.parentElement : c;
        this.renderer.styledMode || (a = c && /(px|em)$/.test(c.style.fontSize) ? c.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a, c || this.svgElement.element).h;
      };
      h.prototype.modifyTree = function (c) {
        var a = this,
          h = function (g, f) {
            var e = g.attributes;
            e = void 0 === e ? {} : e;
            var n = g.children,
              J = g.tagName,
              m = a.renderer.styledMode;
            if ("b" === J || "strong" === J) m ? e["class"] = "highcharts-strong" : e.style = "font-weight:bold;" + (e.style || "");else if ("i" === J || "em" === J) m ? e["class"] = "highcharts-emphasized" : e.style = "font-style:italic;" + (e.style || "");
            x(e.style) && (e.style = e.style.replace(/(;| |^)color([ :])/, "$1fill$2"));
            "br" === J ? (e["class"] = "highcharts-br", g.textContent = "\u200b", (f = c[f + 1]) && f.textContent && (f.textContent = f.textContent.replace(/^ +/gm, ""))) : "a" === J && n && n.some(function (e) {
              return "#text" === e.tagName;
            }) && (g.children = [{
              children: n,
              tagName: "tspan"
            }]);
            "#text" !== J && "a" !== J && (g.tagName = "tspan");
            g.attributes = e;
            n && n.filter(function (e) {
              return "#text" !== e.tagName;
            }).forEach(h);
          };
        c.forEach(h);
      };
      h.prototype.truncate = function (c, a, h, g, f, e) {
        var n = this.svgElement,
          J = n.renderer,
          m = n.rotation,
          p = [],
          l = h ? 1 : 0,
          w = (a || h || "").length,
          b = w,
          v,
          d = function (b, d) {
            d = d || b;
            var k = c.parentNode;
            if (k && "undefined" === typeof p[d]) if (k.getSubStringLength) try {
              p[d] = g + k.getSubStringLength(0, h ? d + 1 : d);
            } catch (O) {
              "";
            } else J.getSpanWidth && (c.textContent = e(a || h, b), p[d] = g + J.getSpanWidth(n, c));
            return p[d];
          };
        n.rotation = 0;
        var D = d(c.textContent.length);
        if (g + D > f) {
          for (; l <= w;) b = Math.ceil((l + w) / 2), h && (v = e(h, b)), D = d(b, v && v.length - 1), l === w ? l = w + 1 : D > f ? w = b - 1 : l = b;
          0 === w ? c.textContent = "" : a && w === a.length - 1 || (c.textContent = v || e(a || h, b));
        }
        h && h.splice(0, b);
        n.actualWidth = D;
        n.rotation = m;
      };
      h.prototype.unescapeEntities = function (c, a) {
        q(this.renderer.escapes, function (h, g) {
          a && -1 !== a.indexOf(h) || (c = c.toString().replace(new RegExp(h, "g"), g));
        });
        return c;
      };
      return h;
    }();
  });
  N(a, "Core/Renderer/SVG/SVGRenderer.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGLabel.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Renderer/SVG/TextBuilder.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F, I, x, q) {
    var m = B.charts,
      h = B.deg2rad,
      c = B.doc,
      n = B.isFirefox,
      z = B.isMS,
      g = B.isWebKit,
      f = B.noop,
      e = B.SVG_NS,
      G = B.symbolSizes,
      J = B.win,
      M = q.addEvent,
      p = q.attr,
      l = q.createElement,
      w = q.css,
      b = q.defined,
      v = q.destroyObjectProperties,
      d = q.extend,
      D = q.isArray,
      C = q.isNumber,
      k = q.isObject,
      K = q.isString,
      O = q.merge,
      r = q.pick,
      A = q.pInt,
      P = q.uniqueKey,
      V;
    B = function () {
      function u(b, d, u, e, k, r, c) {
        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
        this.init(b, d, u, e, k, r, c);
      }
      u.prototype.init = function (b, d, u, e, k, r, l) {
        var L = this.createElement("svg").attr({
            version: "1.1",
            "class": "highcharts-root"
          }),
          f = L.element;
        l || L.css(this.getStyle(e));
        b.appendChild(f);
        p(b, "dir", "ltr");
        -1 === b.innerHTML.indexOf("xmlns") && p(f, "xmlns", this.SVG_NS);
        this.isSVG = !0;
        this.box = f;
        this.boxWrapper = L;
        this.alignedObjects = [];
        this.url = this.getReferenceURL();
        this.createElement("desc").add().element.appendChild(c.createTextNode("Created with Highcharts 9.3.3"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = r;
        this.forExport = k;
        this.styledMode = l;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(d, u, !1);
        var v;
        n && b.getBoundingClientRect && (d = function () {
          w(b, {
            left: 0,
            top: 0
          });
          v = b.getBoundingClientRect();
          w(b, {
            left: Math.ceil(v.left) - v.left + "px",
            top: Math.ceil(v.top) - v.top + "px"
          });
        }, d(), this.unSubPixelFix = M(J, "resize", d));
      };
      u.prototype.definition = function (b) {
        return new a([b]).addToDOM(this.defs.element);
      };
      u.prototype.getReferenceURL = function () {
        if ((n || g) && c.getElementsByTagName("base").length) {
          if (!b(V)) {
            var d = P();
            d = new a([{
              tagName: "svg",
              attributes: {
                width: 8,
                height: 8
              },
              children: [{
                tagName: "defs",
                children: [{
                  tagName: "clipPath",
                  attributes: {
                    id: d
                  },
                  children: [{
                    tagName: "rect",
                    attributes: {
                      width: 4,
                      height: 4
                    }
                  }]
                }]
              }, {
                tagName: "rect",
                attributes: {
                  id: "hitme",
                  width: 8,
                  height: 8,
                  "clip-path": "url(#" + d + ")",
                  fill: "rgba(0,0,0,0.001)"
                }
              }]
            }]).addToDOM(c.body);
            w(d, {
              position: "fixed",
              top: 0,
              left: 0,
              zIndex: 9E5
            });
            var u = c.elementFromPoint(6, 6);
            V = "hitme" === (u && u.id);
            c.body.removeChild(d);
          }
          if (V) return J.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
        }
        return "";
      };
      u.prototype.getStyle = function (b) {
        return this.style = d({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: "12px"
        }, b);
      };
      u.prototype.setStyle = function (b) {
        this.boxWrapper.css(this.getStyle(b));
      };
      u.prototype.isHidden = function () {
        return !this.boxWrapper.getBBox().width;
      };
      u.prototype.destroy = function () {
        var b = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        v(this.gradients || {});
        this.gradients = null;
        b && (this.defs = b.destroy());
        this.unSubPixelFix && this.unSubPixelFix();
        return this.alignedObjects = null;
      };
      u.prototype.createElement = function (b) {
        var d = new this.Element();
        d.init(this, b);
        return d;
      };
      u.prototype.getRadialAttr = function (b, d) {
        return {
          cx: b[0] - b[2] / 2 + (d.cx || 0) * b[2],
          cy: b[1] - b[2] / 2 + (d.cy || 0) * b[2],
          r: (d.r || 0) * b[2]
        };
      };
      u.prototype.buildText = function (b) {
        new x(b).buildSVG();
      };
      u.prototype.getContrast = function (b) {
        b = t.parse(b).rgba;
        b[0] *= 1;
        b[1] *= 1.2;
        b[2] *= .5;
        return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
      };
      u.prototype.button = function (b, u, e, k, r, c, l, f, v, p) {
        var L = this.label(b, u, e, v, void 0, void 0, p, void 0, "button"),
          w = this.styledMode,
          A = 0,
          D = r ? O(r) : {};
        b = D && D.style || {};
        D = a.filterUserAttributes(D);
        L.attr(O({
          padding: 8,
          r: 2
        }, D));
        if (!w) {
          D = O({
            fill: "#f7f7f7",
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontWeight: "normal"
            }
          }, {
            style: b
          }, D);
          var g = D.style;
          delete D.style;
          c = O(D, {
            fill: "#e6e6e6"
          }, a.filterUserAttributes(c || {}));
          var C = c.style;
          delete c.style;
          l = O(D, {
            fill: "#e6ebf5",
            style: {
              color: "#000000",
              fontWeight: "bold"
            }
          }, a.filterUserAttributes(l || {}));
          var h = l.style;
          delete l.style;
          f = O(D, {
            style: {
              color: "#cccccc"
            }
          }, a.filterUserAttributes(f || {}));
          var K = f.style;
          delete f.style;
        }
        M(L.element, z ? "mouseover" : "mouseenter", function () {
          3 !== A && L.setState(1);
        });
        M(L.element, z ? "mouseout" : "mouseleave", function () {
          3 !== A && L.setState(A);
        });
        L.setState = function (b) {
          1 !== b && (L.state = A = b);
          L.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
          w || L.attr([D, c, l, f][b || 0]).css([g, C, h, K][b || 0]);
        };
        w || L.attr(D).css(d({
          cursor: "default"
        }, g));
        return L.on("touchstart", function (b) {
          return b.stopPropagation();
        }).on("click", function (b) {
          3 !== A && k.call(L, b);
        });
      };
      u.prototype.crispLine = function (d, u, e) {
        void 0 === e && (e = "round");
        var k = d[0],
          c = d[1];
        b(k[1]) && k[1] === c[1] && (k[1] = c[1] = Math[e](k[1]) - u % 2 / 2);
        b(k[2]) && k[2] === c[2] && (k[2] = c[2] = Math[e](k[2]) + u % 2 / 2);
        return d;
      };
      u.prototype.path = function (b) {
        var u = this.styledMode ? {} : {
          fill: "none"
        };
        D(b) ? u.d = b : k(b) && d(u, b);
        return this.createElement("path").attr(u);
      };
      u.prototype.circle = function (b, d, u) {
        b = k(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: d,
          r: u
        };
        d = this.createElement("circle");
        d.xSetter = d.ySetter = function (b, d, u) {
          u.setAttribute("c" + d, b);
        };
        return d.attr(b);
      };
      u.prototype.arc = function (b, d, u, e, c, r) {
        k(b) ? (e = b, d = e.y, u = e.r, b = e.x) : e = {
          innerR: e,
          start: c,
          end: r
        };
        b = this.symbol("arc", b, d, u, u, e);
        b.r = u;
        return b;
      };
      u.prototype.rect = function (b, d, u, e, c, r) {
        c = k(b) ? b.r : c;
        var l = this.createElement("rect");
        b = k(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: d,
          width: Math.max(u, 0),
          height: Math.max(e, 0)
        };
        this.styledMode || ("undefined" !== typeof r && (b["stroke-width"] = r, b = l.crisp(b)), b.fill = "none");
        c && (b.r = c);
        l.rSetter = function (b, d, u) {
          l.r = b;
          p(u, {
            rx: b,
            ry: b
          });
        };
        l.rGetter = function () {
          return l.r || 0;
        };
        return l.attr(b);
      };
      u.prototype.setSize = function (b, d, u) {
        this.width = b;
        this.height = d;
        this.boxWrapper.animate({
          width: b,
          height: d
        }, {
          step: function () {
            this.attr({
              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
            });
          },
          duration: r(u, !0) ? void 0 : 0
        });
        this.alignElements();
      };
      u.prototype.g = function (b) {
        var d = this.createElement("g");
        return b ? d.attr({
          "class": "highcharts-" + b
        }) : d;
      };
      u.prototype.image = function (b, d, u, e, k, c) {
        var r = {
            preserveAspectRatio: "none"
          },
          l = function (b, d) {
            b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", d) : b.setAttribute("hc-svg-href", d);
          };
        C(d) && (r.x = d);
        C(u) && (r.y = u);
        C(e) && (r.width = e);
        C(k) && (r.height = k);
        var f = this.createElement("image").attr(r);
        d = function (d) {
          l(f.element, b);
          c.call(f, d);
        };
        c ? (l(f.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), u = new J.Image(), M(u, "load", d), u.src = b, u.complete && d({})) : l(f.element, b);
        return f;
      };
      u.prototype.symbol = function (u, e, k, f, v, p) {
        var L = this,
          D = /^url\((.*?)\)$/,
          A = D.test(u),
          a = !A && (this.symbols[u] ? u : "circle"),
          g = a && this.symbols[a],
          C;
        if (g) {
          "number" === typeof e && (C = g.call(this.symbols, Math.round(e || 0), Math.round(k || 0), f || 0, v || 0, p));
          var h = this.path(C);
          L.styledMode || h.attr("fill", "none");
          d(h, {
            symbolName: a || void 0,
            x: e,
            y: k,
            width: f,
            height: v
          });
          p && d(h, p);
        } else if (A) {
          var K = u.match(D)[1];
          var n = h = this.image(K);
          n.imgwidth = r(G[K] && G[K].width, p && p.width);
          n.imgheight = r(G[K] && G[K].height, p && p.height);
          var Q = function (b) {
            return b.attr({
              width: b.width,
              height: b.height
            });
          };
          ["width", "height"].forEach(function (d) {
            n[d + "Setter"] = function (d, u) {
              var e = this["img" + u];
              this[u] = d;
              b(e) && (p && "within" === p.backgroundSize && this.width && this.height && (e = Math.round(e * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(u, e), this.alignByTranslate || (d = ((this[u] || 0) - e) / 2, this.attr("width" === u ? {
                translateX: d
              } : {
                translateY: d
              })));
            };
          });
          b(e) && n.attr({
            x: e,
            y: k
          });
          n.isImg = !0;
          b(n.imgwidth) && b(n.imgheight) ? Q(n) : (n.attr({
            width: 0,
            height: 0
          }), l("img", {
            onload: function () {
              var b = m[L.chartIndex];
              0 === this.width && (w(this, {
                position: "absolute",
                top: "-999em"
              }), c.body.appendChild(this));
              G[K] = {
                width: this.width,
                height: this.height
              };
              n.imgwidth = this.width;
              n.imgheight = this.height;
              n.element && Q(n);
              this.parentNode && this.parentNode.removeChild(this);
              L.imgCount--;
              if (!L.imgCount && b && !b.hasLoaded) b.onload();
            },
            src: K
          }), this.imgCount++);
        }
        return h;
      };
      u.prototype.clipRect = function (b, d, u, e) {
        var k = P() + "-",
          c = this.createElement("clipPath").attr({
            id: k
          }).add(this.defs);
        b = this.rect(b, d, u, e, 0).add(c);
        b.id = k;
        b.clipPath = c;
        b.count = 0;
        return b;
      };
      u.prototype.text = function (d, u, e, k) {
        var c = {};
        if (k && (this.allowHTML || !this.forExport)) return this.html(d, u, e);
        c.x = Math.round(u || 0);
        e && (c.y = Math.round(e));
        b(d) && (c.text = d);
        d = this.createElement("text").attr(c);
        if (!k || this.forExport && !this.allowHTML) d.xSetter = function (b, d, u) {
          for (var e = u.getElementsByTagName("tspan"), k = u.getAttribute(d), c = 0, r; c < e.length; c++) r = e[c], r.getAttribute(d) === k && r.setAttribute(d, b);
          u.setAttribute(d, b);
        };
        return d;
      };
      u.prototype.fontMetrics = function (b, d) {
        b = !this.styledMode && /px/.test(b) || !J.getComputedStyle ? b || d && d.style && d.style.fontSize || this.style && this.style.fontSize : d && y.prototype.getStyle.call(d, "font-size");
        b = /px/.test(b) ? A(b) : 12;
        d = 24 > b ? b + 3 : Math.round(1.2 * b);
        return {
          h: d,
          b: Math.round(.8 * d),
          f: b
        };
      };
      u.prototype.rotCorr = function (b, d, u) {
        var e = b;
        d && u && (e = Math.max(e * Math.cos(d * h), 4));
        return {
          x: -b / 3 * Math.sin(d * h),
          y: e
        };
      };
      u.prototype.pathToSegments = function (b) {
        for (var d = [], u = [], e = {
            A: 8,
            C: 7,
            H: 2,
            L: 3,
            M: 3,
            Q: 5,
            S: 5,
            T: 3,
            V: 2
          }, k = 0; k < b.length; k++) K(u[0]) && C(b[k]) && u.length === e[u[0].toUpperCase()] && b.splice(k, 0, u[0].replace("M", "L").replace("m", "l")), "string" === typeof b[k] && (u.length && d.push(u.slice(0)), u.length = 0), u.push(b[k]);
        d.push(u.slice(0));
        return d;
      };
      u.prototype.label = function (b, d, u, e, k, c, r, l, f) {
        return new F(this, b, d, u, e, k, c, r, l, f);
      };
      u.prototype.alignElements = function () {
        this.alignedObjects.forEach(function (b) {
          return b.align();
        });
      };
      return u;
    }();
    d(B.prototype, {
      Element: y,
      SVG_NS: e,
      escapes: {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      },
      symbols: I,
      draw: f
    });
    H.registerRendererType("svg", B, !0);
    "";
    return B;
  });
  N(a, "Core/Renderer/HTML/HTMLElement.js", [a["Core/Globals.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = this && this.__extends || function () {
        var c = function (a, f) {
          c = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (e, c) {
            e.__proto__ = c;
          } || function (e, c) {
            for (var f in c) c.hasOwnProperty(f) && (e[f] = c[f]);
          };
          return c(a, f);
        };
        return function (a, f) {
          function e() {
            this.constructor = a;
          }
          c(a, f);
          a.prototype = null === f ? Object.create(f) : (e.prototype = f.prototype, new e());
        };
      }(),
      y = a.isFirefox,
      F = a.isMS,
      I = a.isWebKit,
      x = a.win,
      q = B.css,
      m = B.defined,
      h = B.extend,
      c = B.pick,
      n = B.pInt;
    return function (a) {
      function g() {
        return null !== a && a.apply(this, arguments) || this;
      }
      E(g, a);
      g.compose = function (c) {
        if (-1 === g.composedClasses.indexOf(c)) {
          g.composedClasses.push(c);
          var e = g.prototype,
            f = c.prototype;
          f.getSpanCorrection = e.getSpanCorrection;
          f.htmlCss = e.htmlCss;
          f.htmlGetBBox = e.htmlGetBBox;
          f.htmlUpdateTransform = e.htmlUpdateTransform;
          f.setSpanRotation = e.setSpanRotation;
        }
        return c;
      };
      g.prototype.getSpanCorrection = function (c, e, a) {
        this.xCorr = -c * a;
        this.yCorr = -e;
      };
      g.prototype.htmlCss = function (f) {
        var e = "SPAN" === this.element.tagName && f && "width" in f,
          a = c(e && f.width, void 0);
        if (e) {
          delete f.width;
          this.textWidth = a;
          var g = !0;
        }
        f && "ellipsis" === f.textOverflow && (f.whiteSpace = "nowrap", f.overflow = "hidden");
        this.styles = h(this.styles, f);
        q(this.element, f);
        g && this.htmlUpdateTransform();
        return this;
      };
      g.prototype.htmlGetBBox = function () {
        var c = this.element;
        return {
          x: c.offsetLeft,
          y: c.offsetTop,
          width: c.offsetWidth,
          height: c.offsetHeight
        };
      };
      g.prototype.htmlUpdateTransform = function () {
        if (this.added) {
          var c = this.renderer,
            e = this.element,
            a = this.translateX || 0,
            g = this.translateY || 0,
            h = this.x || 0,
            p = this.y || 0,
            l = this.textAlign || "left",
            w = {
              left: 0,
              center: .5,
              right: 1
            }[l],
            b = this.styles;
          b = b && b.whiteSpace;
          q(e, {
            marginLeft: a,
            marginTop: g
          });
          !c.styledMode && this.shadows && this.shadows.forEach(function (b) {
            q(b, {
              marginLeft: a + 1,
              marginTop: g + 1
            });
          });
          this.inverted && [].forEach.call(e.childNodes, function (b) {
            c.invertChild(b, e);
          });
          if ("SPAN" === e.tagName) {
            var v = this.rotation,
              d = this.textWidth && n(this.textWidth),
              D = [v, l, e.innerHTML, this.textWidth, this.textAlign].join(),
              C = void 0;
            C = !1;
            if (d !== this.oldTextWidth) {
              if (this.textPxLength) var k = this.textPxLength;else q(e, {
                width: "",
                whiteSpace: b || "nowrap"
              }), k = e.offsetWidth;
              (d > this.oldTextWidth || k > d) && (/[ \-]/.test(e.textContent || e.innerText) || "ellipsis" === e.style.textOverflow) && (q(e, {
                width: k > d || v ? d + "px" : "auto",
                display: "block",
                whiteSpace: b || "normal"
              }), this.oldTextWidth = d, C = !0);
            }
            this.hasBoxWidthChanged = C;
            D !== this.cTT && (C = c.fontMetrics(e.style.fontSize, e).b, !m(v) || v === (this.oldRotation || 0) && l === this.oldAlign || this.setSpanRotation(v, w, C), this.getSpanCorrection(!m(v) && this.textPxLength || e.offsetWidth, C, w, v, l));
            q(e, {
              left: h + (this.xCorr || 0) + "px",
              top: p + (this.yCorr || 0) + "px"
            });
            this.cTT = D;
            this.oldRotation = v;
            this.oldAlign = l;
          }
        } else this.alignOnAdd = !0;
      };
      g.prototype.setSpanRotation = function (c, e, a) {
        var f = {},
          g = F && !/Edge/.test(x.navigator.userAgent) ? "-ms-transform" : I ? "-webkit-transform" : y ? "MozTransform" : x.opera ? "-o-transform" : void 0;
        g && (f[g] = f.transform = "rotate(" + c + "deg)", f[g + (y ? "Origin" : "-origin")] = f.transformOrigin = 100 * e + "% " + a + "px", q(this.element, f));
      };
      g.composedClasses = [];
      return g;
    }(t);
  });
  N(a, "Core/Renderer/HTML/HTMLRenderer.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function (a, t, B, H) {
    var E = this && this.__extends || function () {
        var a = function (h, c) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (c, a) {
            c.__proto__ = a;
          } || function (c, a) {
            for (var g in a) a.hasOwnProperty(g) && (c[g] = a[g]);
          };
          return a(h, c);
        };
        return function (h, c) {
          function n() {
            this.constructor = h;
          }
          a(h, c);
          h.prototype = null === c ? Object.create(c) : (n.prototype = c.prototype, new n());
        };
      }(),
      F = H.attr,
      I = H.createElement,
      x = H.extend,
      q = H.pick;
    return function (m) {
      function h() {
        return null !== m && m.apply(this, arguments) || this;
      }
      E(h, m);
      h.compose = function (c) {
        -1 === h.composedClasses.indexOf(c) && (h.composedClasses.push(c), c.prototype.html = h.prototype.html);
        return c;
      };
      h.prototype.html = function (c, h, m) {
        var g = this.createElement("span"),
          f = g.element,
          e = g.renderer,
          n = e.isSVG,
          J = function (e, c) {
            ["opacity", "visibility"].forEach(function (l) {
              e[l + "Setter"] = function (f, b, v) {
                var d = e.div ? e.div.style : c;
                t.prototype[l + "Setter"].call(this, f, b, v);
                d && (d[b] = f);
              };
            });
            e.addedSetters = !0;
          };
        g.textSetter = function (e) {
          e !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, q(e, "")), this.textStr = e, g.doTransform = !0);
        };
        n && J(g, g.element.style);
        g.xSetter = g.ySetter = g.alignSetter = g.rotationSetter = function (e, c) {
          "align" === c ? g.alignValue = g.textAlign = e : g[c] = e;
          g.doTransform = !0;
        };
        g.afterSetters = function () {
          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
        };
        g.attr({
          text: c,
          x: Math.round(h),
          y: Math.round(m)
        }).css({
          position: "absolute"
        });
        e.styledMode || g.css({
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize
        });
        f.style.whiteSpace = "nowrap";
        g.css = g.htmlCss;
        n && (g.add = function (c) {
          var p = e.box.parentNode,
            l = [];
          if (this.parentGroup = c) {
            var a = c.div;
            if (!a) {
              for (; c;) l.push(c), c = c.parentGroup;
              l.reverse().forEach(function (b) {
                function e(d, e) {
                  b[e] = d;
                  "translateX" === e ? f.left = d + "px" : f.top = d + "px";
                  b.doTransform = !0;
                }
                var d = F(b.element, "class"),
                  c = b.styles || {};
                a = b.div = b.div || I("div", d ? {
                  className: d
                } : void 0, {
                  position: "absolute",
                  left: (b.translateX || 0) + "px",
                  top: (b.translateY || 0) + "px",
                  display: b.display,
                  opacity: b.opacity,
                  cursor: c.cursor,
                  pointerEvents: c.pointerEvents,
                  visibility: b.visibility
                }, a || p);
                var f = a.style;
                x(b, {
                  classSetter: function (b) {
                    return function (d) {
                      this.element.setAttribute("class", d);
                      b.className = d;
                    };
                  }(a),
                  on: function () {
                    l[0].div && g.on.apply({
                      element: l[0].div,
                      onEvents: b.onEvents
                    }, arguments);
                    return b;
                  },
                  translateXSetter: e,
                  translateYSetter: e
                });
                b.addedSetters || J(b);
              });
            }
          } else a = p;
          a.appendChild(f);
          g.added = !0;
          g.alignOnAdd && g.htmlUpdateTransform();
          return g;
        });
        return g;
      };
      h.composedClasses = [];
      return h;
    }(B);
  });
  N(a, "Core/Axis/AxisDefaults.js", [], function () {
    var a;
    (function (a) {
      a.defaultXAxisOptions = {
        alignTicks: !0,
        allowDecimals: void 0,
        panningEnabled: !0,
        zIndex: 2,
        zoomEnabled: !0,
        dateTimeLabelFormats: {
          millisecond: {
            main: "%H:%M:%S.%L",
            range: !1
          },
          second: {
            main: "%H:%M:%S",
            range: !1
          },
          minute: {
            main: "%H:%M",
            range: !1
          },
          hour: {
            main: "%H:%M",
            range: !1
          },
          day: {
            main: "%e. %b"
          },
          week: {
            main: "%e. %b"
          },
          month: {
            main: "%b '%y"
          },
          year: {
            main: "%Y"
          }
        },
        endOnTick: !1,
        gridLineDashStyle: "Solid",
        gridZIndex: 1,
        labels: {
          autoRotation: void 0,
          autoRotationLimit: 80,
          distance: void 0,
          enabled: !0,
          indentation: 10,
          overflow: "justify",
          padding: 5,
          reserveSpace: void 0,
          rotation: void 0,
          staggerLines: 0,
          step: 0,
          useHTML: !1,
          x: 0,
          zIndex: 7,
          style: {
            color: "#666666",
            cursor: "default",
            fontSize: "11px"
          }
        },
        maxPadding: .01,
        minorGridLineDashStyle: "Solid",
        minorTickLength: 2,
        minorTickPosition: "outside",
        minPadding: .01,
        offset: void 0,
        opposite: !1,
        reversed: void 0,
        reversedStacks: !1,
        showEmpty: !0,
        showFirstLabel: !0,
        showLastLabel: !0,
        startOfWeek: 1,
        startOnTick: !1,
        tickLength: 10,
        tickPixelInterval: 100,
        tickmarkPlacement: "between",
        tickPosition: "outside",
        title: {
          align: "middle",
          rotation: 0,
          useHTML: !1,
          x: 0,
          y: 0,
          style: {
            color: "#666666"
          }
        },
        type: "linear",
        uniqueNames: !0,
        visible: !0,
        minorGridLineColor: "#f2f2f2",
        minorGridLineWidth: 1,
        minorTickColor: "#999999",
        lineColor: "#ccd6eb",
        lineWidth: 1,
        gridLineColor: "#e6e6e6",
        gridLineWidth: void 0,
        tickColor: "#ccd6eb"
      };
      a.defaultYAxisOptions = {
        reversedStacks: !0,
        endOnTick: !0,
        maxPadding: .05,
        minPadding: .05,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {
          x: -8
        },
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          animation: {},
          allowOverlap: !1,
          enabled: !1,
          crop: !0,
          overflow: "justify",
          formatter: function () {
            var a = this.axis.chart.numberFormatter;
            return a(this.total, -1);
          },
          style: {
            color: "#000000",
            fontSize: "11px",
            fontWeight: "bold",
            textOutline: "1px contrast"
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
      };
      a.defaultLeftAxisOptions = {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      };
      a.defaultRightAxisOptions = {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      };
      a.defaultBottomAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
      a.defaultTopAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
    })(a || (a = {}));
    return a;
  });
  N(a, "Core/Foundation.js", [a["Core/Utilities.js"]], function (a) {
    var E = a.addEvent,
      B = a.isFunction,
      H = a.objectEach,
      y = a.removeEvent,
      F;
    (function (a) {
      a.registerEventOptions = function (a, q) {
        a.eventOptions = a.eventOptions || {};
        H(q.events, function (m, h) {
          a.eventOptions[h] !== m && (a.eventOptions[h] && (y(a, h, a.eventOptions[h]), delete a.eventOptions[h]), B(m) && (a.eventOptions[h] = m, E(a, h, m)));
        });
      };
    })(F || (F = {}));
    return F;
  });
  N(a, "Core/Axis/Tick.js", [a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = t.deg2rad,
      y = B.clamp,
      F = B.correctFloat,
      I = B.defined,
      x = B.destroyObjectProperties,
      q = B.extend,
      m = B.fireEvent,
      h = B.isNumber,
      c = B.merge,
      n = B.objectEach,
      z = B.pick;
    t = function () {
      function g(c, e, a, g, h) {
        this.isNewLabel = this.isNew = !0;
        this.axis = c;
        this.pos = e;
        this.type = a || "";
        this.parameters = h || {};
        this.tickmarkOffset = this.parameters.tickmarkOffset;
        this.options = this.parameters.options;
        m(this, "init");
        a || g || this.addLabel();
      }
      g.prototype.addLabel = function () {
        var c = this,
          e = c.axis,
          g = e.options,
          n = e.chart,
          M = e.categories,
          p = e.logarithmic,
          l = e.names,
          w = c.pos,
          b = z(c.options && c.options.labels, g.labels),
          v = e.tickPositions,
          d = w === v[0],
          D = w === v[v.length - 1],
          C = (!b.step || 1 === b.step) && 1 === e.tickInterval;
        v = v.info;
        var k = c.label,
          K;
        M = this.parameters.category || (M ? z(M[w], l[w], w) : w);
        p && h(M) && (M = F(p.lin2log(M)));
        if (e.dateTime) if (v) {
          var O = n.time.resolveDTLFormat(g.dateTimeLabelFormats[!g.grid && v.higherRanks[w] || v.unitName]);
          var r = O.main;
        } else h(M) && (r = e.dateTime.getXDateFormat(M, g.dateTimeLabelFormats || {}));
        c.isFirst = d;
        c.isLast = D;
        var A = {
          axis: e,
          chart: n,
          dateTimeLabelFormat: r,
          isFirst: d,
          isLast: D,
          pos: w,
          tick: c,
          tickPositionInfo: v,
          value: M
        };
        m(this, "labelFormat", A);
        var P = function (d) {
          return b.formatter ? b.formatter.call(d, d) : b.format ? (d.text = e.defaultLabelFormatter.call(d), a.format(b.format, d, n)) : e.defaultLabelFormatter.call(d, d);
        };
        g = P.call(A, A);
        var V = O && O.list;
        c.shortenLabel = V ? function () {
          for (K = 0; K < V.length; K++) if (q(A, {
            dateTimeLabelFormat: V[K]
          }), k.attr({
            text: P.call(A, A)
          }), k.getBBox().width < e.getSlotWidth(c) - 2 * b.padding) return;
          k.attr({
            text: ""
          });
        } : void 0;
        C && e._addedPlotLB && c.moveLabel(g, b);
        I(k) || c.movedLabel ? k && k.textStr !== g && !C && (!k.textWidth || b.style.width || k.styles.width || k.css({
          width: null
        }), k.attr({
          text: g
        }), k.textPxLength = k.getBBox().width) : (c.label = k = c.createLabel({
          x: 0,
          y: 0
        }, g, b), c.rotation = 0);
      };
      g.prototype.createLabel = function (a, e, g) {
        var f = this.axis,
          h = f.chart;
        if (a = I(e) && g.enabled ? h.renderer.text(e, a.x, a.y, g.useHTML).add(f.labelGroup) : null) h.styledMode || a.css(c(g.style)), a.textPxLength = a.getBBox().width;
        return a;
      };
      g.prototype.destroy = function () {
        x(this, this.axis);
      };
      g.prototype.getPosition = function (c, e, a, g) {
        var f = this.axis,
          p = f.chart,
          l = g && p.oldChartHeight || p.chartHeight;
        c = {
          x: c ? F(f.translate(e + a, null, null, g) + f.transB) : f.left + f.offset + (f.opposite ? (g && p.oldChartWidth || p.chartWidth) - f.right - f.left : 0),
          y: c ? l - f.bottom + f.offset - (f.opposite ? f.height : 0) : F(l - f.translate(e + a, null, null, g) - f.transB)
        };
        c.y = y(c.y, -1E5, 1E5);
        m(this, "afterGetPosition", {
          pos: c
        });
        return c;
      };
      g.prototype.getLabelPosition = function (c, e, a, g, h, p, l, w) {
        var b = this.axis,
          f = b.transA,
          d = b.isLinked && b.linkedParent ? b.linkedParent.reversed : b.reversed,
          D = b.staggerLines,
          C = b.tickRotCorr || {
            x: 0,
            y: 0
          },
          k = g || b.reserveSpaceDefault ? 0 : -b.labelOffset * ("center" === b.labelAlign ? .5 : 1),
          K = {},
          n = h.y;
        I(n) || (n = 0 === b.side ? a.rotation ? -8 : -a.getBBox().height : 2 === b.side ? C.y + 8 : Math.cos(a.rotation * E) * (C.y - a.getBBox(!1, 0).height / 2));
        c = c + h.x + k + C.x - (p && g ? p * f * (d ? -1 : 1) : 0);
        e = e + n - (p && !g ? p * f * (d ? 1 : -1) : 0);
        D && (a = l / (w || 1) % D, b.opposite && (a = D - a - 1), e += b.labelOffset / D * a);
        K.x = c;
        K.y = Math.round(e);
        m(this, "afterGetLabelPosition", {
          pos: K,
          tickmarkOffset: p,
          index: l
        });
        return K;
      };
      g.prototype.getLabelSize = function () {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
      };
      g.prototype.getMarkPath = function (c, e, a, g, h, p) {
        return p.crispLine([["M", c, e], ["L", c + (h ? 0 : -a), e + (h ? a : 0)]], g);
      };
      g.prototype.handleOverflow = function (c) {
        var e = this.axis,
          a = e.options.labels,
          f = c.x,
          g = e.chart.chartWidth,
          p = e.chart.spacing,
          l = z(e.labelLeft, Math.min(e.pos, p[3]));
        p = z(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, g - p[1]));
        var w = this.label,
          b = this.rotation,
          v = {
            left: 0,
            center: .5,
            right: 1
          }[e.labelAlign || w.attr("align")],
          d = w.getBBox().width,
          D = e.getSlotWidth(this),
          C = {},
          k = D,
          h = 1,
          n;
        if (b || "justify" !== a.overflow) 0 > b && f - v * d < l ? n = Math.round(f / Math.cos(b * E) - l) : 0 < b && f + v * d > p && (n = Math.round((g - f) / Math.cos(b * E)));else if (g = f + (1 - v) * d, f - v * d < l ? k = c.x + k * (1 - v) - l : g > p && (k = p - c.x + k * v, h = -1), k = Math.min(D, k), k < D && "center" === e.labelAlign && (c.x += h * (D - k - v * (D - Math.min(d, k)))), d > k || e.autoRotation && (w.styles || {}).width) n = k;
        n && (this.shortenLabel ? this.shortenLabel() : (C.width = Math.floor(n) + "px", (a.style || {}).textOverflow || (C.textOverflow = "ellipsis"), w.css(C)));
      };
      g.prototype.moveLabel = function (c, e) {
        var a = this,
          f = a.label,
          g = a.axis,
          p = g.reversed,
          l = !1;
        f && f.textStr === c ? (a.movedLabel = f, l = !0, delete a.label) : n(g.ticks, function (b) {
          l || b.isNew || b === a || !b.label || b.label.textStr !== c || (a.movedLabel = b.label, l = !0, b.labelPos = a.movedLabel.xy, delete b.label);
        });
        if (!l && (a.labelPos || f)) {
          var w = a.labelPos || f.xy;
          f = g.horiz ? p ? 0 : g.width + g.left : w.x;
          g = g.horiz ? w.y : p ? g.width + g.left : 0;
          a.movedLabel = a.createLabel({
            x: f,
            y: g
          }, c, e);
          a.movedLabel && a.movedLabel.attr({
            opacity: 0
          });
        }
      };
      g.prototype.render = function (c, e, a) {
        var f = this.axis,
          g = f.horiz,
          p = this.pos,
          l = z(this.tickmarkOffset, f.tickmarkOffset);
        p = this.getPosition(g, p, l, e);
        l = p.x;
        var w = p.y;
        f = g && l === f.pos + f.len || !g && w === f.pos ? -1 : 1;
        g = z(a, this.label && this.label.newOpacity, 1);
        a = z(a, 1);
        this.isActive = !0;
        this.renderGridLine(e, a, f);
        this.renderMark(p, a, f);
        this.renderLabel(p, e, g, c);
        this.isNew = !1;
        m(this, "afterRender");
      };
      g.prototype.renderGridLine = function (c, e, a) {
        var f = this.axis,
          g = f.options,
          p = {},
          l = this.pos,
          w = this.type,
          b = z(this.tickmarkOffset, f.tickmarkOffset),
          v = f.chart.renderer,
          d = this.gridLine,
          D = g.gridLineWidth,
          C = g.gridLineColor,
          k = g.gridLineDashStyle;
        "minor" === this.type && (D = g.minorGridLineWidth, C = g.minorGridLineColor, k = g.minorGridLineDashStyle);
        d || (f.chart.styledMode || (p.stroke = C, p["stroke-width"] = D || 0, p.dashstyle = k), w || (p.zIndex = 1), c && (e = 0), this.gridLine = d = v.path().attr(p).addClass("highcharts-" + (w ? w + "-" : "") + "grid-line").add(f.gridGroup));
        if (d && (a = f.getPlotLinePath({
          value: l + b,
          lineWidth: d.strokeWidth() * a,
          force: "pass",
          old: c
        }))) d[c || this.isNew ? "attr" : "animate"]({
          d: a,
          opacity: e
        });
      };
      g.prototype.renderMark = function (c, e, a) {
        var f = this.axis,
          g = f.options,
          p = f.chart.renderer,
          l = this.type,
          w = f.tickSize(l ? l + "Tick" : "tick"),
          b = c.x;
        c = c.y;
        var v = z(g["minor" !== l ? "tickWidth" : "minorTickWidth"], !l && f.isXAxis ? 1 : 0);
        g = g["minor" !== l ? "tickColor" : "minorTickColor"];
        var d = this.mark,
          D = !d;
        w && (f.opposite && (w[0] = -w[0]), d || (this.mark = d = p.path().addClass("highcharts-" + (l ? l + "-" : "") + "tick").add(f.axisGroup), f.chart.styledMode || d.attr({
          stroke: g,
          "stroke-width": v
        })), d[D ? "attr" : "animate"]({
          d: this.getMarkPath(b, c, w[0], d.strokeWidth() * a, f.horiz, p),
          opacity: e
        }));
      };
      g.prototype.renderLabel = function (c, e, a, g) {
        var f = this.axis,
          p = f.horiz,
          l = f.options,
          w = this.label,
          b = l.labels,
          v = b.step;
        f = z(this.tickmarkOffset, f.tickmarkOffset);
        var d = c.x;
        c = c.y;
        var D = !0;
        w && h(d) && (w.xy = c = this.getLabelPosition(d, c, w, p, b, f, g, v), this.isFirst && !this.isLast && !l.showFirstLabel || this.isLast && !this.isFirst && !l.showLastLabel ? D = !1 : !p || b.step || b.rotation || e || 0 === a || this.handleOverflow(c), v && g % v && (D = !1), D && h(c.y) ? (c.opacity = a, w[this.isNewLabel ? "attr" : "animate"](c), this.isNewLabel = !1) : (w.attr("y", -9999), this.isNewLabel = !0));
      };
      g.prototype.replaceMovedLabel = function () {
        var c = this.label,
          e = this.axis,
          a = e.reversed;
        if (c && !this.isNew) {
          var g = e.horiz ? a ? e.left : e.width + e.left : c.xy.x;
          a = e.horiz ? c.xy.y : a ? e.width + e.top : e.top;
          c.animate({
            x: g,
            y: a,
            opacity: 0
          }, void 0, c.destroy);
          delete this.label;
        }
        e.isDirty = !0;
        this.label = this.movedLabel;
        delete this.movedLabel;
      };
      return g;
    }();
    "";
    return t;
  });
  N(a, "Core/Axis/Axis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/AxisDefaults.js"], a["Core/Color/Color.js"], a["Core/DefaultOptions.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Axis/Tick.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F, I, x) {
    var q = a.animObject,
      m = H.defaultOptions,
      h = y.registerEventOptions,
      c = F.deg2rad,
      n = x.arrayMax,
      z = x.arrayMin,
      g = x.clamp,
      f = x.correctFloat,
      e = x.defined,
      G = x.destroyObjectProperties,
      J = x.erase,
      M = x.error,
      p = x.extend,
      l = x.fireEvent,
      w = x.getMagnitude,
      b = x.isArray,
      v = x.isNumber,
      d = x.isString,
      D = x.merge,
      C = x.normalizeTickInterval,
      k = x.objectEach,
      K = x.pick,
      O = x.relativeLength,
      r = x.removeEvent,
      A = x.splat,
      P = x.syncTimeout;
    a = function () {
      function a(b, d) {
        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;
        this.init(b, d);
      }
      a.prototype.init = function (b, d) {
        var u = d.isX;
        this.chart = b;
        this.horiz = b.inverted && !this.isZAxis ? !u : u;
        this.isXAxis = u;
        this.coll = this.coll || (u ? "xAxis" : "yAxis");
        l(this, "init", {
          userOptions: d
        });
        this.opposite = K(d.opposite, this.opposite);
        this.side = K(d.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
        this.setOptions(d);
        var c = this.options,
          k = c.labels,
          a = c.type;
        this.userOptions = d;
        this.minPixelPadding = 0;
        this.reversed = K(c.reversed, this.reversed);
        this.visible = c.visible;
        this.zoomEnabled = c.zoomEnabled;
        this.hasNames = "category" === a || !0 === c.categories;
        this.categories = c.categories || this.hasNames;
        this.names || (this.names = [], this.names.keys = {});
        this.plotLinesAndBandsGroups = {};
        this.positiveValuesOnly = !!this.logarithmic;
        this.isLinked = e(c.linkedTo);
        this.ticks = {};
        this.labelEdge = [];
        this.minorTicks = {};
        this.plotLinesAndBands = [];
        this.alternateBands = {};
        this.len = 0;
        this.minRange = this.userMinRange = c.minRange || c.maxZoom;
        this.range = c.range;
        this.offset = c.offset || 0;
        this.min = this.max = null;
        d = K(c.crosshair, A(b.options.tooltip.crosshairs)[u ? 0 : 1]);
        this.crosshair = !0 === d ? {} : d;
        -1 === b.axes.indexOf(this) && (u ? b.axes.splice(b.xAxis.length, 0, this) : b.axes.push(this), b[this.coll].push(this));
        this.series = this.series || [];
        b.inverted && !this.isZAxis && u && "undefined" === typeof this.reversed && (this.reversed = !0);
        this.labelRotation = v(k.rotation) ? k.rotation : void 0;
        h(this, c);
        l(this, "afterInit");
      };
      a.prototype.setOptions = function (b) {
        this.options = D(t.defaultXAxisOptions, "yAxis" === this.coll && t.defaultYAxisOptions, [t.defaultTopAxisOptions, t.defaultRightAxisOptions, t.defaultBottomAxisOptions, t.defaultLeftAxisOptions][this.side], D(m[this.coll], b));
        l(this, "afterSetOptions", {
          userOptions: b
        });
      };
      a.prototype.defaultLabelFormatter = function (b) {
        var d = this.axis;
        b = this.chart.numberFormatter;
        var u = v(this.value) ? this.value : NaN,
          e = d.chart.time,
          c = this.dateTimeLabelFormat,
          k = m.lang,
          a = k.numericSymbols;
        k = k.numericSymbolMagnitude || 1E3;
        var r = d.logarithmic ? Math.abs(u) : d.tickInterval,
          l = a && a.length;
        if (d.categories) var f = "" + this.value;else if (c) f = e.dateFormat(c, u);else if (l && 1E3 <= r) for (; l-- && "undefined" === typeof f;) d = Math.pow(k, l + 1), r >= d && 0 === 10 * u % d && null !== a[l] && 0 !== u && (f = b(u / d, -1) + a[l]);
        "undefined" === typeof f && (f = 1E4 <= Math.abs(u) ? b(u, -1) : b(u, -1, void 0, ""));
        return f;
      };
      a.prototype.getSeriesExtremes = function () {
        var b = this,
          d = b.chart,
          c;
        l(this, "getSeriesExtremes", null, function () {
          b.hasVisibleSeries = !1;
          b.dataMin = b.dataMax = b.threshold = null;
          b.softThreshold = !b.isXAxis;
          b.stacking && b.stacking.buildStacks();
          b.series.forEach(function (u) {
            if (u.visible || !d.options.chart.ignoreHiddenSeries) {
              var k = u.options,
                a = k.threshold;
              b.hasVisibleSeries = !0;
              b.positiveValuesOnly && 0 >= a && (a = null);
              if (b.isXAxis) {
                if (k = u.xData, k.length) {
                  k = b.logarithmic ? k.filter(b.validatePositiveValue) : k;
                  c = u.getXExtremes(k);
                  var r = c.min;
                  var l = c.max;
                  v(r) || r instanceof Date || (k = k.filter(v), c = u.getXExtremes(k), r = c.min, l = c.max);
                  k.length && (b.dataMin = Math.min(K(b.dataMin, r), r), b.dataMax = Math.max(K(b.dataMax, l), l));
                }
              } else if (u = u.applyExtremes(), v(u.dataMin) && (r = u.dataMin, b.dataMin = Math.min(K(b.dataMin, r), r)), v(u.dataMax) && (l = u.dataMax, b.dataMax = Math.max(K(b.dataMax, l), l)), e(a) && (b.threshold = a), !k.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;
            }
          });
        });
        l(this, "afterGetSeriesExtremes");
      };
      a.prototype.translate = function (b, d, e, c, k, a) {
        var u = this.linkedParent || this,
          r = c && u.old ? u.old.min : u.min,
          l = u.minPixelPadding;
        k = (u.isOrdinal || u.brokenAxis && u.brokenAxis.hasBreaks || u.logarithmic && k) && u.lin2val;
        var f = 1,
          g = 0;
        c = c && u.old ? u.old.transA : u.transA;
        c || (c = u.transA);
        e && (f *= -1, g = u.len);
        u.reversed && (f *= -1, g -= f * (u.sector || u.len));
        d ? (b = (b * f + g - l) / c + r, k && (b = u.lin2val(b))) : (k && (b = u.val2lin(b)), b = v(r) ? f * (b - r) * c + g + f * l + (v(a) ? c * a : 0) : void 0);
        return b;
      };
      a.prototype.toPixels = function (b, d) {
        return this.translate(b, !1, !this.horiz, null, !0) + (d ? 0 : this.pos);
      };
      a.prototype.toValue = function (b, d) {
        return this.translate(b - (d ? 0 : this.pos), !0, !this.horiz, null, !0);
      };
      a.prototype.getPlotLinePath = function (b) {
        function d(b, d, e) {
          if ("pass" !== C && b < d || b > e) C ? b = g(b, d, e) : z = !0;
          return b;
        }
        var e = this,
          c = e.chart,
          u = e.left,
          k = e.top,
          a = b.old,
          r = b.value,
          f = b.lineWidth,
          p = a && c.oldChartHeight || c.chartHeight,
          A = a && c.oldChartWidth || c.chartWidth,
          D = e.transB,
          w = b.translatedValue,
          C = b.force,
          h,
          n,
          O,
          m,
          z;
        b = {
          value: r,
          lineWidth: f,
          old: a,
          force: C,
          acrossPanes: b.acrossPanes,
          translatedValue: w
        };
        l(this, "getPlotLinePath", b, function (b) {
          w = K(w, e.translate(r, null, null, a));
          w = g(w, -1E5, 1E5);
          h = O = Math.round(w + D);
          n = m = Math.round(p - w - D);
          v(w) ? e.horiz ? (n = k, m = p - e.bottom, h = O = d(h, u, u + e.width)) : (h = u, O = A - e.right, n = m = d(n, k, k + e.height)) : (z = !0, C = !1);
          b.path = z && !C ? null : c.renderer.crispLine([["M", h, n], ["L", O, m]], f || 1);
        });
        return b.path;
      };
      a.prototype.getLinearTickPositions = function (b, d, e) {
        var c = f(Math.floor(d / b) * b);
        e = f(Math.ceil(e / b) * b);
        var u = [],
          k;
        f(c + b) === c && (k = 20);
        if (this.single) return [d];
        for (d = c; d <= e;) {
          u.push(d);
          d = f(d + b, k);
          if (d === a) break;
          var a = d;
        }
        return u;
      };
      a.prototype.getMinorTickInterval = function () {
        var b = this.options;
        return !0 === b.minorTicks ? K(b.minorTickInterval, "auto") : !1 === b.minorTicks ? null : b.minorTickInterval;
      };
      a.prototype.getMinorTickPositions = function () {
        var b = this.options,
          d = this.tickPositions,
          e = this.minorTickInterval,
          c = this.pointRangePadding || 0,
          k = this.min - c;
        c = this.max + c;
        var a = c - k,
          r = [];
        if (a && a / e < this.len / 3) {
          var l = this.logarithmic;
          if (l) this.paddedTicks.forEach(function (b, d, c) {
            d && r.push.apply(r, l.getLogTickPositions(e, c[d - 1], c[d], !0));
          });else if (this.dateTime && "auto" === this.getMinorTickInterval()) r = r.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(e), k, c, b.startOfWeek));else for (b = k + (d[0] - k) % e; b <= c && b !== r[0]; b += e) r.push(b);
        }
        0 !== r.length && this.trimTicks(r);
        return r;
      };
      a.prototype.adjustForMinRange = function () {
        var b = this.options,
          d = this.logarithmic,
          c = this.min,
          k = this.max,
          a = 0,
          r,
          l,
          f,
          g;
        this.isXAxis && "undefined" === typeof this.minRange && !d && (e(b.min) || e(b.max) || e(b.floor) || e(b.ceiling) ? this.minRange = null : (this.series.forEach(function (b) {
          f = b.xData;
          g = b.xIncrement ? 1 : f.length - 1;
          if (1 < f.length) for (r = g; 0 < r; r--) if (l = f[r] - f[r - 1], !a || l < a) a = l;
        }), this.minRange = Math.min(5 * a, this.dataMax - this.dataMin)));
        if (k - c < this.minRange) {
          var p = this.dataMax - this.dataMin >= this.minRange;
          var v = this.minRange;
          var w = (v - k + c) / 2;
          w = [c - w, K(b.min, c - w)];
          p && (w[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
          c = n(w);
          k = [c + v, K(b.max, c + v)];
          p && (k[2] = d ? d.log2lin(this.dataMax) : this.dataMax);
          k = z(k);
          k - c < v && (w[0] = k - v, w[1] = K(b.min, k - v), c = n(w));
        }
        this.min = c;
        this.max = k;
      };
      a.prototype.getClosest = function () {
        var b;
        this.categories ? b = 1 : this.series.forEach(function (d) {
          var c = d.closestPointRange,
            k = d.visible || !d.chart.options.chart.ignoreHiddenSeries;
          !d.noSharedTooltip && e(c) && k && (b = e(b) ? Math.min(b, c) : c);
        });
        return b;
      };
      a.prototype.nameToX = function (d) {
        var c = b(this.categories),
          k = c ? this.categories : this.names,
          u = d.options.x;
        d.series.requireSorting = !1;
        e(u) || (u = this.options.uniqueNames ? c ? k.indexOf(d.name) : K(k.keys[d.name], -1) : d.series.autoIncrement());
        if (-1 === u) {
          if (!c) var a = k.length;
        } else a = u;
        "undefined" !== typeof a && (this.names[a] = d.name, this.names.keys[d.name] = a);
        return a;
      };
      a.prototype.updateNames = function () {
        var b = this,
          d = this.names;
        0 < d.length && (Object.keys(d.keys).forEach(function (b) {
          delete d.keys[b];
        }), d.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (d) {
          d.xIncrement = null;
          if (!d.points || d.isDirtyData) b.max = Math.max(b.max, d.xData.length - 1), d.processData(), d.generatePoints();
          d.data.forEach(function (c, e) {
            if (c && c.options && "undefined" !== typeof c.name) {
              var k = b.nameToX(c);
              "undefined" !== typeof k && k !== c.x && (c.x = k, d.xData[e] = k);
            }
          });
        }));
      };
      a.prototype.setAxisTranslation = function () {
        var b = this,
          c = b.max - b.min,
          e = b.linkedParent,
          k = !!b.categories,
          a = b.isXAxis,
          r = b.axisPointRange || 0,
          f = 0,
          g = 0,
          p = b.transA;
        if (a || k || r) {
          var v = b.getClosest();
          e ? (f = e.minPointOffset, g = e.pointRangePadding) : b.series.forEach(function (c) {
            var e = k ? 1 : a ? K(c.options.pointRange, v, 0) : b.axisPointRange || 0,
              u = c.options.pointPlacement;
            r = Math.max(r, e);
            if (!b.single || k) c = c.is("xrange") ? !a : a, f = Math.max(f, c && d(u) ? 0 : e / 2), g = Math.max(g, c && "on" === u ? 0 : e);
          });
          e = b.ordinal && b.ordinal.slope && v ? b.ordinal.slope / v : 1;
          b.minPointOffset = f *= e;
          b.pointRangePadding = g *= e;
          b.pointRange = Math.min(r, b.single && k ? 1 : c);
          a && (b.closestPointRange = v);
        }
        b.translationSlope = b.transA = p = b.staticScale || b.len / (c + g || 1);
        b.transB = b.horiz ? b.left : b.bottom;
        b.minPixelPadding = p * f;
        l(this, "afterSetAxisTranslation");
      };
      a.prototype.minFromRange = function () {
        return this.max - this.range;
      };
      a.prototype.setTickInterval = function (b) {
        var d = this.chart,
          c = this.logarithmic,
          k = this.options,
          a = this.isXAxis,
          u = this.isLinked,
          r = k.tickPixelInterval,
          g = this.categories,
          p = this.softThreshold,
          A = k.maxPadding,
          D = k.minPadding,
          h = v(k.tickInterval) && 0 <= k.tickInterval ? k.tickInterval : void 0,
          n = v(this.threshold) ? this.threshold : null;
        this.dateTime || g || u || this.getTickAmount();
        var O = K(this.userMin, k.min);
        var m = K(this.userMax, k.max);
        if (u) {
          this.linkedParent = d[this.coll][k.linkedTo];
          var z = this.linkedParent.getExtremes();
          this.min = K(z.min, z.dataMin);
          this.max = K(z.max, z.dataMax);
          k.type !== this.linkedParent.options.type && M(11, 1, d);
        } else {
          if (p && e(n)) if (this.dataMin >= n) z = n, D = 0;else if (this.dataMax <= n) {
            var q = n;
            A = 0;
          }
          this.min = K(O, z, this.dataMin);
          this.max = K(m, q, this.dataMax);
        }
        c && (this.positiveValuesOnly && !b && 0 >= Math.min(this.min, K(this.dataMin, this.min)) && M(10, 1, d), this.min = f(c.log2lin(this.min), 16), this.max = f(c.log2lin(this.max), 16));
        this.range && e(this.max) && (this.userMin = this.min = O = Math.max(this.dataMin, this.minFromRange()), this.userMax = m = this.max, this.range = null);
        l(this, "foundExtremes");
        this.beforePadding && this.beforePadding();
        this.adjustForMinRange();
        !(g || this.axisPointRange || this.stacking && this.stacking.usePercentage || u) && e(this.min) && e(this.max) && (d = this.max - this.min) && (!e(O) && D && (this.min -= d * D), !e(m) && A && (this.max += d * A));
        v(this.userMin) || (v(k.softMin) && k.softMin < this.min && (this.min = O = k.softMin), v(k.floor) && (this.min = Math.max(this.min, k.floor)));
        v(this.userMax) || (v(k.softMax) && k.softMax > this.max && (this.max = m = k.softMax), v(k.ceiling) && (this.max = Math.min(this.max, k.ceiling)));
        p && e(this.dataMin) && (n = n || 0, !e(O) && this.min < n && this.dataMin >= n ? this.min = this.options.minRange ? Math.min(n, this.max - this.minRange) : n : !e(m) && this.max > n && this.dataMax <= n && (this.max = this.options.minRange ? Math.max(n, this.min + this.minRange) : n));
        v(this.min) && v(this.max) && !this.chart.polar && this.min > this.max && (e(this.options.min) ? this.max = this.min : e(this.options.max) && (this.min = this.max));
        this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : u && this.linkedParent && !h && r === this.linkedParent.options.tickPixelInterval ? h = this.linkedParent.tickInterval : K(h, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, g ? 1 : (this.max - this.min) * r / Math.max(this.len, r));
        if (a && !b) {
          var G = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
          this.series.forEach(function (b) {
            b.forceCrop = b.forceCropping && b.forceCropping();
            b.processData(G);
          });
          l(this, "postProcessData", {
            hasExtemesChanged: G
          });
        }
        this.setAxisTranslation();
        l(this, "initialAxisTranslation");
        this.pointRange && !h && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
        b = K(k.minTickInterval, this.dateTime && !this.series.some(function (b) {
          return b.noSharedTooltip;
        }) ? this.closestPointRange : 0);
        !h && this.tickInterval < b && (this.tickInterval = b);
        this.dateTime || this.logarithmic || h || (this.tickInterval = C(this.tickInterval, void 0, w(this.tickInterval), K(k.allowDecimals, .5 > this.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));
        this.tickAmount || (this.tickInterval = this.unsquish());
        this.setTickPositions();
      };
      a.prototype.setTickPositions = function () {
        var b = this.options,
          d = b.tickPositions,
          c = this.getMinorTickInterval(),
          k = this.hasVerticalPanning(),
          a = "colorAxis" === this.coll,
          r = (a || !k) && b.startOnTick;
        k = (a || !k) && b.endOnTick;
        a = b.tickPositioner;
        this.tickmarkOffset = this.categories && "between" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
        this.minorTickInterval = "auto" === c && this.tickInterval ? this.tickInterval / 5 : c;
        this.single = this.min === this.max && e(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);
        this.tickPositions = c = d && d.slice();
        !c && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? c = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (c = [this.min, this.max], M(19, !1, this.chart)), c.length > this.len && (c = [c[0], c.pop()], c[0] === c[1] && (c.length = 1)), this.tickPositions = c, a && (a = a.apply(this, [this.min, this.max]))) && (this.tickPositions = c = a);
        this.paddedTicks = c.slice(0);
        this.trimTicks(c, r, k);
        this.isLinked || (this.single && 2 > c.length && !this.categories && !this.series.some(function (b) {
          return b.is("heatmap") && "between" === b.options.pointPlacement;
        }) && (this.min -= .5, this.max += .5), d || a || this.adjustTickAmount());
        l(this, "afterSetTickPositions");
      };
      a.prototype.trimTicks = function (b, d, c) {
        var k = b[0],
          a = b[b.length - 1],
          u = !this.isOrdinal && this.minPointOffset || 0;
        l(this, "trimTicks");
        if (!this.isLinked) {
          if (d && -Infinity !== k) this.min = k;else for (; this.min - u > b[0];) b.shift();
          if (c) this.max = a;else for (; this.max + u < b[b.length - 1];) b.pop();
          0 === b.length && e(k) && !this.options.tickPositions && b.push((a + k) / 2);
        }
      };
      a.prototype.alignToOthers = function () {
        var b = {},
          d = this.options,
          c;
        !1 !== this.chart.options.chart.alignTicks && d.alignTicks && !1 !== d.startOnTick && !1 !== d.endOnTick && !this.logarithmic && this.chart[this.coll].forEach(function (d) {
          var k = d.options;
          k = [d.horiz ? k.left : k.top, k.width, k.height, k.pane].join();
          d.series.length && (b[k] ? c = !0 : b[k] = 1);
        });
        return c;
      };
      a.prototype.getTickAmount = function () {
        var b = this.options,
          d = b.tickPixelInterval,
          c = b.tickAmount;
        !e(b.tickInterval) && !c && this.len < d && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (c = 2);
        !c && this.alignToOthers() && (c = Math.ceil(this.len / d) + 1);
        4 > c && (this.finalTickAmt = c, c = 5);
        this.tickAmount = c;
      };
      a.prototype.adjustTickAmount = function () {
        var b = this.options,
          d = this.tickInterval,
          c = this.tickPositions,
          k = this.tickAmount,
          a = this.finalTickAmt,
          r = c && c.length,
          l = K(this.threshold, this.softThreshold ? 0 : null);
        if (this.hasData() && v(this.min) && v(this.max)) {
          if (r < k) {
            for (; c.length < k;) c.length % 2 || this.min === l ? c.push(f(c[c.length - 1] + d)) : c.unshift(f(c[0] - d));
            this.transA *= (r - 1) / (k - 1);
            this.min = b.startOnTick ? c[0] : Math.min(this.min, c[0]);
            this.max = b.endOnTick ? c[c.length - 1] : Math.max(this.max, c[c.length - 1]);
          } else r > k && (this.tickInterval *= 2, this.setTickPositions());
          if (e(a)) {
            for (d = b = c.length; d--;) (3 === a && 1 === d % 2 || 2 >= a && 0 < d && d < b - 1) && c.splice(d, 1);
            this.finalTickAmt = void 0;
          }
        }
      };
      a.prototype.setScale = function () {
        var b = !1,
          d = !1;
        this.series.forEach(function (c) {
          b = b || c.isDirtyData || c.isDirty;
          d = d || c.xAxis && c.xAxis.isDirty || !1;
        });
        this.setAxisSize();
        var c = this.len !== (this.old && this.old.len);
        c || b || d || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = c || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
        b && this.panningState && (this.panningState.isDirty = !0);
        l(this, "afterSetScale");
      };
      a.prototype.setExtremes = function (b, d, c, k, e) {
        var a = this,
          u = a.chart;
        c = K(c, !0);
        a.series.forEach(function (b) {
          delete b.kdTree;
        });
        e = p(e, {
          min: b,
          max: d
        });
        l(a, "setExtremes", e, function () {
          a.userMin = b;
          a.userMax = d;
          a.eventArgs = e;
          c && u.redraw(k);
        });
      };
      a.prototype.zoom = function (b, d) {
        var c = this,
          k = this.dataMin,
          a = this.dataMax,
          u = this.options,
          r = Math.min(k, K(u.min, k)),
          f = Math.max(a, K(u.max, a));
        b = {
          newMin: b,
          newMax: d
        };
        l(this, "zoom", b, function (b) {
          var d = b.newMin,
            u = b.newMax;
          if (d !== c.min || u !== c.max) c.allowZoomOutside || (e(k) && (d < r && (d = r), d > f && (d = f)), e(a) && (u < r && (u = r), u > f && (u = f))), c.displayBtn = "undefined" !== typeof d || "undefined" !== typeof u, c.setExtremes(d, u, !1, void 0, {
            trigger: "zoom"
          });
          b.zoomed = !0;
        });
        return b.zoomed;
      };
      a.prototype.setAxisSize = function () {
        var b = this.chart,
          d = this.options,
          c = d.offsets || [0, 0, 0, 0],
          k = this.horiz,
          e = this.width = Math.round(O(K(d.width, b.plotWidth - c[3] + c[1]), b.plotWidth)),
          a = this.height = Math.round(O(K(d.height, b.plotHeight - c[0] + c[2]), b.plotHeight)),
          r = this.top = Math.round(O(K(d.top, b.plotTop + c[0]), b.plotHeight, b.plotTop));
        d = this.left = Math.round(O(K(d.left, b.plotLeft + c[3]), b.plotWidth, b.plotLeft));
        this.bottom = b.chartHeight - a - r;
        this.right = b.chartWidth - e - d;
        this.len = Math.max(k ? e : a, 0);
        this.pos = k ? d : r;
      };
      a.prototype.getExtremes = function () {
        var b = this.logarithmic;
        return {
          min: b ? f(b.lin2log(this.min)) : this.min,
          max: b ? f(b.lin2log(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        };
      };
      a.prototype.getThreshold = function (b) {
        var d = this.logarithmic,
          c = d ? d.lin2log(this.min) : this.min;
        d = d ? d.lin2log(this.max) : this.max;
        null === b || -Infinity === b ? b = c : Infinity === b ? b = d : c > b ? b = c : d < b && (b = d);
        return this.translate(b, 0, 1, 0, 1);
      };
      a.prototype.autoLabelAlign = function (b) {
        var d = (K(b, 0) - 90 * this.side + 720) % 360;
        b = {
          align: "center"
        };
        l(this, "autoLabelAlign", b, function (b) {
          15 < d && 165 > d ? b.align = "right" : 195 < d && 345 > d && (b.align = "left");
        });
        return b.align;
      };
      a.prototype.tickSize = function (b) {
        var d = this.options,
          c = K(d["tick" === b ? "tickWidth" : "minorTickWidth"], "tick" === b && this.isXAxis && !this.categories ? 1 : 0),
          k = d["tick" === b ? "tickLength" : "minorTickLength"];
        if (c && k) {
          "inside" === d[b + "Position"] && (k = -k);
          var e = [k, c];
        }
        b = {
          tickSize: e
        };
        l(this, "afterTickSize", b);
        return b.tickSize;
      };
      a.prototype.labelMetrics = function () {
        var b = this.tickPositions && this.tickPositions[0] || 0;
        return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);
      };
      a.prototype.unsquish = function () {
        var b = this.options.labels,
          d = this.horiz,
          k = this.tickInterval,
          e = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / k),
          a = b.rotation,
          r = this.labelMetrics(),
          l = Math.max(this.max - this.min, 0),
          g = function (b) {
            var d = b / (e || 1);
            d = 1 < d ? Math.ceil(d) : 1;
            d * k > l && Infinity !== b && Infinity !== e && l && (d = Math.ceil(l / k));
            return f(d * k);
          },
          p = k,
          w,
          A,
          D = Number.MAX_VALUE;
        if (d) {
          if (!b.staggerLines && !b.step) if (v(a)) var C = [a];else e < b.autoRotationLimit && (C = b.autoRotation);
          C && C.forEach(function (b) {
            if (b === a || b && -90 <= b && 90 >= b) {
              A = g(Math.abs(r.h / Math.sin(c * b)));
              var d = A + Math.abs(b / 360);
              d < D && (D = d, w = b, p = A);
            }
          });
        } else b.step || (p = g(r.h));
        this.autoRotation = C;
        this.labelRotation = K(w, v(a) ? a : 0);
        return p;
      };
      a.prototype.getSlotWidth = function (b) {
        var d = this.chart,
          c = this.horiz,
          k = this.options.labels,
          e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
          a = d.margin[3];
        if (b && v(b.slotWidth)) return b.slotWidth;
        if (c && 2 > k.step) return k.rotation ? 0 : (this.staggerLines || 1) * this.len / e;
        if (!c) {
          b = k.style.width;
          if (void 0 !== b) return parseInt(String(b), 10);
          if (a) return a - d.spacing[3];
        }
        return .33 * d.chartWidth;
      };
      a.prototype.renderUnsquish = function () {
        var b = this.chart,
          c = b.renderer,
          k = this.tickPositions,
          e = this.ticks,
          a = this.options.labels,
          r = a.style,
          l = this.horiz,
          f = this.getSlotWidth(),
          g = Math.max(1, Math.round(f - 2 * a.padding)),
          p = {},
          v = this.labelMetrics(),
          w = r.textOverflow,
          A = 0;
        d(a.rotation) || (p.rotation = a.rotation || 0);
        k.forEach(function (b) {
          b = e[b];
          b.movedLabel && b.replaceMovedLabel();
          b && b.label && b.label.textPxLength > A && (A = b.label.textPxLength);
        });
        this.maxLabelLength = A;
        if (this.autoRotation) A > g && A > v.h ? p.rotation = this.labelRotation : this.labelRotation = 0;else if (f) {
          var D = g;
          if (!w) {
            var C = "clip";
            for (g = k.length; !l && g--;) {
              var h = k[g];
              if (h = e[h].label) h.styles && "ellipsis" === h.styles.textOverflow ? h.css({
                textOverflow: "clip"
              }) : h.textPxLength > f && h.css({
                width: f + "px"
              }), h.getBBox().height > this.len / k.length - (v.h - v.f) && (h.specificTextOverflow = "ellipsis");
            }
          }
        }
        p.rotation && (D = A > .5 * b.chartHeight ? .33 * b.chartHeight : A, w || (C = "ellipsis"));
        if (this.labelAlign = a.align || this.autoLabelAlign(this.labelRotation)) p.align = this.labelAlign;
        k.forEach(function (b) {
          var d = (b = e[b]) && b.label,
            c = r.width,
            k = {};
          d && (d.attr(p), b.shortenLabel ? b.shortenLabel() : D && !c && "nowrap" !== r.whiteSpace && (D < d.textPxLength || "SPAN" === d.element.tagName) ? (k.width = D + "px", w || (k.textOverflow = d.specificTextOverflow || C), d.css(k)) : d.styles && d.styles.width && !k.width && !c && d.css({
            width: null
          }), delete d.specificTextOverflow, b.rotation = p.rotation);
        }, this);
        this.tickRotCorr = c.rotCorr(v.b, this.labelRotation || 0, 0 !== this.side);
      };
      a.prototype.hasData = function () {
        return this.series.some(function (b) {
          return b.hasData();
        }) || this.options.showEmpty && e(this.min) && e(this.max);
      };
      a.prototype.addTitle = function (b) {
        var d = this.chart.renderer,
          c = this.horiz,
          k = this.opposite,
          e = this.options.title,
          a = this.chart.styledMode,
          r;
        this.axisTitle || ((r = e.textAlign) || (r = (c ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: k ? "right" : "left",
          middle: "center",
          high: k ? "left" : "right"
        })[e.align]), this.axisTitle = d.text(e.text || "", 0, 0, e.useHTML).attr({
          zIndex: 7,
          rotation: e.rotation,
          align: r
        }).addClass("highcharts-axis-title"), a || this.axisTitle.css(D(e.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
        a || e.style.width || this.isRadial || this.axisTitle.css({
          width: this.len + "px"
        });
        this.axisTitle[b ? "show" : "hide"](b);
      };
      a.prototype.generateTick = function (b) {
        var d = this.ticks;
        d[b] ? d[b].addLabel() : d[b] = new I(this, b);
      };
      a.prototype.getOffset = function () {
        var b = this,
          d = this,
          c = d.chart,
          a = d.horiz,
          r = d.options,
          f = d.side,
          g = d.ticks,
          p = d.tickPositions,
          v = d.coll,
          w = d.axisParent,
          A = c.renderer,
          D = c.inverted && !d.isZAxis ? [1, 0, 3, 2][f] : f,
          C = d.hasData(),
          h = r.title,
          n = r.labels,
          O = c.axisOffset;
        c = c.clipOffset;
        var m = [-1, 1, 1, -1][f],
          z = r.className,
          q,
          G = 0,
          J = 0,
          P = 0;
        d.showAxis = q = C || r.showEmpty;
        d.staggerLines = d.horiz && n.staggerLines || void 0;
        if (!d.axisGroup) {
          var M = function (d, c, k) {
            return A.g(d).attr({
              zIndex: k
            }).addClass("highcharts-" + v.toLowerCase() + c + " " + (b.isRadial ? "highcharts-radial-axis" + c + " " : "") + (z || "")).add(w);
          };
          d.gridGroup = M("grid", "-grid", r.gridZIndex);
          d.axisGroup = M("axis", "", r.zIndex);
          d.labelGroup = M("axis-labels", "-labels", n.zIndex);
        }
        C || d.isLinked ? (p.forEach(function (b) {
          d.generateTick(b);
        }), d.renderUnsquish(), d.reserveSpaceDefault = 0 === f || 2 === f || {
          1: "left",
          3: "right"
        }[f] === d.labelAlign, K(n.reserveSpace, "center" === d.labelAlign ? !0 : null, d.reserveSpaceDefault) && p.forEach(function (b) {
          P = Math.max(g[b].getLabelSize(), P);
        }), d.staggerLines && (P *= d.staggerLines), d.labelOffset = P * (d.opposite ? -1 : 1)) : k(g, function (b, d) {
          b.destroy();
          delete g[d];
        });
        if (h && h.text && !1 !== h.enabled && (d.addTitle(q), q && !1 !== h.reserveSpace)) {
          d.titleOffset = G = d.axisTitle.getBBox()[a ? "height" : "width"];
          var V = h.offset;
          J = e(V) ? 0 : K(h.margin, a ? 5 : 10);
        }
        d.renderLine();
        d.offset = m * K(r.offset, O[f] ? O[f] + (r.margin || 0) : 0);
        d.tickRotCorr = d.tickRotCorr || {
          x: 0,
          y: 0
        };
        h = 0 === f ? -d.labelMetrics().h : 2 === f ? d.tickRotCorr.y : 0;
        C = Math.abs(P) + J;
        P && (C = C - h + m * (a ? K(n.y, d.tickRotCorr.y + 8 * m) : n.x));
        d.axisTitleMargin = K(V, C);
        d.getMaxLabelDimensions && (d.maxLabelDimensions = d.getMaxLabelDimensions(g, p));
        "colorAxis" !== v && (a = this.tickSize("tick"), O[f] = Math.max(O[f], (d.axisTitleMargin || 0) + G + m * d.offset, C, p && p.length && a ? a[0] + m * d.offset : 0), r = !d.axisLine || r.offset ? 0 : 2 * Math.floor(d.axisLine.strokeWidth() / 2), c[D] = Math.max(c[D], r));
        l(this, "afterGetOffset");
      };
      a.prototype.getLinePath = function (b) {
        var d = this.chart,
          c = this.opposite,
          k = this.offset,
          e = this.horiz,
          a = this.left + (c ? this.width : 0) + k;
        k = d.chartHeight - this.bottom - (c ? this.height : 0) + k;
        c && (b *= -1);
        return d.renderer.crispLine([["M", e ? this.left : a, e ? k : this.top], ["L", e ? d.chartWidth - this.right : a, e ? k : d.chartHeight - this.bottom]], b);
      };
      a.prototype.renderLine = function () {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        }));
      };
      a.prototype.getTitlePosition = function () {
        var b = this.horiz,
          d = this.left,
          c = this.top,
          k = this.len,
          e = this.options.title,
          a = b ? d : c,
          r = this.opposite,
          f = this.offset,
          g = e.x,
          p = e.y,
          v = this.axisTitle,
          w = this.chart.renderer.fontMetrics(e.style.fontSize, v);
        v = Math.max(v.getBBox(null, 0).height - w.h - 1, 0);
        k = {
          low: a + (b ? 0 : k),
          middle: a + k / 2,
          high: a + (b ? k : 0)
        }[e.align];
        d = (b ? c + this.height : d) + (b ? 1 : -1) * (r ? -1 : 1) * this.axisTitleMargin + [-v, v, w.f, -v][this.side];
        b = {
          x: b ? k + g : d + (r ? this.width : 0) + f + g,
          y: b ? d + p - (r ? this.height : 0) + f : k + p
        };
        l(this, "afterGetTitlePosition", {
          titlePosition: b
        });
        return b;
      };
      a.prototype.renderMinorTick = function (b, d) {
        var c = this.minorTicks;
        c[b] || (c[b] = new I(this, b, "minor"));
        d && c[b].isNew && c[b].render(null, !0);
        c[b].render(null, !1, 1);
      };
      a.prototype.renderTick = function (b, d, c) {
        var k = this.ticks;
        if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) k[b] || (k[b] = new I(this, b)), c && k[b].isNew && k[b].render(d, !0, -1), k[b].render(d);
      };
      a.prototype.render = function () {
        var b = this,
          d = b.chart,
          c = b.logarithmic,
          e = b.options,
          a = b.isLinked,
          r = b.tickPositions,
          f = b.axisTitle,
          g = b.ticks,
          p = b.minorTicks,
          w = b.alternateBands,
          A = e.stackLabels,
          D = e.alternateGridColor,
          C = b.tickmarkOffset,
          h = b.axisLine,
          n = b.showAxis,
          K = q(d.renderer.globalAnimation),
          O,
          m;
        b.labelEdge.length = 0;
        b.overlap = !1;
        [g, p, w].forEach(function (b) {
          k(b, function (b) {
            b.isActive = !1;
          });
        });
        if (b.hasData() || a) {
          var z = b.chart.hasRendered && b.old && v(b.old.min);
          b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (d) {
            b.renderMinorTick(d, z);
          });
          r.length && (r.forEach(function (d, c) {
            b.renderTick(d, c, z);
          }), C && (0 === b.min || b.single) && (g[-1] || (g[-1] = new I(b, -1, null, !0)), g[-1].render(-1)));
          D && r.forEach(function (k, e) {
            m = "undefined" !== typeof r[e + 1] ? r[e + 1] + C : b.max - C;
            0 === e % 2 && k < b.max && m <= b.max + (d.polar ? -C : C) && (w[k] || (w[k] = new F.PlotLineOrBand(b)), O = k + C, w[k].options = {
              from: c ? c.lin2log(O) : O,
              to: c ? c.lin2log(m) : m,
              color: D,
              className: "highcharts-alternate-grid"
            }, w[k].render(), w[k].isActive = !0);
          });
          b._addedPlotLB || (b._addedPlotLB = !0, (e.plotLines || []).concat(e.plotBands || []).forEach(function (d) {
            b.addPlotBandOrLine(d);
          }));
        }
        [g, p, w].forEach(function (b) {
          var c = [],
            e = K.duration;
          k(b, function (b, d) {
            b.isActive || (b.render(d, !1, 0), b.isActive = !1, c.push(d));
          });
          P(function () {
            for (var d = c.length; d--;) b[c[d]] && !b[c[d]].isActive && (b[c[d]].destroy(), delete b[c[d]]);
          }, b !== w && d.hasRendered && e ? e : 0);
        });
        h && (h[h.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(h.strokeWidth())
        }), h.isPlaced = !0, h[n ? "show" : "hide"](n));
        f && n && (e = b.getTitlePosition(), v(e.y) ? (f[f.isNew ? "attr" : "animate"](e), f.isNew = !1) : (f.attr("y", -9999), f.isNew = !0));
        A && A.enabled && b.stacking && b.stacking.renderStackTotals();
        b.old = {
          len: b.len,
          max: b.max,
          min: b.min,
          transA: b.transA,
          userMax: b.userMax,
          userMin: b.userMin
        };
        b.isDirty = !1;
        l(this, "afterRender");
      };
      a.prototype.redraw = function () {
        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {
          b.render();
        }));
        this.series.forEach(function (b) {
          b.isDirty = !0;
        });
      };
      a.prototype.getKeepProps = function () {
        return this.keepProps || a.keepProps;
      };
      a.prototype.destroy = function (b) {
        var d = this,
          c = d.plotLinesAndBands,
          e = this.eventOptions;
        l(this, "destroy", {
          keepEvents: b
        });
        b || r(d);
        [d.ticks, d.minorTicks, d.alternateBands].forEach(function (b) {
          G(b);
        });
        if (c) for (b = c.length; b--;) c[b].destroy();
        "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (b) {
          d[b] && (d[b] = d[b].destroy());
        });
        for (var a in d.plotLinesAndBandsGroups) d.plotLinesAndBandsGroups[a] = d.plotLinesAndBandsGroups[a].destroy();
        k(d, function (b, c) {
          -1 === d.getKeepProps().indexOf(c) && delete d[c];
        });
        this.eventOptions = e;
      };
      a.prototype.drawCrosshair = function (b, d) {
        var c = this.crosshair,
          k = K(c && c.snap, !0),
          a = this.chart,
          r,
          f = this.cross;
        l(this, "drawCrosshair", {
          e: b,
          point: d
        });
        b || (b = this.cross && this.cross.e);
        if (c && !1 !== (e(d) || !k)) {
          k ? e(d) && (r = K("colorAxis" !== this.coll ? d.crosshairPos : null, this.isXAxis ? d.plotX : this.len - d.plotY)) : r = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);
          if (e(r)) {
            var g = {
              value: d && (this.isXAxis ? d.x : K(d.stackY, d.y)),
              translatedValue: r
            };
            a.polar && p(g, {
              isCrosshair: !0,
              chartX: b && b.chartX,
              chartY: b && b.chartY,
              point: d
            });
            g = this.getPlotLinePath(g) || null;
          }
          if (!e(g)) {
            this.hideCrosshair();
            return;
          }
          k = this.categories && !this.isRadial;
          f || (this.cross = f = a.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (k ? "category " : "thin ") + (c.className || "")).attr({
            zIndex: K(c.zIndex, 2)
          }).add(), a.styledMode || (f.attr({
            stroke: c.color || (k ? B.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
            "stroke-width": K(c.width, 1)
          }).css({
            "pointer-events": "none"
          }), c.dashStyle && f.attr({
            dashstyle: c.dashStyle
          })));
          f.show().attr({
            d: g
          });
          k && !c.width && f.attr({
            "stroke-width": this.transA
          });
          this.cross.e = b;
        } else this.hideCrosshair();
        l(this, "afterDrawCrosshair", {
          e: b,
          point: d
        });
      };
      a.prototype.hideCrosshair = function () {
        this.cross && this.cross.hide();
        l(this, "afterHideCrosshair");
      };
      a.prototype.hasVerticalPanning = function () {
        var b = this.chart.options.chart.panning;
        return !!(b && b.enabled && /y/.test(b.type));
      };
      a.prototype.validatePositiveValue = function (b) {
        return v(b) && 0 < b;
      };
      a.prototype.update = function (b, d) {
        var c = this.chart;
        b = D(this.userOptions, b);
        this.destroy(!0);
        this.init(c, b);
        c.isDirtyBox = !0;
        K(d, !0) && c.redraw();
      };
      a.prototype.remove = function (b) {
        for (var d = this.chart, c = this.coll, k = this.series, e = k.length; e--;) k[e] && k[e].remove(!1);
        J(d.axes, this);
        J(d[c], this);
        d[c].forEach(function (b, d) {
          b.options.index = b.userOptions.index = d;
        });
        this.destroy();
        d.isDirtyBox = !0;
        K(b, !0) && d.redraw();
      };
      a.prototype.setTitle = function (b, d) {
        this.update({
          title: b
        }, d);
      };
      a.prototype.setCategories = function (b, d) {
        this.update({
          categories: b
        }, d);
      };
      a.defaultOptions = t.defaultXAxisOptions;
      a.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
      return a;
    }();
    "";
    return a;
  });
  N(a, "Core/Axis/DateTimeAxis.js", [a["Core/Utilities.js"]], function (a) {
    var E = a.addEvent,
      B = a.getMagnitude,
      H = a.normalizeTickInterval,
      y = a.timeUnits,
      F;
    (function (a) {
      function x() {
        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
      }
      function q(c) {
        "datetime" !== c.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new h(this));
      }
      var m = [];
      a.compose = function (c) {
        -1 === m.indexOf(c) && (m.push(c), c.keepProps.push("dateTime"), c.prototype.getTimeTicks = x, E(c, "init", q));
        return c;
      };
      var h = function () {
        function c(c) {
          this.axis = c;
        }
        c.prototype.normalizeTimeTickInterval = function (c, a) {
          var g = a || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
          a = g[g.length - 1];
          var f = y[a[0]],
            e = a[1],
            h;
          for (h = 0; h < g.length && !(a = g[h], f = y[a[0]], e = a[1], g[h + 1] && c <= (f * e[e.length - 1] + y[g[h + 1][0]]) / 2); h++);
          f === y.year && c < 5 * f && (e = [1, 2, 5]);
          c = H(c / f, e, "year" === a[0] ? Math.max(B(c / f), 1) : 1);
          return {
            unitRange: f,
            count: c,
            unitName: a[0]
          };
        };
        c.prototype.getXDateFormat = function (c, a) {
          var g = this.axis;
          return g.closestPointRange ? g.chart.time.getDateFormat(g.closestPointRange, c, g.options.startOfWeek, a) || a.year : a.day;
        };
        return c;
      }();
      a.Additions = h;
    })(F || (F = {}));
    return F;
  });
  N(a, "Core/Axis/LogarithmicAxis.js", [a["Core/Utilities.js"]], function (a) {
    var E = a.addEvent,
      B = a.getMagnitude,
      H = a.normalizeTickInterval,
      y = a.pick,
      F;
    (function (a) {
      function x(c) {
        var a = this.logarithmic;
        "logarithmic" !== c.userOptions.type ? this.logarithmic = void 0 : a || (this.logarithmic = new h(this));
      }
      function q() {
        var c = this.logarithmic;
        c && (this.lin2val = function (a) {
          return c.lin2log(a);
        }, this.val2lin = function (a) {
          return c.log2lin(a);
        });
      }
      var m = [];
      a.compose = function (c) {
        -1 === m.indexOf(c) && (m.push(c), c.keepProps.push("logarithmic"), E(c, "init", x), E(c, "afterInit", q));
        return c;
      };
      var h = function () {
        function c(c) {
          this.axis = c;
        }
        c.prototype.getLogTickPositions = function (c, a, g, f) {
          var e = this.axis,
            h = e.len,
            n = e.options,
            m = [];
          f || (this.minorAutoInterval = void 0);
          if (.5 <= c) c = Math.round(c), m = e.getLinearTickPositions(c, a, g);else if (.08 <= c) {
            var p = Math.floor(a),
              l,
              w = n = void 0;
            for (h = .3 < c ? [1, 2, 4] : .15 < c ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; p < g + 1 && !w; p++) {
              var b = h.length;
              for (l = 0; l < b && !w; l++) {
                var v = this.log2lin(this.lin2log(p) * h[l]);
                v > a && (!f || n <= g) && "undefined" !== typeof n && m.push(n);
                n > g && (w = !0);
                n = v;
              }
            }
          } else a = this.lin2log(a), g = this.lin2log(g), c = f ? e.getMinorTickInterval() : n.tickInterval, c = y("auto" === c ? null : c, this.minorAutoInterval, n.tickPixelInterval / (f ? 5 : 1) * (g - a) / ((f ? h / e.tickPositions.length : h) || 1)), c = H(c, void 0, B(c)), m = e.getLinearTickPositions(c, a, g).map(this.log2lin), f || (this.minorAutoInterval = c / 5);
          f || (e.tickInterval = c);
          return m;
        };
        c.prototype.lin2log = function (c) {
          return Math.pow(10, c);
        };
        c.prototype.log2lin = function (c) {
          return Math.log(c) / Math.LN10;
        };
        return c;
      }();
      a.Additions = h;
    })(F || (F = {}));
    return F;
  });
  N(a, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [a["Core/Utilities.js"]], function (a) {
    var E = a.erase,
      B = a.extend,
      H = a.isNumber,
      y;
    (function (a) {
      var t = [],
        x;
      a.compose = function (a, h) {
        x || (x = a);
        -1 === t.indexOf(h) && (t.push(h), B(h.prototype, q.prototype));
        return h;
      };
      var q = function () {
        function a() {}
        a.prototype.getPlotBandPath = function (a, c, n) {
          void 0 === n && (n = this.options);
          var h = this.getPlotLinePath({
              value: c,
              force: !0,
              acrossPanes: n.acrossPanes
            }),
            g = [],
            f = this.horiz;
          c = !H(this.min) || !H(this.max) || a < this.min && c < this.min || a > this.max && c > this.max;
          a = this.getPlotLinePath({
            value: a,
            force: !0,
            acrossPanes: n.acrossPanes
          });
          n = 1;
          if (a && h) {
            if (c) {
              var e = a.toString() === h.toString();
              n = 0;
            }
            for (c = 0; c < a.length; c += 2) {
              var m = a[c],
                q = a[c + 1],
                M = h[c],
                p = h[c + 1];
              "M" !== m[0] && "L" !== m[0] || "M" !== q[0] && "L" !== q[0] || "M" !== M[0] && "L" !== M[0] || "M" !== p[0] && "L" !== p[0] || (f && M[1] === m[1] ? (M[1] += n, p[1] += n) : f || M[2] !== m[2] || (M[2] += n, p[2] += n), g.push(["M", m[1], m[2]], ["L", q[1], q[2]], ["L", p[1], p[2]], ["L", M[1], M[2]], ["Z"]));
              g.isFlat = e;
            }
          }
          return g;
        };
        a.prototype.addPlotBand = function (a) {
          return this.addPlotBandOrLine(a, "plotBands");
        };
        a.prototype.addPlotLine = function (a) {
          return this.addPlotBandOrLine(a, "plotLines");
        };
        a.prototype.addPlotBandOrLine = function (a, c) {
          var h = this,
            m = this.userOptions,
            g = new x(this, a);
          this.visible && (g = g.render());
          if (g) {
            this._addedPlotLB || (this._addedPlotLB = !0, (m.plotLines || []).concat(m.plotBands || []).forEach(function (c) {
              h.addPlotBandOrLine(c);
            }));
            if (c) {
              var f = m[c] || [];
              f.push(a);
              m[c] = f;
            }
            this.plotLinesAndBands.push(g);
          }
          return g;
        };
        a.prototype.removePlotBandOrLine = function (a) {
          var c = this.plotLinesAndBands,
            h = this.options,
            m = this.userOptions;
          if (c) {
            for (var g = c.length; g--;) c[g].id === a && c[g].destroy();
            [h.plotLines || [], m.plotLines || [], h.plotBands || [], m.plotBands || []].forEach(function (c) {
              for (g = c.length; g--;) (c[g] || {}).id === a && E(c, c[g]);
            });
          }
        };
        a.prototype.removePlotBand = function (a) {
          this.removePlotBandOrLine(a);
        };
        a.prototype.removePlotLine = function (a) {
          this.removePlotBandOrLine(a);
        };
        return a;
      }();
    })(y || (y = {}));
    return y;
  });
  N(a, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [a["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], a["Core/Utilities.js"]], function (a, t) {
    var E = t.arrayMax,
      H = t.arrayMin,
      y = t.defined,
      F = t.destroyObjectProperties,
      I = t.erase,
      x = t.fireEvent,
      q = t.merge,
      m = t.objectEach,
      h = t.pick;
    t = function () {
      function c(c, a) {
        this.axis = c;
        a && (this.options = a, this.id = a.id);
      }
      c.compose = function (h) {
        return a.compose(c, h);
      };
      c.prototype.render = function () {
        x(this, "render");
        var c = this,
          a = c.axis,
          g = a.horiz,
          f = a.logarithmic,
          e = c.options,
          G = e.color,
          J = h(e.zIndex, 0),
          M = e.events,
          p = {},
          l = a.chart.renderer,
          w = e.label,
          b = c.label,
          v = e.to,
          d = e.from,
          D = e.value,
          C = c.svgElem,
          k = [],
          K = y(d) && y(v);
        k = y(D);
        var O = !C,
          r = {
            "class": "highcharts-plot-" + (K ? "band " : "line ") + (e.className || "")
          },
          A = K ? "bands" : "lines";
        f && (d = f.log2lin(d), v = f.log2lin(v), D = f.log2lin(D));
        a.chart.styledMode || (k ? (r.stroke = G || "#999999", r["stroke-width"] = h(e.width, 1), e.dashStyle && (r.dashstyle = e.dashStyle)) : K && (r.fill = G || "#e6ebf5", e.borderWidth && (r.stroke = e.borderColor, r["stroke-width"] = e.borderWidth)));
        p.zIndex = J;
        A += "-" + J;
        (f = a.plotLinesAndBandsGroups[A]) || (a.plotLinesAndBandsGroups[A] = f = l.g("plot-" + A).attr(p).add());
        O && (c.svgElem = C = l.path().attr(r).add(f));
        if (k) k = a.getPlotLinePath({
          value: D,
          lineWidth: C.strokeWidth(),
          acrossPanes: e.acrossPanes
        });else if (K) k = a.getPlotBandPath(d, v, e);else return;
        !c.eventsAdded && M && (m(M, function (b, d) {
          C.on(d, function (b) {
            M[d].apply(c, [b]);
          });
        }), c.eventsAdded = !0);
        (O || !C.d) && k && k.length ? C.attr({
          d: k
        }) : C && (k ? (C.show(!0), C.animate({
          d: k
        })) : C.d && (C.hide(), b && (c.label = b = b.destroy())));
        w && (y(w.text) || y(w.formatter)) && k && k.length && 0 < a.width && 0 < a.height && !k.isFlat ? (w = q({
          align: g && K && "center",
          x: g ? !K && 4 : 10,
          verticalAlign: !g && K && "middle",
          y: g ? K ? 16 : 10 : K ? 6 : -4,
          rotation: g && !K && 90
        }, w), this.renderLabel(w, k, K, J)) : b && b.hide();
        return c;
      };
      c.prototype.renderLabel = function (c, a, g, f) {
        var e = this.axis,
          h = e.chart.renderer,
          n = this.label;
        n || (this.label = n = h.text(this.getLabelText(c), 0, 0, c.useHTML).attr({
          align: c.textAlign || c.align,
          rotation: c.rotation,
          "class": "highcharts-plot-" + (g ? "band" : "line") + "-label " + (c.className || ""),
          zIndex: f
        }).add(), e.chart.styledMode || n.css(q({
          textOverflow: "ellipsis"
        }, c.style)));
        f = a.xBounds || [a[0][1], a[1][1], g ? a[2][1] : a[0][1]];
        a = a.yBounds || [a[0][2], a[1][2], g ? a[2][2] : a[0][2]];
        g = H(f);
        h = H(a);
        n.align(c, !1, {
          x: g,
          y: h,
          width: E(f) - g,
          height: E(a) - h
        });
        n.alignValue && "left" !== n.alignValue || n.css({
          width: (90 === n.rotation ? e.height - (n.alignAttr.y - e.top) : e.width - (n.alignAttr.x - e.left)) + "px"
        });
        n.show(!0);
      };
      c.prototype.getLabelText = function (c) {
        return y(c.formatter) ? c.formatter.call(this) : c.text;
      };
      c.prototype.destroy = function () {
        I(this.axis.plotLinesAndBands, this);
        delete this.axis;
        F(this);
      };
      return c;
    }();
    "";
    "";
    return t;
  });
  N(a, "Core/Tooltip.js", [a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function (a, t, B, H, y) {
    var E = a.format,
      I = t.doc,
      x = B.distribute,
      q = y.addEvent,
      m = y.clamp,
      h = y.css,
      c = y.defined,
      n = y.discardElement,
      z = y.extend,
      g = y.fireEvent,
      f = y.isArray,
      e = y.isNumber,
      G = y.isString,
      J = y.merge,
      M = y.pick,
      p = y.splat,
      l = y.syncTimeout;
    a = function () {
      function a(b, c) {
        this.allowShared = !0;
        this.container = void 0;
        this.crosshairs = [];
        this.distance = 0;
        this.isHidden = !0;
        this.isSticky = !1;
        this.now = {};
        this.options = {};
        this.outside = !1;
        this.chart = b;
        this.init(b, c);
      }
      a.prototype.applyFilter = function () {
        var b = this.chart;
        b.renderer.definition({
          tagName: "filter",
          attributes: {
            id: "drop-shadow-" + b.index,
            opacity: .5
          },
          children: [{
            tagName: "feGaussianBlur",
            attributes: {
              "in": "SourceAlpha",
              stdDeviation: 1
            }
          }, {
            tagName: "feOffset",
            attributes: {
              dx: 1,
              dy: 1
            }
          }, {
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncA",
              attributes: {
                type: "linear",
                slope: .3
              }
            }]
          }, {
            tagName: "feMerge",
            children: [{
              tagName: "feMergeNode"
            }, {
              tagName: "feMergeNode",
              attributes: {
                "in": "SourceGraphic"
              }
            }]
          }]
        });
      };
      a.prototype.bodyFormatter = function (b) {
        return b.map(function (b) {
          var d = b.series.tooltipOptions;
          return (d[(b.point.formatPrefix || "point") + "Formatter"] || b.point.tooltipFormatter).call(b.point, d[(b.point.formatPrefix || "point") + "Format"] || "");
        });
      };
      a.prototype.cleanSplit = function (b) {
        this.chart.series.forEach(function (c) {
          var d = c && c.tt;
          d && (!d.isActive || b ? c.tt = d.destroy() : d.isActive = !1);
        });
      };
      a.prototype.defaultFormatter = function (b) {
        var c = this.points || p(this);
        var d = [b.tooltipFooterHeaderFormatter(c[0])];
        d = d.concat(b.bodyFormatter(c));
        d.push(b.tooltipFooterHeaderFormatter(c[0], !0));
        return d;
      };
      a.prototype.destroy = function () {
        this.label && (this.label = this.label.destroy());
        this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());
        this.renderer && (this.renderer = this.renderer.destroy(), n(this.container));
        y.clearTimeout(this.hideTimer);
        y.clearTimeout(this.tooltipTimeout);
      };
      a.prototype.getAnchor = function (b, c) {
        var d = this.chart,
          a = d.pointer,
          e = d.inverted,
          k = d.plotTop,
          l = d.plotLeft,
          f,
          r,
          g = 0,
          v = 0;
        b = p(b);
        this.followPointer && c ? ("undefined" === typeof c.chartX && (c = a.normalize(c)), a = [c.chartX - l, c.chartY - k]) : b[0].tooltipPos ? a = b[0].tooltipPos : (b.forEach(function (b) {
          f = b.series.yAxis;
          r = b.series.xAxis;
          g += b.plotX || 0;
          v += b.plotLow ? (b.plotLow + (b.plotHigh || 0)) / 2 : b.plotY || 0;
          r && f && (e ? (g += k + d.plotHeight - r.len - r.pos, v += l + d.plotWidth - f.len - f.pos) : (g += r.pos - l, v += f.pos - k));
        }), g /= b.length, v /= b.length, a = [e ? d.plotWidth - v : g, e ? d.plotHeight - g : v], this.shared && 1 < b.length && c && (e ? a[0] = c.chartX - l : a[1] = c.chartY - k));
        return a.map(Math.round);
      };
      a.prototype.getLabel = function () {
        var b = this,
          a = this.chart.styledMode,
          d = this.options,
          e = this.split && this.allowShared,
          l = "tooltip" + (c(d.className) ? " " + d.className : ""),
          k = d.style.pointerEvents || (!this.followPointer && d.stickOnContact ? "auto" : "none"),
          f = function () {
            b.inContact = !0;
          },
          g = function (d) {
            var c = b.chart.hoverSeries;
            b.inContact = b.shouldStickOnContact() && b.chart.pointer.inClass(d.relatedTarget, "highcharts-tooltip");
            if (!b.inContact && c && c.onMouseOut) c.onMouseOut();
          },
          r,
          p = this.chart.renderer;
        if (b.label) {
          var w = !b.label.hasClass("highcharts-label");
          (e && !w || !e && w) && b.destroy();
        }
        if (!this.label) {
          if (this.outside) {
            w = this.chart.options.chart.style;
            var n = H.getRendererType();
            this.container = r = t.doc.createElement("div");
            r.className = "highcharts-tooltip-container";
            h(r, {
              position: "absolute",
              top: "1px",
              pointerEvents: k,
              zIndex: Math.max(this.options.style.zIndex || 0, (w && w.zIndex || 0) + 3)
            });
            q(r, "mouseenter", f);
            q(r, "mouseleave", g);
            t.doc.body.appendChild(r);
            this.renderer = p = new n(r, 0, 0, w, void 0, void 0, p.styledMode);
          }
          e ? this.label = p.g(l) : (this.label = p.label("", 0, 0, d.shape, void 0, void 0, d.useHTML, void 0, l).attr({
            padding: d.padding,
            r: d.borderRadius
          }), a || this.label.attr({
            fill: d.backgroundColor,
            "stroke-width": d.borderWidth
          }).css(d.style).css({
            pointerEvents: k
          }).shadow(d.shadow));
          a && d.shadow && (this.applyFilter(), this.label.attr({
            filter: "url(#drop-shadow-" + this.chart.index + ")"
          }));
          if (b.outside && !b.split) {
            var u = this.label,
              m = u.xSetter,
              z = u.ySetter;
            u.xSetter = function (d) {
              m.call(u, b.distance);
              r.style.left = d + "px";
            };
            u.ySetter = function (d) {
              z.call(u, b.distance);
              r.style.top = d + "px";
            };
          }
          this.label.on("mouseenter", f).on("mouseleave", g).attr({
            zIndex: 8
          }).add();
        }
        return this.label;
      };
      a.prototype.getPosition = function (b, c, d) {
        var a = this.chart,
          e = this.distance,
          k = {},
          l = a.inverted && d.h || 0,
          f = this.outside,
          r = f ? I.documentElement.clientWidth - 2 * e : a.chartWidth,
          g = f ? Math.max(I.body.scrollHeight, I.documentElement.scrollHeight, I.body.offsetHeight, I.documentElement.offsetHeight, I.documentElement.clientHeight) : a.chartHeight,
          p = a.pointer.getChartPosition(),
          v = function (k) {
            var l = "x" === k;
            return [k, l ? r : g, l ? b : c].concat(f ? [l ? b * p.scaleX : c * p.scaleY, l ? p.left - e + (d.plotX + a.plotLeft) * p.scaleX : p.top - e + (d.plotY + a.plotTop) * p.scaleY, 0, l ? r : g] : [l ? b : c, l ? d.plotX + a.plotLeft : d.plotY + a.plotTop, l ? a.plotLeft : a.plotTop, l ? a.plotLeft + a.plotWidth : a.plotTop + a.plotHeight]);
          },
          w = v("y"),
          h = v("x"),
          n;
        v = !!d.negative;
        !a.polar && a.hoverSeries && a.hoverSeries.yAxis && a.hoverSeries.yAxis.reversed && (v = !v);
        var m = !this.followPointer && M(d.ttBelow, !a.inverted === v),
          q = function (b, d, c, a, r, g, v) {
            var w = f ? "y" === b ? e * p.scaleY : e * p.scaleX : e,
              h = (c - a) / 2,
              A = a < r - e,
              u = r + e + a < d,
              D = r - w - c + h;
            r = r + w - h;
            if (m && u) k[b] = r;else if (!m && A) k[b] = D;else if (A) k[b] = Math.min(v - a, 0 > D - l ? D : D - l);else if (u) k[b] = Math.max(g, r + l + c > d ? r : r + l);else return !1;
          },
          z = function (b, d, c, a, r) {
            var l;
            r < e || r > d - e ? l = !1 : k[b] = r < c / 2 ? 1 : r > d - a / 2 ? d - a - 2 : r - c / 2;
            return l;
          },
          Q = function (b) {
            var d = w;
            w = h;
            h = d;
            n = b;
          },
          G = function () {
            !1 !== q.apply(0, w) ? !1 !== z.apply(0, h) || n || (Q(!0), G()) : n ? k.x = k.y = 0 : (Q(!0), G());
          };
        (a.inverted || 1 < this.len) && Q();
        G();
        return k;
      };
      a.prototype.hide = function (b) {
        var c = this;
        y.clearTimeout(this.hideTimer);
        b = M(b, this.options.hideDelay);
        this.isHidden || (this.hideTimer = l(function () {
          c.getLabel().fadeOut(b ? void 0 : b);
          c.isHidden = !0;
        }, b));
      };
      a.prototype.init = function (b, c) {
        this.chart = b;
        this.options = c;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.split = c.split && !b.inverted && !b.polar;
        this.shared = c.shared || this.split;
        this.outside = M(c.outside, !(!b.scrollablePixelsX && !b.scrollablePixelsY));
      };
      a.prototype.shouldStickOnContact = function () {
        return !(this.followPointer || !this.options.stickOnContact);
      };
      a.prototype.isStickyOnContact = function () {
        return !(!this.shouldStickOnContact() || !this.inContact);
      };
      a.prototype.move = function (b, c, d, a) {
        var e = this,
          k = e.now,
          l = !1 !== e.options.animation && !e.isHidden && (1 < Math.abs(b - k.x) || 1 < Math.abs(c - k.y)),
          f = e.followPointer || 1 < e.len;
        z(k, {
          x: l ? (2 * k.x + b) / 3 : b,
          y: l ? (k.y + c) / 2 : c,
          anchorX: f ? void 0 : l ? (2 * k.anchorX + d) / 3 : d,
          anchorY: f ? void 0 : l ? (k.anchorY + a) / 2 : a
        });
        e.getLabel().attr(k);
        e.drawTracker();
        l && (y.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
          e && e.move(b, c, d, a);
        }, 32));
      };
      a.prototype.refresh = function (b, c) {
        var d = this.chart,
          a = this.options,
          e = p(b),
          k = e[0],
          l = [],
          w = a.formatter || this.defaultFormatter,
          r = this.shared,
          v = d.styledMode,
          h = {};
        if (a.enabled) {
          y.clearTimeout(this.hideTimer);
          this.allowShared = !(!f(b) && b.series && b.series.noSharedTooltip);
          this.followPointer = !this.split && k.series.tooltipOptions.followPointer;
          b = this.getAnchor(b, c);
          var n = b[0],
            u = b[1];
          r && this.allowShared ? (d.pointer.applyInactiveState(e), e.forEach(function (b) {
            b.setState("hover");
            l.push(b.getLabelConfig());
          }), h = {
            x: k.category,
            y: k.y
          }, h.points = l) : h = k.getLabelConfig();
          this.len = l.length;
          w = w.call(h, this);
          r = k.series;
          this.distance = M(r.tooltipOptions.distance, 16);
          if (!1 === w) this.hide();else {
            if (this.split && this.allowShared) this.renderSplit(w, e);else {
              var m = n,
                q = u;
              c && d.pointer.isDirectTouch && (m = c.chartX - d.plotLeft, q = c.chartY - d.plotTop);
              if (d.polar || !1 === r.options.clip || e.some(function (b) {
                return b.series.shouldShowTooltip(m, q);
              })) c = this.getLabel(), a.style.width && !v || c.css({
                width: this.chart.spacingBox.width + "px"
              }), c.attr({
                text: w && w.join ? w.join("") : w
              }), c.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + M(k.colorIndex, r.colorIndex)), v || c.attr({
                stroke: a.borderColor || k.color || r.color || "#666666"
              }), this.updatePosition({
                plotX: n,
                plotY: u,
                negative: k.negative,
                ttBelow: k.ttBelow,
                h: b[2] || 0
              });else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({
              opacity: 1
            }).show();
            this.isHidden = !1;
          }
          g(this, "refresh");
        }
      };
      a.prototype.renderSplit = function (b, c) {
        function d(b, d, c, e, k) {
          void 0 === k && (k = !0);
          c ? (d = y ? 0 : N, b = m(b - e / 2, U.left, U.right - e - (a.outside ? B : 0))) : (d -= H, b = k ? b - e - E : b + E, b = m(b, k ? b : U.left, U.right));
          return {
            x: b,
            y: d
          };
        }
        var a = this,
          e = a.chart,
          k = a.chart,
          l = k.chartWidth,
          f = k.chartHeight,
          r = k.plotHeight,
          g = k.plotLeft,
          p = k.plotTop,
          w = k.pointer,
          v = k.scrollablePixelsY;
        v = void 0 === v ? 0 : v;
        var h = k.scrollablePixelsX,
          n = k.scrollingContainer;
        n = void 0 === n ? {
          scrollLeft: 0,
          scrollTop: 0
        } : n;
        var q = n.scrollLeft;
        n = n.scrollTop;
        var J = k.styledMode,
          E = a.distance,
          Q = a.options,
          Y = a.options.positioner,
          U = a.outside && "number" !== typeof h ? I.documentElement.getBoundingClientRect() : {
            left: q,
            right: q + l,
            top: n,
            bottom: n + f
          },
          t = a.getLabel(),
          F = this.renderer || e.renderer,
          y = !(!e.xAxis[0] || !e.xAxis[0].opposite);
        e = w.getChartPosition();
        var B = e.left;
        e = e.top;
        var H = p + n,
          ba = 0,
          N = r - v;
        G(b) && (b = [!1, b]);
        b = b.slice(0, c.length + 1).reduce(function (b, e, k) {
          if (!1 !== e && "" !== e) {
            k = c[k - 1] || {
              isHeader: !0,
              plotX: c[0].plotX,
              plotY: r,
              series: {}
            };
            var l = k.isHeader,
              f = l ? a : k.series;
            e = e.toString();
            var w = f.tt,
              v = k.isHeader;
            var h = k.series;
            var A = "highcharts-color-" + M(k.colorIndex, h.colorIndex, "none");
            w || (w = {
              padding: Q.padding,
              r: Q.borderRadius
            }, J || (w.fill = Q.backgroundColor, w["stroke-width"] = Q.borderWidth), w = F.label("", 0, 0, Q[v ? "headerShape" : "shape"], void 0, void 0, Q.useHTML).addClass((v ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + A).attr(w).add(t));
            w.isActive = !0;
            w.attr({
              text: e
            });
            J || w.css(Q.style).shadow(Q.shadow).attr({
              stroke: Q.borderColor || k.color || h.color || "#333333"
            });
            f = f.tt = w;
            v = f.getBBox();
            e = v.width + f.strokeWidth();
            l && (ba = v.height, N += ba, y && (H -= ba));
            h = k.plotX;
            h = void 0 === h ? 0 : h;
            A = k.plotY;
            A = void 0 === A ? 0 : A;
            w = k.series;
            if (k.isHeader) {
              h = g + h;
              var u = p + r / 2;
            } else {
              var D = w.xAxis,
                C = w.yAxis;
              h = D.pos + m(h, -E, D.len + E);
              w.shouldShowTooltip(0, C.pos - p + A, {
                ignoreX: !0
              }) && (u = C.pos + A);
            }
            h = m(h, U.left - E, U.right + E);
            "number" === typeof u ? (v = v.height + 1, A = Y ? Y.call(a, e, v, k) : d(h, u, l, e), b.push({
              align: Y ? 0 : void 0,
              anchorX: h,
              anchorY: u,
              boxWidth: e,
              point: k,
              rank: M(A.rank, l ? 1 : 0),
              size: v,
              target: A.y,
              tt: f,
              x: A.x
            })) : f.isActive = !1;
          }
          return b;
        }, []);
        !Y && b.some(function (b) {
          var d = (a.outside ? B : 0) + b.anchorX;
          return d < U.left && d + b.boxWidth < U.right ? !0 : d < B - U.left + b.boxWidth && U.right - d > d;
        }) && (b = b.map(function (b) {
          var c = d(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
          return z(b, {
            target: c.y,
            x: c.x
          });
        }));
        a.cleanSplit();
        x(b, N);
        var Z = B,
          ca = B;
        b.forEach(function (b) {
          var d = b.x,
            c = b.boxWidth;
          b = b.isHeader;
          b || (a.outside && B + d < Z && (Z = B + d), !b && a.outside && Z + c > ca && (ca = B + d));
        });
        b.forEach(function (b) {
          var d = b.x,
            c = b.anchorX,
            k = b.pos,
            e = b.point.isHeader;
          k = {
            visibility: "undefined" === typeof k ? "hidden" : "inherit",
            x: d,
            y: k + H,
            anchorX: c,
            anchorY: b.anchorY
          };
          if (a.outside && d < c) {
            var r = B - Z;
            0 < r && (e || (k.x = d + r, k.anchorX = c + r), e && (k.x = (ca - Z) / 2, k.anchorX = c + r));
          }
          b.tt.attr(k);
        });
        b = a.container;
        v = a.renderer;
        a.outside && b && v && (k = t.getBBox(), v.setSize(k.width + k.x, k.height + k.y, !1), b.style.left = Z + "px", b.style.top = e + "px");
      };
      a.prototype.drawTracker = function () {
        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
          var b = this.chart,
            c = this.label,
            d = this.shared ? b.hoverPoints : b.hoverPoint;
          if (c && d) {
            var a = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
            d = this.getAnchor(d);
            var e = c.getBBox();
            d[0] += b.plotLeft - c.translateX;
            d[1] += b.plotTop - c.translateY;
            a.x = Math.min(0, d[0]);
            a.y = Math.min(0, d[1]);
            a.width = 0 > d[0] ? Math.max(Math.abs(d[0]), e.width - d[0]) : Math.max(Math.abs(d[0]), e.width);
            a.height = 0 > d[1] ? Math.max(Math.abs(d[1]), e.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), e.height);
            this.tracker ? this.tracker.attr(a) : (this.tracker = c.renderer.rect(a).addClass("highcharts-tracker").add(c), b.styledMode || this.tracker.attr({
              fill: "rgba(0,0,0,0)"
            }));
          }
        }
      };
      a.prototype.styledModeFormat = function (b) {
        return b.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
      };
      a.prototype.tooltipFooterHeaderFormatter = function (b, c) {
        var d = b.series,
          a = d.tooltipOptions,
          l = d.xAxis,
          k = l && l.dateTime;
        l = {
          isFooter: c,
          labelConfig: b
        };
        var f = a.xDateFormat,
          p = a[c ? "footerFormat" : "headerFormat"];
        g(this, "headerFormatter", l, function (c) {
          k && !f && e(b.key) && (f = k.getXDateFormat(b.key, a.dateTimeLabelFormats));
          k && f && (b.point && b.point.tooltipDateKeys || ["key"]).forEach(function (b) {
            p = p.replace("{point." + b + "}", "{point." + b + ":" + f + "}");
          });
          d.chart.styledMode && (p = this.styledModeFormat(p));
          c.text = E(p, {
            point: b,
            series: d
          }, this.chart);
        });
        return l.text;
      };
      a.prototype.update = function (b) {
        this.destroy();
        J(!0, this.chart.options.tooltip.userOptions, b);
        this.init(this.chart, J(!0, this.options, b));
      };
      a.prototype.updatePosition = function (b) {
        var c = this.chart,
          d = this.options,
          a = c.pointer,
          e = this.getLabel();
        a = a.getChartPosition();
        var k = (d.positioner || this.getPosition).call(this, e.width, e.height, b),
          l = b.plotX + c.plotLeft;
        b = b.plotY + c.plotTop;
        if (this.outside) {
          d = d.borderWidth + 2 * this.distance;
          this.renderer.setSize(e.width + d, e.height + d, !1);
          if (1 !== a.scaleX || 1 !== a.scaleY) h(this.container, {
            transform: "scale(" + a.scaleX + ", " + a.scaleY + ")"
          }), l *= a.scaleX, b *= a.scaleY;
          l += a.left - k.x;
          b += a.top - k.y;
        }
        this.move(Math.round(k.x), Math.round(k.y || 0), l, b);
      };
      return a;
    }();
    "";
    return a;
  });
  N(a, "Core/Series/Point.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Animation/AnimationUtilities.js"], a["Core/DefaultOptions.js"], a["Core/FormatUtilities.js"], a["Core/Utilities.js"]], function (a, t, B, H, y) {
    var E = t.animObject,
      I = B.defaultOptions,
      x = H.format,
      q = y.addEvent,
      m = y.defined,
      h = y.erase,
      c = y.extend,
      n = y.fireEvent,
      z = y.getNestedProperty,
      g = y.isArray,
      f = y.isFunction,
      e = y.isNumber,
      G = y.isObject,
      J = y.merge,
      M = y.objectEach,
      p = y.pick,
      l = y.syncTimeout,
      w = y.removeEvent,
      b = y.uniqueKey;
    t = function () {
      function v() {
        this.colorIndex = this.category = void 0;
        this.formatPrefix = "point";
        this.id = void 0;
        this.isNull = !1;
        this.percentage = this.options = this.name = void 0;
        this.selected = !1;
        this.total = this.series = void 0;
        this.visible = !0;
        this.x = void 0;
      }
      v.prototype.animateBeforeDestroy = function () {
        var b = this,
          a = {
            x: b.startXPos,
            opacity: 0
          },
          e = b.getGraphicalProps();
        e.singular.forEach(function (d) {
          b[d] = b[d].animate("dataLabel" === d ? {
            x: b[d].startXPos,
            y: b[d].startYPos,
            opacity: 0
          } : a);
        });
        e.plural.forEach(function (d) {
          b[d].forEach(function (d) {
            d.element && d.animate(c({
              x: b.startXPos
            }, d.startYPos ? {
              x: d.startXPos,
              y: d.startYPos
            } : {}));
          });
        });
      };
      v.prototype.applyOptions = function (b, a) {
        var d = this.series,
          k = d.options.pointValKey || d.pointValKey;
        b = v.prototype.optionsToObject.call(this, b);
        c(this, b);
        this.options = this.options ? c(this.options, b) : b;
        b.group && delete this.group;
        b.dataLabels && delete this.dataLabels;
        k && (this.y = v.prototype.getNestedProperty.call(this, k));
        this.formatPrefix = (this.isNull = p(this.isValid && !this.isValid(), null === this.x || !e(this.y))) ? "null" : "point";
        this.selected && (this.state = "select");
        "name" in this && "undefined" === typeof a && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));
        "undefined" === typeof this.x && d ? this.x = "undefined" === typeof a ? d.autoIncrement() : a : e(b.x) && d.options.relativeXValue && (this.x = d.autoIncrement(b.x));
        return this;
      };
      v.prototype.destroy = function () {
        function b() {
          if (c.graphic || c.dataLabel || c.dataLabels) w(c), c.destroyElements();
          for (r in c) c[r] = null;
        }
        var c = this,
          a = c.series,
          e = a.chart;
        a = a.options.dataSorting;
        var f = e.hoverPoints,
          g = E(c.series.chart.renderer.globalAnimation),
          r;
        c.legendItem && e.legend.destroyItem(c);
        f && (c.setState(), h(f, c), f.length || (e.hoverPoints = null));
        if (c === e.hoverPoint) c.onMouseOut();
        a && a.enabled ? (this.animateBeforeDestroy(), l(b, g.duration)) : b();
        e.pointCount--;
      };
      v.prototype.destroyElements = function (b) {
        var d = this;
        b = d.getGraphicalProps(b);
        b.singular.forEach(function (b) {
          d[b] = d[b].destroy();
        });
        b.plural.forEach(function (b) {
          d[b].forEach(function (b) {
            b.element && b.destroy();
          });
          delete d[b];
        });
      };
      v.prototype.firePointEvent = function (b, c, a) {
        var d = this,
          e = this.series.options;
        (e.point.events[b] || d.options && d.options.events && d.options.events[b]) && d.importEvents();
        "click" === b && e.allowPointSelect && (a = function (b) {
          d.select && d.select(null, b.ctrlKey || b.metaKey || b.shiftKey);
        });
        n(d, b, c, a);
      };
      v.prototype.getClassName = function () {
        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
      };
      v.prototype.getGraphicalProps = function (b) {
        var d = this,
          c = [],
          a = {
            singular: [],
            plural: []
          },
          e;
        b = b || {
          graphic: 1,
          dataLabel: 1
        };
        b.graphic && c.push("graphic", "upperGraphic", "shadowGroup");
        b.dataLabel && c.push("dataLabel", "dataLabelUpper", "connector");
        for (e = c.length; e--;) {
          var l = c[e];
          d[l] && a.singular.push(l);
        }
        ["dataLabel", "connector"].forEach(function (c) {
          var e = c + "s";
          b[c] && d[e] && a.plural.push(e);
        });
        return a;
      };
      v.prototype.getLabelConfig = function () {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      };
      v.prototype.getNestedProperty = function (b) {
        if (b) return 0 === b.indexOf("custom.") ? z(b, this.options) : this[b];
      };
      v.prototype.getZone = function () {
        var b = this.series,
          c = b.zones;
        b = b.zoneAxis || "y";
        var a,
          e = 0;
        for (a = c[e]; this[b] >= a.value;) a = c[++e];
        this.nonZonedColor || (this.nonZonedColor = this.color);
        this.color = a && a.color && !this.options.color ? a.color : this.nonZonedColor;
        return a;
      };
      v.prototype.hasNewShapeType = function () {
        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
      };
      v.prototype.init = function (d, c, a) {
        this.series = d;
        this.applyOptions(c, a);
        this.id = m(this.id) ? this.id : b();
        this.resolveColor();
        d.chart.pointCount++;
        n(this, "afterInit");
        return this;
      };
      v.prototype.optionsToObject = function (b) {
        var d = this.series,
          c = d.options.keys,
          a = c || d.pointArrayMap || ["y"],
          l = a.length,
          f = {},
          r = 0,
          p = 0;
        if (e(b) || null === b) f[a[0]] = b;else if (g(b)) for (!c && b.length > l && (d = typeof b[0], "string" === d ? f.name = b[0] : "number" === d && (f.x = b[0]), r++); p < l;) c && "undefined" === typeof b[r] || (0 < a[p].indexOf(".") ? v.prototype.setNestedProperty(f, b[r], a[p]) : f[a[p]] = b[r]), r++, p++;else "object" === typeof b && (f = b, b.dataLabels && (d._hasPointLabels = !0), b.marker && (d._hasPointMarkers = !0));
        return f;
      };
      v.prototype.resolveColor = function () {
        var b = this.series,
          c = b.chart.styledMode;
        var a = b.chart.options.chart.colorCount;
        delete this.nonZonedColor;
        if (b.options.colorByPoint) {
          if (!c) {
            a = b.options.colors || b.chart.options.colors;
            var e = a[b.colorCounter];
            a = a.length;
          }
          c = b.colorCounter;
          b.colorCounter++;
          b.colorCounter === a && (b.colorCounter = 0);
        } else c || (e = b.color), c = b.colorIndex;
        this.colorIndex = p(this.options.colorIndex, c);
        this.color = p(this.options.color, e);
      };
      v.prototype.setNestedProperty = function (b, c, a) {
        a.split(".").reduce(function (b, d, a, e) {
          b[d] = e.length - 1 === a ? c : G(b[d], !0) ? b[d] : {};
          return b[d];
        }, b);
        return b;
      };
      v.prototype.tooltipFormatter = function (b) {
        var d = this.series,
          c = d.tooltipOptions,
          a = p(c.valueDecimals, ""),
          e = c.valuePrefix || "",
          l = c.valueSuffix || "";
        d.chart.styledMode && (b = d.chart.tooltip.styledModeFormat(b));
        (d.pointArrayMap || ["y"]).forEach(function (d) {
          d = "{point." + d;
          if (e || l) b = b.replace(RegExp(d + "}", "g"), e + d + "}" + l);
          b = b.replace(RegExp(d + "}", "g"), d + ":,." + a + "f}");
        });
        return x(b, {
          point: this,
          series: this.series
        }, d.chart);
      };
      v.prototype.update = function (b, c, a, e) {
        function d() {
          k.applyOptions(b);
          var d = l && k.hasDummyGraphic;
          d = null === k.y ? !d : d;
          l && d && (k.graphic = l.destroy(), delete k.hasDummyGraphic);
          G(b, !0) && (l && l.element && b && b.marker && "undefined" !== typeof b.marker.symbol && (k.graphic = l.destroy()), b && b.dataLabels && k.dataLabel && (k.dataLabel = k.dataLabel.destroy()), k.connector && (k.connector = k.connector.destroy()));
          w = k.index;
          r.updateParallelArrays(k, w);
          g.data[w] = G(g.data[w], !0) || G(b, !0) ? k.options : p(b, g.data[w]);
          r.isDirty = r.isDirtyData = !0;
          !r.fixedBox && r.hasCartesianSeries && (f.isDirtyBox = !0);
          "point" === g.legendType && (f.isDirtyLegend = !0);
          c && f.redraw(a);
        }
        var k = this,
          r = k.series,
          l = k.graphic,
          f = r.chart,
          g = r.options,
          w;
        c = p(c, !0);
        !1 === e ? d() : k.firePointEvent("update", {
          options: b
        }, d);
      };
      v.prototype.remove = function (b, c) {
        this.series.removePoint(this.series.data.indexOf(this), b, c);
      };
      v.prototype.select = function (b, c) {
        var d = this,
          a = d.series,
          e = a.chart;
        this.selectedStaging = b = p(b, !d.selected);
        d.firePointEvent(b ? "select" : "unselect", {
          accumulate: c
        }, function () {
          d.selected = d.options.selected = b;
          a.options.data[a.data.indexOf(d)] = d.options;
          d.setState(b && "select");
          c || e.getSelectedPoints().forEach(function (b) {
            var c = b.series;
            b.selected && b !== d && (b.selected = b.options.selected = !1, c.options.data[c.data.indexOf(b)] = b.options, b.setState(e.hoverPoints && c.options.inactiveOtherPoints ? "inactive" : ""), b.firePointEvent("unselect"));
          });
        });
        delete this.selectedStaging;
      };
      v.prototype.onMouseOver = function (b) {
        var d = this.series.chart,
          c = d.pointer;
        b = b ? c.normalize(b) : c.getChartCoordinatesFromPoint(this, d.inverted);
        c.runPointActions(b, this);
      };
      v.prototype.onMouseOut = function () {
        var b = this.series.chart;
        this.firePointEvent("mouseOut");
        this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function (b) {
          b.setState();
        });
        b.hoverPoints = b.hoverPoint = null;
      };
      v.prototype.importEvents = function () {
        if (!this.hasImportedEvents) {
          var b = this,
            c = J(b.series.options.point, b.options).events;
          b.events = c;
          M(c, function (d, c) {
            f(d) && q(b, c, d);
          });
          this.hasImportedEvents = !0;
        }
      };
      v.prototype.setState = function (b, l) {
        var d = this.series,
          k = this.state,
          f = d.options.states[b || "normal"] || {},
          g = I.plotOptions[d.type].marker && d.options.marker,
          r = g && !1 === g.enabled,
          w = g && g.states && g.states[b || "normal"] || {},
          h = !1 === w.enabled,
          v = this.marker || {},
          u = d.chart,
          D = g && d.markerAttribs,
          m = d.halo,
          q,
          z = d.stateMarkerGraphic;
        b = b || "";
        if (!(b === this.state && !l || this.selected && "select" !== b || !1 === f.enabled || b && (h || r && !1 === w.enabled) || b && v.states && v.states[b] && !1 === v.states[b].enabled)) {
          this.state = b;
          D && (q = d.markerAttribs(this, b));
          if (this.graphic && !this.hasDummyGraphic) {
            k && this.graphic.removeClass("highcharts-point-" + k);
            b && this.graphic.addClass("highcharts-point-" + b);
            if (!u.styledMode) {
              var G = d.pointAttribs(this, b);
              var Q = p(u.options.chart.animation, f.animation);
              d.options.inactiveOtherPoints && e(G.opacity) && ((this.dataLabels || []).forEach(function (b) {
                b && b.animate({
                  opacity: G.opacity
                }, Q);
              }), this.connector && this.connector.animate({
                opacity: G.opacity
              }, Q));
              this.graphic.animate(G, Q);
            }
            q && this.graphic.animate(q, p(u.options.chart.animation, w.animation, g.animation));
            z && z.hide();
          } else {
            if (b && w) {
              k = v.symbol || d.symbol;
              z && z.currentSymbol !== k && (z = z.destroy());
              if (q) if (z) z[l ? "animate" : "attr"]({
                x: q.x,
                y: q.y
              });else k && (d.stateMarkerGraphic = z = u.renderer.symbol(k, q.x, q.y, q.width, q.height).add(d.markerGroup), z.currentSymbol = k);
              !u.styledMode && z && "inactive" !== this.state && z.attr(d.pointAttribs(this, b));
            }
            z && (z[b && this.isInside ? "show" : "hide"](), z.element.point = this, z.addClass(this.getClassName(), !0));
          }
          f = f.halo;
          q = (z = this.graphic || z) && z.visibility || "inherit";
          f && f.size && z && "hidden" !== q && !this.isCluster ? (m || (d.halo = m = u.renderer.path().add(z.parentGroup)), m.show()[l ? "animate" : "attr"]({
            d: this.haloPath(f.size)
          }), m.attr({
            "class": "highcharts-halo highcharts-color-" + p(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: q,
            zIndex: -1
          }), m.point = this, u.styledMode || m.attr(c({
            fill: this.color || d.color,
            "fill-opacity": f.opacity
          }, a.filterUserAttributes(f.attributes || {})))) : m && m.point && m.point.haloPath && m.animate({
            d: m.point.haloPath(0)
          }, null, m.hide);
          n(this, "afterSetState", {
            state: b
          });
        }
      };
      v.prototype.haloPath = function (b) {
        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - b, this.plotY - b, 2 * b, 2 * b);
      };
      return v;
    }();
    "";
    return t;
  });
  N(a, "Core/Pointer.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Tooltip.js"], a["Core/Utilities.js"]], function (a, t, B, H) {
    var E = a.parse,
      F = t.charts,
      I = t.noop,
      x = H.addEvent,
      q = H.attr,
      m = H.css,
      h = H.defined,
      c = H.extend,
      n = H.find,
      z = H.fireEvent,
      g = H.isNumber,
      f = H.isObject,
      e = H.objectEach,
      G = H.offset,
      J = H.pick,
      M = H.splat;
    a = function () {
      function a(c, a) {
        this.lastValidTouch = {};
        this.pinchDown = [];
        this.runChartClick = !1;
        this.eventsToUnbind = [];
        this.chart = c;
        this.hasDragged = !1;
        this.options = a;
        this.init(c, a);
      }
      a.prototype.applyInactiveState = function (c) {
        var a = [],
          b;
        (c || []).forEach(function (c) {
          b = c.series;
          a.push(b);
          b.linkedParent && a.push(b.linkedParent);
          b.linkedSeries && (a = a.concat(b.linkedSeries));
          b.navigatorSeries && a.push(b.navigatorSeries);
        });
        this.chart.series.forEach(function (b) {
          -1 === a.indexOf(b) ? b.setState("inactive", !0) : b.options.inactiveOtherPoints && b.setAllPointsToState("inactive");
        });
      };
      a.prototype.destroy = function () {
        var c = this;
        this.eventsToUnbind.forEach(function (c) {
          return c();
        });
        this.eventsToUnbind = [];
        t.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
        clearInterval(c.tooltipTimeout);
        e(c, function (a, b) {
          c[b] = void 0;
        });
      };
      a.prototype.drag = function (c) {
        var a = this.chart,
          b = a.options.chart,
          e = this.zoomHor,
          d = this.zoomVert,
          l = a.plotLeft,
          g = a.plotTop,
          k = a.plotWidth,
          p = a.plotHeight,
          h = this.mouseDownX || 0,
          r = this.mouseDownY || 0,
          A = f(b.panning) ? b.panning && b.panning.enabled : b.panning,
          n = b.panKey && c[b.panKey + "Key"],
          m = c.chartX,
          u = c.chartY,
          q = this.selectionMarker;
        if (!q || !q.touch) if (m < l ? m = l : m > l + k && (m = l + k), u < g ? u = g : u > g + p && (u = g + p), this.hasDragged = Math.sqrt(Math.pow(h - m, 2) + Math.pow(r - u, 2)), 10 < this.hasDragged) {
          var z = a.isInsidePlot(h - l, r - g, {
            visiblePlotOnly: !0
          });
          !a.hasCartesianSeries && !a.mapView || !this.zoomX && !this.zoomY || !z || n || q || (this.selectionMarker = q = a.renderer.rect(l, g, e ? 1 : k, d ? 1 : p, 0).attr({
            "class": "highcharts-selection-marker",
            zIndex: 7
          }).add(), a.styledMode || q.attr({
            fill: b.selectionMarkerFill || E("#335cad").setOpacity(.25).get()
          }));
          q && e && (e = m - h, q.attr({
            width: Math.abs(e),
            x: (0 < e ? 0 : e) + h
          }));
          q && d && (e = u - r, q.attr({
            height: Math.abs(e),
            y: (0 < e ? 0 : e) + r
          }));
          z && !q && A && a.pan(c, b.panning);
        }
      };
      a.prototype.dragStart = function (c) {
        var a = this.chart;
        a.mouseIsDown = c.type;
        a.cancelClick = !1;
        a.mouseDownX = this.mouseDownX = c.chartX;
        a.mouseDownY = this.mouseDownY = c.chartY;
      };
      a.prototype.drop = function (a) {
        var e = this,
          b = this.chart,
          l = this.hasPinched;
        if (this.selectionMarker) {
          var d = this.selectionMarker,
            f = d.attr ? d.attr("x") : d.x,
            p = d.attr ? d.attr("y") : d.y,
            k = d.attr ? d.attr("width") : d.width,
            n = d.attr ? d.attr("height") : d.height,
            q = {
              originalEvent: a,
              xAxis: [],
              yAxis: [],
              x: f,
              y: p,
              width: k,
              height: n
            },
            r = !!b.mapView;
          if (this.hasDragged || l) b.axes.forEach(function (b) {
            if (b.zoomEnabled && h(b.min) && (l || e[{
              xAxis: "zoomX",
              yAxis: "zoomY"
            }[b.coll]]) && g(f) && g(p)) {
              var d = b.horiz,
                c = "touchend" === a.type ? b.minPixelPadding : 0,
                w = b.toValue((d ? f : p) + c);
              d = b.toValue((d ? f + k : p + n) - c);
              q[b.coll].push({
                axis: b,
                min: Math.min(w, d),
                max: Math.max(w, d)
              });
              r = !0;
            }
          }), r && z(b, "selection", q, function (d) {
            b.zoom(c(d, l ? {
              animation: !1
            } : null));
          });
          g(b.index) && (this.selectionMarker = this.selectionMarker.destroy());
          l && this.scaleGroups();
        }
        b && g(b.index) && (m(b.container, {
          cursor: b._cursor
        }), b.cancelClick = 10 < this.hasDragged, b.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
      };
      a.prototype.findNearestKDPoint = function (c, a, b) {
        var e = this.chart,
          d = e.hoverPoint;
        e = e.tooltip;
        if (d && e && e.isStickyOnContact()) return d;
        var l;
        c.forEach(function (d) {
          var c = !(d.noSharedTooltip && a) && 0 > d.options.findNearestPointBy.indexOf("y");
          d = d.searchPoint(b, c);
          if ((c = f(d, !0) && d.series) && !(c = !f(l, !0))) {
            c = l.distX - d.distX;
            var e = l.dist - d.dist,
              g = (d.series.group && d.series.group.zIndex) - (l.series.group && l.series.group.zIndex);
            c = 0 < (0 !== c && a ? c : 0 !== e ? e : 0 !== g ? g : l.series.index > d.series.index ? -1 : 1);
          }
          c && (l = d);
        });
        return l;
      };
      a.prototype.getChartCoordinatesFromPoint = function (c, a) {
        var b = c.series,
          e = b.xAxis;
        b = b.yAxis;
        var d = c.shapeArgs;
        if (e && b) {
          var l = J(c.clientX, c.plotX),
            f = c.plotY || 0;
          c.isNode && d && g(d.x) && g(d.y) && (l = d.x, f = d.y);
          return a ? {
            chartX: b.len + b.pos - f,
            chartY: e.len + e.pos - l
          } : {
            chartX: l + e.pos,
            chartY: f + b.pos
          };
        }
        if (d && d.x && d.y) return {
          chartX: d.x,
          chartY: d.y
        };
      };
      a.prototype.getChartPosition = function () {
        if (this.chartPosition) return this.chartPosition;
        var c = this.chart.container,
          a = G(c);
        this.chartPosition = {
          left: a.left,
          top: a.top,
          scaleX: 1,
          scaleY: 1
        };
        var b = c.offsetWidth;
        c = c.offsetHeight;
        2 < b && 2 < c && (this.chartPosition.scaleX = a.width / b, this.chartPosition.scaleY = a.height / c);
        return this.chartPosition;
      };
      a.prototype.getCoordinates = function (c) {
        var a = {
          xAxis: [],
          yAxis: []
        };
        this.chart.axes.forEach(function (b) {
          a[b.isXAxis ? "xAxis" : "yAxis"].push({
            axis: b,
            value: b.toValue(c[b.horiz ? "chartX" : "chartY"])
          });
        });
        return a;
      };
      a.prototype.getHoverData = function (c, a, b, e, d, g) {
        var l = [];
        e = !(!e || !c);
        var k = {
          chartX: g ? g.chartX : void 0,
          chartY: g ? g.chartY : void 0,
          shared: d
        };
        z(this, "beforeGetHoverData", k);
        var p = a && !a.stickyTracking ? [a] : b.filter(function (b) {
          return k.filter ? k.filter(b) : b.visible && !(!d && b.directTouch) && J(b.options.enableMouseTracking, !0) && b.stickyTracking;
        });
        var h = e || !g ? c : this.findNearestKDPoint(p, d, g);
        a = h && h.series;
        h && (d && !a.noSharedTooltip ? (p = b.filter(function (b) {
          return k.filter ? k.filter(b) : b.visible && !(!d && b.directTouch) && J(b.options.enableMouseTracking, !0) && !b.noSharedTooltip;
        }), p.forEach(function (b) {
          var d = n(b.points, function (b) {
            return b.x === h.x && !b.isNull;
          });
          f(d) && (b.chart.isBoosting && (d = b.getPoint(d)), l.push(d));
        })) : l.push(h));
        k = {
          hoverPoint: h
        };
        z(this, "afterGetHoverData", k);
        return {
          hoverPoint: k.hoverPoint,
          hoverSeries: a,
          hoverPoints: l
        };
      };
      a.prototype.getPointFromEvent = function (c) {
        c = c.target;
        for (var a; c && !a;) a = c.point, c = c.parentNode;
        return a;
      };
      a.prototype.onTrackerMouseOut = function (c) {
        c = c.relatedTarget || c.toElement;
        var a = this.chart.hoverSeries;
        this.isDirectTouch = !1;
        if (!(!a || !c || a.stickyTracking || this.inClass(c, "highcharts-tooltip") || this.inClass(c, "highcharts-series-" + a.index) && this.inClass(c, "highcharts-tracker"))) a.onMouseOut();
      };
      a.prototype.inClass = function (c, a) {
        for (var b; c;) {
          if (b = q(c, "class")) {
            if (-1 !== b.indexOf(a)) return !0;
            if (-1 !== b.indexOf("highcharts-container")) return !1;
          }
          c = c.parentNode;
        }
      };
      a.prototype.init = function (c, a) {
        this.options = a;
        this.chart = c;
        this.runChartClick = !(!a.chart.events || !a.chart.events.click);
        this.pinchDown = [];
        this.lastValidTouch = {};
        B && (c.tooltip = new B(c, a.tooltip), this.followTouchMove = J(a.tooltip.followTouchMove, !0));
        this.setDOMEvents();
      };
      a.prototype.normalize = function (a, e) {
        var b = a.touches,
          f = b ? b.length ? b.item(0) : J(b.changedTouches, a.changedTouches)[0] : a;
        e || (e = this.getChartPosition());
        b = f.pageX - e.left;
        f = f.pageY - e.top;
        b /= e.scaleX;
        f /= e.scaleY;
        return c(a, {
          chartX: Math.round(b),
          chartY: Math.round(f)
        });
      };
      a.prototype.onContainerClick = function (a) {
        var e = this.chart,
          b = e.hoverPoint;
        a = this.normalize(a);
        var f = e.plotLeft,
          d = e.plotTop;
        e.cancelClick || (b && this.inClass(a.target, "highcharts-tracker") ? (z(b.series, "click", c(a, {
          point: b
        })), e.hoverPoint && b.firePointEvent("click", a)) : (c(a, this.getCoordinates(a)), e.isInsidePlot(a.chartX - f, a.chartY - d, {
          visiblePlotOnly: !0
        }) && z(e, "click", a)));
      };
      a.prototype.onContainerMouseDown = function (c) {
        var a = 1 === ((c.buttons || c.button) & 1);
        c = this.normalize(c);
        if (t.isFirefox && 0 !== c.button) this.onContainerMouseMove(c);
        if ("undefined" === typeof c.button || a) this.zoomOption(c), a && c.preventDefault && c.preventDefault(), this.dragStart(c);
      };
      a.prototype.onContainerMouseLeave = function (c) {
        var e = F[J(a.hoverChartIndex, -1)],
          b = this.chart.tooltip;
        b && b.shouldStickOnContact() && this.inClass(c.relatedTarget, "highcharts-tooltip-container") || (c = this.normalize(c), e && (c.relatedTarget || c.toElement) && (e.pointer.reset(), e.pointer.chartPosition = void 0), b && !b.isHidden && this.reset());
      };
      a.prototype.onContainerMouseEnter = function (c) {
        delete this.chartPosition;
      };
      a.prototype.onContainerMouseMove = function (c) {
        var a = this.chart;
        c = this.normalize(c);
        this.setHoverChartIndex();
        c.preventDefault || (c.returnValue = !1);
        ("mousedown" === a.mouseIsDown || this.touchSelect(c)) && this.drag(c);
        a.openMenu || !this.inClass(c.target, "highcharts-tracker") && !a.isInsidePlot(c.chartX - a.plotLeft, c.chartY - a.plotTop, {
          visiblePlotOnly: !0
        }) || (this.inClass(c.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(c));
      };
      a.prototype.onDocumentTouchEnd = function (c) {
        var e = F[J(a.hoverChartIndex, -1)];
        e && e.pointer.drop(c);
      };
      a.prototype.onContainerTouchMove = function (c) {
        if (this.touchSelect(c)) this.onContainerMouseMove(c);else this.touch(c);
      };
      a.prototype.onContainerTouchStart = function (c) {
        if (this.touchSelect(c)) this.onContainerMouseDown(c);else this.zoomOption(c), this.touch(c, !0);
      };
      a.prototype.onDocumentMouseMove = function (c) {
        var a = this.chart,
          b = this.chartPosition;
        c = this.normalize(c, b);
        var e = a.tooltip;
        !b || e && e.isStickyOnContact() || a.isInsidePlot(c.chartX - a.plotLeft, c.chartY - a.plotTop, {
          visiblePlotOnly: !0
        }) || this.inClass(c.target, "highcharts-tracker") || this.reset();
      };
      a.prototype.onDocumentMouseUp = function (c) {
        var e = F[J(a.hoverChartIndex, -1)];
        e && e.pointer.drop(c);
      };
      a.prototype.pinch = function (a) {
        var e = this,
          b = e.chart,
          f = e.pinchDown,
          d = a.touches || [],
          g = d.length,
          l = e.lastValidTouch,
          k = e.hasZoom,
          p = {},
          h = 1 === g && (e.inClass(a.target, "highcharts-tracker") && b.runTrackerClick || e.runChartClick),
          r = {},
          A = e.selectionMarker;
        1 < g ? e.initiated = !0 : 1 === g && this.followTouchMove && (e.initiated = !1);
        k && e.initiated && !h && !1 !== a.cancelable && a.preventDefault();
        [].map.call(d, function (b) {
          return e.normalize(b);
        });
        "touchstart" === a.type ? ([].forEach.call(d, function (b, d) {
          f[d] = {
            chartX: b.chartX,
            chartY: b.chartY
          };
        }), l.x = [f[0].chartX, f[1] && f[1].chartX], l.y = [f[0].chartY, f[1] && f[1].chartY], b.axes.forEach(function (d) {
          if (d.zoomEnabled) {
            var c = b.bounds[d.horiz ? "h" : "v"],
              a = d.minPixelPadding,
              e = d.toPixels(Math.min(J(d.options.min, d.dataMin), d.dataMin)),
              k = d.toPixels(Math.max(J(d.options.max, d.dataMax), d.dataMax)),
              f = Math.max(e, k);
            c.min = Math.min(d.pos, Math.min(e, k) - a);
            c.max = Math.max(d.pos + d.len, f + a);
          }
        }), e.res = !0) : e.followTouchMove && 1 === g ? this.runPointActions(e.normalize(a)) : f.length && (z(b, "touchpan", {
          originalEvent: a
        }, function () {
          A || (e.selectionMarker = A = c({
            destroy: I,
            touch: !0
          }, b.plotBox));
          e.pinchTranslate(f, d, p, A, r, l);
          e.hasPinched = k;
          e.scaleGroups(p, r);
        }), e.res && (e.res = !1, this.reset(!1, 0)));
      };
      a.prototype.pinchTranslate = function (c, a, b, e, d, f) {
        this.zoomHor && this.pinchTranslateDirection(!0, c, a, b, e, d, f);
        this.zoomVert && this.pinchTranslateDirection(!1, c, a, b, e, d, f);
      };
      a.prototype.pinchTranslateDirection = function (c, a, b, e, d, f, g, k) {
        var l = this.chart,
          p = c ? "x" : "y",
          r = c ? "X" : "Y",
          h = "chart" + r,
          v = c ? "width" : "height",
          n = l["plot" + (c ? "Left" : "Top")],
          u = l.inverted,
          w = l.bounds[c ? "h" : "v"],
          m = 1 === a.length,
          q = a[0][h],
          D = !m && a[1][h];
        a = function () {
          "number" === typeof J && 20 < Math.abs(q - D) && (z = k || Math.abs(G - J) / Math.abs(q - D));
          Q = (n - G) / z + q;
          C = l["plot" + (c ? "Width" : "Height")] / z;
        };
        var C,
          Q,
          z = k || 1,
          G = b[0][h],
          J = !m && b[1][h];
        a();
        b = Q;
        if (b < w.min) {
          b = w.min;
          var M = !0;
        } else b + C > w.max && (b = w.max - C, M = !0);
        M ? (G -= .8 * (G - g[p][0]), "number" === typeof J && (J -= .8 * (J - g[p][1])), a()) : g[p] = [G, J];
        u || (f[p] = Q - n, f[v] = C);
        f = u ? 1 / z : z;
        d[v] = C;
        d[p] = b;
        e[u ? c ? "scaleY" : "scaleX" : "scale" + r] = z;
        e["translate" + r] = f * n + (G - f * q);
      };
      a.prototype.reset = function (c, a) {
        var b = this.chart,
          e = b.hoverSeries,
          d = b.hoverPoint,
          f = b.hoverPoints,
          g = b.tooltip,
          k = g && g.shared ? f : d;
        c && k && M(k).forEach(function (b) {
          b.series.isCartesian && "undefined" === typeof b.plotX && (c = !1);
        });
        if (c) g && k && M(k).length && (g.refresh(k), g.shared && f ? f.forEach(function (b) {
          b.setState(b.state, !0);
          b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));
        }) : d && (d.setState(d.state, !0), b.axes.forEach(function (b) {
          b.crosshair && d.series[b.coll] === b && b.drawCrosshair(null, d);
        })));else {
          if (d) d.onMouseOut();
          f && f.forEach(function (b) {
            b.setState();
          });
          if (e) e.onMouseOut();
          g && g.hide(a);
          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
          b.axes.forEach(function (b) {
            b.hideCrosshair();
          });
          this.hoverX = b.hoverPoints = b.hoverPoint = null;
        }
      };
      a.prototype.runPointActions = function (c, e) {
        var b = this.chart,
          f = b.tooltip && b.tooltip.options.enabled ? b.tooltip : void 0,
          d = f ? f.shared : !1,
          g = e || b.hoverPoint,
          l = g && g.series || b.hoverSeries;
        e = this.getHoverData(g, l, b.series, (!c || "touchmove" !== c.type) && (!!e || l && l.directTouch && this.isDirectTouch), d, c);
        g = e.hoverPoint;
        l = e.hoverSeries;
        var k = e.hoverPoints;
        e = l && l.tooltipOptions.followPointer && !l.tooltipOptions.split;
        d = d && l && !l.noSharedTooltip;
        if (g && (g !== b.hoverPoint || f && f.isHidden)) {
          (b.hoverPoints || []).forEach(function (b) {
            -1 === k.indexOf(b) && b.setState();
          });
          if (b.hoverSeries !== l) l.onMouseOver();
          this.applyInactiveState(k);
          (k || []).forEach(function (b) {
            b.setState("hover");
          });
          b.hoverPoint && b.hoverPoint.firePointEvent("mouseOut");
          if (!g.series) return;
          b.hoverPoints = k;
          b.hoverPoint = g;
          g.firePointEvent("mouseOver");
          f && f.refresh(d ? k : g, c);
        } else e && f && !f.isHidden && (g = f.getAnchor([{}], c), b.isInsidePlot(g[0], g[1], {
          visiblePlotOnly: !0
        }) && f.updatePosition({
          plotX: g[0],
          plotY: g[1]
        }));
        this.unDocMouseMove || (this.unDocMouseMove = x(b.container.ownerDocument, "mousemove", function (b) {
          var d = F[a.hoverChartIndex];
          if (d) d.pointer.onDocumentMouseMove(b);
        }), this.eventsToUnbind.push(this.unDocMouseMove));
        b.axes.forEach(function (d) {
          var a = J((d.crosshair || {}).snap, !0),
            e;
          a && ((e = b.hoverPoint) && e.series[d.coll] === d || (e = n(k, function (b) {
            return b.series[d.coll] === d;
          })));
          e || !a ? d.drawCrosshair(c, e) : d.hideCrosshair();
        });
      };
      a.prototype.scaleGroups = function (c, a) {
        var b = this.chart;
        b.series.forEach(function (e) {
          var d = c || e.getPlotBox();
          e.group && (e.xAxis && e.xAxis.zoomEnabled || b.mapView) && (e.group.attr(d), e.markerGroup && (e.markerGroup.attr(d), e.markerGroup.clip(a ? b.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(d));
        });
        b.clipRect.attr(a || b.clipBox);
      };
      a.prototype.setDOMEvents = function () {
        var c = this,
          e = this.chart.container,
          b = e.ownerDocument;
        e.onmousedown = this.onContainerMouseDown.bind(this);
        e.onmousemove = this.onContainerMouseMove.bind(this);
        e.onclick = this.onContainerClick.bind(this);
        this.eventsToUnbind.push(x(e, "mouseenter", this.onContainerMouseEnter.bind(this)));
        this.eventsToUnbind.push(x(e, "mouseleave", this.onContainerMouseLeave.bind(this)));
        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = x(b, "mouseup", this.onDocumentMouseUp.bind(this)));
        for (var f = this.chart.renderTo.parentElement; f && "BODY" !== f.tagName;) this.eventsToUnbind.push(x(f, "scroll", function () {
          delete c.chartPosition;
        })), f = f.parentElement;
        t.hasTouch && (this.eventsToUnbind.push(x(e, "touchstart", this.onContainerTouchStart.bind(this), {
          passive: !1
        })), this.eventsToUnbind.push(x(e, "touchmove", this.onContainerTouchMove.bind(this), {
          passive: !1
        })), a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = x(b, "touchend", this.onDocumentTouchEnd.bind(this), {
          passive: !1
        })));
      };
      a.prototype.setHoverChartIndex = function () {
        var c = this.chart,
          e = t.charts[J(a.hoverChartIndex, -1)];
        if (e && e !== c) e.pointer.onContainerMouseLeave({
          relatedTarget: !0
        });
        e && e.mouseIsDown || (a.hoverChartIndex = c.index);
      };
      a.prototype.touch = function (c, a) {
        var b = this.chart,
          e;
        this.setHoverChartIndex();
        if (1 === c.touches.length) {
          if (c = this.normalize(c), (e = b.isInsidePlot(c.chartX - b.plotLeft, c.chartY - b.plotTop, {
            visiblePlotOnly: !0
          })) && !b.openMenu) {
            a && this.runPointActions(c);
            if ("touchmove" === c.type) {
              a = this.pinchDown;
              var d = a[0] ? 4 <= Math.sqrt(Math.pow(a[0].chartX - c.chartX, 2) + Math.pow(a[0].chartY - c.chartY, 2)) : !1;
            }
            J(d, !0) && this.pinch(c);
          } else a && this.reset();
        } else 2 === c.touches.length && this.pinch(c);
      };
      a.prototype.touchSelect = function (c) {
        return !(!this.chart.options.chart.zoomBySingleTouch || !c.touches || 1 !== c.touches.length);
      };
      a.prototype.zoomOption = function (c) {
        var a = this.chart,
          b = a.options.chart;
        a = a.inverted;
        var e = b.zoomType || "";
        /touch/.test(c.type) && (e = J(b.pinchType, e));
        this.zoomX = c = /x/.test(e);
        this.zoomY = b = /y/.test(e);
        this.zoomHor = c && !a || b && a;
        this.zoomVert = b && !a || c && a;
        this.hasZoom = c || b;
      };
      return a;
    }();
    "";
    return a;
  });
  N(a, "Core/MSPointer.js", [a["Core/Globals.js"], a["Core/Pointer.js"], a["Core/Utilities.js"]], function (a, t, B) {
    function E() {
      var c = [];
      c.item = function (c) {
        return this[c];
      };
      n(g, function (a) {
        c.push({
          pageX: a.pageX,
          pageY: a.pageY,
          target: a.target
        });
      });
      return c;
    }
    function y(c, a, f, g) {
      var e = I[t.hoverChartIndex || NaN];
      "touch" !== c.pointerType && c.pointerType !== c.MSPOINTER_TYPE_TOUCH || !e || (e = e.pointer, g(c), e[a]({
        type: f,
        target: c.currentTarget,
        preventDefault: q,
        touches: E()
      }));
    }
    var F = this && this.__extends || function () {
        var c = function (a, e) {
          c = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (c, a) {
            c.__proto__ = a;
          } || function (c, a) {
            for (var e in a) a.hasOwnProperty(e) && (c[e] = a[e]);
          };
          return c(a, e);
        };
        return function (a, e) {
          function f() {
            this.constructor = a;
          }
          c(a, e);
          a.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
        };
      }(),
      I = a.charts,
      x = a.doc,
      q = a.noop,
      m = a.win,
      h = B.addEvent,
      c = B.css,
      n = B.objectEach,
      z = B.removeEvent,
      g = {},
      f = !!m.PointerEvent;
    return function (e) {
      function n() {
        return null !== e && e.apply(this, arguments) || this;
      }
      F(n, e);
      n.isRequired = function () {
        return !(a.hasTouch || !m.PointerEvent && !m.MSPointerEvent);
      };
      n.prototype.batchMSEvents = function (c) {
        c(this.chart.container, f ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
        c(this.chart.container, f ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
        c(x, f ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
      };
      n.prototype.destroy = function () {
        this.batchMSEvents(z);
        e.prototype.destroy.call(this);
      };
      n.prototype.init = function (a, f) {
        e.prototype.init.call(this, a, f);
        this.hasZoom && c(a.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      };
      n.prototype.onContainerPointerDown = function (c) {
        y(c, "onContainerTouchStart", "touchstart", function (c) {
          g[c.pointerId] = {
            pageX: c.pageX,
            pageY: c.pageY,
            target: c.currentTarget
          };
        });
      };
      n.prototype.onContainerPointerMove = function (c) {
        y(c, "onContainerTouchMove", "touchmove", function (c) {
          g[c.pointerId] = {
            pageX: c.pageX,
            pageY: c.pageY
          };
          g[c.pointerId].target || (g[c.pointerId].target = c.currentTarget);
        });
      };
      n.prototype.onDocumentPointerUp = function (c) {
        y(c, "onDocumentTouchEnd", "touchend", function (c) {
          delete g[c.pointerId];
        });
      };
      n.prototype.setDOMEvents = function () {
        e.prototype.setDOMEvents.call(this);
        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(h);
      };
      return n;
    }(t);
  });
  N(a, "Core/Legend/Legend.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Series/Point.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F) {
    var E = a.animObject,
      x = a.setAnimation,
      q = t.format;
    a = B.isFirefox;
    var m = B.marginNames;
    B = B.win;
    var h = y.distribute,
      c = F.addEvent,
      n = F.createElement,
      z = F.css,
      g = F.defined,
      f = F.discardElement,
      e = F.find,
      G = F.fireEvent,
      J = F.isNumber,
      M = F.merge,
      p = F.pick,
      l = F.relativeLength,
      w = F.stableSort,
      b = F.syncTimeout;
    y = F.wrap;
    F = function () {
      function a(b, c) {
        this.allItems = [];
        this.contentGroup = this.box = void 0;
        this.display = !1;
        this.group = void 0;
        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
        this.options = {};
        this.padding = 0;
        this.pages = [];
        this.proximate = !1;
        this.scrollGroup = void 0;
        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
        this.chart = b;
        this.init(b, c);
      }
      a.prototype.init = function (b, a) {
        this.chart = b;
        this.setOptions(a);
        a.enabled && (this.render(), c(this.chart, "endResize", function () {
          this.legend.positionCheckboxes();
        }), this.proximate ? this.unchartrender = c(this.chart, "render", function () {
          this.legend.proximatePositions();
          this.legend.positionItems();
        }) : this.unchartrender && this.unchartrender());
      };
      a.prototype.setOptions = function (b) {
        var c = p(b.padding, 8);
        this.options = b;
        this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = M(this.itemStyle, b.itemHiddenStyle));
        this.itemMarginTop = b.itemMarginTop || 0;
        this.itemMarginBottom = b.itemMarginBottom || 0;
        this.padding = c;
        this.initialItemY = c - 5;
        this.symbolWidth = p(b.symbolWidth, 16);
        this.pages = [];
        this.proximate = "proximate" === b.layout && !this.chart.inverted;
        this.baseline = void 0;
      };
      a.prototype.update = function (b, c) {
        var d = this.chart;
        this.setOptions(M(!0, this.options, b));
        this.destroy();
        d.isDirtyLegend = d.isDirtyBox = !0;
        p(c, !0) && d.redraw();
        G(this, "afterUpdate");
      };
      a.prototype.colorizeItem = function (b, c) {
        b.legendGroup[c ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
        if (!this.chart.styledMode) {
          var d = this.options,
            a = b.legendItem,
            e = b.legendLine,
            f = b.legendSymbol,
            r = this.itemHiddenStyle.color;
          d = c ? d.itemStyle.color : r;
          var g = c ? b.color || r : r,
            l = b.options && b.options.marker,
            p = {
              fill: g
            };
          a && a.css({
            fill: d,
            color: d
          });
          e && e.attr({
            stroke: g
          });
          f && (l && f.isMarker && (p = b.pointAttribs(), c || (p.stroke = p.fill = r)), f.attr(p));
        }
        G(this, "afterColorizeItem", {
          item: b,
          visible: c
        });
      };
      a.prototype.positionItems = function () {
        this.allItems.forEach(this.positionItem, this);
        this.chart.isResizing || this.positionCheckboxes();
      };
      a.prototype.positionItem = function (b) {
        var c = this,
          d = this.options,
          a = d.symbolPadding,
          e = !d.rtl,
          f = b._legendItemPos;
        d = f[0];
        f = f[1];
        var r = b.checkbox,
          l = b.legendGroup;
        l && l.element && (a = {
          translateX: e ? d : this.legendWidth - d - 2 * a - 4,
          translateY: f
        }, e = function () {
          G(c, "afterPositionItem", {
            item: b
          });
        }, g(l.translateY) ? l.animate(a, void 0, e) : (l.attr(a), e()));
        r && (r.x = d, r.y = f);
      };
      a.prototype.destroyItem = function (b) {
        var c = b.checkbox;
        ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (c) {
          b[c] && (b[c] = b[c].destroy());
        });
        c && f(b.checkbox);
      };
      a.prototype.destroy = function () {
        function b(b) {
          this[b] && (this[b] = this[b].destroy());
        }
        this.getAllItems().forEach(function (c) {
          ["legendItem", "legendGroup"].forEach(b, c);
        });
        "clipRect up down pager nav box title group".split(" ").forEach(b, this);
        this.display = null;
      };
      a.prototype.positionCheckboxes = function () {
        var b = this.group && this.group.alignAttr,
          c = this.clipHeight || this.legendHeight,
          a = this.titleHeight;
        if (b) {
          var e = b.translateY;
          this.allItems.forEach(function (d) {
            var k = d.checkbox;
            if (k) {
              var f = e + a + k.y + (this.scrollOffset || 0) + 3;
              z(k, {
                left: b.translateX + d.checkboxOffset + k.x - 20 + "px",
                top: f + "px",
                display: this.proximate || f > e - 6 && f < e + c - 6 ? "" : "none"
              });
            }
          }, this);
        }
      };
      a.prototype.renderTitle = function () {
        var b = this.options,
          c = this.padding,
          a = b.title,
          e = 0;
        a.text && (this.title || (this.title = this.chart.renderer.label(a.text, c - 3, c - 4, null, null, null, b.useHTML, null, "legend-title").attr({
          zIndex: 1
        }), this.chart.styledMode || this.title.css(a.style), this.title.add(this.group)), a.width || this.title.css({
          width: this.maxLegendWidth + "px"
        }), b = this.title.getBBox(), e = b.height, this.offsetWidth = b.width, this.contentGroup.attr({
          translateY: e
        }));
        this.titleHeight = e;
      };
      a.prototype.setText = function (b) {
        var c = this.options;
        b.legendItem.attr({
          text: c.labelFormat ? q(c.labelFormat, b, this.chart) : c.labelFormatter.call(b)
        });
      };
      a.prototype.renderItem = function (b) {
        var c = this.chart,
          d = c.renderer,
          a = this.options,
          e = this.symbolWidth,
          f = a.symbolPadding || 0,
          r = this.itemStyle,
          g = this.itemHiddenStyle,
          l = "horizontal" === a.layout ? p(a.itemDistance, 20) : 0,
          h = !a.rtl,
          u = !b.series,
          n = !u && b.series.drawLegendSymbol ? b.series : b,
          v = n.options,
          w = this.createCheckboxForItem && v && v.showCheckbox,
          m = a.useHTML,
          q = b.options.className,
          Q = b.legendItem;
        v = e + f + l + (w ? 20 : 0);
        Q || (b.legendGroup = d.g("legend-item").addClass("highcharts-" + n.type + "-series highcharts-color-" + b.colorIndex + (q ? " " + q : "") + (u ? " highcharts-series-" + b.index : "")).attr({
          zIndex: 1
        }).add(this.scrollGroup), b.legendItem = Q = d.text("", h ? e + f : -f, this.baseline || 0, m), c.styledMode || Q.css(M(b.visible ? r : g)), Q.attr({
          align: h ? "left" : "right",
          zIndex: 2
        }).add(b.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(c.styledMode ? 12 : r.fontSize, Q), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, Q.attr("y", this.baseline), this.symbolHeight = a.symbolHeight || this.fontMetrics.f, a.squareSymbol && (this.symbolWidth = p(a.symbolWidth, Math.max(this.symbolHeight, 16)), v = this.symbolWidth + f + l + (w ? 20 : 0), h && Q.attr("x", this.symbolWidth + f))), n.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, Q, m));
        w && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);
        this.colorizeItem(b, b.visible);
        !c.styledMode && r.width || Q.css({
          width: (a.itemWidth || this.widthOption || c.spacingBox.width) - v + "px"
        });
        this.setText(b);
        c = Q.getBBox();
        d = this.fontMetrics && this.fontMetrics.h || 0;
        b.itemWidth = b.checkboxOffset = a.itemWidth || b.legendItemWidth || c.width + v;
        this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);
        this.totalItemWidth += b.itemWidth;
        this.itemHeight = b.itemHeight = Math.round(b.legendItemHeight || (c.height > 1.5 * d ? c.height : d));
      };
      a.prototype.layoutItem = function (b) {
        var c = this.options,
          d = this.padding,
          a = "horizontal" === c.layout,
          e = b.itemHeight,
          f = this.itemMarginBottom,
          r = this.itemMarginTop,
          g = a ? p(c.itemDistance, 20) : 0,
          l = this.maxLegendWidth;
        c = c.alignColumns && this.totalItemWidth > l ? this.maxItemWidth : b.itemWidth;
        a && this.itemX - d + c > l && (this.itemX = d, this.lastLineHeight && (this.itemY += r + this.lastLineHeight + f), this.lastLineHeight = 0);
        this.lastItemY = r + this.itemY + f;
        this.lastLineHeight = Math.max(e, this.lastLineHeight);
        b._legendItemPos = [this.itemX, this.itemY];
        a ? this.itemX += c : (this.itemY += r + e + f, this.lastLineHeight = e);
        this.offsetWidth = this.widthOption || Math.max((a ? this.itemX - d - (b.checkbox ? 0 : g) : c) + d, this.offsetWidth);
      };
      a.prototype.getAllItems = function () {
        var b = [];
        this.chart.series.forEach(function (c) {
          var d = c && c.options;
          c && p(d.showInLegend, g(d.linkedTo) ? !1 : void 0, !0) && (b = b.concat(c.legendItems || ("point" === d.legendType ? c.data : c)));
        });
        G(this, "afterGetAllItems", {
          allItems: b
        });
        return b;
      };
      a.prototype.getAlignment = function () {
        var b = this.options;
        return this.proximate ? b.align.charAt(0) + "tv" : b.floating ? "" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);
      };
      a.prototype.adjustMargins = function (b, c) {
        var a = this.chart,
          d = this.options,
          e = this.getAlignment();
        e && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (k, f) {
          k.test(e) && !g(b[f]) && (a[m[f]] = Math.max(a[m[f]], a.legend[(f + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][f] * d[f % 2 ? "x" : "y"] + p(d.margin, 12) + c[f] + (a.titleOffset[f] || 0)));
        });
      };
      a.prototype.proximatePositions = function () {
        var b = this.chart,
          c = [],
          a = "left" === this.options.align;
        this.allItems.forEach(function (d) {
          var k;
          var f = a;
          if (d.yAxis) {
            d.xAxis.options.reversed && (f = !f);
            d.points && (k = e(f ? d.points : d.points.slice(0).reverse(), function (b) {
              return J(b.plotY);
            }));
            f = this.itemMarginTop + d.legendItem.getBBox().height + this.itemMarginBottom;
            var g = d.yAxis.top - b.plotTop;
            d.visible ? (k = k ? k.plotY : d.yAxis.height, k += g - .3 * f) : k = g + d.yAxis.height;
            c.push({
              target: k,
              size: f,
              item: d
            });
          }
        }, this);
        h(c, b.plotHeight).forEach(function (c) {
          c.item._legendItemPos && (c.item._legendItemPos[1] = b.plotTop - b.spacing[0] + c.pos);
        });
      };
      a.prototype.render = function () {
        var b = this.chart,
          c = b.renderer,
          a = this.options,
          e = this.padding,
          f = this.getAllItems(),
          g = this.group,
          r = this.box;
        this.itemX = e;
        this.itemY = this.initialItemY;
        this.lastItemY = this.offsetWidth = 0;
        this.widthOption = l(a.width, b.spacingBox.width - e);
        var p = b.spacingBox.width - 2 * e - a.x;
        -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (p /= 2);
        this.maxLegendWidth = this.widthOption || p;
        g || (this.group = g = c.g("legend").addClass(a.className || "").attr({
          zIndex: 7
        }).add(), this.contentGroup = c.g().attr({
          zIndex: 1
        }).add(g), this.scrollGroup = c.g().add(this.contentGroup));
        this.renderTitle();
        w(f, function (b, c) {
          return (b.options && b.options.legendIndex || 0) - (c.options && c.options.legendIndex || 0);
        });
        a.reversed && f.reverse();
        this.allItems = f;
        this.display = p = !!f.length;
        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
        f.forEach(this.renderItem, this);
        f.forEach(this.layoutItem, this);
        f = (this.widthOption || this.offsetWidth) + e;
        var h = this.lastItemY + this.lastLineHeight + this.titleHeight;
        h = this.handleOverflow(h);
        h += e;
        r || (this.box = r = c.rect().addClass("highcharts-legend-box").attr({
          r: a.borderRadius
        }).add(g), r.isNew = !0);
        b.styledMode || r.attr({
          stroke: a.borderColor,
          "stroke-width": a.borderWidth || 0,
          fill: a.backgroundColor || "none"
        }).shadow(a.shadow);
        0 < f && 0 < h && (r[r.isNew ? "attr" : "animate"](r.crisp.call({}, {
          x: 0,
          y: 0,
          width: f,
          height: h
        }, r.strokeWidth())), r.isNew = !1);
        r[p ? "show" : "hide"]();
        b.styledMode && "none" === g.getStyle("display") && (f = h = 0);
        this.legendWidth = f;
        this.legendHeight = h;
        p && this.align();
        this.proximate || this.positionItems();
        G(this, "afterRender");
      };
      a.prototype.align = function (b) {
        void 0 === b && (b = this.chart.spacingBox);
        var c = this.chart,
          a = this.options,
          d = b.y;
        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < c.titleOffset[0] ? d += c.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < c.titleOffset[2] && (d -= c.titleOffset[2]);
        d !== b.y && (b = M(b, {
          y: d
        }));
        this.group.align(M(a, {
          width: this.legendWidth,
          height: this.legendHeight,
          verticalAlign: this.proximate ? "top" : a.verticalAlign
        }), !0, b);
      };
      a.prototype.handleOverflow = function (b) {
        var c = this,
          a = this.chart,
          d = a.renderer,
          e = this.options,
          f = e.y,
          g = "top" === e.verticalAlign,
          l = this.padding,
          h = e.maxHeight,
          n = e.navigation,
          u = p(n.animation, !0),
          v = n.arrowSize || 12,
          w = this.pages,
          m = this.allItems,
          q = function (b) {
            "number" === typeof b ? M.attr({
              height: b
            }) : M && (c.clipRect = M.destroy(), c.contentGroup.clip());
            c.contentGroup.div && (c.contentGroup.div.style.clip = b ? "rect(" + l + "px,9999px," + (l + b) + "px,0)" : "auto");
          },
          z = function (b) {
            c[b] = d.circle(0, 0, 1.3 * v).translate(v / 2, v / 2).add(J);
            a.styledMode || c[b].attr("fill", "rgba(0,0,0,0.0001)");
            return c[b];
          },
          Q,
          G;
        f = a.spacingBox.height + (g ? -f : f) - l;
        var J = this.nav,
          M = this.clipRect;
        "horizontal" !== e.layout || "middle" === e.verticalAlign || e.floating || (f /= 2);
        h && (f = Math.min(f, h));
        w.length = 0;
        b && 0 < f && b > f && !1 !== n.enabled ? (this.clipHeight = Q = Math.max(f - 20 - this.titleHeight - l, 0), this.currentPage = p(this.currentPage, 1), this.fullHeight = b, m.forEach(function (b, c) {
          var a = b._legendItemPos[1],
            d = Math.round(b.legendItem.getBBox().height),
            e = w.length;
          if (!e || a - w[e - 1] > Q && (G || a) !== w[e - 1]) w.push(G || a), e++;
          b.pageIx = e - 1;
          G && (m[c - 1].pageIx = e - 1);
          c === m.length - 1 && a + d - w[e - 1] > Q && d <= Q && (w.push(a), b.pageIx = e);
          a !== G && (G = a);
        }), M || (M = c.clipRect = d.clipRect(0, l, 9999, 0), c.contentGroup.clip(M)), q(Q), J || (this.nav = J = d.g().attr({
          zIndex: 1
        }).add(this.group), this.up = d.symbol("triangle", 0, 0, v, v).add(J), z("upTracker").on("click", function () {
          c.scroll(-1, u);
        }), this.pager = d.text("", 15, 10).addClass("highcharts-legend-navigation"), a.styledMode || this.pager.css(n.style), this.pager.add(J), this.down = d.symbol("triangle-down", 0, 0, v, v).add(J), z("downTracker").on("click", function () {
          c.scroll(1, u);
        })), c.scroll(0), b = f) : J && (q(), this.nav = J.destroy(), this.scrollGroup.attr({
          translateY: 1
        }), this.clipHeight = 0);
        return b;
      };
      a.prototype.scroll = function (c, a) {
        var d = this,
          e = this.chart,
          f = this.pages,
          g = f.length,
          r = this.clipHeight,
          l = this.options.navigation,
          h = this.pager,
          n = this.padding,
          u = this.currentPage + c;
        u > g && (u = g);
        0 < u && ("undefined" !== typeof a && x(a, e), this.nav.attr({
          translateX: n,
          translateY: r + this.padding + 7 + this.titleHeight,
          visibility: "visible"
        }), [this.up, this.upTracker].forEach(function (b) {
          b.attr({
            "class": 1 === u ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }), h.attr({
          text: u + "/" + g
        }), [this.down, this.downTracker].forEach(function (b) {
          b.attr({
            x: 18 + this.pager.getBBox().width,
            "class": u === g ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }, this), e.styledMode || (this.up.attr({
          fill: 1 === u ? l.inactiveColor : l.activeColor
        }), this.upTracker.css({
          cursor: 1 === u ? "default" : "pointer"
        }), this.down.attr({
          fill: u === g ? l.inactiveColor : l.activeColor
        }), this.downTracker.css({
          cursor: u === g ? "default" : "pointer"
        })), this.scrollOffset = -f[u - 1] + this.initialItemY, this.scrollGroup.animate({
          translateY: this.scrollOffset
        }), this.currentPage = u, this.positionCheckboxes(), c = E(p(a, e.renderer.globalAnimation, !0)), b(function () {
          G(d, "afterScroll", {
            currentPage: u
          });
        }, c.duration));
      };
      a.prototype.setItemEvents = function (b, c, a) {
        var d = this,
          e = d.chart.renderer.boxWrapper,
          f = b instanceof H,
          g = "highcharts-legend-" + (f ? "point" : "series") + "-active",
          l = d.chart.styledMode,
          h = function (c) {
            d.allItems.forEach(function (a) {
              b !== a && [a].concat(a.linkedSeries || []).forEach(function (b) {
                b.setState(c, !f);
              });
            });
          };
        (a ? [c, b.legendSymbol] : [b.legendGroup]).forEach(function (a) {
          if (a) a.on("mouseover", function () {
            b.visible && h("inactive");
            b.setState("hover");
            b.visible && e.addClass(g);
            l || c.css(d.options.itemHoverStyle);
          }).on("mouseout", function () {
            d.chart.styledMode || c.css(M(b.visible ? d.itemStyle : d.itemHiddenStyle));
            h("");
            e.removeClass(g);
            b.setState();
          }).on("click", function (c) {
            var a = function () {
              b.setVisible && b.setVisible();
              h(b.visible ? "inactive" : "");
            };
            e.removeClass(g);
            c = {
              browserEvent: c
            };
            b.firePointEvent ? b.firePointEvent("legendItemClick", c, a) : G(b, "legendItemClick", c, a);
          });
        });
      };
      a.prototype.createCheckboxForItem = function (b) {
        b.checkbox = n("input", {
          type: "checkbox",
          className: "highcharts-legend-checkbox",
          checked: b.selected,
          defaultChecked: b.selected
        }, this.options.itemCheckboxStyle, this.chart.container);
        c(b.checkbox, "click", function (c) {
          G(b.series || b, "checkboxClick", {
            checked: c.target.checked,
            item: b
          }, function () {
            b.select();
          });
        });
      };
      return a;
    }();
    (/Trident\/7\.0/.test(B.navigator && B.navigator.userAgent) || a) && y(F.prototype, "positionItem", function (b, c) {
      var a = this,
        d = function () {
          c._legendItemPos && b.call(a, c);
        };
      d();
      a.bubbleLegend || setTimeout(d);
    });
    "";
    return F;
  });
  N(a, "Core/Series/SeriesRegistry.js", [a["Core/Globals.js"], a["Core/DefaultOptions.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function (a, t, B, H) {
    var E = t.defaultOptions,
      F = H.error,
      I = H.extendClass,
      x = H.merge,
      q;
    (function (m) {
      function h(c, a) {
        var h = E.plotOptions || {},
          g = a.defaultOptions;
        a.prototype.pointClass || (a.prototype.pointClass = B);
        a.prototype.type = c;
        g && (h[c] = g);
        m.seriesTypes[c] = a;
      }
      m.seriesTypes = a.seriesTypes;
      m.getSeries = function (c, a) {
        void 0 === a && (a = {});
        var h = c.options.chart;
        h = a.type || h.type || h.defaultSeriesType || "";
        var g = m.seriesTypes[h];
        m || F(17, !0, c, {
          missingModuleFor: h
        });
        h = new g();
        "function" === typeof h.init && h.init(c, a);
        return h;
      };
      m.registerSeriesType = h;
      m.seriesType = function (c, a, q, g, f) {
        var e = E.plotOptions || {};
        a = a || "";
        e[c] = x(e[a], q);
        h(c, I(m.seriesTypes[a] || function () {}, g));
        m.seriesTypes[c].prototype.type = c;
        f && (m.seriesTypes[c].prototype.pointClass = I(B, f));
        return m.seriesTypes[c];
      };
    })(q || (q = {}));
    return q;
  });
  N(a, "Core/Chart/Chart.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/FormatUtilities.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Legend/Legend.js"], a["Core/MSPointer.js"], a["Core/DefaultOptions.js"], a["Core/Pointer.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Time.js"], a["Core/Utilities.js"], a["Core/Renderer/HTML/AST.js"]], function (a, t, B, H, y, F, I, x, q, m, h, c, n, z, g) {
    var f = a.animate,
      e = a.animObject,
      G = a.setAnimation,
      J = B.numberFormat,
      M = H.registerEventOptions,
      p = y.charts,
      l = y.doc,
      w = y.marginNames,
      b = y.svg,
      v = y.win,
      d = x.defaultOptions,
      D = x.defaultTime,
      C = h.seriesTypes,
      k = z.addEvent,
      K = z.attr,
      O = z.cleanRecursively,
      r = z.createElement,
      A = z.css,
      P = z.defined,
      E = z.discardElement,
      u = z.erase,
      L = z.error,
      aa = z.extend,
      da = z.find,
      R = z.fireEvent,
      ea = z.getStyle,
      Q = z.isArray,
      Y = z.isNumber,
      U = z.isObject,
      fa = z.isString,
      T = z.merge,
      W = z.objectEach,
      S = z.pick,
      ha = z.pInt,
      ba = z.relativeLength,
      N = z.removeEvent,
      Z = z.splat,
      ca = z.syncTimeout,
      ia = z.uniqueKey;
    a = function () {
      function a(b, c, a) {
        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
        this.sharedClips = {};
        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
        this.getArgs(b, c, a);
      }
      a.chart = function (b, c, d) {
        return new a(b, c, d);
      };
      a.prototype.getArgs = function (b, c, a) {
        fa(b) || b.nodeName ? (this.renderTo = b, this.init(c, a)) : this.init(b, c);
      };
      a.prototype.init = function (b, c) {
        var a = b.plotOptions || {};
        R(this, "init", {
          args: arguments
        }, function () {
          var e = T(d, b),
            k = e.chart;
          W(e.plotOptions, function (b, c) {
            U(b) && (b.tooltip = a[c] && T(a[c].tooltip) || void 0);
          });
          e.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
          this.userOptions = b;
          this.margin = [];
          this.spacing = [];
          this.bounds = {
            h: {},
            v: {}
          };
          this.labelCollectors = [];
          this.callback = c;
          this.isResizing = 0;
          this.options = e;
          this.axes = [];
          this.series = [];
          this.time = b.time && Object.keys(b.time).length ? new n(b.time) : y.time;
          this.numberFormatter = k.numberFormatter || J;
          this.styledMode = k.styledMode;
          this.hasCartesianSeries = k.showAxes;
          this.index = p.length;
          p.push(this);
          y.chartCount++;
          M(this, k);
          this.xAxis = [];
          this.yAxis = [];
          this.pointCount = this.colorCounter = this.symbolCounter = 0;
          R(this, "afterInit");
          this.firstRender();
        });
      };
      a.prototype.initSeries = function (b) {
        var c = this.options.chart;
        c = b.type || c.type || c.defaultSeriesType;
        var a = C[c];
        a || L(17, !0, this, {
          missingModuleFor: c
        });
        c = new a();
        "function" === typeof c.init && c.init(this, b);
        return c;
      };
      a.prototype.setSeriesData = function () {
        this.getSeriesOrderByLinks().forEach(function (b) {
          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
        });
      };
      a.prototype.getSeriesOrderByLinks = function () {
        return this.series.concat().sort(function (b, c) {
          return b.linkedSeries.length || c.linkedSeries.length ? c.linkedSeries.length - b.linkedSeries.length : 0;
        });
      };
      a.prototype.orderSeries = function (b) {
        var c = this.series;
        b = b || 0;
        for (var a = c.length; b < a; ++b) c[b] && (c[b].index = b, c[b].name = c[b].getName());
      };
      a.prototype.isInsidePlot = function (b, c, a) {
        void 0 === a && (a = {});
        var d = this.inverted,
          e = this.plotBox,
          k = this.plotLeft,
          f = this.plotTop,
          g = this.scrollablePlotBox,
          r = 0;
        var l = 0;
        a.visiblePlotOnly && this.scrollingContainer && (l = this.scrollingContainer, r = l.scrollLeft, l = l.scrollTop);
        var h = a.series;
        e = a.visiblePlotOnly && g || e;
        g = a.inverted ? c : b;
        c = a.inverted ? b : c;
        b = {
          x: g,
          y: c,
          isInsidePlot: !0
        };
        if (!a.ignoreX) {
          var p = h && (d ? h.yAxis : h.xAxis) || {
            pos: k,
            len: Infinity
          };
          g = a.paneCoordinates ? p.pos + g : k + g;
          g >= Math.max(r + k, p.pos) && g <= Math.min(r + k + e.width, p.pos + p.len) || (b.isInsidePlot = !1);
        }
        !a.ignoreY && b.isInsidePlot && (d = h && (d ? h.xAxis : h.yAxis) || {
          pos: f,
          len: Infinity
        }, a = a.paneCoordinates ? d.pos + c : f + c, a >= Math.max(l + f, d.pos) && a <= Math.min(l + f + e.height, d.pos + d.len) || (b.isInsidePlot = !1));
        R(this, "afterIsInsidePlot", b);
        return b.isInsidePlot;
      };
      a.prototype.redraw = function (b) {
        R(this, "beforeRedraw");
        var c = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
          a = this.series,
          d = this.pointer,
          e = this.legend,
          k = this.userOptions.legend,
          f = this.renderer,
          g = f.isHidden(),
          r = [],
          l = this.isDirtyBox,
          h = this.isDirtyLegend;
        this.setResponsive && this.setResponsive(!1);
        G(this.hasRendered ? b : !1, this);
        g && this.temporaryDisplay();
        this.layOutTitles();
        for (b = a.length; b--;) {
          var p = a[b];
          if (p.options.stacking || p.options.centerInCategory) {
            var u = !0;
            if (p.isDirty) {
              var n = !0;
              break;
            }
          }
        }
        if (n) for (b = a.length; b--;) p = a[b], p.options.stacking && (p.isDirty = !0);
        a.forEach(function (b) {
          b.isDirty && ("point" === b.options.legendType ? ("function" === typeof b.updateTotals && b.updateTotals(), h = !0) : k && (k.labelFormatter || k.labelFormat) && (h = !0));
          b.isDirtyData && R(b, "updatedData");
        });
        h && e && e.options.enabled && (e.render(), this.isDirtyLegend = !1);
        u && this.getStacks();
        c.forEach(function (b) {
          b.updateNames();
          b.setScale();
        });
        this.getMargins();
        c.forEach(function (b) {
          b.isDirty && (l = !0);
        });
        c.forEach(function (b) {
          var c = b.min + "," + b.max;
          b.extKey !== c && (b.extKey = c, r.push(function () {
            R(b, "afterSetExtremes", aa(b.eventArgs, b.getExtremes()));
            delete b.eventArgs;
          }));
          (l || u) && b.redraw();
        });
        l && this.drawChartBox();
        R(this, "predraw");
        a.forEach(function (b) {
          (l || b.isDirty) && b.visible && b.redraw();
          b.isDirtyData = !1;
        });
        d && d.reset(!0);
        f.draw();
        R(this, "redraw");
        R(this, "render");
        g && this.temporaryDisplay(!0);
        r.forEach(function (b) {
          b.call();
        });
      };
      a.prototype.get = function (b) {
        function c(c) {
          return c.id === b || c.options && c.options.id === b;
        }
        for (var a = this.series, d = da(this.axes, c) || da(this.series, c), e = 0; !d && e < a.length; e++) d = da(a[e].points || [], c);
        return d;
      };
      a.prototype.getAxes = function () {
        var b = this,
          c = this.options,
          a = c.xAxis = Z(c.xAxis || {});
        c = c.yAxis = Z(c.yAxis || {});
        R(this, "getAxes");
        a.forEach(function (b, c) {
          b.index = c;
          b.isX = !0;
        });
        c.forEach(function (b, c) {
          b.index = c;
        });
        a.concat(c).forEach(function (c) {
          new t(b, c);
        });
        R(this, "afterGetAxes");
      };
      a.prototype.getSelectedPoints = function () {
        return this.series.reduce(function (b, c) {
          c.getPointsCollection().forEach(function (c) {
            S(c.selectedStaging, c.selected) && b.push(c);
          });
          return b;
        }, []);
      };
      a.prototype.getSelectedSeries = function () {
        return this.series.filter(function (b) {
          return b.selected;
        });
      };
      a.prototype.setTitle = function (b, c, a) {
        this.applyDescription("title", b);
        this.applyDescription("subtitle", c);
        this.applyDescription("caption", void 0);
        this.layOutTitles(a);
      };
      a.prototype.applyDescription = function (b, c) {
        var a = this,
          d = "title" === b ? {
            color: "#333333",
            fontSize: this.options.isStock ? "16px" : "18px"
          } : {
            color: "#666666"
          };
        d = this.options[b] = T(!this.styledMode && {
          style: d
        }, this.options[b], c);
        var e = this[b];
        e && c && (this[b] = e = e.destroy());
        d && !e && (e = this.renderer.text(d.text, 0, 0, d.useHTML).attr({
          align: d.align,
          "class": "highcharts-" + b,
          zIndex: d.zIndex || 4
        }).add(), e.update = function (c) {
          a[{
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }[b]](c);
        }, this.styledMode || e.css(d.style), this[b] = e);
      };
      a.prototype.layOutTitles = function (b) {
        var c = [0, 0, 0],
          a = this.renderer,
          d = this.spacingBox;
        ["title", "subtitle", "caption"].forEach(function (b) {
          var e = this[b],
            k = this.options[b],
            f = k.verticalAlign || "top";
          b = "title" === b ? "top" === f ? -3 : 0 : "top" === f ? c[0] + 2 : 0;
          var g;
          if (e) {
            this.styledMode || (g = k.style && k.style.fontSize);
            g = a.fontMetrics(g, e).b;
            e.css({
              width: (k.width || d.width + (k.widthAdjust || 0)) + "px"
            });
            var r = Math.round(e.getBBox(k.useHTML).height);
            e.align(aa({
              y: "bottom" === f ? g : b + g,
              height: r
            }, k), !1, "spacingBox");
            k.floating || ("top" === f ? c[0] = Math.ceil(c[0] + r) : "bottom" === f && (c[2] = Math.ceil(c[2] + r)));
          }
        }, this);
        c[0] && "top" === (this.options.title.verticalAlign || "top") && (c[0] += this.options.title.margin);
        c[2] && "bottom" === this.options.caption.verticalAlign && (c[2] += this.options.caption.margin);
        var e = !this.titleOffset || this.titleOffset.join(",") !== c.join(",");
        this.titleOffset = c;
        R(this, "afterLayOutTitles");
        !this.isDirtyBox && e && (this.isDirtyBox = this.isDirtyLegend = e, this.hasRendered && S(b, !0) && this.isDirtyBox && this.redraw());
      };
      a.prototype.getChartSize = function () {
        var b = this.options.chart,
          c = b.width;
        b = b.height;
        var a = this.renderTo;
        P(c) || (this.containerWidth = ea(a, "width"));
        P(b) || (this.containerHeight = ea(a, "height"));
        this.chartWidth = Math.max(0, c || this.containerWidth || 600);
        this.chartHeight = Math.max(0, ba(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
      };
      a.prototype.temporaryDisplay = function (b) {
        var c = this.renderTo;
        if (b) for (; c && c.style;) c.hcOrigStyle && (A(c, c.hcOrigStyle), delete c.hcOrigStyle), c.hcOrigDetached && (l.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode;else for (; c && c.style;) {
          l.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, l.body.appendChild(c));
          if ("none" === ea(c, "display", !1) || c.hcOricDetached) c.hcOrigStyle = {
            display: c.style.display,
            height: c.style.height,
            overflow: c.style.overflow
          }, b = {
            display: "block",
            overflow: "hidden"
          }, c !== this.renderTo && (b.height = 0), A(c, b), c.offsetWidth || c.style.setProperty("display", "block", "important");
          c = c.parentNode;
          if (c === l.body) break;
        }
      };
      a.prototype.setClassName = function (b) {
        this.container.className = "highcharts-container " + (b || "");
      };
      a.prototype.getContainer = function () {
        var a = this.options,
          d = a.chart,
          e = ia(),
          k,
          f = this.renderTo;
        f || (this.renderTo = f = d.renderTo);
        fa(f) && (this.renderTo = f = l.getElementById(f));
        f || L(13, !0, this);
        var h = ha(K(f, "data-highcharts-chart"));
        Y(h) && p[h] && p[h].hasRendered && p[h].destroy();
        K(f, "data-highcharts-chart", this.index);
        f.innerHTML = g.emptyHTML;
        d.skipClone || f.offsetWidth || this.temporaryDisplay();
        this.getChartSize();
        h = this.chartWidth;
        var u = this.chartHeight;
        A(f, {
          overflow: "hidden"
        });
        this.styledMode || (k = aa({
          position: "relative",
          overflow: "hidden",
          width: h + "px",
          height: u + "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
          userSelect: "none",
          "touch-action": "manipulation",
          outline: "none"
        }, d.style || {}));
        this.container = e = r("div", {
          id: e
        }, k, f);
        this._cursor = e.style.cursor;
        this.renderer = new (d.renderer || !b ? m.getRendererType(d.renderer) : c)(e, h, u, void 0, d.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);
        G(void 0, this);
        this.setClassName(d.className);
        if (this.styledMode) for (var n in a.defs) this.renderer.definition(a.defs[n]);else this.renderer.setStyle(d.style);
        this.renderer.chartIndex = this.index;
        R(this, "afterGetContainer");
      };
      a.prototype.getMargins = function (b) {
        var c = this.spacing,
          a = this.margin,
          d = this.titleOffset;
        this.resetMargins();
        d[0] && !P(a[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + c[0]));
        d[2] && !P(a[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + c[2]));
        this.legend && this.legend.display && this.legend.adjustMargins(a, c);
        R(this, "getMargins");
        b || this.getAxisMargins();
      };
      a.prototype.getAxisMargins = function () {
        var b = this,
          c = b.axisOffset = [0, 0, 0, 0],
          a = b.colorAxis,
          d = b.margin,
          e = function (b) {
            b.forEach(function (b) {
              b.visible && b.getOffset();
            });
          };
        b.hasCartesianSeries ? e(b.axes) : a && a.length && e(a);
        w.forEach(function (a, e) {
          P(d[e]) || (b[a] += c[e]);
        });
        b.setChartSize();
      };
      a.prototype.reflow = function (b) {
        var c = this,
          a = c.options.chart,
          d = c.renderTo,
          e = P(a.width) && P(a.height),
          k = a.width || ea(d, "width");
        a = a.height || ea(d, "height");
        d = b ? b.target : v;
        delete c.pointer.chartPosition;
        if (!e && !c.isPrinting && k && a && (d === v || d === l)) {
          if (k !== c.containerWidth || a !== c.containerHeight) z.clearTimeout(c.reflowTimeout), c.reflowTimeout = ca(function () {
            c.container && c.setSize(void 0, void 0, !1);
          }, b ? 100 : 0);
          c.containerWidth = k;
          c.containerHeight = a;
        }
      };
      a.prototype.setReflow = function (b) {
        var c = this;
        !1 === b || this.unbindReflow ? !1 === b && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = k(v, "resize", function (b) {
          c.options && c.reflow(b);
        }), k(this, "destroy", this.unbindReflow));
      };
      a.prototype.setSize = function (b, c, a) {
        var d = this,
          k = d.renderer;
        d.isResizing += 1;
        G(a, d);
        a = k.globalAnimation;
        d.oldChartHeight = d.chartHeight;
        d.oldChartWidth = d.chartWidth;
        "undefined" !== typeof b && (d.options.chart.width = b);
        "undefined" !== typeof c && (d.options.chart.height = c);
        d.getChartSize();
        d.styledMode || (a ? f : A)(d.container, {
          width: d.chartWidth + "px",
          height: d.chartHeight + "px"
        }, a);
        d.setChartSize(!0);
        k.setSize(d.chartWidth, d.chartHeight, a);
        d.axes.forEach(function (b) {
          b.isDirty = !0;
          b.setScale();
        });
        d.isDirtyLegend = !0;
        d.isDirtyBox = !0;
        d.layOutTitles();
        d.getMargins();
        d.redraw(a);
        d.oldChartHeight = null;
        R(d, "resize");
        ca(function () {
          d && R(d, "endResize", null, function () {
            --d.isResizing;
          });
        }, e(a).duration);
      };
      a.prototype.setChartSize = function (b) {
        var c = this.inverted,
          a = this.renderer,
          d = this.chartWidth,
          e = this.chartHeight,
          k = this.options.chart,
          f = this.spacing,
          g = this.clipOffset,
          r,
          h,
          l,
          p;
        this.plotLeft = r = Math.round(this.plotLeft);
        this.plotTop = h = Math.round(this.plotTop);
        this.plotWidth = l = Math.max(0, Math.round(d - r - this.marginRight));
        this.plotHeight = p = Math.max(0, Math.round(e - h - this.marginBottom));
        this.plotSizeX = c ? p : l;
        this.plotSizeY = c ? l : p;
        this.plotBorderWidth = k.plotBorderWidth || 0;
        this.spacingBox = a.spacingBox = {
          x: f[3],
          y: f[0],
          width: d - f[3] - f[1],
          height: e - f[0] - f[2]
        };
        this.plotBox = a.plotBox = {
          x: r,
          y: h,
          width: l,
          height: p
        };
        c = 2 * Math.floor(this.plotBorderWidth / 2);
        d = Math.ceil(Math.max(c, g[3]) / 2);
        e = Math.ceil(Math.max(c, g[0]) / 2);
        this.clipBox = {
          x: d,
          y: e,
          width: Math.floor(this.plotSizeX - Math.max(c, g[1]) / 2 - d),
          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(c, g[2]) / 2 - e))
        };
        b || (this.axes.forEach(function (b) {
          b.setAxisSize();
          b.setAxisTranslation();
        }), a.alignElements());
        R(this, "afterSetChartSize", {
          skipAxes: b
        });
      };
      a.prototype.resetMargins = function () {
        R(this, "resetMargins");
        var b = this,
          c = b.options.chart;
        ["margin", "spacing"].forEach(function (a) {
          var d = c[a],
            e = U(d) ? d : [d, d, d, d];
          ["Top", "Right", "Bottom", "Left"].forEach(function (d, k) {
            b[a][k] = S(c[a + d], e[k]);
          });
        });
        w.forEach(function (c, a) {
          b[c] = S(b.margin[a], b.spacing[a]);
        });
        b.axisOffset = [0, 0, 0, 0];
        b.clipOffset = [0, 0, 0, 0];
      };
      a.prototype.drawChartBox = function () {
        var b = this.options.chart,
          c = this.renderer,
          a = this.chartWidth,
          d = this.chartHeight,
          e = this.styledMode,
          k = this.plotBGImage,
          f = b.backgroundColor,
          g = b.plotBackgroundColor,
          r = b.plotBackgroundImage,
          h = this.plotLeft,
          l = this.plotTop,
          p = this.plotWidth,
          u = this.plotHeight,
          n = this.plotBox,
          A = this.clipRect,
          v = this.clipBox,
          w = this.chartBackground,
          m = this.plotBackground,
          q = this.plotBorder,
          Q,
          z = "animate";
        w || (this.chartBackground = w = c.rect().addClass("highcharts-background").add(), z = "attr");
        if (e) var K = Q = w.strokeWidth();else {
          K = b.borderWidth || 0;
          Q = K + (b.shadow ? 8 : 0);
          f = {
            fill: f || "none"
          };
          if (K || w["stroke-width"]) f.stroke = b.borderColor, f["stroke-width"] = K;
          w.attr(f).shadow(b.shadow);
        }
        w[z]({
          x: Q / 2,
          y: Q / 2,
          width: a - Q - K % 2,
          height: d - Q - K % 2,
          r: b.borderRadius
        });
        z = "animate";
        m || (z = "attr", this.plotBackground = m = c.rect().addClass("highcharts-plot-background").add());
        m[z](n);
        e || (m.attr({
          fill: g || "none"
        }).shadow(b.plotShadow), r && (k ? (r !== k.attr("href") && k.attr("href", r), k.animate(n)) : this.plotBGImage = c.image(r, h, l, p, u).add()));
        A ? A.animate({
          width: v.width,
          height: v.height
        }) : this.clipRect = c.clipRect(v);
        z = "animate";
        q || (z = "attr", this.plotBorder = q = c.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
        }).add());
        e || q.attr({
          stroke: b.plotBorderColor,
          "stroke-width": b.plotBorderWidth || 0,
          fill: "none"
        });
        q[z](q.crisp({
          x: h,
          y: l,
          width: p,
          height: u
        }, -q.strokeWidth()));
        this.isDirtyBox = !1;
        R(this, "afterDrawChartBox");
      };
      a.prototype.propFromSeries = function () {
        var b = this,
          c = b.options.chart,
          a = b.options.series,
          d,
          e,
          k;
        ["inverted", "angular", "polar"].forEach(function (f) {
          e = C[c.type || c.defaultSeriesType];
          k = c[f] || e && e.prototype[f];
          for (d = a && a.length; !k && d--;) (e = C[a[d].type]) && e.prototype[f] && (k = !0);
          b[f] = k;
        });
      };
      a.prototype.linkSeries = function () {
        var b = this,
          c = b.series;
        c.forEach(function (b) {
          b.linkedSeries.length = 0;
        });
        c.forEach(function (c) {
          var a = c.options.linkedTo;
          fa(a) && (a = ":previous" === a ? b.series[c.index - 1] : b.get(a)) && a.linkedParent !== c && (a.linkedSeries.push(c), c.linkedParent = a, a.enabledDataSorting && c.setDataSortingOptions(), c.visible = S(c.options.visible, a.options.visible, c.visible));
        });
        R(this, "afterLinkSeries");
      };
      a.prototype.renderSeries = function () {
        this.series.forEach(function (b) {
          b.translate();
          b.render();
        });
      };
      a.prototype.renderLabels = function () {
        var b = this,
          c = b.options.labels;
        c.items && c.items.forEach(function (a) {
          var d = aa(c.style, a.style),
            e = ha(d.left) + b.plotLeft,
            k = ha(d.top) + b.plotTop + 12;
          delete d.left;
          delete d.top;
          b.renderer.text(a.html, e, k).attr({
            zIndex: 2
          }).css(d).add();
        });
      };
      a.prototype.render = function () {
        var b = this.axes,
          c = this.colorAxis,
          a = this.renderer,
          d = this.options,
          e = function (b) {
            b.forEach(function (b) {
              b.visible && b.render();
            });
          },
          k = 0;
        this.setTitle();
        this.legend = new F(this, d.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        d = this.plotWidth;
        b.some(function (b) {
          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return k = 21, !0;
        });
        var f = this.plotHeight = Math.max(this.plotHeight - k, 0);
        b.forEach(function (b) {
          b.setScale();
        });
        this.getAxisMargins();
        var g = 1.1 < d / this.plotWidth,
          r = 1.05 < f / this.plotHeight;
        if (g || r) b.forEach(function (b) {
          (b.horiz && g || !b.horiz && r) && b.setTickInterval(!0);
        }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries ? e(b) : c && c.length && e(c);
        this.seriesGroup || (this.seriesGroup = a.g("series-group").attr({
          zIndex: 3
        }).add());
        this.renderSeries();
        this.renderLabels();
        this.addCredits();
        this.setResponsive && this.setResponsive();
        this.hasRendered = !0;
      };
      a.prototype.addCredits = function (b) {
        var c = this,
          a = T(!0, this.options.credits, b);
        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
          a.href && (v.location.href = a.href);
        }).attr({
          align: a.position.align,
          zIndex: 8
        }), c.styledMode || this.credits.css(a.style), this.credits.add().align(a.position), this.credits.update = function (b) {
          c.credits = c.credits.destroy();
          c.addCredits(b);
        });
      };
      a.prototype.destroy = function () {
        var b = this,
          c = b.axes,
          a = b.series,
          d = b.container,
          e = d && d.parentNode,
          k;
        R(b, "destroy");
        b.renderer.forExport ? u(p, b) : p[b.index] = void 0;
        y.chartCount--;
        b.renderTo.removeAttribute("data-highcharts-chart");
        N(b);
        for (k = c.length; k--;) c[k] = c[k].destroy();
        this.scroller && this.scroller.destroy && this.scroller.destroy();
        for (k = a.length; k--;) a[k] = a[k].destroy();
        "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (c) {
          var a = b[c];
          a && a.destroy && (b[c] = a.destroy());
        });
        d && (d.innerHTML = g.emptyHTML, N(d), e && E(d));
        W(b, function (c, a) {
          delete b[a];
        });
      };
      a.prototype.firstRender = function () {
        var b = this,
          c = b.options;
        if (!b.isReadyToRender || b.isReadyToRender()) {
          b.getContainer();
          b.resetMargins();
          b.setChartSize();
          b.propFromSeries();
          b.getAxes();
          (Q(c.series) ? c.series : []).forEach(function (c) {
            b.initSeries(c);
          });
          b.linkSeries();
          b.setSeriesData();
          R(b, "beforeRender");
          q && (I.isRequired() ? b.pointer = new I(b, c) : b.pointer = new q(b, c));
          b.render();
          b.pointer.getChartPosition();
          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
          b.temporaryDisplay(!0);
        }
      };
      a.prototype.onload = function () {
        this.callbacks.concat([this.callback]).forEach(function (b) {
          b && "undefined" !== typeof this.index && b.apply(this, [this]);
        }, this);
        R(this, "load");
        R(this, "render");
        P(this.index) && this.setReflow(this.options.chart.reflow);
        this.hasLoaded = !0;
      };
      a.prototype.addSeries = function (b, c, a) {
        var d = this,
          e;
        b && (c = S(c, !0), R(d, "addSeries", {
          options: b
        }, function () {
          e = d.initSeries(b);
          d.isDirtyLegend = !0;
          d.linkSeries();
          e.enabledDataSorting && e.setData(b.data, !1);
          R(d, "afterAddSeries", {
            series: e
          });
          c && d.redraw(a);
        }));
        return e;
      };
      a.prototype.addAxis = function (b, c, a, d) {
        return this.createAxis(c ? "xAxis" : "yAxis", {
          axis: b,
          redraw: a,
          animation: d
        });
      };
      a.prototype.addColorAxis = function (b, c, a) {
        return this.createAxis("colorAxis", {
          axis: b,
          redraw: c,
          animation: a
        });
      };
      a.prototype.createAxis = function (b, c) {
        b = new t(this, T(c.axis, {
          index: this[b].length,
          isX: "xAxis" === b
        }));
        S(c.redraw, !0) && this.redraw(c.animation);
        return b;
      };
      a.prototype.showLoading = function (b) {
        var c = this,
          a = c.options,
          d = a.loading,
          e = function () {
            h && A(h, {
              left: c.plotLeft + "px",
              top: c.plotTop + "px",
              width: c.plotWidth + "px",
              height: c.plotHeight + "px"
            });
          },
          h = c.loadingDiv,
          l = c.loadingSpan;
        h || (c.loadingDiv = h = r("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, c.container));
        l || (c.loadingSpan = l = r("span", {
          className: "highcharts-loading-inner"
        }, null, h), k(c, "redraw", e));
        h.className = "highcharts-loading";
        g.setElementHTML(l, S(b, a.lang.loading, ""));
        c.styledMode || (A(h, aa(d.style, {
          zIndex: 10
        })), A(l, d.labelStyle), c.loadingShown || (A(h, {
          opacity: 0,
          display: ""
        }), f(h, {
          opacity: d.style.opacity || .5
        }, {
          duration: d.showDuration || 0
        })));
        c.loadingShown = !0;
        e();
      };
      a.prototype.hideLoading = function () {
        var b = this.options,
          c = this.loadingDiv;
        c && (c.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || f(c, {
          opacity: 0
        }, {
          duration: b.loading.hideDuration || 100,
          complete: function () {
            A(c, {
              display: "none"
            });
          }
        }));
        this.loadingShown = !1;
      };
      a.prototype.update = function (b, c, a, d) {
        var e = this,
          k = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          },
          f = b.isResponsiveOptions,
          g = [],
          r,
          h;
        R(e, "update", {
          options: b
        });
        f || e.setResponsive(!1, !0);
        b = O(b, e.options);
        e.userOptions = T(e.userOptions, b);
        var l = b.chart;
        if (l) {
          T(!0, e.options.chart, l);
          "className" in l && e.setClassName(l.className);
          "reflow" in l && e.setReflow(l.reflow);
          if ("inverted" in l || "polar" in l || "type" in l) {
            e.propFromSeries();
            var p = !0;
          }
          "alignTicks" in l && (p = !0);
          "events" in l && M(this, l);
          W(l, function (b, c) {
            -1 !== e.propsRequireUpdateSeries.indexOf("chart." + c) && (r = !0);
            -1 !== e.propsRequireDirtyBox.indexOf(c) && (e.isDirtyBox = !0);
            -1 !== e.propsRequireReflow.indexOf(c) && (f ? e.isDirtyBox = !0 : h = !0);
          });
          !e.styledMode && l.style && e.renderer.setStyle(e.options.chart.style || {});
        }
        !e.styledMode && b.colors && (this.options.colors = b.colors);
        b.time && (this.time === D && (this.time = new n(b.time)), T(!0, e.options.time, b.time));
        W(b, function (c, a) {
          if (e[a] && "function" === typeof e[a].update) e[a].update(c, !1);else if ("function" === typeof e[k[a]]) e[k[a]](c);else "colors" !== a && -1 === e.collectionsWithUpdate.indexOf(a) && T(!0, e.options[a], b[a]);
          "chart" !== a && -1 !== e.propsRequireUpdateSeries.indexOf(a) && (r = !0);
        });
        this.collectionsWithUpdate.forEach(function (c) {
          if (b[c]) {
            var d = [];
            e[c].forEach(function (b, c) {
              b.options.isInternal || d.push(S(b.options.index, c));
            });
            Z(b[c]).forEach(function (b, k) {
              var f = P(b.id),
                g;
              f && (g = e.get(b.id));
              !g && e[c] && (g = e[c][d ? d[k] : k]) && f && P(g.options.id) && (g = void 0);
              g && g.coll === c && (g.update(b, !1), a && (g.touched = !0));
              !g && a && e.collectionsWithInit[c] && (e.collectionsWithInit[c][0].apply(e, [b].concat(e.collectionsWithInit[c][1] || []).concat([!1])).touched = !0);
            });
            a && e[c].forEach(function (b) {
              b.touched || b.options.isInternal ? delete b.touched : g.push(b);
            });
          }
        });
        g.forEach(function (b) {
          b.chart && b.remove && b.remove(!1);
        });
        p && e.axes.forEach(function (b) {
          b.update({}, !1);
        });
        r && e.getSeriesOrderByLinks().forEach(function (b) {
          b.chart && b.update({}, !1);
        }, this);
        p = l && l.width;
        l = l && (fa(l.height) ? ba(l.height, p || e.chartWidth) : l.height);
        h || Y(p) && p !== e.chartWidth || Y(l) && l !== e.chartHeight ? e.setSize(p, l, d) : S(c, !0) && e.redraw(d);
        R(e, "afterUpdate", {
          options: b,
          redraw: c,
          animation: d
        });
      };
      a.prototype.setSubtitle = function (b, c) {
        this.applyDescription("subtitle", b);
        this.layOutTitles(c);
      };
      a.prototype.setCaption = function (b, c) {
        this.applyDescription("caption", b);
        this.layOutTitles(c);
      };
      a.prototype.showResetZoom = function () {
        function b() {
          c.zoomOut();
        }
        var c = this,
          a = d.lang,
          e = c.options.chart.resetZoomButton,
          k = e.theme,
          f = k.states,
          g = "chart" === e.relativeTo || "spacingBox" === e.relativeTo ? null : "scrollablePlotBox";
        R(this, "beforeShowResetZoom", null, function () {
          c.resetZoomButton = c.renderer.button(a.resetZoom, null, null, b, k, f && f.hover).attr({
            align: e.position.align,
            title: a.resetZoomTitle
          }).addClass("highcharts-reset-zoom").add().align(e.position, !1, g);
        });
        R(this, "afterShowResetZoom");
      };
      a.prototype.zoomOut = function () {
        R(this, "selection", {
          resetSelection: !0
        }, this.zoom);
      };
      a.prototype.zoom = function (b) {
        var c = this,
          a = c.pointer,
          d = c.inverted ? a.mouseDownX : a.mouseDownY,
          e = !1,
          k;
        !b || b.resetSelection ? (c.axes.forEach(function (b) {
          k = b.zoom();
        }), a.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {
          var f = b.axis,
            g = c.inverted ? f.left : f.top,
            r = c.inverted ? g + f.width : g + f.height,
            l = f.isXAxis,
            h = !1;
          if (!l && d >= g && d <= r || l || !P(d)) h = !0;
          a[l ? "zoomX" : "zoomY"] && h && (k = f.zoom(b.min, b.max), f.displayBtn && (e = !0));
        });
        var f = c.resetZoomButton;
        e && !f ? c.showResetZoom() : !e && U(f) && (c.resetZoomButton = f.destroy());
        k && c.redraw(S(c.options.chart.animation, b && b.animation, 100 > c.pointCount));
      };
      a.prototype.pan = function (b, c) {
        var a = this,
          d = a.hoverPoints;
        c = "object" === typeof c ? c : {
          enabled: c,
          type: "x"
        };
        var e = a.options.chart,
          k = a.options.mapNavigation && a.options.mapNavigation.enabled;
        e && e.panning && (e.panning = c);
        var f = c.type,
          g;
        R(this, "pan", {
          originalEvent: b
        }, function () {
          d && d.forEach(function (b) {
            b.setState();
          });
          var c = a.xAxis;
          "xy" === f ? c = c.concat(a.yAxis) : "y" === f && (c = a.yAxis);
          var e = {};
          c.forEach(function (c) {
            if (c.options.panningEnabled && !c.options.isInternal) {
              var d = c.horiz,
                r = b[d ? "chartX" : "chartY"];
              d = d ? "mouseDownX" : "mouseDownY";
              var l = a[d],
                h = c.minPointOffset || 0,
                p = c.reversed && !a.inverted || !c.reversed && a.inverted ? -1 : 1,
                u = c.getExtremes(),
                n = c.toValue(l - r, !0) + h * p,
                A = c.toValue(l + c.len - r, !0) - (h * p || c.isXAxis && c.pointRangePadding || 0),
                v = A < n;
              p = c.hasVerticalPanning();
              l = v ? A : n;
              n = v ? n : A;
              var w = c.panningState;
              !p || c.isXAxis || w && !w.isDirty || c.series.forEach(function (b) {
                var c = b.getProcessedData(!0);
                c = b.getExtremes(c.yData, !0);
                w || (w = {
                  startMin: Number.MAX_VALUE,
                  startMax: -Number.MAX_VALUE
                });
                Y(c.dataMin) && Y(c.dataMax) && (w.startMin = Math.min(S(b.options.threshold, Infinity), c.dataMin, w.startMin), w.startMax = Math.max(S(b.options.threshold, -Infinity), c.dataMax, w.startMax));
              });
              p = Math.min(S(w && w.startMin, u.dataMin), h ? u.min : c.toValue(c.toPixels(u.min) - c.minPixelPadding));
              A = Math.max(S(w && w.startMax, u.dataMax), h ? u.max : c.toValue(c.toPixels(u.max) + c.minPixelPadding));
              c.panningState = w;
              c.isOrdinal || (h = p - l, 0 < h && (n += h, l = p), h = n - A, 0 < h && (n = A, l -= h), c.series.length && l !== u.min && n !== u.max && l >= p && n <= A && (c.setExtremes(l, n, !1, !1, {
                trigger: "pan"
              }), a.resetZoomButton || k || l === p || n === A || !f.match("y") || (a.showResetZoom(), c.displayBtn = !1), g = !0), e[d] = r);
            }
          });
          W(e, function (b, c) {
            a[c] = b;
          });
          g && a.redraw(!1);
          A(a.container, {
            cursor: "move"
          });
        });
      };
      return a;
    }();
    aa(a.prototype, {
      callbacks: [],
      collectionsWithInit: {
        xAxis: [a.prototype.addAxis, [!0]],
        yAxis: [a.prototype.addAxis, [!1]],
        series: [a.prototype.addSeries]
      },
      collectionsWithUpdate: ["xAxis", "yAxis", "series"],
      propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
      propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
    });
    "";
    return a;
  });
  N(a, "Core/Legend/LegendSymbol.js", [a["Core/Utilities.js"]], function (a) {
    var E = a.merge,
      B = a.pick,
      H;
    (function (a) {
      a.drawLineMarker = function (a) {
        var t = this.options,
          x = a.symbolWidth,
          q = a.symbolHeight,
          m = q / 2,
          h = this.chart.renderer,
          c = this.legendGroup;
        a = a.baseline - Math.round(.3 * a.fontMetrics.b);
        var n = {},
          z = t.marker;
        this.chart.styledMode || (n = {
          "stroke-width": t.lineWidth || 0
        }, t.dashStyle && (n.dashstyle = t.dashStyle));
        this.legendLine = h.path([["M", 0, a], ["L", x, a]]).addClass("highcharts-graph").attr(n).add(c);
        z && !1 !== z.enabled && x && (t = Math.min(B(z.radius, m), m), 0 === this.symbol.indexOf("url") && (z = E(z, {
          width: q,
          height: q
        }), t = 0), this.legendSymbol = x = h.symbol(this.symbol, x / 2 - t, a - t, 2 * t, 2 * t, z).addClass("highcharts-point").add(c), x.isMarker = !0);
      };
      a.drawRectangle = function (a, t) {
        var x = a.symbolHeight,
          q = a.options.squareSymbol;
        t.legendSymbol = this.chart.renderer.rect(q ? (a.symbolWidth - x) / 2 : 0, a.baseline - x + 1, q ? x : a.symbolWidth, x, B(a.options.symbolRadius, x / 2)).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(t.legendGroup);
      };
    })(H || (H = {}));
    return H;
  });
  N(a, "Core/Series/SeriesDefaults.js", [], function () {
    return {
      lineWidth: 2,
      allowPointSelect: !1,
      crisp: !0,
      showCheckbox: !1,
      animation: {
        duration: 1E3
      },
      events: {},
      marker: {
        enabledThreshold: 2,
        lineColor: "#ffffff",
        lineWidth: 0,
        radius: 4,
        states: {
          normal: {
            animation: !0
          },
          hover: {
            animation: {
              duration: 50
            },
            enabled: !0,
            radiusPlus: 2,
            lineWidthPlus: 1
          },
          select: {
            fillColor: "#cccccc",
            lineColor: "#000000",
            lineWidth: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        animation: {},
        align: "center",
        defer: !0,
        formatter: function () {
          var a = this.series.chart.numberFormatter;
          return "number" !== typeof this.y ? "" : a(this.y, -1);
        },
        padding: 5,
        style: {
          fontSize: "11px",
          fontWeight: "bold",
          color: "contrast",
          textOutline: "1px contrast"
        },
        verticalAlign: "bottom",
        x: 0,
        y: 0
      },
      cropThreshold: 300,
      opacity: 1,
      pointRange: 0,
      softThreshold: !0,
      states: {
        normal: {
          animation: !0
        },
        hover: {
          animation: {
            duration: 50
          },
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10,
            opacity: .25
          }
        },
        select: {
          animation: {
            duration: 0
          }
        },
        inactive: {
          animation: {
            duration: 50
          },
          opacity: .2
        }
      },
      stickyTracking: !0,
      turboThreshold: 1E3,
      findNearestPointBy: "x"
    };
  });
  N(a, "Core/Series/Series.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/DefaultOptions.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/Point.js"], a["Core/Series/SeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F, I, x, q, m) {
    var h = a.animObject,
      c = a.setAnimation,
      n = t.defaultOptions,
      z = B.registerEventOptions,
      g = H.hasTouch,
      f = H.svg,
      e = H.win,
      G = x.seriesTypes,
      J = m.addEvent,
      M = m.arrayMax,
      p = m.arrayMin,
      l = m.clamp,
      w = m.cleanRecursively,
      b = m.correctFloat,
      v = m.defined,
      d = m.erase,
      D = m.error,
      C = m.extend,
      k = m.find,
      K = m.fireEvent,
      O = m.getNestedProperty,
      r = m.isArray,
      A = m.isNumber,
      P = m.isString,
      E = m.merge,
      u = m.objectEach,
      L = m.pick,
      aa = m.removeEvent,
      da = m.splat,
      R = m.syncTimeout;
    a = function () {
      function a() {
        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
      }
      a.prototype.init = function (b, c) {
        K(this, "init", {
          options: c
        });
        var a = this,
          d = b.series;
        this.eventsToUnbind = [];
        a.chart = b;
        a.options = a.setOptions(c);
        c = a.options;
        a.linkedSeries = [];
        a.bindAxes();
        C(a, {
          name: c.name,
          state: "",
          visible: !1 !== c.visible,
          selected: !0 === c.selected
        });
        z(this, c);
        var e = c.events;
        if (e && e.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) b.runTrackerClick = !0;
        a.getColor();
        a.getSymbol();
        a.parallelArrays.forEach(function (b) {
          a[b + "Data"] || (a[b + "Data"] = []);
        });
        a.isCartesian && (b.hasCartesianSeries = !0);
        var k;
        d.length && (k = d[d.length - 1]);
        a._i = L(k && k._i, -1) + 1;
        a.opacity = a.options.opacity;
        b.orderSeries(this.insert(d));
        c.dataSorting && c.dataSorting.enabled ? a.setDataSortingOptions() : a.points || a.data || a.setData(c.data, !1);
        K(this, "afterInit");
      };
      a.prototype.is = function (b) {
        return G[b] && this instanceof G[b];
      };
      a.prototype.insert = function (b) {
        var c = this.options.index,
          a;
        if (A(c)) {
          for (a = b.length; a--;) if (c >= L(b[a].options.index, b[a]._i)) {
            b.splice(a + 1, 0, this);
            break;
          }
          -1 === a && b.unshift(this);
          a += 1;
        } else b.push(this);
        return L(a, b.length - 1);
      };
      a.prototype.bindAxes = function () {
        var b = this,
          c = b.options,
          a = b.chart,
          d;
        K(this, "bindAxes", null, function () {
          (b.axisTypes || []).forEach(function (e) {
            var k = 0;
            a[e].forEach(function (a) {
              d = a.options;
              if (c[e] === k && !d.isInternal || "undefined" !== typeof c[e] && c[e] === d.id || "undefined" === typeof c[e] && 0 === d.index) b.insert(a.series), b[e] = a, a.isDirty = !0;
              d.isInternal || k++;
            });
            b[e] || b.optionalAxis === e || D(18, !0, a);
          });
        });
        K(this, "afterBindAxes");
      };
      a.prototype.updateParallelArrays = function (b, c) {
        var a = b.series,
          d = arguments,
          e = A(c) ? function (d) {
            var e = "y" === d && a.toYData ? a.toYData(b) : b[d];
            a[d + "Data"][c] = e;
          } : function (b) {
            Array.prototype[c].apply(a[b + "Data"], Array.prototype.slice.call(d, 2));
          };
        a.parallelArrays.forEach(e);
      };
      a.prototype.hasData = function () {
        return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
      };
      a.prototype.autoIncrement = function (b) {
        var c = this.options,
          a = c.pointIntervalUnit,
          d = c.relativeXValue,
          e = this.chart.time,
          k = this.xIncrement,
          f;
        k = L(k, c.pointStart, 0);
        this.pointInterval = f = L(this.pointInterval, c.pointInterval, 1);
        d && A(b) && (f *= b);
        a && (c = new e.Date(k), "day" === a ? e.set("Date", c, e.get("Date", c) + f) : "month" === a ? e.set("Month", c, e.get("Month", c) + f) : "year" === a && e.set("FullYear", c, e.get("FullYear", c) + f), f = c.getTime() - k);
        if (d && A(b)) return k + f;
        this.xIncrement = k + f;
        return k;
      };
      a.prototype.setDataSortingOptions = function () {
        var b = this.options;
        C(this, {
          requireSorting: !1,
          sorted: !1,
          enabledDataSorting: !0,
          allowDG: !1
        });
        v(b.pointRange) || (b.pointRange = 1);
      };
      a.prototype.setOptions = function (b) {
        var c = this.chart,
          a = c.options,
          d = a.plotOptions,
          e = c.userOptions || {};
        b = E(b);
        c = c.styledMode;
        var k = {
          plotOptions: d,
          userOptions: b
        };
        K(this, "setOptions", k);
        var f = k.plotOptions[this.type],
          g = e.plotOptions || {};
        this.userOptions = k.userOptions;
        e = E(f, d.series, e.plotOptions && e.plotOptions[this.type], b);
        this.tooltipOptions = E(n.tooltip, n.plotOptions.series && n.plotOptions.series.tooltip, n.plotOptions[this.type].tooltip, a.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, b.tooltip);
        this.stickyTracking = L(b.stickyTracking, g[this.type] && g[this.type].stickyTracking, g.series && g.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : e.stickyTracking);
        null === f.marker && delete e.marker;
        this.zoneAxis = e.zoneAxis;
        d = this.zones = (e.zones || []).slice();
        !e.negativeColor && !e.negativeFillColor || e.zones || (a = {
          value: e[this.zoneAxis + "Threshold"] || e.threshold || 0,
          className: "highcharts-negative"
        }, c || (a.color = e.negativeColor, a.fillColor = e.negativeFillColor), d.push(a));
        d.length && v(d[d.length - 1].value) && d.push(c ? {} : {
          color: this.color,
          fillColor: this.fillColor
        });
        K(this, "afterSetOptions", {
          options: e
        });
        return e;
      };
      a.prototype.getName = function () {
        return L(this.options.name, "Series " + (this.index + 1));
      };
      a.prototype.getCyclic = function (b, c, a) {
        var d = this.chart,
          e = this.userOptions,
          k = b + "Index",
          f = b + "Counter",
          g = a ? a.length : L(d.options.chart[b + "Count"], d[b + "Count"]);
        if (!c) {
          var r = L(e[k], e["_" + k]);
          v(r) || (d.series.length || (d[f] = 0), e["_" + k] = r = d[f] % g, d[f] += 1);
          a && (c = a[r]);
        }
        "undefined" !== typeof r && (this[k] = r);
        this[b] = c;
      };
      a.prototype.getColor = function () {
        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || n.plotOptions[this.type].color, this.chart.options.colors);
      };
      a.prototype.getPointsCollection = function () {
        return (this.hasGroupedData ? this.points : this.data) || [];
      };
      a.prototype.getSymbol = function () {
        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
      };
      a.prototype.findPointIndex = function (b, c) {
        var a = b.id,
          d = b.x,
          e = this.points,
          f = this.options.dataSorting,
          g,
          r;
        if (a) f = this.chart.get(a), f instanceof F && (g = f);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (g = function (c) {
          return !c.touched && c.index === b.index;
        }, f && f.matchByName ? g = function (c) {
          return !c.touched && c.name === b.name;
        } : this.options.relativeXValue && (g = function (c) {
          return !c.touched && c.options.x === b.x;
        }), g = k(e, g), !g) return;
        if (g) {
          var l = g && g.index;
          "undefined" !== typeof l && (r = !0);
        }
        "undefined" === typeof l && A(d) && (l = this.xData.indexOf(d, c));
        -1 !== l && "undefined" !== typeof l && this.cropped && (l = l >= this.cropStart ? l - this.cropStart : l);
        !r && A(l) && e[l] && e[l].touched && (l = void 0);
        return l;
      };
      a.prototype.updateData = function (b, c) {
        var a = this.options,
          d = a.dataSorting,
          e = this.points,
          k = [],
          f = this.requireSorting,
          g = b.length === e.length,
          r,
          l,
          h,
          p = !0;
        this.xIncrement = null;
        b.forEach(function (b, c) {
          var l = v(b) && this.pointClass.prototype.optionsToObject.call({
              series: this
            }, b) || {},
            p = l.x;
          if (l.id || A(p)) {
            if (l = this.findPointIndex(l, h), -1 === l || "undefined" === typeof l ? k.push(b) : e[l] && b !== a.data[l] ? (e[l].update(b, !1, null, !1), e[l].touched = !0, f && (h = l + 1)) : e[l] && (e[l].touched = !0), !g || c !== l || d && d.enabled || this.hasDerivedData) r = !0;
          } else k.push(b);
        }, this);
        if (r) for (b = e.length; b--;) (l = e[b]) && !l.touched && l.remove && l.remove(!1, c);else !g || d && d.enabled ? p = !1 : (b.forEach(function (b, c) {
          b !== e[c].y && e[c].update && e[c].update(b, !1, null, !1);
        }), k.length = 0);
        e.forEach(function (b) {
          b && (b.touched = !1);
        });
        if (!p) return !1;
        k.forEach(function (b) {
          this.addPoint(b, !1, null, null, !1);
        }, this);
        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = M(this.xData), this.autoIncrement());
        return !0;
      };
      a.prototype.setData = function (b, c, a, d) {
        var e = this,
          k = e.points,
          f = k && k.length || 0,
          g = e.options,
          l = e.chart,
          h = g.dataSorting,
          p = e.xAxis,
          u = g.turboThreshold,
          n = this.xData,
          v = this.yData,
          w = e.pointArrayMap;
        w = w && w.length;
        var m = g.keys,
          q,
          z = 0,
          K = 1,
          G = null;
        b = b || [];
        var C = b.length;
        c = L(c, !0);
        h && h.enabled && (b = this.sortData(b));
        !1 !== d && C && f && !e.cropped && !e.hasGroupedData && e.visible && !e.isSeriesBoosting && (q = this.updateData(b, a));
        if (!q) {
          e.xIncrement = null;
          e.colorCounter = 0;
          this.parallelArrays.forEach(function (b) {
            e[b + "Data"].length = 0;
          });
          if (u && C > u) {
            if (G = e.getFirstValidPoint(b), A(G)) for (a = 0; a < C; a++) n[a] = this.autoIncrement(), v[a] = b[a];else if (r(G)) {
              if (w) {
                if (G.length === w) for (a = 0; a < C; a++) n[a] = this.autoIncrement(), v[a] = b[a];else for (a = 0; a < C; a++) d = b[a], n[a] = d[0], v[a] = d.slice(1, w + 1);
              } else if (m && (z = m.indexOf("x"), K = m.indexOf("y"), z = 0 <= z ? z : 0, K = 0 <= K ? K : 1), 1 === G.length && (K = 0), z === K) for (a = 0; a < C; a++) n[a] = this.autoIncrement(), v[a] = b[a][K];else for (a = 0; a < C; a++) d = b[a], n[a] = d[z], v[a] = d[K];
            } else D(12, !1, l);
          } else for (a = 0; a < C; a++) "undefined" !== typeof b[a] && (d = {
            series: e
          }, e.pointClass.prototype.applyOptions.apply(d, [b[a]]), e.updateParallelArrays(d, a));
          v && P(v[0]) && D(14, !0, l);
          e.data = [];
          e.options.data = e.userOptions.data = b;
          for (a = f; a--;) k[a] && k[a].destroy && k[a].destroy();
          p && (p.minRange = p.userMinRange);
          e.isDirty = l.isDirtyBox = !0;
          e.isDirtyData = !!k;
          a = !1;
        }
        "point" === g.legendType && (this.processData(), this.generatePoints());
        c && l.redraw(a);
      };
      a.prototype.sortData = function (b) {
        var c = this,
          a = c.options.dataSorting.sortKey || "y",
          d = function (b, c) {
            return v(c) && b.pointClass.prototype.optionsToObject.call({
              series: b
            }, c) || {};
          };
        b.forEach(function (a, e) {
          b[e] = d(c, a);
          b[e].index = e;
        }, this);
        b.concat().sort(function (b, c) {
          b = O(a, b);
          c = O(a, c);
          return c < b ? -1 : c > b ? 1 : 0;
        }).forEach(function (b, c) {
          b.x = c;
        }, this);
        c.linkedSeries && c.linkedSeries.forEach(function (c) {
          var a = c.options,
            e = a.data;
          a.dataSorting && a.dataSorting.enabled || !e || (e.forEach(function (a, k) {
            e[k] = d(c, a);
            b[k] && (e[k].x = b[k].x, e[k].index = k);
          }), c.setData(e, !1));
        });
        return b;
      };
      a.prototype.getProcessedData = function (b) {
        var c = this.xAxis,
          a = this.options,
          d = a.cropThreshold,
          e = b || this.getExtremesFromAll || a.getExtremesFromAll,
          k = this.isCartesian;
        b = c && c.val2lin;
        a = !(!c || !c.logarithmic);
        var f = 0,
          g = this.xData,
          r = this.yData,
          l = this.requireSorting;
        var h = !1;
        var p = g.length;
        if (c) {
          h = c.getExtremes();
          var u = h.min;
          var n = h.max;
          h = c.categories && !c.names.length;
        }
        if (k && this.sorted && !e && (!d || p > d || this.forceCrop)) if (g[p - 1] < u || g[0] > n) g = [], r = [];else if (this.yData && (g[0] < u || g[p - 1] > n)) {
          var A = this.cropData(this.xData, this.yData, u, n);
          g = A.xData;
          r = A.yData;
          f = A.start;
          A = !0;
        }
        for (d = g.length || 1; --d;) if (c = a ? b(g[d]) - b(g[d - 1]) : g[d] - g[d - 1], 0 < c && ("undefined" === typeof v || c < v)) var v = c;else 0 > c && l && !h && (D(15, !1, this.chart), l = !1);
        return {
          xData: g,
          yData: r,
          cropped: A,
          cropStart: f,
          closestPointRange: v
        };
      };
      a.prototype.processData = function (b) {
        var c = this.xAxis;
        if (this.isCartesian && !this.isDirty && !c.isDirty && !this.yAxis.isDirty && !b) return !1;
        b = this.getProcessedData();
        this.cropped = b.cropped;
        this.cropStart = b.cropStart;
        this.processedXData = b.xData;
        this.processedYData = b.yData;
        this.closestPointRange = this.basePointRange = b.closestPointRange;
        K(this, "afterProcessData");
      };
      a.prototype.cropData = function (b, c, a, d, e) {
        var k = b.length,
          f,
          g = 0,
          r = k;
        e = L(e, this.cropShoulder);
        for (f = 0; f < k; f++) if (b[f] >= a) {
          g = Math.max(0, f - e);
          break;
        }
        for (a = f; a < k; a++) if (b[a] > d) {
          r = a + e;
          break;
        }
        return {
          xData: b.slice(g, r),
          yData: c.slice(g, r),
          start: g,
          end: r
        };
      };
      a.prototype.generatePoints = function () {
        var b = this.options,
          c = b.data,
          a = this.processedXData,
          d = this.processedYData,
          e = this.pointClass,
          k = a.length,
          f = this.cropStart || 0,
          g = this.hasGroupedData,
          r = b.keys,
          l = [];
        b = b.dataGrouping && b.dataGrouping.groupAll ? f : 0;
        var h,
          p,
          u = this.data;
        if (!u && !g) {
          var n = [];
          n.length = c.length;
          u = this.data = n;
        }
        r && g && (this.options.keys = !1);
        for (p = 0; p < k; p++) {
          n = f + p;
          if (g) {
            var A = new e().init(this, [a[p]].concat(da(d[p])));
            A.dataGroup = this.groupMap[b + p];
            A.dataGroup.options && (A.options = A.dataGroup.options, C(A, A.dataGroup.options), delete A.dataLabels);
          } else (A = u[n]) || "undefined" === typeof c[n] || (u[n] = A = new e().init(this, c[n], a[p]));
          A && (A.index = g ? b + p : n, l[p] = A);
        }
        this.options.keys = r;
        if (u && (k !== (h = u.length) || g)) for (p = 0; p < h; p++) p !== f || g || (p += k), u[p] && (u[p].destroyElements(), u[p].plotX = void 0);
        this.data = u;
        this.points = l;
        K(this, "afterGeneratePoints");
      };
      a.prototype.getXExtremes = function (b) {
        return {
          min: p(b),
          max: M(b)
        };
      };
      a.prototype.getExtremes = function (b, c) {
        var a = this.xAxis,
          d = this.yAxis,
          e = this.processedXData || this.xData,
          k = [],
          f = this.requireSorting ? this.cropShoulder : 0;
        d = d ? d.positiveValuesOnly : !1;
        var g,
          l = 0,
          h = 0,
          u = 0;
        b = b || this.stackedYData || this.processedYData || [];
        var n = b.length;
        if (a) {
          var v = a.getExtremes();
          l = v.min;
          h = v.max;
        }
        for (g = 0; g < n; g++) {
          var w = e[g];
          v = b[g];
          var m = (A(v) || r(v)) && (v.length || 0 < v || !d);
          w = c || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !a || (e[g + f] || w) >= l && (e[g - f] || w) <= h;
          if (m && w) if (m = v.length) for (; m--;) A(v[m]) && (k[u++] = v[m]);else k[u++] = v;
        }
        b = {
          activeYData: k,
          dataMin: p(k),
          dataMax: M(k)
        };
        K(this, "afterGetExtremes", {
          dataExtremes: b
        });
        return b;
      };
      a.prototype.applyExtremes = function () {
        var b = this.getExtremes();
        this.dataMin = b.dataMin;
        this.dataMax = b.dataMax;
        return b;
      };
      a.prototype.getFirstValidPoint = function (b) {
        for (var c = b.length, a = 0, d = null; null === d && a < c;) d = b[a], a++;
        return d;
      };
      a.prototype.translate = function () {
        this.processedXData || this.processData();
        this.generatePoints();
        var c = this.options,
          a = c.stacking,
          d = this.xAxis,
          e = d.categories,
          k = this.enabledDataSorting,
          f = this.yAxis,
          g = this.points,
          h = g.length,
          p = this.pointPlacementToXValue(),
          u = !!p,
          n = c.threshold,
          w = c.startFromThreshold ? n : 0,
          m = this.zoneAxis || "y",
          q,
          z,
          G = Number.MAX_VALUE;
        for (q = 0; q < h; q++) {
          var C = g[q],
            J = C.x,
            D = void 0,
            O = void 0,
            M = C.y,
            P = C.low,
            x = a && f.stacking && f.stacking.stacks[(this.negStacks && M < (w ? 0 : n) ? "-" : "") + this.stackKey];
          if (f.positiveValuesOnly && !f.validatePositiveValue(M) || d.positiveValuesOnly && !d.validatePositiveValue(J)) C.isNull = !0;
          C.plotX = z = b(l(d.translate(J, 0, 0, 0, 1, p, "flags" === this.type), -1E5, 1E5));
          if (a && this.visible && x && x[J]) {
            var t = this.getStackIndicator(t, J, this.index);
            C.isNull || (D = x[J], O = D.points[t.key]);
          }
          r(O) && (P = O[0], M = O[1], P === w && t.key === x[J].base && (P = L(A(n) && n, f.min)), f.positiveValuesOnly && 0 >= P && (P = null), C.total = C.stackTotal = D.total, C.percentage = D.total && C.y / D.total * 100, C.stackY = M, this.irregularWidths || D.setOffset(this.pointXOffset || 0, this.barW || 0));
          C.yBottom = v(P) ? l(f.translate(P, 0, 1, 0, 1), -1E5, 1E5) : null;
          this.dataModify && (M = this.dataModify.modifyValue(M, q));
          C.plotY = void 0;
          A(M) && (D = f.translate(M, !1, !0, !1, !0), "undefined" !== typeof D && (C.plotY = l(D, -1E5, 1E5)));
          C.isInside = this.isPointInside(C);
          C.clientX = u ? b(d.translate(J, 0, 0, 0, 1, p)) : z;
          C.negative = C[m] < (c[m + "Threshold"] || n || 0);
          C.category = e && "undefined" !== typeof e[C.x] ? e[C.x] : C.x;
          if (!C.isNull && !1 !== C.visible) {
            "undefined" !== typeof E && (G = Math.min(G, Math.abs(z - E)));
            var E = z;
          }
          C.zone = this.zones.length ? C.getZone() : void 0;
          !C.graphic && this.group && k && (C.isNew = !0);
        }
        this.closestPointRangePx = G;
        K(this, "afterTranslate");
      };
      a.prototype.getValidPoints = function (b, c, a) {
        var d = this.chart;
        return (b || this.points || []).filter(function (b) {
          return c && !d.isInsidePlot(b.plotX, b.plotY, {
            inverted: d.inverted
          }) ? !1 : !1 !== b.visible && (a || !b.isNull);
        });
      };
      a.prototype.getClipBox = function () {
        var b = this.chart,
          c = this.xAxis,
          a = this.yAxis,
          d = E(b.clipBox);
        c && c.len !== b.plotSizeX && (d.width = c.len);
        a && a.len !== b.plotSizeY && (d.height = a.len);
        return d;
      };
      a.prototype.getSharedClipKey = function () {
        return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
      };
      a.prototype.setClip = function () {
        var b = this.chart,
          c = this.group,
          a = this.markerGroup,
          d = b.sharedClips;
        b = b.renderer;
        var e = this.getClipBox(),
          k = this.getSharedClipKey(),
          f = d[k];
        f ? f.animate(e) : d[k] = f = b.clipRect(e);
        c && c.clip(!1 === this.options.clip ? void 0 : f);
        a && a.clip();
      };
      a.prototype.animate = function (b) {
        var c = this.chart,
          a = this.group,
          d = this.markerGroup,
          e = c.inverted,
          k = h(this.options.animation),
          f = [this.getSharedClipKey(), k.duration, k.easing, k.defer].join(),
          g = c.sharedClips[f],
          r = c.sharedClips[f + "m"];
        if (b && a) k = this.getClipBox(), g ? g.attr("height", k.height) : (k.width = 0, e && (k.x = c.plotHeight), g = c.renderer.clipRect(k), c.sharedClips[f] = g, r = c.renderer.clipRect({
          x: e ? (c.plotSizeX || 0) + 99 : -99,
          y: e ? -c.plotLeft : -c.plotTop,
          width: 99,
          height: e ? c.chartWidth : c.chartHeight
        }), c.sharedClips[f + "m"] = r), a.clip(g), d && d.clip(r);else if (g && !g.hasClass("highcharts-animating")) {
          c = this.getClipBox();
          var l = k.step;
          d && d.element.childNodes.length && (k.step = function (b, c) {
            l && l.apply(c, arguments);
            r && r.element && r.attr(c.prop, "width" === c.prop ? b + 99 : b);
          });
          g.addClass("highcharts-animating").animate(c, k);
        }
      };
      a.prototype.afterAnimate = function () {
        var b = this;
        this.setClip();
        u(this.chart.sharedClips, function (c, a, d) {
          c && !b.chart.container.querySelector('[clip-path="url(#' + c.id + ')"]') && (c.destroy(), delete d[a]);
        });
        this.finishedAnimating = !0;
        K(this, "afterAnimate");
      };
      a.prototype.drawPoints = function () {
        var b = this.points,
          c = this.chart,
          a = this.options.marker,
          d = this[this.specialGroup] || this.markerGroup,
          e = this.xAxis,
          k = L(a.enabled, !e || e.isRadial ? !0 : null, this.closestPointRangePx >= a.enabledThreshold * a.radius),
          f,
          g;
        if (!1 !== a.enabled || this._hasPointMarkers) for (f = 0; f < b.length; f++) {
          var r = b[f];
          var l = (g = r.graphic) ? "animate" : "attr";
          var h = r.marker || {};
          var p = !!r.marker;
          if ((k && "undefined" === typeof h.enabled || h.enabled) && !r.isNull && !1 !== r.visible) {
            var u = L(h.symbol, this.symbol, "rect");
            var n = this.markerAttribs(r, r.selected && "select");
            this.enabledDataSorting && (r.startXPos = e.reversed ? -(n.width || 0) : e.width);
            var A = !1 !== r.isInside;
            g ? g[A ? "show" : "hide"](A).animate(n) : A && (0 < (n.width || 0) || r.hasImage) && (r.graphic = g = c.renderer.symbol(u, n.x, n.y, n.width, n.height, p ? h : a).add(d), this.enabledDataSorting && c.hasRendered && (g.attr({
              x: r.startXPos
            }), l = "animate"));
            g && "animate" === l && g[A ? "show" : "hide"](A).animate(n);
            if (g && !c.styledMode) g[l](this.pointAttribs(r, r.selected && "select"));
            g && g.addClass(r.getClassName(), !0);
          } else g && (r.graphic = g.destroy());
        }
      };
      a.prototype.markerAttribs = function (b, c) {
        var a = this.options,
          d = a.marker,
          e = b.marker || {},
          k = e.symbol || d.symbol,
          f = L(e.radius, d.radius);
        c && (d = d.states[c], c = e.states && e.states[c], f = L(c && c.radius, d && d.radius, f + (d && d.radiusPlus || 0)));
        b.hasImage = k && 0 === k.indexOf("url");
        b.hasImage && (f = 0);
        b = {
          x: a.crisp ? Math.floor(b.plotX - f) : b.plotX - f,
          y: b.plotY - f
        };
        f && (b.width = b.height = 2 * f);
        return b;
      };
      a.prototype.pointAttribs = function (b, c) {
        var a = this.options.marker,
          d = b && b.options,
          e = d && d.marker || {},
          k = d && d.color,
          f = b && b.color,
          g = b && b.zone && b.zone.color,
          r = this.color;
        b = L(e.lineWidth, a.lineWidth);
        d = 1;
        r = k || g || f || r;
        k = e.fillColor || a.fillColor || r;
        f = e.lineColor || a.lineColor || r;
        c = c || "normal";
        a = a.states[c] || {};
        c = e.states && e.states[c] || {};
        b = L(c.lineWidth, a.lineWidth, b + L(c.lineWidthPlus, a.lineWidthPlus, 0));
        k = c.fillColor || a.fillColor || k;
        f = c.lineColor || a.lineColor || f;
        d = L(c.opacity, a.opacity, d);
        return {
          stroke: f,
          "stroke-width": b,
          fill: k,
          opacity: d
        };
      };
      a.prototype.destroy = function (b) {
        var c = this,
          a = c.chart,
          k = /AppleWebKit\/533/.test(e.navigator.userAgent),
          f = c.data || [],
          g,
          r,
          l,
          h;
        K(c, "destroy");
        this.removeEvents(b);
        (c.axisTypes || []).forEach(function (b) {
          (h = c[b]) && h.series && (d(h.series, c), h.isDirty = h.forceRedraw = !0);
        });
        c.legendItem && c.chart.legend.destroyItem(c);
        for (r = f.length; r--;) (l = f[r]) && l.destroy && l.destroy();
        c.clips && c.clips.forEach(function (b) {
          return b.destroy();
        });
        m.clearTimeout(c.animationTimeout);
        u(c, function (b, c) {
          b instanceof q && !b.survive && (g = k && "group" === c ? "hide" : "destroy", b[g]());
        });
        a.hoverSeries === c && (a.hoverSeries = void 0);
        d(a.series, c);
        a.orderSeries();
        u(c, function (a, d) {
          b && "hcEvents" === d || delete c[d];
        });
      };
      a.prototype.applyZones = function () {
        var b = this,
          c = this.chart,
          a = c.renderer,
          d = this.zones,
          e = this.clips || [],
          k = this.graph,
          f = this.area,
          g = Math.max(c.chartWidth, c.chartHeight),
          r = this[(this.zoneAxis || "y") + "Axis"],
          h = c.inverted,
          p,
          u,
          n,
          A,
          v,
          w,
          m,
          q,
          z = !1;
        if (d.length && (k || f) && r && "undefined" !== typeof r.min) {
          var C = r.reversed;
          var K = r.horiz;
          k && !this.showLine && k.hide();
          f && f.hide();
          var G = r.getExtremes();
          d.forEach(function (d, J) {
            p = C ? K ? c.plotWidth : 0 : K ? 0 : r.toPixels(G.min) || 0;
            p = l(L(u, p), 0, g);
            u = l(Math.round(r.toPixels(L(d.value, G.max), !0) || 0), 0, g);
            z && (p = u = r.toPixels(G.max));
            A = Math.abs(p - u);
            v = Math.min(p, u);
            w = Math.max(p, u);
            r.isXAxis ? (n = {
              x: h ? w : v,
              y: 0,
              width: A,
              height: g
            }, K || (n.x = c.plotHeight - n.x)) : (n = {
              x: 0,
              y: h ? w : v,
              width: g,
              height: A
            }, K && (n.y = c.plotWidth - n.y));
            h && a.isVML && (n = r.isXAxis ? {
              x: 0,
              y: C ? v : w,
              height: n.width,
              width: c.chartWidth
            } : {
              x: n.y - c.plotLeft - c.spacingBox.x,
              y: 0,
              width: n.height,
              height: c.chartHeight
            });
            e[J] ? e[J].animate(n) : e[J] = a.clipRect(n);
            m = b["zone-area-" + J];
            q = b["zone-graph-" + J];
            k && q && q.clip(e[J]);
            f && m && m.clip(e[J]);
            z = d.value > G.max;
            b.resetZones && 0 === u && (u = void 0);
          });
          this.clips = e;
        } else b.visible && (k && k.show(!0), f && f.show(!0));
      };
      a.prototype.invertGroups = function (b) {
        function c() {
          ["group", "markerGroup"].forEach(function (c) {
            a[c] && (d.renderer.isVML && a[c].attr({
              width: a.yAxis.len,
              height: a.xAxis.len
            }), a[c].width = a.yAxis.len, a[c].height = a.xAxis.len, a[c].invert(a.isRadialSeries ? !1 : b));
          });
        }
        var a = this,
          d = a.chart;
        a.xAxis && (a.eventsToUnbind.push(J(d, "resize", c)), c(), a.invertGroups = c);
      };
      a.prototype.plotGroup = function (b, c, a, d, e) {
        var k = this[b],
          f = !k;
        a = {
          visibility: a,
          zIndex: d || .1
        };
        "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (a.opacity = this.opacity);
        f && (this[b] = k = this.chart.renderer.g().add(e));
        k.addClass("highcharts-" + c + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (v(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (k.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
        k.attr(a)[f ? "attr" : "animate"](this.getPlotBox());
        return k;
      };
      a.prototype.getPlotBox = function () {
        var b = this.chart,
          c = this.xAxis,
          a = this.yAxis;
        b.inverted && (c = a, a = this.xAxis);
        return {
          translateX: c ? c.left : b.plotLeft,
          translateY: a ? a.top : b.plotTop,
          scaleX: 1,
          scaleY: 1
        };
      };
      a.prototype.removeEvents = function (b) {
        b || aa(this);
        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {
          b();
        }), this.eventsToUnbind.length = 0);
      };
      a.prototype.render = function () {
        var b = this,
          c = b.chart,
          a = b.options,
          d = h(a.animation),
          e = b.visible ? "inherit" : "hidden",
          k = a.zIndex,
          f = b.hasRendered,
          g = c.seriesGroup,
          r = c.inverted;
        c = !b.finishedAnimating && c.renderer.isSVG ? d.duration : 0;
        K(this, "render");
        var l = b.plotGroup("group", "series", e, k, g);
        b.markerGroup = b.plotGroup("markerGroup", "markers", e, k, g);
        !1 !== a.clip && b.setClip();
        b.animate && c && b.animate(!0);
        l.inverted = L(b.invertible, b.isCartesian) ? r : !1;
        b.drawGraph && (b.drawGraph(), b.applyZones());
        b.visible && b.drawPoints();
        b.drawDataLabels && b.drawDataLabels();
        b.redrawPoints && b.redrawPoints();
        b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();
        b.invertGroups(r);
        b.animate && c && b.animate();
        f || (c && d.defer && (c += d.defer), b.animationTimeout = R(function () {
          b.afterAnimate();
        }, c || 0));
        b.isDirty = !1;
        b.hasRendered = !0;
        K(b, "afterRender");
      };
      a.prototype.redraw = function () {
        var b = this.chart,
          c = this.isDirty || this.isDirtyData,
          a = this.group,
          d = this.xAxis,
          e = this.yAxis;
        a && (b.inverted && a.attr({
          width: b.plotWidth,
          height: b.plotHeight
        }), a.animate({
          translateX: L(d && d.left, b.plotLeft),
          translateY: L(e && e.top, b.plotTop)
        }));
        this.translate();
        this.render();
        c && delete this.kdTree;
      };
      a.prototype.searchPoint = function (b, c) {
        var a = this.xAxis,
          d = this.yAxis,
          e = this.chart.inverted;
        return this.searchKDTree({
          clientX: e ? a.len - b.chartY + a.pos : b.chartX - a.pos,
          plotY: e ? d.len - b.chartX + d.pos : b.chartY - d.pos
        }, c, b);
      };
      a.prototype.buildKDTree = function (b) {
        function c(b, d, e) {
          var k = b && b.length;
          if (k) {
            var f = a.kdAxisArray[d % e];
            b.sort(function (b, c) {
              return b[f] - c[f];
            });
            k = Math.floor(k / 2);
            return {
              point: b[k],
              left: c(b.slice(0, k), d + 1, e),
              right: c(b.slice(k + 1), d + 1, e)
            };
          }
        }
        this.buildingKdTree = !0;
        var a = this,
          d = -1 < a.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        delete a.kdTree;
        R(function () {
          a.kdTree = c(a.getValidPoints(null, !a.directTouch), d, d);
          a.buildingKdTree = !1;
        }, a.options.kdNow || b && "touchstart" === b.type ? 0 : 1);
      };
      a.prototype.searchKDTree = function (b, c, a) {
        function d(b, c, a, r) {
          var l = c.point,
            h = e.kdAxisArray[a % r],
            p = l,
            u = v(b[k]) && v(l[k]) ? Math.pow(b[k] - l[k], 2) : null;
          var n = v(b[f]) && v(l[f]) ? Math.pow(b[f] - l[f], 2) : null;
          n = (u || 0) + (n || 0);
          l.dist = v(n) ? Math.sqrt(n) : Number.MAX_VALUE;
          l.distX = v(u) ? Math.sqrt(u) : Number.MAX_VALUE;
          h = b[h] - l[h];
          n = 0 > h ? "left" : "right";
          u = 0 > h ? "right" : "left";
          c[n] && (n = d(b, c[n], a + 1, r), p = n[g] < p[g] ? n : l);
          c[u] && Math.sqrt(h * h) < p[g] && (b = d(b, c[u], a + 1, r), p = b[g] < p[g] ? b : p);
          return p;
        }
        var e = this,
          k = this.kdAxisArray[0],
          f = this.kdAxisArray[1],
          g = c ? "distX" : "dist";
        c = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        this.kdTree || this.buildingKdTree || this.buildKDTree(a);
        if (this.kdTree) return d(b, this.kdTree, c, c);
      };
      a.prototype.pointPlacementToXValue = function () {
        var b = this.options,
          c = b.pointRange,
          a = this.xAxis;
        b = b.pointPlacement;
        "between" === b && (b = a.reversed ? -.5 : .5);
        return A(b) ? b * (c || a.pointRange) : 0;
      };
      a.prototype.isPointInside = function (b) {
        var c = this.chart,
          a = this.xAxis,
          d = this.yAxis;
        return "undefined" !== typeof b.plotY && "undefined" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (d ? d.len : c.plotHeight) && 0 <= b.plotX && b.plotX <= (a ? a.len : c.plotWidth);
      };
      a.prototype.drawTracker = function () {
        var b = this,
          c = b.options,
          a = c.trackByArea,
          d = [].concat(a ? b.areaPath : b.graphPath),
          e = b.chart,
          k = e.pointer,
          r = e.renderer,
          l = e.options.tooltip.snap,
          h = b.tracker,
          p = function (c) {
            if (e.hoverSeries !== b) b.onMouseOver();
          },
          u = "rgba(192,192,192," + (f ? .0001 : .002) + ")";
        h ? h.attr({
          d: d
        }) : b.graph && (b.tracker = r.path(d).attr({
          visibility: b.visible ? "visible" : "hidden",
          zIndex: 2
        }).addClass(a ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b.group), e.styledMode || b.tracker.attr({
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          stroke: u,
          fill: a ? u : "none",
          "stroke-width": b.graph.strokeWidth() + (a ? 0 : 2 * l)
        }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {
          if (b && (b.addClass("highcharts-tracker").on("mouseover", p).on("mouseout", function (b) {
            k.onTrackerMouseOut(b);
          }), c.cursor && !e.styledMode && b.css({
            cursor: c.cursor
          }), g)) b.on("touchstart", p);
        }));
        K(this, "afterDrawTracker");
      };
      a.prototype.addPoint = function (b, c, a, d, e) {
        var k = this.options,
          f = this.data,
          g = this.chart,
          r = this.xAxis;
        r = r && r.hasNames && r.names;
        var l = k.data,
          h = this.xData,
          p;
        c = L(c, !0);
        var u = {
          series: this
        };
        this.pointClass.prototype.applyOptions.apply(u, [b]);
        var n = u.x;
        var A = h.length;
        if (this.requireSorting && n < h[A - 1]) for (p = !0; A && h[A - 1] > n;) A--;
        this.updateParallelArrays(u, "splice", A, 0, 0);
        this.updateParallelArrays(u, A);
        r && u.name && (r[n] = u.name);
        l.splice(A, 0, b);
        p && (this.data.splice(A, 0, null), this.processData());
        "point" === k.legendType && this.generatePoints();
        a && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(u, "shift"), l.shift()));
        !1 !== e && K(this, "addPoint", {
          point: u
        });
        this.isDirtyData = this.isDirty = !0;
        c && g.redraw(d);
      };
      a.prototype.removePoint = function (b, a, d) {
        var e = this,
          k = e.data,
          f = k[b],
          g = e.points,
          r = e.chart,
          l = function () {
            g && g.length === k.length && g.splice(b, 1);
            k.splice(b, 1);
            e.options.data.splice(b, 1);
            e.updateParallelArrays(f || {
              series: e
            }, "splice", b, 1);
            f && f.destroy();
            e.isDirty = !0;
            e.isDirtyData = !0;
            a && r.redraw();
          };
        c(d, r);
        a = L(a, !0);
        f ? f.firePointEvent("remove", null, l) : l();
      };
      a.prototype.remove = function (b, c, a, d) {
        function e() {
          k.destroy(d);
          f.isDirtyLegend = f.isDirtyBox = !0;
          f.linkSeries();
          L(b, !0) && f.redraw(c);
        }
        var k = this,
          f = k.chart;
        !1 !== a ? K(k, "remove", null, e) : e();
      };
      a.prototype.update = function (b, c) {
        b = w(b, this.userOptions);
        K(this, "update", {
          options: b
        });
        var a = this,
          d = a.chart,
          e = a.userOptions,
          k = a.initialType || a.type,
          f = d.options.plotOptions,
          g = G[k].prototype,
          r = a.finishedAnimating && {
            animation: !1
          },
          l = {},
          h,
          p = ["eventOptions", "navigatorSeries", "baseSeries"],
          u = b.type || e.type || d.options.chart.type,
          n = !(this.hasDerivedData || u && u !== this.type || "undefined" !== typeof b.pointStart || "undefined" !== typeof b.pointInterval || "undefined" !== typeof b.relativeXValue || a.hasOptionChanged("dataGrouping") || a.hasOptionChanged("pointStart") || a.hasOptionChanged("pointInterval") || a.hasOptionChanged("pointIntervalUnit") || a.hasOptionChanged("keys"));
        u = u || k;
        n && (p.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== b.visible && p.push("area", "graph"), a.parallelArrays.forEach(function (b) {
          p.push(b + "Data");
        }), b.data && (b.dataSorting && C(a.options.dataSorting, b.dataSorting), this.setData(b.data, !1)));
        b = E(e, r, {
          index: "undefined" === typeof e.index ? a.index : e.index,
          pointStart: L(f && f.series && f.series.pointStart, e.pointStart, a.xData[0])
        }, !n && {
          data: a.options.data
        }, b);
        n && b.data && (b.data = a.options.data);
        p = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p);
        p.forEach(function (b) {
          p[b] = a[b];
          delete a[b];
        });
        f = !1;
        if (G[u]) {
          if (f = u !== a.type, a.remove(!1, !1, !1, !0), f) if (Object.setPrototypeOf) Object.setPrototypeOf(a, G[u].prototype);else {
            r = Object.hasOwnProperty.call(a, "hcEvents") && a.hcEvents;
            for (h in g) a[h] = void 0;
            C(a, G[u].prototype);
            r ? a.hcEvents = r : delete a.hcEvents;
          }
        } else D(17, !0, d, {
          missingModuleFor: u
        });
        p.forEach(function (b) {
          a[b] = p[b];
        });
        a.init(d, b);
        if (n && this.points) {
          var A = a.options;
          !1 === A.visible ? (l.graphic = 1, l.dataLabel = 1) : a._hasPointLabels || (b = A.marker, g = A.dataLabels, !b || !1 !== b.enabled && (e.marker && e.marker.symbol) === b.symbol || (l.graphic = 1), g && !1 === g.enabled && (l.dataLabel = 1));
          this.points.forEach(function (b) {
            b && b.series && (b.resolveColor(), Object.keys(l).length && b.destroyElements(l), !1 === A.showInLegend && b.legendItem && d.legend.destroyItem(b));
          }, this);
        }
        a.initialType = k;
        d.linkSeries();
        f && a.linkedSeries.length && (a.isDirtyData = !0);
        K(this, "afterUpdate");
        L(c, !0) && d.redraw(n ? void 0 : !1);
      };
      a.prototype.setName = function (b) {
        this.name = this.options.name = this.userOptions.name = b;
        this.chart.isDirtyLegend = !0;
      };
      a.prototype.hasOptionChanged = function (b) {
        var c = this.options[b],
          a = this.chart.options.plotOptions,
          d = this.userOptions[b];
        return d ? c !== d : c !== L(a && a[this.type] && a[this.type][b], a && a.series && a.series[b], c);
      };
      a.prototype.onMouseOver = function () {
        var b = this.chart,
          c = b.hoverSeries;
        b.pointer.setHoverChartIndex();
        if (c && c !== this) c.onMouseOut();
        this.options.events.mouseOver && K(this, "mouseOver");
        this.setState("hover");
        b.hoverSeries = this;
      };
      a.prototype.onMouseOut = function () {
        var b = this.options,
          c = this.chart,
          a = c.tooltip,
          d = c.hoverPoint;
        c.hoverSeries = null;
        if (d) d.onMouseOut();
        this && b.events.mouseOut && K(this, "mouseOut");
        !a || this.stickyTracking || a.shared && !this.noSharedTooltip || a.hide();
        c.series.forEach(function (b) {
          b.setState("", !0);
        });
      };
      a.prototype.setState = function (b, c) {
        var a = this,
          d = a.options,
          e = a.graph,
          k = d.inactiveOtherPoints,
          f = d.states,
          g = L(f[b || "normal"] && f[b || "normal"].animation, a.chart.options.chart.animation),
          r = d.lineWidth,
          l = 0,
          h = d.opacity;
        b = b || "";
        if (a.state !== b && ([a.group, a.markerGroup, a.dataLabelsGroup].forEach(function (c) {
          c && (a.state && c.removeClass("highcharts-series-" + a.state), b && c.addClass("highcharts-series-" + b));
        }), a.state = b, !a.chart.styledMode)) {
          if (f[b] && !1 === f[b].enabled) return;
          b && (r = f[b].lineWidth || r + (f[b].lineWidthPlus || 0), h = L(f[b].opacity, h));
          if (e && !e.dashstyle) for (d = {
            "stroke-width": r
          }, e.animate(d, g); a["zone-graph-" + l];) a["zone-graph-" + l].animate(d, g), l += 1;
          k || [a.group, a.markerGroup, a.dataLabelsGroup, a.labelBySeries].forEach(function (b) {
            b && b.animate({
              opacity: h
            }, g);
          });
        }
        c && k && a.points && a.setAllPointsToState(b || void 0);
      };
      a.prototype.setAllPointsToState = function (b) {
        this.points.forEach(function (c) {
          c.setState && c.setState(b);
        });
      };
      a.prototype.setVisible = function (b, c) {
        var a = this,
          d = a.chart,
          e = a.legendItem,
          k = d.options.chart.ignoreHiddenSeries,
          f = a.visible,
          g = (a.visible = b = a.options.visible = a.userOptions.visible = "undefined" === typeof b ? !f : b) ? "show" : "hide";
        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (b) {
          if (a[b]) a[b][g]();
        });
        if (d.hoverSeries === a || (d.hoverPoint && d.hoverPoint.series) === a) a.onMouseOut();
        e && d.legend.colorizeItem(a, b);
        a.isDirty = !0;
        a.options.stacking && d.series.forEach(function (b) {
          b.options.stacking && b.visible && (b.isDirty = !0);
        });
        a.linkedSeries.forEach(function (c) {
          c.setVisible(b, !1);
        });
        k && (d.isDirtyBox = !0);
        K(a, g);
        !1 !== c && d.redraw();
      };
      a.prototype.show = function () {
        this.setVisible(!0);
      };
      a.prototype.hide = function () {
        this.setVisible(!1);
      };
      a.prototype.select = function (b) {
        this.selected = b = this.options.selected = "undefined" === typeof b ? !this.selected : b;
        this.checkbox && (this.checkbox.checked = b);
        K(this, b ? "select" : "unselect");
      };
      a.prototype.shouldShowTooltip = function (b, c, a) {
        void 0 === a && (a = {});
        a.series = this;
        a.visiblePlotOnly = !0;
        return this.chart.isInsidePlot(b, c, a);
      };
      a.defaultOptions = I;
      return a;
    }();
    C(a.prototype, {
      axisTypes: ["xAxis", "yAxis"],
      coll: "series",
      colorCounter: 0,
      cropShoulder: 1,
      directTouch: !1,
      drawLegendSymbol: y.drawLineMarker,
      isCartesian: !0,
      kdAxisArray: ["clientX", "plotY"],
      parallelArrays: ["x", "y"],
      pointClass: F,
      requireSorting: !0,
      sorted: !0
    });
    x.series = a;
    "";
    "";
    return a;
  });
  N(a, "Extensions/ScrollablePlotArea.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F) {
    var E = a.stop,
      x = F.addEvent,
      q = F.createElement,
      m = F.merge,
      h = F.pick;
    x(B, "afterSetChartSize", function (c) {
      var a = this.options.chart.scrollablePlotArea,
        h = a && a.minWidth;
      a = a && a.minHeight;
      if (!this.renderer.forExport) {
        if (h) {
          if (this.scrollablePixelsX = h = Math.max(0, h - this.chartWidth)) {
            this.scrollablePlotBox = this.renderer.scrollablePlotBox = m(this.plotBox);
            this.plotBox.width = this.plotWidth += h;
            this.inverted ? this.clipBox.height += h : this.clipBox.width += h;
            var g = {
              1: {
                name: "right",
                value: h
              }
            };
          }
        } else a && (this.scrollablePixelsY = h = Math.max(0, a - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = m(this.plotBox), this.plotBox.height = this.plotHeight += h, this.inverted ? this.clipBox.width += h : this.clipBox.height += h, g = {
          2: {
            name: "bottom",
            value: h
          }
        });
        g && !c.skipAxes && this.axes.forEach(function (c) {
          g[c.side] ? c.getPlotLinePath = function () {
            var a = g[c.side].name,
              f = this[a];
            this[a] = f - g[c.side].value;
            var h = t.prototype.getPlotLinePath.apply(this, arguments);
            this[a] = f;
            return h;
          } : (c.setAxisSize(), c.setAxisTranslation());
        });
      }
    });
    x(B, "render", function () {
      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
    });
    B.prototype.setUpScrolling = function () {
      var c = this,
        a = {
          WebkitOverflowScrolling: "touch",
          overflowX: "hidden",
          overflowY: "hidden"
        };
      this.scrollablePixelsX && (a.overflowX = "auto");
      this.scrollablePixelsY && (a.overflowY = "auto");
      this.scrollingParent = q("div", {
        className: "highcharts-scrolling-parent"
      }, {
        position: "relative"
      }, this.renderTo);
      this.scrollingContainer = q("div", {
        className: "highcharts-scrolling"
      }, a, this.scrollingParent);
      x(this.scrollingContainer, "scroll", function () {
        c.pointer && delete c.pointer.chartPosition;
      });
      this.innerContainer = q("div", {
        className: "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null;
    };
    B.prototype.moveFixedElements = function () {
      var c = this.container,
        a = this.fixedRenderer,
        h = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
        g;
      this.scrollablePixelsX && !this.inverted ? g = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (g = ".highcharts-yaxis");
      g && h.push(g + ":not(.highcharts-radial-axis)", g + "-labels:not(.highcharts-radial-axis-labels)");
      h.forEach(function (f) {
        [].forEach.call(c.querySelectorAll(f), function (c) {
          (c.namespaceURI === a.SVG_NS ? a.box : a.box.parentNode).appendChild(c);
          c.style.pointerEvents = "auto";
        });
      });
    };
    B.prototype.applyFixed = function () {
      var c = !this.fixedDiv,
        a = this.options.chart,
        m = a.scrollablePlotArea,
        g = y.getRendererType();
      c ? (this.fixedDiv = q("div", {
        className: "highcharts-fixed"
      }, {
        position: "absolute",
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: (a.style && a.style.zIndex || 0) + 2,
        top: 0
      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = a = new g(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = a.path().attr({
        fill: this.options.chart.backgroundColor || "#fff",
        "fill-opacity": h(m.opacity, .85),
        zIndex: -1
      }).addClass("highcharts-scrollable-mask").add(), x(this, "afterShowResetZoom", this.moveFixedElements), x(this, "afterDrilldown", this.moveFixedElements), x(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      if (this.scrollableDirty || c) this.scrollableDirty = !1, this.moveFixedElements();
      a = this.chartWidth + (this.scrollablePixelsX || 0);
      g = this.chartHeight + (this.scrollablePixelsY || 0);
      E(this.container);
      this.container.style.width = a + "px";
      this.container.style.height = g + "px";
      this.renderer.boxWrapper.attr({
        width: a,
        height: g,
        viewBox: [0, 0, a, g].join(" ")
      });
      this.chartBackground.attr({
        width: a,
        height: g
      });
      this.scrollingContainer.style.height = this.chartHeight + "px";
      c && (m.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * m.scrollPositionX), m.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * m.scrollPositionY));
      g = this.axisOffset;
      c = this.plotTop - g[0] - 1;
      m = this.plotLeft - g[3] - 1;
      a = this.plotTop + this.plotHeight + g[2] + 1;
      g = this.plotLeft + this.plotWidth + g[1] + 1;
      var f = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
        e = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
      c = this.scrollablePixelsX ? [["M", 0, c], ["L", this.plotLeft - 1, c], ["L", this.plotLeft - 1, a], ["L", 0, a], ["Z"], ["M", f, c], ["L", this.chartWidth, c], ["L", this.chartWidth, a], ["L", f, a], ["Z"]] : this.scrollablePixelsY ? [["M", m, 0], ["L", m, this.plotTop - 1], ["L", g, this.plotTop - 1], ["L", g, 0], ["Z"], ["M", m, e], ["L", m, this.chartHeight], ["L", g, this.chartHeight], ["L", g, e], ["Z"]] : [["M", 0, 0]];
      "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
        d: c
      });
    };
    x(t, "afterInit", function () {
      this.chart.scrollableDirty = !0;
    });
    x(H, "show", function () {
      this.chart.scrollableDirty = !0;
    });
    "";
  });
  N(a, "Core/Axis/StackingAxis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = a.getDeferredAnimation,
      y = B.addEvent,
      F = B.destroyObjectProperties,
      I = B.fireEvent,
      x = B.isNumber,
      q = B.objectEach,
      m;
    (function (a) {
      function c() {
        var c = this.stacking;
        if (c) {
          var a = c.stacks;
          q(a, function (c, e) {
            F(c);
            a[e] = null;
          });
          c && c.stackTotalGroup && c.stackTotalGroup.destroy();
        }
      }
      function h() {
        this.stacking || (this.stacking = new g(this));
      }
      var m = [];
      a.compose = function (a) {
        -1 === m.indexOf(a) && (m.push(a), y(a, "init", h), y(a, "destroy", c));
        return a;
      };
      var g = function () {
        function c(c) {
          this.oldStacks = {};
          this.stacks = {};
          this.stacksTouched = 0;
          this.axis = c;
        }
        c.prototype.buildStacks = function () {
          var c = this.axis,
            a = c.series,
            f = c.options.reversedStacks,
            g = a.length,
            h;
          if (!c.isXAxis) {
            this.usePercentage = !1;
            for (h = g; h--;) {
              var l = a[f ? h : g - h - 1];
              l.setStackedPoints();
              l.setGroupedPoints();
            }
            for (h = 0; h < g; h++) a[h].modifyStacks();
            I(c, "afterBuildStacks");
          }
        };
        c.prototype.cleanStacks = function () {
          if (!this.axis.isXAxis) {
            if (this.oldStacks) var c = this.stacks = this.oldStacks;
            q(c, function (c) {
              q(c, function (c) {
                c.cumulative = c.total;
              });
            });
          }
        };
        c.prototype.resetStacks = function () {
          var c = this,
            a = c.stacks;
          c.axis.isXAxis || q(a, function (a) {
            q(a, function (e, f) {
              x(e.touched) && e.touched < c.stacksTouched ? (e.destroy(), delete a[f]) : (e.total = null, e.cumulative = null);
            });
          });
        };
        c.prototype.renderStackTotals = function () {
          var c = this.axis,
            a = c.chart,
            f = a.renderer,
            g = this.stacks;
          c = E(a, c.options.stackLabels && c.options.stackLabels.animation || !1);
          var h = this.stackTotalGroup = this.stackTotalGroup || f.g("stack-labels").attr({
            visibility: "visible",
            zIndex: 6,
            opacity: 0
          }).add();
          h.translate(a.plotLeft, a.plotTop);
          q(g, function (c) {
            q(c, function (c) {
              c.render(h);
            });
          });
          h.animate({
            opacity: 1
          }, c);
        };
        return c;
      }();
      a.Additions = g;
    })(m || (m = {}));
    return m;
  });
  N(a, "Extensions/Stacking.js", [a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Axis/StackingAxis.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F, I) {
    var x = B.format,
      q = I.correctFloat,
      m = I.defined,
      h = I.destroyObjectProperties,
      c = I.isArray,
      n = I.isNumber,
      z = I.objectEach,
      g = I.pick,
      f = function () {
        function c(c, a, e, f, g) {
          var l = c.chart.inverted;
          this.axis = c;
          this.isNegative = e;
          this.options = a = a || {};
          this.x = f;
          this.total = null;
          this.points = {};
          this.hasValidPoints = !1;
          this.stack = g;
          this.rightCliff = this.leftCliff = 0;
          this.alignOptions = {
            align: a.align || (l ? e ? "left" : "right" : "center"),
            verticalAlign: a.verticalAlign || (l ? "middle" : e ? "bottom" : "top"),
            y: a.y,
            x: a.x
          };
          this.textAlign = a.textAlign || (l ? e ? "right" : "left" : "center");
        }
        c.prototype.destroy = function () {
          h(this, this.axis);
        };
        c.prototype.render = function (c) {
          var a = this.axis.chart,
            e = this.options,
            f = e.format;
          f = f ? x(f, this, a) : e.formatter.call(this);
          this.label ? this.label.attr({
            text: f,
            visibility: "hidden"
          }) : (this.label = a.renderer.label(f, null, null, e.shape, null, null, e.useHTML, !1, "stack-labels"), f = {
            r: e.borderRadius || 0,
            text: f,
            rotation: e.rotation,
            padding: g(e.padding, 5),
            visibility: "hidden"
          }, a.styledMode || (f.fill = e.backgroundColor, f.stroke = e.borderColor, f["stroke-width"] = e.borderWidth, this.label.css(e.style)), this.label.attr(f), this.label.added || this.label.add(c));
          this.label.labelrank = a.plotSizeY;
        };
        c.prototype.setOffset = function (c, a, e, f, l) {
          var h = this.axis,
            b = h.chart;
          f = h.translate(h.stacking.usePercentage ? 100 : f ? f : this.total, 0, 0, 0, 1);
          e = h.translate(e ? e : 0);
          e = m(f) && Math.abs(f - e);
          c = g(l, b.xAxis[0].translate(this.x)) + c;
          h = m(f) && this.getStackBox(b, this, c, f, a, e, h);
          a = this.label;
          e = this.isNegative;
          c = "justify" === g(this.options.overflow, "justify");
          var p = this.textAlign;
          a && h && (l = a.getBBox(), f = a.padding, p = "left" === p ? b.inverted ? -f : f : "right" === p ? l.width : b.inverted && "center" === p ? l.width / 2 : b.inverted ? e ? l.width + f : -f : l.width / 2, e = b.inverted ? l.height / 2 : e ? -f : l.height, this.alignOptions.x = g(this.options.x, 0), this.alignOptions.y = g(this.options.y, 0), h.x -= p, h.y -= e, a.align(this.alignOptions, null, h), b.isInsidePlot(a.alignAttr.x + p - this.alignOptions.x, a.alignAttr.y + e - this.alignOptions.y) ? a.show() : (a.alignAttr.y = -9999, c = !1), c && y.prototype.justifyDataLabel.call(this.axis, a, this.alignOptions, a.alignAttr, l, h), a.attr({
            x: a.alignAttr.x,
            y: a.alignAttr.y
          }), g(!c && this.options.crop, !0) && ((b = n(a.x) && n(a.y) && b.isInsidePlot(a.x - f + a.width, a.y) && b.isInsidePlot(a.x + f, a.y)) || a.hide()));
        };
        c.prototype.getStackBox = function (c, a, e, f, g, h, b) {
          var l = a.axis.reversed,
            d = c.inverted,
            p = b.height + b.pos - (d ? c.plotLeft : c.plotTop);
          a = a.isNegative && !l || !a.isNegative && l;
          return {
            x: d ? a ? f - b.right : f - h + b.pos - c.plotLeft : e + c.xAxis[0].transB - c.plotLeft,
            y: d ? b.height - e - g : a ? p - f - h : p - f,
            width: d ? h : g,
            height: d ? g : h
          };
        };
        return c;
      }();
    t.prototype.getStacks = function () {
      var c = this,
        a = c.inverted;
      c.yAxis.forEach(function (c) {
        c.stacking && c.stacking.stacks && c.hasVisibleSeries && (c.stacking.oldStacks = c.stacking.stacks);
      });
      c.series.forEach(function (e) {
        var f = e.xAxis && e.xAxis.options || {};
        !e.options.stacking || !0 !== e.visible && !1 !== c.options.chart.ignoreHiddenSeries || (e.stackKey = [e.type, g(e.options.stack, ""), a ? f.top : f.left, a ? f.height : f.width].join());
      });
    };
    F.compose(a);
    y.prototype.setGroupedPoints = function () {
      var c = this.yAxis.stacking;
      this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? y.prototype.setStackedPoints.call(this, "group") : c && z(c.stacks, function (a, e) {
        "group" === e.slice(-5) && (z(a, function (c) {
          return c.destroy();
        }), delete c.stacks[e]);
      });
    };
    y.prototype.setStackedPoints = function (a) {
      var e = a || this.options.stacking;
      if (e && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
        var h = this.processedXData,
          n = this.processedYData,
          p = [],
          l = n.length,
          w = this.options,
          b = w.threshold,
          v = g(w.startFromThreshold && b, 0);
        w = w.stack;
        a = a ? this.type + "," + e : this.stackKey;
        var d = "-" + a,
          z = this.negStacks,
          C = this.yAxis,
          k = C.stacking.stacks,
          K = C.stacking.oldStacks,
          O,
          r;
        C.stacking.stacksTouched += 1;
        for (r = 0; r < l; r++) {
          var A = h[r];
          var P = n[r];
          var x = this.getStackIndicator(x, A, this.index);
          var u = x.key;
          var L = (O = z && P < (v ? 0 : b)) ? d : a;
          k[L] || (k[L] = {});
          k[L][A] || (K[L] && K[L][A] ? (k[L][A] = K[L][A], k[L][A].total = null) : k[L][A] = new f(C, C.options.stackLabels, O, A, w));
          L = k[L][A];
          null !== P ? (L.points[u] = L.points[this.index] = [g(L.cumulative, v)], m(L.cumulative) || (L.base = u), L.touched = C.stacking.stacksTouched, 0 < x.index && !1 === this.singleStacks && (L.points[u][0] = L.points[this.index + "," + A + ",0"][0])) : L.points[u] = L.points[this.index] = null;
          "percent" === e ? (O = O ? a : d, z && k[O] && k[O][A] ? (O = k[O][A], L.total = O.total = Math.max(O.total, L.total) + Math.abs(P) || 0) : L.total = q(L.total + (Math.abs(P) || 0))) : "group" === e ? (c(P) && (P = P[0]), null !== P && (L.total = (L.total || 0) + 1)) : L.total = q(L.total + (P || 0));
          L.cumulative = "group" === e ? (L.total || 1) - 1 : g(L.cumulative, v) + (P || 0);
          null !== P && (L.points[u].push(L.cumulative), p[r] = L.cumulative, L.hasValidPoints = !0);
        }
        "percent" === e && (C.stacking.usePercentage = !0);
        "group" !== e && (this.stackedYData = p);
        C.stacking.oldStacks = {};
      }
    };
    y.prototype.modifyStacks = function () {
      var c = this,
        a = c.stackKey,
        f = c.yAxis.stacking.stacks,
        g = c.processedXData,
        h,
        l = c.options.stacking;
      c[l + "Stacker"] && [a, "-" + a].forEach(function (a) {
        for (var b = g.length, e, d; b--;) if (e = g[b], h = c.getStackIndicator(h, e, c.index, a), d = (e = f[a] && f[a][e]) && e.points[h.key]) c[l + "Stacker"](d, e, b);
      });
    };
    y.prototype.percentStacker = function (c, a, f) {
      a = a.total ? 100 / a.total : 0;
      c[0] = q(c[0] * a);
      c[1] = q(c[1] * a);
      this.stackedYData[f] = c[1];
    };
    y.prototype.getStackIndicator = function (c, a, f, g) {
      !m(c) || c.x !== a || g && c.key !== g ? c = {
        x: a,
        index: 0,
        key: g
      } : c.index++;
      c.key = [f, a, c.index].join();
      return c;
    };
    H.StackItem = f;
    "";
    return H.StackItem;
  });
  N(a, "Series/Line/LineSeries.js", [a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = this && this.__extends || function () {
        var a = function (x, q) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, h) {
            a.__proto__ = h;
          } || function (a, h) {
            for (var c in h) h.hasOwnProperty(c) && (a[c] = h[c]);
          };
          return a(x, q);
        };
        return function (x, q) {
          function m() {
            this.constructor = x;
          }
          a(x, q);
          x.prototype = null === q ? Object.create(q) : (m.prototype = q.prototype, new m());
        };
      }(),
      y = B.defined,
      F = B.merge;
    B = function (t) {
      function x() {
        var a = null !== t && t.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      E(x, t);
      x.prototype.drawGraph = function () {
        var a = this,
          m = this.options,
          h = (this.gappedPath || this.getGraphPath).call(this),
          c = this.chart.styledMode,
          n = [["graph", "highcharts-graph"]];
        c || n[0].push(m.lineColor || this.color || "#cccccc", m.dashStyle);
        n = a.getZonesGraphs(n);
        n.forEach(function (n, g) {
          var f = n[0],
            e = a[f],
            q = e ? "animate" : "attr";
          e ? (e.endX = a.preventGraphAnimation ? null : h.xMap, e.animate({
            d: h
          })) : h.length && (a[f] = e = a.chart.renderer.path(h).addClass(n[1]).attr({
            zIndex: 1
          }).add(a.group));
          e && !c && (f = {
            stroke: n[2],
            "stroke-width": m.lineWidth,
            fill: a.fillGraph && a.color || "none"
          }, n[3] ? f.dashstyle = n[3] : "square" !== m.linecap && (f["stroke-linecap"] = f["stroke-linejoin"] = "round"), e[q](f).shadow(2 > g && m.shadow));
          e && (e.startX = h.xMap, e.isArea = h.isArea);
        });
      };
      x.prototype.getGraphPath = function (a, m, h) {
        var c = this,
          n = c.options,
          q = [],
          g = [],
          f,
          e = n.step;
        a = a || c.points;
        var G = a.reversed;
        G && a.reverse();
        (e = {
          right: 1,
          center: 2
        }[e] || e && 3) && G && (e = 4 - e);
        a = this.getValidPoints(a, !1, !(n.connectNulls && !m && !h));
        a.forEach(function (z, G) {
          var p = z.plotX,
            l = z.plotY,
            w = a[G - 1];
          (z.leftCliff || w && w.rightCliff) && !h && (f = !0);
          z.isNull && !y(m) && 0 < G ? f = !n.connectNulls : z.isNull && !m ? f = !0 : (0 === G || f ? G = [["M", z.plotX, z.plotY]] : c.getPointSpline ? G = [c.getPointSpline(a, z, G)] : e ? (G = 1 === e ? [["L", w.plotX, l]] : 2 === e ? [["L", (w.plotX + p) / 2, w.plotY], ["L", (w.plotX + p) / 2, l]] : [["L", p, w.plotY]], G.push(["L", p, l])) : G = [["L", p, l]], g.push(z.x), e && (g.push(z.x), 2 === e && g.push(z.x)), q.push.apply(q, G), f = !1);
        });
        q.xMap = g;
        return c.graphPath = q;
      };
      x.prototype.getZonesGraphs = function (a) {
        this.zones.forEach(function (m, h) {
          h = ["zone-graph-" + h, "highcharts-graph highcharts-zone-graph-" + h + " " + (m.className || "")];
          this.chart.styledMode || h.push(m.color || this.color, m.dashStyle || this.options.dashStyle);
          a.push(h);
        }, this);
        return a;
      };
      x.defaultOptions = F(a.defaultOptions, {});
      return x;
    }(a);
    t.registerSeriesType("line", B);
    "";
    return B;
  });
  N(a, "Series/Area/AreaSeries.js", [a["Core/Color/Color.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t, B, H) {
    var E = this && this.__extends || function () {
        var a = function (c, h) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (c, a) {
            c.__proto__ = a;
          } || function (c, a) {
            for (var f in a) a.hasOwnProperty(f) && (c[f] = a[f]);
          };
          return a(c, h);
        };
        return function (c, h) {
          function n() {
            this.constructor = c;
          }
          a(c, h);
          c.prototype = null === h ? Object.create(h) : (n.prototype = h.prototype, new n());
        };
      }(),
      F = a.parse,
      I = B.seriesTypes.line;
    a = H.extend;
    var x = H.merge,
      q = H.objectEach,
      m = H.pick;
    H = function (a) {
      function c() {
        var c = null !== a && a.apply(this, arguments) || this;
        c.data = void 0;
        c.options = void 0;
        c.points = void 0;
        return c;
      }
      E(c, a);
      c.prototype.drawGraph = function () {
        this.areaPath = [];
        a.prototype.drawGraph.apply(this);
        var c = this,
          h = this.areaPath,
          g = this.options,
          f = [["area", "highcharts-area", this.color, g.fillColor]];
        this.zones.forEach(function (a, h) {
          f.push(["zone-area-" + h, "highcharts-area highcharts-zone-area-" + h + " " + a.className, a.color || c.color, a.fillColor || g.fillColor]);
        });
        f.forEach(function (a) {
          var e = a[0],
            f = c[e],
            n = f ? "animate" : "attr",
            p = {};
          f ? (f.endX = c.preventGraphAnimation ? null : h.xMap, f.animate({
            d: h
          })) : (p.zIndex = 0, f = c[e] = c.chart.renderer.path(h).addClass(a[1]).add(c.group), f.isArea = !0);
          c.chart.styledMode || (p.fill = m(a[3], F(a[2]).setOpacity(m(g.fillOpacity, .75)).get()));
          f[n](p);
          f.startX = h.xMap;
          f.shiftUnit = g.step ? 2 : 1;
        });
      };
      c.prototype.getGraphPath = function (c) {
        var a = I.prototype.getGraphPath,
          g = this.options,
          f = g.stacking,
          e = this.yAxis,
          h,
          n = [],
          q = [],
          p = this.index,
          l = e.stacking.stacks[this.stackKey],
          w = g.threshold,
          b = Math.round(e.getThreshold(g.threshold));
        g = m(g.connectNulls, "percent" === f);
        var v = function (a, d, g) {
          var k = c[a];
          a = f && l[k.x].points[p];
          var h = k[g + "Null"] || 0;
          g = k[g + "Cliff"] || 0;
          k = !0;
          if (g || h) {
            var v = (h ? a[0] : a[1]) + g;
            var m = a[0] + g;
            k = !!h;
          } else !f && c[d] && c[d].isNull && (v = m = w);
          "undefined" !== typeof v && (q.push({
            plotX: D,
            plotY: null === v ? b : e.getThreshold(v),
            isNull: k,
            isCliff: !0
          }), n.push({
            plotX: D,
            plotY: null === m ? b : e.getThreshold(m),
            doCurve: !1
          }));
        };
        c = c || this.points;
        f && (c = this.getStackPoints(c));
        for (h = 0; h < c.length; h++) {
          f || (c[h].leftCliff = c[h].rightCliff = c[h].leftNull = c[h].rightNull = void 0);
          var d = c[h].isNull;
          var D = m(c[h].rectPlotX, c[h].plotX);
          var C = f ? m(c[h].yBottom, b) : b;
          if (!d || g) g || v(h, h - 1, "left"), d && !f && g || (q.push(c[h]), n.push({
            x: h,
            plotX: D,
            plotY: C
          })), g || v(h, h + 1, "right");
        }
        h = a.call(this, q, !0, !0);
        n.reversed = !0;
        d = a.call(this, n, !0, !0);
        (C = d[0]) && "M" === C[0] && (d[0] = ["L", C[1], C[2]]);
        d = h.concat(d);
        d.length && d.push(["Z"]);
        a = a.call(this, q, !1, g);
        d.xMap = h.xMap;
        this.areaPath = d;
        return a;
      };
      c.prototype.getStackPoints = function (c) {
        var a = this,
          g = [],
          f = [],
          e = this.xAxis,
          h = this.yAxis,
          n = h.stacking.stacks[this.stackKey],
          x = {},
          p = h.series,
          l = p.length,
          w = h.options.reversedStacks ? 1 : -1,
          b = p.indexOf(a);
        c = c || this.points;
        if (this.options.stacking) {
          for (var v = 0; v < c.length; v++) c[v].leftNull = c[v].rightNull = void 0, x[c[v].x] = c[v];
          q(n, function (b, c) {
            null !== b.total && f.push(c);
          });
          f.sort(function (b, c) {
            return b - c;
          });
          var d = p.map(function (b) {
            return b.visible;
          });
          f.forEach(function (c, v) {
            var k = 0,
              q,
              C;
            if (x[c] && !x[c].isNull) g.push(x[c]), [-1, 1].forEach(function (e) {
              var k = 1 === e ? "rightNull" : "leftNull",
                g = 0,
                r = n[f[v + e]];
              if (r) for (var h = b; 0 <= h && h < l;) {
                var A = p[h].index;
                q = r.points[A];
                q || (A === a.index ? x[c][k] = !0 : d[h] && (C = n[c].points[A]) && (g -= C[1] - C[0]));
                h += w;
              }
              x[c][1 === e ? "rightCliff" : "leftCliff"] = g;
            });else {
              for (var r = b; 0 <= r && r < l;) {
                if (q = n[c].points[p[r].index]) {
                  k = q[1];
                  break;
                }
                r += w;
              }
              k = m(k, 0);
              k = h.translate(k, 0, 1, 0, 1);
              g.push({
                isNull: !0,
                plotX: e.translate(c, 0, 0, 0, 1),
                x: c,
                plotY: k,
                yBottom: k
              });
            }
          });
        }
        return g;
      };
      c.defaultOptions = x(I.defaultOptions, {
        threshold: 0
      });
      return c;
    }(I);
    a(H.prototype, {
      singleStacks: !1,
      drawLegendSymbol: t.drawRectangle
    });
    B.registerSeriesType("area", H);
    "";
    return H;
  });
  N(a, "Series/Spline/SplineSeries.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t) {
    var E = this && this.__extends || function () {
        var a = function (x, q) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, h) {
            a.__proto__ = h;
          } || function (a, h) {
            for (var c in h) h.hasOwnProperty(c) && (a[c] = h[c]);
          };
          return a(x, q);
        };
        return function (x, q) {
          function m() {
            this.constructor = x;
          }
          a(x, q);
          x.prototype = null === q ? Object.create(q) : (m.prototype = q.prototype, new m());
        };
      }(),
      H = a.seriesTypes.line,
      y = t.merge,
      F = t.pick;
    t = function (a) {
      function x() {
        var q = null !== a && a.apply(this, arguments) || this;
        q.data = void 0;
        q.options = void 0;
        q.points = void 0;
        return q;
      }
      E(x, a);
      x.prototype.getPointSpline = function (a, m, h) {
        var c = m.plotX || 0,
          n = m.plotY || 0,
          q = a[h - 1];
        h = a[h + 1];
        if (q && !q.isNull && !1 !== q.doCurve && !m.isCliff && h && !h.isNull && !1 !== h.doCurve && !m.isCliff) {
          a = q.plotY || 0;
          var g = h.plotX || 0;
          h = h.plotY || 0;
          var f = 0;
          var e = (1.5 * c + (q.plotX || 0)) / 2.5;
          var G = (1.5 * n + a) / 2.5;
          g = (1.5 * c + g) / 2.5;
          var J = (1.5 * n + h) / 2.5;
          g !== e && (f = (J - G) * (g - c) / (g - e) + n - J);
          G += f;
          J += f;
          G > a && G > n ? (G = Math.max(a, n), J = 2 * n - G) : G < a && G < n && (G = Math.min(a, n), J = 2 * n - G);
          J > h && J > n ? (J = Math.max(h, n), G = 2 * n - J) : J < h && J < n && (J = Math.min(h, n), G = 2 * n - J);
          m.rightContX = g;
          m.rightContY = J;
        }
        m = ["C", F(q.rightContX, q.plotX, 0), F(q.rightContY, q.plotY, 0), F(e, c, 0), F(G, n, 0), c, n];
        q.rightContX = q.rightContY = void 0;
        return m;
      };
      x.defaultOptions = y(H.defaultOptions);
      return x;
    }(H);
    a.registerSeriesType("spline", t);
    "";
    return t;
  });
  N(a, "Series/AreaSpline/AreaSplineSeries.js", [a["Series/Area/AreaSeries.js"], a["Series/Spline/SplineSeries.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t, B, H, y) {
    var E = this && this.__extends || function () {
        var a = function (h, c) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var g in c) c.hasOwnProperty(g) && (a[g] = c[g]);
          };
          return a(h, c);
        };
        return function (h, c) {
          function n() {
            this.constructor = h;
          }
          a(h, c);
          h.prototype = null === c ? Object.create(c) : (n.prototype = c.prototype, new n());
        };
      }(),
      I = a.prototype,
      x = y.extend,
      q = y.merge;
    y = function (m) {
      function h() {
        var a = null !== m && m.apply(this, arguments) || this;
        a.data = void 0;
        a.points = void 0;
        a.options = void 0;
        return a;
      }
      E(h, m);
      h.defaultOptions = q(t.defaultOptions, a.defaultOptions);
      return h;
    }(t);
    x(y.prototype, {
      getGraphPath: I.getGraphPath,
      getStackPoints: I.getStackPoints,
      drawGraph: I.drawGraph,
      drawLegendSymbol: B.drawRectangle
    });
    H.registerSeriesType("areaspline", y);
    "";
    return y;
  });
  N(a, "Series/Column/ColumnSeries.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F, I) {
    var x = this && this.__extends || function () {
        var a = function (c, b) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (b, a) {
            b.__proto__ = a;
          } || function (b, a) {
            for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);
          };
          return a(c, b);
        };
        return function (c, b) {
          function e() {
            this.constructor = c;
          }
          a(c, b);
          c.prototype = null === b ? Object.create(b) : (e.prototype = b.prototype, new e());
        };
      }(),
      q = a.animObject,
      m = t.parse,
      h = B.hasTouch;
    a = B.noop;
    var c = I.clamp,
      n = I.css,
      z = I.defined,
      g = I.extend,
      f = I.fireEvent,
      e = I.isArray,
      G = I.isNumber,
      J = I.merge,
      M = I.pick,
      p = I.objectEach;
    I = function (a) {
      function l() {
        var b = null !== a && a.apply(this, arguments) || this;
        b.borderWidth = void 0;
        b.data = void 0;
        b.group = void 0;
        b.options = void 0;
        b.points = void 0;
        return b;
      }
      x(l, a);
      l.prototype.animate = function (b) {
        var a = this,
          d = this.yAxis,
          e = a.options,
          f = this.chart.inverted,
          k = {},
          h = f ? "translateX" : "translateY";
        if (b) k.scaleY = .001, b = c(d.toPixels(e.threshold), d.pos, d.pos + d.len), f ? k.translateX = b - d.len : k.translateY = b, a.clipBox && a.setClip(), a.group.attr(k);else {
          var l = Number(a.group.attr(h));
          a.group.animate({
            scaleY: 1
          }, g(q(a.options.animation), {
            step: function (b, c) {
              a.group && (k[h] = l + c.pos * (d.pos - l), a.group.attr(k));
            }
          }));
        }
      };
      l.prototype.init = function (b, c) {
        a.prototype.init.apply(this, arguments);
        var d = this;
        b = d.chart;
        b.hasRendered && b.series.forEach(function (b) {
          b.type === d.type && (b.isDirty = !0);
        });
      };
      l.prototype.getColumnMetrics = function () {
        var b = this,
          a = b.options,
          c = b.xAxis,
          e = b.yAxis,
          f = c.options.reversedStacks;
        f = c.reversed && !f || !c.reversed && f;
        var k = {},
          g,
          h = 0;
        !1 === a.grouping ? h = 1 : b.chart.series.forEach(function (a) {
          var c = a.yAxis,
            d = a.options;
          if (a.type === b.type && (a.visible || !b.chart.options.chart.ignoreHiddenSeries) && e.len === c.len && e.pos === c.pos) {
            if (d.stacking && "group" !== d.stacking) {
              g = a.stackKey;
              "undefined" === typeof k[g] && (k[g] = h++);
              var f = k[g];
            } else !1 !== d.grouping && (f = h++);
            a.columnIndex = f;
          }
        });
        var r = Math.min(Math.abs(c.transA) * (c.ordinal && c.ordinal.slope || a.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),
          l = r * a.groupPadding,
          p = (r - 2 * l) / (h || 1);
        a = Math.min(a.maxPointWidth || c.len, M(a.pointWidth, p * (1 - 2 * a.pointPadding)));
        b.columnMetrics = {
          width: a,
          offset: (p - a) / 2 + (l + ((b.columnIndex || 0) + (f ? 1 : 0)) * p - r / 2) * (f ? -1 : 1),
          paddedWidth: p,
          columnCount: h
        };
        return b.columnMetrics;
      };
      l.prototype.crispCol = function (b, a, c, e) {
        var d = this.chart,
          f = this.borderWidth,
          g = -(f % 2 ? .5 : 0);
        f = f % 2 ? .5 : 1;
        d.inverted && d.renderer.isVML && (f += 1);
        this.options.crisp && (c = Math.round(b + c) + g, b = Math.round(b) + g, c -= b);
        e = Math.round(a + e) + f;
        g = .5 >= Math.abs(a) && .5 < e;
        a = Math.round(a) + f;
        e -= a;
        g && e && (--a, e += 1);
        return {
          x: b,
          y: a,
          width: c,
          height: e
        };
      };
      l.prototype.adjustForMissingColumns = function (b, a, c, f) {
        var d = this,
          k = this.options.stacking;
        if (!c.isNull && 1 < f.columnCount) {
          var g = 0,
            h = 0;
          p(this.yAxis.stacking && this.yAxis.stacking.stacks, function (b) {
            if ("number" === typeof c.x && (b = b[c.x.toString()])) {
              var a = b.points[d.index],
                f = b.total;
              k ? (a && (g = h), b.hasValidPoints && h++) : e(a) && (g = a[1], h = f || 0);
            }
          });
          b = (c.plotX || 0) + ((h - 1) * f.paddedWidth + a) / 2 - a - g * f.paddedWidth;
        }
        return b;
      };
      l.prototype.translate = function () {
        var b = this,
          a = b.chart,
          d = b.options,
          e = b.dense = 2 > b.closestPointRange * b.xAxis.transA;
        e = b.borderWidth = M(d.borderWidth, e ? 0 : 1);
        var f = b.xAxis,
          k = b.yAxis,
          g = d.threshold,
          h = b.translatedThreshold = k.getThreshold(g),
          r = M(d.minPointLength, 5),
          l = b.getColumnMetrics(),
          p = l.width,
          n = b.pointXOffset = l.offset,
          u = b.dataMin,
          m = b.dataMax,
          w = b.barW = Math.max(p, 1 + 2 * e);
        a.inverted && (h -= .5);
        d.pointPadding && (w = Math.ceil(w));
        y.prototype.translate.apply(b);
        b.points.forEach(function (e) {
          var A = M(e.yBottom, h),
            v = 999 + Math.abs(A),
            q = e.plotX || 0;
          v = c(e.plotY, -v, k.len + v);
          var C = Math.min(v, A),
            K = Math.max(v, A) - C,
            L = p,
            O = q + n,
            D = w;
          r && Math.abs(K) < r && (K = r, q = !k.reversed && !e.negative || k.reversed && e.negative, G(g) && G(m) && e.y === g && m <= g && (k.min || 0) < g && (u !== m || (k.max || 0) <= g) && (q = !q), C = Math.abs(C - h) > r ? A - r : h - (q ? r : 0));
          z(e.options.pointWidth) && (L = D = Math.ceil(e.options.pointWidth), O -= Math.round((L - p) / 2));
          d.centerInCategory && (O = b.adjustForMissingColumns(O, L, e, l));
          e.barX = O;
          e.pointWidth = L;
          e.tooltipPos = a.inverted ? [c(k.len + k.pos - a.plotLeft - v, k.pos - a.plotLeft, k.len + k.pos - a.plotLeft), f.len + f.pos - a.plotTop - O - D / 2, K] : [f.left - a.plotLeft + O + D / 2, c(v + k.pos - a.plotTop, k.pos - a.plotTop, k.len + k.pos - a.plotTop), K];
          e.shapeType = b.pointClass.prototype.shapeType || "rect";
          e.shapeArgs = b.crispCol.apply(b, e.isNull ? [O, h, D, 0] : [O, C, D, K]);
        });
      };
      l.prototype.drawGraph = function () {
        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
      };
      l.prototype.pointAttribs = function (b, a) {
        var c = this.options,
          e = this.pointAttrToOptions || {},
          f = e.stroke || "borderColor",
          k = e["stroke-width"] || "borderWidth",
          g = b && b.color || this.color,
          h = b && b[f] || c[f] || g;
        e = b && b.options.dashStyle || c.dashStyle;
        var r = b && b[k] || c[k] || this[k] || 0,
          l = M(b && b.opacity, c.opacity, 1);
        if (b && this.zones.length) {
          var p = b.getZone();
          g = b.options.color || p && (p.color || b.nonZonedColor) || this.color;
          p && (h = p.borderColor || h, e = p.dashStyle || e, r = p.borderWidth || r);
        }
        a && b && (b = J(c.states[a], b.options.states && b.options.states[a] || {}), a = b.brightness, g = b.color || "undefined" !== typeof a && m(g).brighten(b.brightness).get() || g, h = b[f] || h, r = b[k] || r, e = b.dashStyle || e, l = M(b.opacity, l));
        f = {
          fill: g,
          stroke: h,
          "stroke-width": r,
          opacity: l
        };
        e && (f.dashstyle = e);
        return f;
      };
      l.prototype.drawPoints = function () {
        var b = this,
          a = this.chart,
          c = b.options,
          e = a.renderer,
          f = c.animationLimit || 250,
          k;
        b.points.forEach(function (d) {
          var g = d.graphic,
            h = !!g,
            l = g && a.pointCount < f ? "animate" : "attr";
          if (G(d.plotY) && null !== d.y) {
            k = d.shapeArgs;
            g && d.hasNewShapeType() && (g = g.destroy());
            b.enabledDataSorting && (d.startXPos = b.xAxis.reversed ? -(k ? k.width || 0 : 0) : b.xAxis.width);
            g || (d.graphic = g = e[d.shapeType](k).add(d.group || b.group)) && b.enabledDataSorting && a.hasRendered && a.pointCount < f && (g.attr({
              x: d.startXPos
            }), h = !0, l = "animate");
            if (g && h) g[l](J(k));
            if (c.borderRadius) g[l]({
              r: c.borderRadius
            });
            a.styledMode || g[l](b.pointAttribs(d, d.selected && "select")).shadow(!1 !== d.allowShadow && c.shadow, null, c.stacking && !c.borderRadius);
            g && (g.addClass(d.getClassName(), !0), g.attr({
              visibility: d.visible ? "inherit" : "hidden"
            }));
          } else g && (d.graphic = g.destroy());
        });
      };
      l.prototype.drawTracker = function () {
        var b = this,
          a = b.chart,
          c = a.pointer,
          g = function (b) {
            var a = c.getPointFromEvent(b);
            "undefined" !== typeof a && (c.isDirectTouch = !0, a.onMouseOver(b));
          },
          l;
        b.points.forEach(function (b) {
          l = e(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];
          b.graphic && (b.graphic.element.point = b);
          l.forEach(function (a) {
            a.div ? a.div.point = b : a.element.point = b;
          });
        });
        b._hasTracking || (b.trackerGroups.forEach(function (d) {
          if (b[d]) {
            b[d].addClass("highcharts-tracker").on("mouseover", g).on("mouseout", function (b) {
              c.onTrackerMouseOut(b);
            });
            if (h) b[d].on("touchstart", g);
            !a.styledMode && b.options.cursor && b[d].css(n).css({
              cursor: b.options.cursor
            });
          }
        }), b._hasTracking = !0);
        f(this, "afterDrawTracker");
      };
      l.prototype.remove = function () {
        var b = this,
          a = b.chart;
        a.hasRendered && a.series.forEach(function (a) {
          a.type === b.type && (a.isDirty = !0);
        });
        y.prototype.remove.apply(b, arguments);
      };
      l.defaultOptions = J(y.defaultOptions, {
        borderRadius: 0,
        centerInCategory: !1,
        groupPadding: .2,
        marker: null,
        pointPadding: .1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
          hover: {
            halo: !1,
            brightness: .1
          },
          select: {
            color: "#cccccc",
            borderColor: "#000000"
          }
        },
        dataLabels: {
          align: void 0,
          verticalAlign: void 0,
          y: void 0
        },
        startFromThreshold: !0,
        stickyTracking: !1,
        tooltip: {
          distance: 6
        },
        threshold: 0,
        borderColor: "#ffffff"
      });
      return l;
    }(y);
    g(I.prototype, {
      cropShoulder: 0,
      directTouch: !0,
      drawLegendSymbol: H.drawRectangle,
      getSymbol: a,
      negStacks: !0,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    F.registerSeriesType("column", I);
    "";
    "";
    return I;
  });
  N(a, "Core/Series/DataLabel.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = a.getDeferredAnimation,
      y = t.format,
      F = B.defined,
      I = B.extend,
      x = B.fireEvent,
      q = B.isArray,
      m = B.merge,
      h = B.objectEach,
      c = B.pick,
      n = B.splat,
      z;
    (function (a) {
      function f(a, b, e, d, f) {
        var g = this,
          k = this.chart,
          h = this.isCartesian && k.inverted,
          l = this.enabledDataSorting,
          r = c(a.dlBox && a.dlBox.centerX, a.plotX, -9999),
          p = c(a.plotY, -9999),
          n = b.getBBox(),
          m = e.rotation,
          u = e.align,
          w = k.isInsidePlot(r, Math.round(p), {
            inverted: h,
            paneCoordinates: !0,
            series: g
          }),
          v = function (c) {
            l && g.xAxis && !q && g.setDataLabelStartPos(a, b, f, w, c);
          },
          q = "justify" === c(e.overflow, l ? "none" : "justify"),
          z = this.visible && !1 !== a.visible && (a.series.forceDL || l && !q || w || c(e.inside, !!this.options.stacking) && d && k.isInsidePlot(r, h ? d.x + 1 : d.y + d.height - 1, {
            inverted: h,
            paneCoordinates: !0,
            series: g
          }));
        if (z) {
          var G = k.renderer.fontMetrics(k.styledMode ? void 0 : e.style.fontSize, b).b;
          d = I({
            x: h ? this.yAxis.len - p : r,
            y: Math.round(h ? this.xAxis.len - r : p),
            width: 0,
            height: 0
          }, d);
          I(e, {
            width: n.width,
            height: n.height
          });
          m ? (q = !1, r = k.renderer.rotCorr(G, m), r = {
            x: d.x + (e.x || 0) + d.width / 2 + r.x,
            y: d.y + (e.y || 0) + {
              top: 0,
              middle: .5,
              bottom: 1
            }[e.verticalAlign] * d.height
          }, v(r), b[f ? "attr" : "animate"](r).attr({
            align: u
          }), v = (m + 720) % 360, v = 180 < v && 360 > v, "left" === u ? r.y -= v ? n.height : 0 : "center" === u ? (r.x -= n.width / 2, r.y -= n.height / 2) : "right" === u && (r.x -= n.width, r.y -= v ? 0 : n.height), b.placed = !0, b.alignAttr = r) : (v(d), b.align(e, void 0, d), r = b.alignAttr);
          q && 0 <= d.height ? this.justifyDataLabel(b, e, r, n, d, f) : c(e.crop, !0) && (z = k.isInsidePlot(r.x, r.y, {
            paneCoordinates: !0,
            series: g
          }) && k.isInsidePlot(r.x + n.width, r.y + n.height, {
            paneCoordinates: !0,
            series: g
          }));
          if (e.shape && !m) b[f ? "attr" : "animate"]({
            anchorX: h ? k.plotWidth - a.plotY : a.plotX,
            anchorY: h ? k.plotHeight - a.plotX : a.plotY
          });
        }
        f && l && (b.placed = !1);
        z || l && !q || (b.hide(!0), b.placed = !1);
      }
      function e(a, b) {
        var c = b.filter;
        return c ? (b = c.operator, a = a[c.property], c = c.value, ">" === b && a > c || "<" === b && a < c || ">=" === b && a >= c || "<=" === b && a <= c || "==" === b && a == c || "===" === b && a === c ? !0 : !1) : !0;
      }
      function g() {
        var a = this,
          b = a.chart,
          f = a.options,
          d = a.points,
          g = a.hasRendered || 0,
          l = b.renderer,
          k = f.dataLabels,
          p,
          m = k.animation;
        m = k.defer ? E(b, m, a) : {
          defer: 0,
          duration: 0
        };
        k = t(t(b.options.plotOptions && b.options.plotOptions.series && b.options.plotOptions.series.dataLabels, b.options.plotOptions && b.options.plotOptions[a.type] && b.options.plotOptions[a.type].dataLabels), k);
        x(this, "drawDataLabels");
        if (q(k) || k.enabled || a._hasPointLabels) {
          var r = a.plotGroup("dataLabelsGroup", "data-labels", g ? "inherit" : "hidden", k.zIndex || 6);
          r.attr({
            opacity: +g
          });
          !g && (g = a.dataLabelsGroup) && (a.visible && r.show(!0), g[f.animation ? "animate" : "attr"]({
            opacity: 1
          }, m));
          d.forEach(function (d) {
            p = n(t(k, d.dlOptions || d.options && d.options.dataLabels));
            p.forEach(function (k, g) {
              var p = k.enabled && (!d.isNull || d.dataLabelOnNull) && e(d, k),
                n = d.connectors ? d.connectors[g] : d.connector,
                m = d.dataLabels ? d.dataLabels[g] : d.dataLabel,
                A = c(k.distance, d.labelDistance),
                q = !m;
              if (p) {
                var v = d.getLabelConfig();
                var w = c(k[d.formatPrefix + "Format"], k.format);
                v = F(w) ? y(w, v, b) : (k[d.formatPrefix + "Formatter"] || k.formatter).call(v, k);
                w = k.style;
                var z = k.rotation;
                b.styledMode || (w.color = c(k.color, w.color, a.color, "#000000"), "contrast" === w.color ? (d.contrastColor = l.getContrast(d.color || a.color), w.color = !F(A) && k.inside || 0 > A || f.stacking ? d.contrastColor : "#000000") : delete d.contrastColor, f.cursor && (w.cursor = f.cursor));
                var C = {
                  r: k.borderRadius || 0,
                  rotation: z,
                  padding: k.padding,
                  zIndex: 1
                };
                b.styledMode || (C.fill = k.backgroundColor, C.stroke = k.borderColor, C["stroke-width"] = k.borderWidth);
                h(C, function (b, a) {
                  "undefined" === typeof b && delete C[a];
                });
              }
              !m || p && F(v) && !!m.div === !!k.useHTML || (d.dataLabel = m = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[g]), g || delete d.dataLabel, n && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[g])));
              p && F(v) && (m ? C.text = v : (d.dataLabels = d.dataLabels || [], m = d.dataLabels[g] = z ? l.text(v, 0, -9999, k.useHTML).addClass("highcharts-data-label") : l.label(v, 0, -9999, k.shape, null, null, k.useHTML, null, "data-label"), g || (d.dataLabel = m), m.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (k.className || "") + (k.useHTML ? " highcharts-tracker" : ""))), m.options = k, m.attr(C), b.styledMode || m.css(w).shadow(k.shadow), m.added || m.add(r), k.textPath && !k.useHTML && (m.setTextPath(d.getDataLabelPath && d.getDataLabelPath(m) || d.graphic, k.textPath), d.dataLabelPath && !k.textPath.enabled && (d.dataLabelPath = d.dataLabelPath.destroy())), a.alignDataLabel(d, m, k, null, q));
            });
          });
        }
        x(this, "afterDrawDataLabels");
      }
      function z(a, b, c, d, e, f) {
        var k = this.chart,
          g = b.align,
          h = b.verticalAlign,
          r = a.box ? 0 : a.padding || 0,
          l = b.x;
        l = void 0 === l ? 0 : l;
        var p = b.y;
        p = void 0 === p ? 0 : p;
        var n = (c.x || 0) + r;
        if (0 > n) {
          "right" === g && 0 <= l ? (b.align = "left", b.inside = !0) : l -= n;
          var u = !0;
        }
        n = (c.x || 0) + d.width - r;
        n > k.plotWidth && ("left" === g && 0 >= l ? (b.align = "right", b.inside = !0) : l += k.plotWidth - n, u = !0);
        n = c.y + r;
        0 > n && ("bottom" === h && 0 <= p ? (b.verticalAlign = "top", b.inside = !0) : p -= n, u = !0);
        n = (c.y || 0) + d.height - r;
        n > k.plotHeight && ("top" === h && 0 >= p ? (b.verticalAlign = "bottom", b.inside = !0) : p += k.plotHeight - n, u = !0);
        u && (b.x = l, b.y = p, a.placed = !f, a.align(b, void 0, e));
        return u;
      }
      function t(a, b) {
        var c = [],
          d;
        if (q(a) && !q(b)) c = a.map(function (a) {
          return m(a, b);
        });else if (q(b) && !q(a)) c = b.map(function (b) {
          return m(a, b);
        });else if (q(a) || q(b)) for (d = Math.max(a.length, b.length); d--;) c[d] = m(a[d], b[d]);else c = m(a, b);
        return c;
      }
      function p(a, b, c, d, e) {
        var f = this.chart,
          k = f.inverted,
          g = this.xAxis,
          h = g.reversed,
          l = k ? b.height / 2 : b.width / 2;
        a = (a = a.pointWidth) ? a / 2 : 0;
        b.startXPos = k ? e.x : h ? -l - a : g.width - l + a;
        b.startYPos = k ? h ? this.yAxis.height - l + a : -l - a : e.y;
        d ? "hidden" === b.visibility && (b.show(), b.attr({
          opacity: 0
        }).animate({
          opacity: 1
        })) : b.attr({
          opacity: 1
        }).animate({
          opacity: 0
        }, void 0, b.hide);
        f.hasRendered && (c && b.attr({
          x: b.startXPos,
          y: b.startYPos
        }), b.placed = !0);
      }
      var l = [];
      a.compose = function (a) {
        if (-1 === l.indexOf(a)) {
          var b = a.prototype;
          l.push(a);
          b.alignDataLabel = f;
          b.drawDataLabels = g;
          b.justifyDataLabel = z;
          b.setDataLabelStartPos = p;
        }
      };
    })(z || (z = {}));
    "";
    return z;
  });
  N(a, "Series/Column/ColumnDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = t.series,
      y = B.merge,
      F = B.pick,
      I;
    (function (x) {
      function q(a, c, n, m, g) {
        var f = this.chart.inverted,
          e = a.series,
          h = (e.xAxis ? e.xAxis.len : this.chart.plotSizeX) || 0;
        e = (e.yAxis ? e.yAxis.len : this.chart.plotSizeY) || 0;
        var q = a.dlBox || a.shapeArgs,
          z = F(a.below, a.plotY > F(this.translatedThreshold, e)),
          p = F(n.inside, !!this.options.stacking);
        q && (m = y(q), 0 > m.y && (m.height += m.y, m.y = 0), q = m.y + m.height - e, 0 < q && q < m.height && (m.height -= q), f && (m = {
          x: e - m.y - m.height,
          y: h - m.x - m.width,
          width: m.height,
          height: m.width
        }), p || (f ? (m.x += z ? 0 : m.width, m.width = 0) : (m.y += z ? m.height : 0, m.height = 0)));
        n.align = F(n.align, !f || p ? "center" : z ? "right" : "left");
        n.verticalAlign = F(n.verticalAlign, f || p ? "middle" : z ? "top" : "bottom");
        E.prototype.alignDataLabel.call(this, a, c, n, m, g);
        n.inside && a.contrastColor && c.css({
          color: a.contrastColor
        });
      }
      var m = [];
      x.compose = function (h) {
        a.compose(E);
        -1 === m.indexOf(h) && (m.push(h), h.prototype.alignDataLabel = q);
      };
    })(I || (I = {}));
    return I;
  });
  N(a, "Series/Bar/BarSeries.js", [a["Series/Column/ColumnSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = this && this.__extends || function () {
        var a = function (x, q) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, h) {
            a.__proto__ = h;
          } || function (a, h) {
            for (var c in h) h.hasOwnProperty(c) && (a[c] = h[c]);
          };
          return a(x, q);
        };
        return function (x, q) {
          function m() {
            this.constructor = x;
          }
          a(x, q);
          x.prototype = null === q ? Object.create(q) : (m.prototype = q.prototype, new m());
        };
      }(),
      y = B.extend,
      F = B.merge;
    B = function (t) {
      function x() {
        var a = null !== t && t.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      E(x, t);
      x.defaultOptions = F(a.defaultOptions, {});
      return x;
    }(a);
    y(B.prototype, {
      inverted: !0
    });
    t.registerSeriesType("bar", B);
    "";
    return B;
  });
  N(a, "Series/Scatter/ScatterSeries.js", [a["Series/Column/ColumnSeries.js"], a["Series/Line/LineSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t, B, H) {
    var E = this && this.__extends || function () {
        var a = function (m, h) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, h) {
            a.__proto__ = h;
          } || function (a, h) {
            for (var c in h) h.hasOwnProperty(c) && (a[c] = h[c]);
          };
          return a(m, h);
        };
        return function (m, h) {
          function c() {
            this.constructor = m;
          }
          a(m, h);
          m.prototype = null === h ? Object.create(h) : (c.prototype = h.prototype, new c());
        };
      }(),
      F = H.addEvent,
      I = H.extend,
      x = H.merge;
    H = function (a) {
      function m() {
        var h = null !== a && a.apply(this, arguments) || this;
        h.data = void 0;
        h.options = void 0;
        h.points = void 0;
        return h;
      }
      E(m, a);
      m.prototype.applyJitter = function () {
        var a = this,
          c = this.options.jitter,
          n = this.points.length;
        c && this.points.forEach(function (h, g) {
          ["x", "y"].forEach(function (f, e) {
            var m = "plot" + f.toUpperCase();
            if (c[f] && !h.isNull) {
              var q = a[f + "Axis"];
              var z = c[f] * q.transA;
              if (q && !q.isLog) {
                var p = Math.max(0, h[m] - z);
                q = Math.min(q.len, h[m] + z);
                e = 1E4 * Math.sin(g + e * n);
                h[m] = p + (q - p) * (e - Math.floor(e));
                "x" === f && (h.clientX = h.plotX);
              }
            }
          });
        });
      };
      m.prototype.drawGraph = function () {
        this.options.lineWidth ? a.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
      };
      m.defaultOptions = x(t.defaultOptions, {
        lineWidth: 0,
        findNearestPointBy: "xy",
        jitter: {
          x: 0,
          y: 0
        },
        marker: {
          enabled: !0
        },
        tooltip: {
          headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
          pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
        }
      });
      return m;
    }(t);
    I(H.prototype, {
      drawTracker: a.prototype.drawTracker,
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1
    });
    F(H, "afterTranslate", function () {
      this.applyJitter();
    });
    B.registerSeriesType("scatter", H);
    "";
    return H;
  });
  N(a, "Series/CenteredUtilities.js", [a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = a.deg2rad,
      y = B.isNumber,
      F = B.pick,
      I = B.relativeLength,
      x;
    (function (a) {
      a.getCenter = function () {
        var a = this.options,
          h = this.chart,
          c = 2 * (a.slicedOffset || 0),
          n = h.plotWidth - 2 * c,
          q = h.plotHeight - 2 * c,
          g = a.center,
          f = Math.min(n, q),
          e = a.size,
          G = a.innerSize || 0;
        "string" === typeof e && (e = parseFloat(e));
        "string" === typeof G && (G = parseFloat(G));
        a = [F(g[0], "50%"), F(g[1], "50%"), F(e && 0 > e ? void 0 : a.size, "100%"), F(G && 0 > G ? void 0 : a.innerSize || 0, "0%")];
        !h.angular || this instanceof t || (a[3] = 0);
        for (g = 0; 4 > g; ++g) e = a[g], h = 2 > g || 2 === g && /%$/.test(e), a[g] = I(e, [n, q, f, a[2]][g]) + (h ? c : 0);
        a[3] > a[2] && (a[3] = a[2]);
        return a;
      };
      a.getStartAndEndRadians = function (a, h) {
        a = y(a) ? a : 0;
        h = y(h) && h > a && 360 > h - a ? h : a + 360;
        return {
          start: E * (a + -90),
          end: E * (h + -90)
        };
      };
    })(x || (x = {}));
    "";
    return x;
  });
  N(a, "Series/Pie/PiePoint.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = this && this.__extends || function () {
        var a = function (c, h) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);
          };
          return a(c, h);
        };
        return function (c, h) {
          function n() {
            this.constructor = c;
          }
          a(c, h);
          c.prototype = null === h ? Object.create(h) : (n.prototype = h.prototype, new n());
        };
      }(),
      y = a.setAnimation,
      F = B.addEvent,
      I = B.defined;
    a = B.extend;
    var x = B.isNumber,
      q = B.pick,
      m = B.relativeLength;
    t = function (a) {
      function c() {
        var c = null !== a && a.apply(this, arguments) || this;
        c.labelDistance = void 0;
        c.options = void 0;
        c.series = void 0;
        return c;
      }
      E(c, a);
      c.prototype.getConnectorPath = function () {
        var a = this.labelPosition,
          c = this.series.options.dataLabels,
          g = this.connectorShapes,
          f = c.connectorShape;
        g[f] && (f = g[f]);
        return f.call(this, {
          x: a.final.x,
          y: a.final.y,
          alignment: a.alignment
        }, a.connectorPosition, c);
      };
      c.prototype.getTranslate = function () {
        return this.sliced ? this.slicedTranslation : {
          translateX: 0,
          translateY: 0
        };
      };
      c.prototype.haloPath = function (a) {
        var c = this.shapeArgs;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {
          innerR: c.r - 1,
          start: c.start,
          end: c.end
        });
      };
      c.prototype.init = function () {
        var c = this;
        a.prototype.init.apply(this, arguments);
        this.name = q(this.name, "Slice");
        var h = function (a) {
          c.slice("select" === a.type);
        };
        F(this, "select", h);
        F(this, "unselect", h);
        return this;
      };
      c.prototype.isValid = function () {
        return x(this.y) && 0 <= this.y;
      };
      c.prototype.setVisible = function (a, c) {
        var g = this,
          f = this.series,
          e = f.chart,
          h = f.options.ignoreHiddenPoint;
        c = q(c, h);
        a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a, f.options.data[f.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (c) {
          if (g[c]) g[c][a ? "show" : "hide"](a);
        }), this.legendItem && e.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""), h && (f.isDirty = !0), c && e.redraw());
      };
      c.prototype.slice = function (a, c, g) {
        var f = this.series;
        y(g, f.chart);
        q(c, !0);
        this.sliced = this.options.sliced = I(a) ? a : !this.sliced;
        f.options.data[f.data.indexOf(this)] = this.options;
        this.graphic && this.graphic.animate(this.getTranslate());
        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
      };
      return c;
    }(t);
    a(t.prototype, {
      connectorShapes: {
        fixedOffset: function (a, c, n) {
          var h = c.breakAt;
          c = c.touchingSliceAt;
          return [["M", a.x, a.y], n.softConnector ? ["C", a.x + ("left" === a.alignment ? -5 : 5), a.y, 2 * h.x - c.x, 2 * h.y - c.y, h.x, h.y] : ["L", h.x, h.y], ["L", c.x, c.y]];
        },
        straight: function (a, c) {
          c = c.touchingSliceAt;
          return [["M", a.x, a.y], ["L", c.x, c.y]];
        },
        crookedLine: function (a, c, n) {
          c = c.touchingSliceAt;
          var h = this.series,
            g = h.center[0],
            f = h.chart.plotWidth,
            e = h.chart.plotLeft;
          h = a.alignment;
          var q = this.shapeArgs.r;
          n = m(n.crookDistance, 1);
          f = "left" === h ? g + q + (f + e - g - q) * (1 - n) : e + (g - q) * n;
          n = ["L", f, a.y];
          g = !0;
          if ("left" === h ? f > a.x || f < c.x : f < a.x || f > c.x) g = !1;
          a = [["M", a.x, a.y]];
          g && a.push(n);
          a.push(["L", c.x, c.y]);
          return a;
        }
      }
    });
    return t;
  });
  N(a, "Series/Pie/PieSeries.js", [a["Series/CenteredUtilities.js"], a["Series/Column/ColumnSeries.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Series/Pie/PiePoint.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F, I, x, q) {
    var m = this && this.__extends || function () {
        var a = function (c, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
          };
          return a(c, e);
        };
        return function (c, e) {
          function f() {
            this.constructor = c;
          }
          a(c, e);
          c.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
        };
      }(),
      h = a.getStartAndEndRadians;
    B = B.noop;
    var c = q.clamp,
      n = q.extend,
      z = q.fireEvent,
      g = q.merge,
      f = q.pick,
      e = q.relativeLength;
    q = function (a) {
      function n() {
        var c = null !== a && a.apply(this, arguments) || this;
        c.center = void 0;
        c.data = void 0;
        c.maxLabelDistance = void 0;
        c.options = void 0;
        c.points = void 0;
        return c;
      }
      m(n, a);
      n.prototype.animate = function (a) {
        var c = this,
          e = c.points,
          g = c.startAngleRad;
        a || e.forEach(function (b) {
          var a = b.graphic,
            d = b.shapeArgs;
          a && d && (a.attr({
            r: f(b.startR, c.center && c.center[3] / 2),
            start: g,
            end: g
          }), a.animate({
            r: d.r,
            start: d.start,
            end: d.end
          }, c.options.animation));
        });
      };
      n.prototype.drawEmpty = function () {
        var a = this.startAngleRad,
          c = this.endAngleRad,
          e = this.options;
        if (0 === this.total && this.center) {
          var f = this.center[0];
          var b = this.center[1];
          this.graph || (this.graph = this.chart.renderer.arc(f, b, this.center[1] / 2, 0, a, c).addClass("highcharts-empty-series").add(this.group));
          this.graph.attr({
            d: x.arc(f, b, this.center[2] / 2, 0, {
              start: a,
              end: c,
              innerR: this.center[3] / 2
            })
          });
          this.chart.styledMode || this.graph.attr({
            "stroke-width": e.borderWidth,
            fill: e.fillColor || "none",
            stroke: e.color || "#cccccc"
          });
        } else this.graph && (this.graph = this.graph.destroy());
      };
      n.prototype.drawPoints = function () {
        var a = this.chart.renderer;
        this.points.forEach(function (c) {
          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
          c.graphic || (c.graphic = a[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
        });
      };
      n.prototype.generatePoints = function () {
        a.prototype.generatePoints.call(this);
        this.updateTotals();
      };
      n.prototype.getX = function (a, e, f) {
        var g = this.center,
          b = this.radii ? this.radii[f.index] || 0 : g[2] / 2;
        a = Math.asin(c((a - g[1]) / (b + f.labelDistance), -1, 1));
        return g[0] + (e ? -1 : 1) * Math.cos(a) * (b + f.labelDistance) + (0 < f.labelDistance ? (e ? -1 : 1) * this.options.dataLabels.padding : 0);
      };
      n.prototype.hasData = function () {
        return !!this.processedXData.length;
      };
      n.prototype.redrawPoints = function () {
        var a = this,
          c = a.chart,
          e = c.renderer,
          f = a.options.shadow,
          b,
          h,
          d,
          n;
        this.drawEmpty();
        !f || a.shadowGroup || c.styledMode || (a.shadowGroup = e.g("shadow").attr({
          zIndex: -1
        }).add(a.group));
        a.points.forEach(function (l) {
          var k = {};
          h = l.graphic;
          if (!l.isNull && h) {
            var p = void 0;
            n = l.shapeArgs;
            b = l.getTranslate();
            c.styledMode || (p = l.shadowGroup, f && !p && (p = l.shadowGroup = e.g("shadow").add(a.shadowGroup)), p && p.attr(b), d = a.pointAttribs(l, l.selected && "select"));
            l.delayedRendering ? (h.setRadialReference(a.center).attr(n).attr(b), c.styledMode || h.attr(d).attr({
              "stroke-linejoin": "round"
            }).shadow(f, p), l.delayedRendering = !1) : (h.setRadialReference(a.center), c.styledMode || g(!0, k, d), g(!0, k, n, b), h.animate(k));
            h.attr({
              visibility: l.visible ? "inherit" : "hidden"
            });
            h.addClass(l.getClassName(), !0);
          } else h && (l.graphic = h.destroy());
        });
      };
      n.prototype.sortByAngle = function (a, c) {
        a.sort(function (a, e) {
          return "undefined" !== typeof a.angle && (e.angle - a.angle) * c;
        });
      };
      n.prototype.translate = function (a) {
        this.generatePoints();
        var c = this.options,
          g = c.slicedOffset,
          n = g + (c.borderWidth || 0),
          b = h(c.startAngle, c.endAngle),
          m = this.startAngleRad = b.start;
        b = (this.endAngleRad = b.end) - m;
        var d = this.points,
          q = c.dataLabels.distance;
        c = c.ignoreHiddenPoint;
        var C = d.length,
          k,
          K = 0;
        a || (this.center = a = this.getCenter());
        for (k = 0; k < C; k++) {
          var G = d[k];
          var r = m + K * b;
          !G.isValid() || c && !G.visible || (K += G.percentage / 100);
          var A = m + K * b;
          var x = {
            x: a[0],
            y: a[1],
            r: a[2] / 2,
            innerR: a[3] / 2,
            start: Math.round(1E3 * r) / 1E3,
            end: Math.round(1E3 * A) / 1E3
          };
          G.shapeType = "arc";
          G.shapeArgs = x;
          G.labelDistance = f(G.options.dataLabels && G.options.dataLabels.distance, q);
          G.labelDistance = e(G.labelDistance, x.r);
          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, G.labelDistance);
          A = (A + r) / 2;
          A > 1.5 * Math.PI ? A -= 2 * Math.PI : A < -Math.PI / 2 && (A += 2 * Math.PI);
          G.slicedTranslation = {
            translateX: Math.round(Math.cos(A) * g),
            translateY: Math.round(Math.sin(A) * g)
          };
          x = Math.cos(A) * a[2] / 2;
          var t = Math.sin(A) * a[2] / 2;
          G.tooltipPos = [a[0] + .7 * x, a[1] + .7 * t];
          G.half = A < -Math.PI / 2 || A > Math.PI / 2 ? 1 : 0;
          G.angle = A;
          r = Math.min(n, G.labelDistance / 5);
          G.labelPosition = {
            natural: {
              x: a[0] + x + Math.cos(A) * G.labelDistance,
              y: a[1] + t + Math.sin(A) * G.labelDistance
            },
            "final": {},
            alignment: 0 > G.labelDistance ? "center" : G.half ? "right" : "left",
            connectorPosition: {
              breakAt: {
                x: a[0] + x + Math.cos(A) * r,
                y: a[1] + t + Math.sin(A) * r
              },
              touchingSliceAt: {
                x: a[0] + x,
                y: a[1] + t
              }
            }
          };
        }
        z(this, "afterTranslate");
      };
      n.prototype.updateTotals = function () {
        var a = this.points,
          c = a.length,
          e = this.options.ignoreHiddenPoint,
          f,
          b = 0;
        for (f = 0; f < c; f++) {
          var g = a[f];
          !g.isValid() || e && !g.visible || (b += g.y);
        }
        this.total = b;
        for (f = 0; f < c; f++) g = a[f], g.percentage = 0 < b && (g.visible || !e) ? g.y / b * 100 : 0, g.total = b;
      };
      n.defaultOptions = g(F.defaultOptions, {
        center: [null, null],
        clip: !1,
        colorByPoint: !0,
        dataLabels: {
          allowOverlap: !0,
          connectorPadding: 5,
          connectorShape: "fixedOffset",
          crookDistance: "70%",
          distance: 30,
          enabled: !0,
          formatter: function () {
            return this.point.isNull ? void 0 : this.point.name;
          },
          softConnector: !0,
          x: 0
        },
        fillColor: void 0,
        ignoreHiddenPoint: !0,
        inactiveOtherPoints: !0,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: !1,
        slicedOffset: 10,
        stickyTracking: !1,
        tooltip: {
          followPointer: !0
        },
        borderColor: "#ffffff",
        borderWidth: 1,
        lineWidth: void 0,
        states: {
          hover: {
            brightness: .1
          }
        }
      });
      return n;
    }(F);
    n(q.prototype, {
      axisTypes: [],
      directTouch: !0,
      drawGraph: void 0,
      drawLegendSymbol: H.drawRectangle,
      drawTracker: t.prototype.drawTracker,
      getCenter: a.getCenter,
      getSymbol: B,
      isCartesian: !1,
      noSharedTooltip: !0,
      pointAttribs: t.prototype.pointAttribs,
      pointClass: y,
      requireSorting: !1,
      searchPoint: B,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    I.registerSeriesType("pie", q);
    "";
    return q;
  });
  N(a, "Series/Pie/PieDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Globals.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t, B, H, y) {
    var E = t.noop,
      I = B.distribute,
      x = H.series,
      q = y.arrayMax,
      m = y.clamp,
      h = y.defined,
      c = y.merge,
      n = y.pick,
      z = y.relativeLength,
      g;
    (function (f) {
      function e() {
        var a = this,
          e = a.data,
          b = a.chart,
          f = a.options.dataLabels || {},
          d = f.connectorPadding,
          g = b.plotWidth,
          p = b.plotHeight,
          k = b.plotLeft,
          m = Math.round(b.chartWidth / 3),
          G = a.center,
          r = G[2] / 2,
          A = G[1],
          z = [[], []],
          t = [0, 0, 0, 0],
          u = a.dataLabelPositioners,
          L,
          J,
          E,
          y,
          F,
          M,
          B,
          H,
          N,
          T,
          W,
          S;
        a.visible && (f.enabled || a._hasPointLabels) && (e.forEach(function (b) {
          b.dataLabel && b.visible && b.dataLabel.shortened && (b.dataLabel.attr({
            width: "auto"
          }).css({
            width: "auto",
            textOverflow: "clip"
          }), b.dataLabel.shortened = !1);
        }), x.prototype.drawDataLabels.apply(a), e.forEach(function (b) {
          b.dataLabel && (b.visible ? (z[b.half].push(b), b.dataLabel._pos = null, !h(f.style.width) && !h(b.options.dataLabels && b.options.dataLabels.style && b.options.dataLabels.style.width) && b.dataLabel.getBBox().width > m && (b.dataLabel.css({
            width: Math.round(.7 * m) + "px"
          }), b.dataLabel.shortened = !0)) : (b.dataLabel = b.dataLabel.destroy(), b.dataLabels && 1 === b.dataLabels.length && delete b.dataLabels));
        }), z.forEach(function (c, e) {
          var l = c.length,
            m = [],
            q;
          if (l) {
            a.sortByAngle(c, e - .5);
            if (0 < a.maxLabelDistance) {
              var v = Math.max(0, A - r - a.maxLabelDistance);
              var w = Math.min(A + r + a.maxLabelDistance, b.plotHeight);
              c.forEach(function (a) {
                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, A - r - a.labelDistance), a.bottom = Math.min(A + r + a.labelDistance, b.plotHeight), q = a.dataLabel.getBBox().height || 21, a.distributeBox = {
                  target: a.labelPosition.natural.y - a.top + q / 2,
                  size: q,
                  rank: a.y
                }, m.push(a.distributeBox));
              });
              v = w + q - v;
              I(m, v, v / 5);
            }
            for (W = 0; W < l; W++) {
              L = c[W];
              M = L.labelPosition;
              y = L.dataLabel;
              T = !1 === L.visible ? "hidden" : "inherit";
              N = v = M.natural.y;
              m && h(L.distributeBox) && ("undefined" === typeof L.distributeBox.pos ? T = "hidden" : (B = L.distributeBox.size, N = u.radialDistributionY(L)));
              delete L.positionIndex;
              if (f.justify) H = u.justify(L, r, G);else switch (f.alignTo) {
                case "connectors":
                  H = u.alignToConnectors(c, e, g, k);
                  break;
                case "plotEdges":
                  H = u.alignToPlotEdges(y, e, g, k);
                  break;
                default:
                  H = u.radialDistributionX(a, L, N, v);
              }
              y._attr = {
                visibility: T,
                align: M.alignment
              };
              S = L.options.dataLabels || {};
              y._pos = {
                x: H + n(S.x, f.x) + ({
                  left: d,
                  right: -d
                }[M.alignment] || 0),
                y: N + n(S.y, f.y) - 10
              };
              M.final.x = H;
              M.final.y = N;
              n(f.crop, !0) && (F = y.getBBox().width, v = null, H - F < d && 1 === e ? (v = Math.round(F - H + d), t[3] = Math.max(v, t[3])) : H + F > g - d && 0 === e && (v = Math.round(H + F - g + d), t[1] = Math.max(v, t[1])), 0 > N - B / 2 ? t[0] = Math.max(Math.round(-N + B / 2), t[0]) : N + B / 2 > p && (t[2] = Math.max(Math.round(N + B / 2 - p), t[2])), y.sideOverflow = v);
            }
          }
        }), 0 === q(t) || this.verifyDataLabelOverflow(t)) && (this.placeDataLabels(), this.points.forEach(function (d) {
          S = c(f, d.options.dataLabels);
          if (J = n(S.connectorWidth, 1)) {
            var e;
            E = d.connector;
            if ((y = d.dataLabel) && y._pos && d.visible && 0 < d.labelDistance) {
              T = y._attr.visibility;
              if (e = !E) d.connector = E = b.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + d.colorIndex + (d.className ? " " + d.className : "")).add(a.dataLabelsGroup), b.styledMode || E.attr({
                "stroke-width": J,
                stroke: S.connectorColor || d.color || "#666666"
              });
              E[e ? "attr" : "animate"]({
                d: d.getConnectorPath()
              });
              E.attr("visibility", T);
            } else E && (d.connector = E.destroy());
          }
        }));
      }
      function g() {
        this.points.forEach(function (a) {
          var c = a.dataLabel,
            b;
          c && a.visible && ((b = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
            width: c._attr.width + "px",
            textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
          }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](b), c.moved = !0) : c && c.attr({
            y: -9999
          }));
          delete a.distributeBox;
        }, this);
      }
      function t(a) {
        var c = this.center,
          b = this.options,
          e = b.center,
          d = b.minSize || 80,
          f = null !== b.size;
        if (!f) {
          if (null !== e[0]) var g = Math.max(c[2] - Math.max(a[1], a[3]), d);else g = Math.max(c[2] - a[1] - a[3], d), c[0] += (a[3] - a[1]) / 2;
          null !== e[1] ? g = m(g, d, c[2] - Math.max(a[0], a[2])) : (g = m(g, d, c[2] - a[0] - a[2]), c[1] += (a[0] - a[2]) / 2);
          g < c[2] ? (c[2] = g, c[3] = Math.min(z(b.innerSize || 0, g), g), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : f = !0;
        }
        return f;
      }
      var y = [],
        p = {
          radialDistributionY: function (a) {
            return a.top + a.distributeBox.pos;
          },
          radialDistributionX: function (a, c, b, e) {
            return a.getX(b < c.top + 2 || b > c.bottom - 2 ? e : b, c.half, c);
          },
          justify: function (a, c, b) {
            return b[0] + (a.half ? -1 : 1) * (c + a.labelDistance);
          },
          alignToPlotEdges: function (a, c, b, e) {
            a = a.getBBox().width;
            return c ? a + e : b - a - e;
          },
          alignToConnectors: function (a, c, b, e) {
            var d = 0,
              f;
            a.forEach(function (b) {
              f = b.dataLabel.getBBox().width;
              f > d && (d = f);
            });
            return c ? d + e : b - d - e;
          }
        };
      f.compose = function (c) {
        a.compose(x);
        -1 === y.indexOf(c) && (y.push(c), c = c.prototype, c.dataLabelPositioners = p, c.alignDataLabel = E, c.drawDataLabels = e, c.placeDataLabels = g, c.verifyDataLabelOverflow = t);
      };
    })(g || (g = {}));
    return g;
  });
  N(a, "Extensions/OverlappingDataLabels.js", [a["Core/Chart/Chart.js"], a["Core/Utilities.js"]], function (a, t) {
    function E(a, h) {
      var c = !1;
      if (a) {
        var n = a.newOpacity;
        a.oldOpacity !== n && (a.alignAttr && a.placed ? (a[n ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), c = !0, a.alignAttr.opacity = n, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, function () {
          h.styledMode || a.css({
            pointerEvents: n ? "auto" : "none"
          });
        }), y(h, "afterHideOverlappingLabel")) : a.attr({
          opacity: n
        }));
        a.isOld = !0;
      }
      return c;
    }
    var H = t.addEvent,
      y = t.fireEvent,
      F = t.isArray,
      I = t.isNumber,
      x = t.objectEach,
      q = t.pick;
    H(a, "render", function () {
      var a = this,
        h = [];
      (this.labelCollectors || []).forEach(function (a) {
        h = h.concat(a());
      });
      (this.yAxis || []).forEach(function (a) {
        a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && x(a.stacking.stacks, function (a) {
          x(a, function (a) {
            a.label && "hidden" !== a.label.visibility && h.push(a.label);
          });
        });
      });
      (this.series || []).forEach(function (c) {
        var n = c.options.dataLabels;
        c.visible && (!1 !== n.enabled || c._hasPointLabels) && (n = function (c) {
          return c.forEach(function (c) {
            c.visible && (F(c.dataLabels) ? c.dataLabels : c.dataLabel ? [c.dataLabel] : []).forEach(function (f) {
              var e = f.options;
              f.labelrank = q(e.labelrank, c.labelrank, c.shapeArgs && c.shapeArgs.height);
              e.allowOverlap ? (f.oldOpacity = f.opacity, f.newOpacity = 1, E(f, a)) : h.push(f);
            });
          });
        }, n(c.nodes || []), n(c.points));
      });
      this.hideOverlappingLabels(h);
    });
    a.prototype.hideOverlappingLabels = function (a) {
      var h = this,
        c = a.length,
        n = h.renderer,
        m,
        g,
        f,
        e = !1;
      var q = function (a) {
        var c,
          e = a.box ? 0 : a.padding || 0,
          b = c = 0,
          f;
        if (a && (!a.alignAttr || a.placed)) {
          var d = a.alignAttr || {
            x: a.attr("x"),
            y: a.attr("y")
          };
          var g = a.parentGroup;
          a.width || (c = a.getBBox(), a.width = c.width, a.height = c.height, c = n.fontMetrics(null, a.element).h);
          var h = a.width - 2 * e;
          (f = {
            left: "0",
            center: "0.5",
            right: "1"
          }[a.alignValue]) ? b = +f * h : I(a.x) && Math.round(a.x) !== a.translateX && (b = a.x - a.translateX);
          return {
            x: d.x + (g.translateX || 0) + e - (b || 0),
            y: d.y + (g.translateY || 0) + e - c,
            width: a.width - 2 * e,
            height: a.height - 2 * e
          };
        }
      };
      for (g = 0; g < c; g++) if (m = a[g]) m.oldOpacity = m.opacity, m.newOpacity = 1, m.absoluteBox = q(m);
      a.sort(function (a, c) {
        return (c.labelrank || 0) - (a.labelrank || 0);
      });
      for (g = 0; g < c; g++) {
        var t = (q = a[g]) && q.absoluteBox;
        for (m = g + 1; m < c; ++m) {
          var x = (f = a[m]) && f.absoluteBox;
          !t || !x || q === f || 0 === q.newOpacity || 0 === f.newOpacity || x.x >= t.x + t.width || x.x + x.width <= t.x || x.y >= t.y + t.height || x.y + x.height <= t.y || ((q.labelrank < f.labelrank ? q : f).newOpacity = 0);
        }
      }
      a.forEach(function (a) {
        E(a, h) && (e = !0);
      });
      e && y(h, "afterHideAllOverlappingLabels");
    };
  });
  N(a, "Core/Responsive.js", [a["Core/Utilities.js"]], function (a) {
    var t = a.extend,
      E = a.find,
      H = a.isArray,
      y = a.isObject,
      F = a.merge,
      I = a.objectEach,
      x = a.pick,
      q = a.splat,
      m = a.uniqueKey,
      h;
    (function (a) {
      var c = [];
      a.compose = function (a) {
        -1 === c.indexOf(a) && (c.push(a), t(a.prototype, h.prototype));
        return a;
      };
      var h = function () {
        function a() {}
        a.prototype.currentOptions = function (a) {
          function c(a, e, g, h) {
            var b;
            I(a, function (a, d) {
              if (!h && -1 < f.collectionsWithUpdate.indexOf(d) && e[d]) for (a = q(a), g[d] = [], b = 0; b < Math.max(a.length, e[d].length); b++) e[d][b] && (void 0 === a[b] ? g[d][b] = e[d][b] : (g[d][b] = {}, c(a[b], e[d][b], g[d][b], h + 1)));else y(a) ? (g[d] = H(a) ? [] : {}, c(a, e[d] || {}, g[d], h + 1)) : g[d] = "undefined" === typeof e[d] ? null : e[d];
            });
          }
          var f = this,
            g = {};
          c(a, this.options, g, 0);
          return g;
        };
        a.prototype.matchResponsiveRule = function (a, c) {
          var e = a.condition;
          (e.callback || function () {
            return this.chartWidth <= x(e.maxWidth, Number.MAX_VALUE) && this.chartHeight <= x(e.maxHeight, Number.MAX_VALUE) && this.chartWidth >= x(e.minWidth, 0) && this.chartHeight >= x(e.minHeight, 0);
          }).call(this) && c.push(a._id);
        };
        a.prototype.setResponsive = function (a, c) {
          var e = this,
            f = this.options.responsive,
            g = this.currentResponsive,
            h = [];
          !c && f && f.rules && f.rules.forEach(function (a) {
            "undefined" === typeof a._id && (a._id = m());
            e.matchResponsiveRule(a, h);
          }, this);
          c = F.apply(void 0, h.map(function (a) {
            return E((f || {}).rules || [], function (c) {
              return c._id === a;
            });
          }).map(function (a) {
            return a && a.chartOptions;
          }));
          c.isResponsiveOptions = !0;
          h = h.toString() || void 0;
          h !== (g && g.ruleIds) && (g && this.update(g.undoOptions, a, !0), h ? (g = this.currentOptions(c), g.isResponsiveOptions = !0, this.currentResponsive = {
            ruleIds: h,
            mergedOptions: c,
            undoOptions: g
          }, this.update(c, a, !0)) : this.currentResponsive = void 0);
        };
        return a;
      }();
    })(h || (h = {}));
    "";
    "";
    return h;
  });
  N(a, "masters/highcharts.src.js", [a["Core/Globals.js"], a["Core/Utilities.js"], a["Core/DefaultOptions.js"], a["Core/Animation/Fx.js"], a["Core/Animation/AnimationUtilities.js"], a["Core/Renderer/HTML/AST.js"], a["Core/FormatUtilities.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Renderer/HTML/HTMLElement.js"], a["Core/Renderer/HTML/HTMLRenderer.js"], a["Core/Axis/Axis.js"], a["Core/Axis/DateTimeAxis.js"], a["Core/Axis/LogarithmicAxis.js"], a["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], a["Core/Axis/Tick.js"], a["Core/Tooltip.js"], a["Core/Series/Point.js"], a["Core/Pointer.js"], a["Core/MSPointer.js"], a["Core/Legend/Legend.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Series/Column/ColumnSeries.js"], a["Series/Column/ColumnDataLabel.js"], a["Series/Pie/PieSeries.js"], a["Series/Pie/PieDataLabel.js"], a["Core/Series/DataLabel.js"], a["Core/Responsive.js"], a["Core/Color/Color.js"], a["Core/Time.js"]], function (a, t, B, H, y, F, I, x, q, m, h, c, n, z, g, f, e, G, J, M, p, l, w, b, v, d, D, C, k, K, O, r, A) {
    a.animate = y.animate;
    a.animObject = y.animObject;
    a.getDeferredAnimation = y.getDeferredAnimation;
    a.setAnimation = y.setAnimation;
    a.stop = y.stop;
    a.timers = H.timers;
    a.AST = F;
    a.Axis = n;
    a.Chart = w;
    a.chart = w.chart;
    a.Fx = H;
    a.Legend = l;
    a.PlotLineOrBand = f;
    a.Point = J;
    a.Pointer = p.isRequired() ? p : M;
    a.Series = b;
    a.SVGElement = q;
    a.SVGRenderer = m;
    a.Tick = e;
    a.Time = A;
    a.Tooltip = G;
    a.Color = r;
    a.color = r.parse;
    c.compose(m);
    h.compose(q);
    a.defaultOptions = B.defaultOptions;
    a.getOptions = B.getOptions;
    a.time = B.defaultTime;
    a.setOptions = B.setOptions;
    a.dateFormat = I.dateFormat;
    a.format = I.format;
    a.numberFormat = I.numberFormat;
    a.addEvent = t.addEvent;
    a.arrayMax = t.arrayMax;
    a.arrayMin = t.arrayMin;
    a.attr = t.attr;
    a.clearTimeout = t.clearTimeout;
    a.correctFloat = t.correctFloat;
    a.createElement = t.createElement;
    a.css = t.css;
    a.defined = t.defined;
    a.destroyObjectProperties = t.destroyObjectProperties;
    a.discardElement = t.discardElement;
    a.distribute = x.distribute;
    a.erase = t.erase;
    a.error = t.error;
    a.extend = t.extend;
    a.extendClass = t.extendClass;
    a.find = t.find;
    a.fireEvent = t.fireEvent;
    a.getMagnitude = t.getMagnitude;
    a.getStyle = t.getStyle;
    a.inArray = t.inArray;
    a.isArray = t.isArray;
    a.isClass = t.isClass;
    a.isDOMElement = t.isDOMElement;
    a.isFunction = t.isFunction;
    a.isNumber = t.isNumber;
    a.isObject = t.isObject;
    a.isString = t.isString;
    a.keys = t.keys;
    a.merge = t.merge;
    a.normalizeTickInterval = t.normalizeTickInterval;
    a.objectEach = t.objectEach;
    a.offset = t.offset;
    a.pad = t.pad;
    a.pick = t.pick;
    a.pInt = t.pInt;
    a.relativeLength = t.relativeLength;
    a.removeEvent = t.removeEvent;
    a.seriesType = v.seriesType;
    a.splat = t.splat;
    a.stableSort = t.stableSort;
    a.syncTimeout = t.syncTimeout;
    a.timeUnits = t.timeUnits;
    a.uniqueKey = t.uniqueKey;
    a.useSerialIds = t.useSerialIds;
    a.wrap = t.wrap;
    D.compose(d);
    K.compose(b);
    z.compose(n);
    g.compose(n);
    k.compose(C);
    f.compose(n);
    O.compose(w);
    return a;
  });
  N(a, "Series/XRange/XRangePoint.js", [a["Core/Series/Point.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = this && this.__extends || function () {
      var a = function (t, y) {
        a = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (a, q) {
          a.__proto__ = q;
        } || function (a, q) {
          for (var m in q) q.hasOwnProperty(m) && (a[m] = q[m]);
        };
        return a(t, y);
      };
      return function (t, y) {
        function x() {
          this.constructor = t;
        }
        a(t, y);
        t.prototype = null === y ? Object.create(y) : (x.prototype = y.prototype, new x());
      };
    }();
    B = B.extend;
    t = function (t) {
      function y() {
        var a = null !== t && t.apply(this, arguments) || this;
        a.options = void 0;
        a.series = void 0;
        return a;
      }
      E(y, t);
      y.getColorByCategory = function (a, t) {
        var q = a.options.colors || a.chart.options.colors;
        a = t.y % (q ? q.length : a.chart.options.chart.colorCount);
        return {
          colorIndex: a,
          color: q && q[a]
        };
      };
      y.prototype.resolveColor = function () {
        var a = this.series;
        if (a.options.colorByPoint && !this.options.color) {
          var t = y.getColorByCategory(a, this);
          a.chart.styledMode || (this.color = t.color);
          this.options.colorIndex || (this.colorIndex = t.colorIndex);
        } else this.color || (this.color = a.color);
      };
      y.prototype.init = function () {
        a.prototype.init.apply(this, arguments);
        this.y || (this.y = 0);
        return this;
      };
      y.prototype.setState = function () {
        a.prototype.setState.apply(this, arguments);
        this.series.drawPoint(this, this.series.getAnimationVerb());
      };
      y.prototype.getLabelConfig = function () {
        var t = a.prototype.getLabelConfig.call(this),
          x = this.series.yAxis.categories;
        t.x2 = this.x2;
        t.yCategory = this.yCategory = x && x[this.y];
        return t;
      };
      y.prototype.isValid = function () {
        return "number" === typeof this.x && "number" === typeof this.x2;
      };
      return y;
    }(t.seriesTypes.column.prototype.pointClass);
    B(t.prototype, {
      ttBelow: !1,
      tooltipDateKeys: ["x", "x2"]
    });
    return t;
  });
  N(a, "Series/XRange/XRangeComposition.js", [a["Core/Axis/Axis.js"], a["Core/Utilities.js"]], function (a, t) {
    var B = t.addEvent,
      E = t.pick;
    B(a, "afterGetSeriesExtremes", function () {
      var a = this.series,
        t;
      if (this.isXAxis) {
        var B = E(this.dataMax, -Number.MAX_VALUE);
        a.forEach(function (a) {
          a.x2Data && a.x2Data.forEach(function (a) {
            a > B && (B = a, t = !0);
          });
        });
        t && (this.dataMax = B);
      }
    });
  });
  N(a, "Series/XRange/XRangeSeries.js", [a["Core/Globals.js"], a["Core/Color/Color.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"], a["Series/XRange/XRangePoint.js"]], function (a, t, B, H, y) {
    var F = this && this.__extends || function () {
        var a = function (c, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);
          };
          return a(c, e);
        };
        return function (c, e) {
          function f() {
            this.constructor = c;
          }
          a(c, e);
          c.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
        };
      }(),
      I = t.parse,
      x = B.series,
      q = B.seriesTypes.column,
      m = q.prototype,
      h = H.clamp,
      c = H.correctFloat,
      n = H.defined;
    t = H.extend;
    var z = H.find,
      g = H.isNumber,
      f = H.isObject,
      e = H.merge,
      G = H.pick;
    H = function (a) {
      function t() {
        var c = null !== a && a.apply(this, arguments) || this;
        c.data = void 0;
        c.options = void 0;
        c.points = void 0;
        return c;
      }
      F(t, a);
      t.prototype.init = function () {
        q.prototype.init.apply(this, arguments);
        this.options.stacking = void 0;
      };
      t.prototype.getColumnMetrics = function () {
        function a() {
          c.series.forEach(function (b) {
            var a = b.xAxis;
            b.xAxis = b.yAxis;
            b.yAxis = a;
          });
        }
        var c = this.chart;
        a();
        var e = m.getColumnMetrics.call(this);
        a();
        return e;
      };
      t.prototype.cropData = function (a, c, e, b) {
        c = x.prototype.cropData.call(this, this.x2Data, c, e, b);
        c.xData = a.slice(c.start, c.end);
        return c;
      };
      t.prototype.findPointIndex = function (a) {
        var c = this.cropped,
          e = this.cropStart,
          b = this.points,
          f = a.id;
        if (f) var d = (d = z(b, function (b) {
          return b.id === f;
        })) ? d.index : void 0;
        "undefined" === typeof d && (d = (d = z(b, function (b) {
          return b.x === a.x && b.x2 === a.x2 && !b.touched;
        })) ? d.index : void 0);
        c && g(d) && g(e) && d >= e && (d -= e);
        return d;
      };
      t.prototype.translatePoint = function (a) {
        var c = this.xAxis,
          p = this.yAxis,
          b = this.columnMetrics,
          m = this.options,
          d = m.minPointLength || 0,
          q = (a.shapeArgs && a.shapeArgs.width || 0) / 2,
          C = this.pointXOffset = b.offset,
          k = a.plotX,
          K = G(a.x2, a.x + (a.len || 0)),
          t = c.translate(K, 0, 0, 0, 1);
        K = Math.abs(t - k);
        var r = this.chart.inverted,
          A = G(m.borderWidth, 1) % 2 / 2,
          z = b.offset,
          x = Math.round(b.width);
        d && (d -= K, 0 > d && (d = 0), k -= d / 2, t += d / 2);
        k = Math.max(k, -10);
        t = h(t, -10, c.len + 10);
        n(a.options.pointWidth) && (z -= (Math.ceil(a.options.pointWidth) - x) / 2, x = Math.ceil(a.options.pointWidth));
        m.pointPlacement && g(a.plotY) && p.categories && (a.plotY = p.translate(a.y, 0, 1, 0, 1, m.pointPlacement));
        m = Math.floor(Math.min(k, t)) + A;
        m = {
          x: m,
          y: Math.floor(a.plotY + z) + A,
          width: Math.floor(Math.max(k, t)) + A - m,
          height: x,
          r: this.options.borderRadius
        };
        a.shapeArgs = m;
        r ? a.tooltipPos[1] += C + q : a.tooltipPos[0] -= q + C - m.width / 2;
        q = m.x;
        C = q + m.width;
        0 > q || C > c.len ? (q = h(q, 0, c.len), C = h(C, 0, c.len), t = C - q, a.dlBox = e(m, {
          x: q,
          width: C - q,
          centerX: t ? t / 2 : null
        })) : a.dlBox = null;
        q = a.tooltipPos;
        C = r ? 1 : 0;
        t = r ? 0 : 1;
        b = this.columnMetrics ? this.columnMetrics.offset : -b.width / 2;
        q[C] = r ? q[C] + m.width / 2 : q[C] + (c.reversed ? -1 : 0) * m.width;
        q[t] = h(q[t] + (r ? -1 : 1) * b, 0, p.len - 1);
        if (p = a.partialFill) f(p) && (p = p.amount), g(p) || (p = 0), a.partShapeArgs = e(m, {
          r: this.options.borderRadius
        }), k = Math.max(Math.round(K * p + a.plotX - k), 0), a.clipRectArgs = {
          x: c.reversed ? m.x + K - k : m.x,
          y: m.y,
          width: k,
          height: m.height
        };
      };
      t.prototype.translate = function () {
        m.translate.apply(this, arguments);
        this.points.forEach(function (a) {
          this.translatePoint(a);
        }, this);
      };
      t.prototype.drawPoint = function (a, c) {
        var g = this.options,
          b = this.chart.renderer,
          h = a.graphic,
          d = a.shapeType,
          l = a.shapeArgs,
          p = a.partShapeArgs,
          k = a.clipRectArgs,
          n = a.partialFill,
          m = g.stacking && !g.borderRadius,
          r = a.state,
          A = g.states[r || "normal"] || {},
          q = "undefined" === typeof r ? "attr" : c;
        r = this.pointAttribs(a, r);
        A = G(this.chart.options.chart.animation, A.animation);
        if (a.isNull || !1 === a.visible) h && (a.graphic = h.destroy());else {
          if (h) h.rect[c](l);else a.graphic = h = b.g("point").addClass(a.getClassName()).add(a.group || this.group), h.rect = b[d](e(l)).addClass(a.getClassName()).addClass("highcharts-partfill-original").add(h);
          p && (h.partRect ? (h.partRect[c](e(p)), h.partialClipRect[c](e(k))) : (h.partialClipRect = b.clipRect(k.x, k.y, k.width, k.height), h.partRect = b[d](p).addClass("highcharts-partfill-overlay").add(h).clip(h.partialClipRect)));
          this.chart.styledMode || (h.rect[c](r, A).shadow(g.shadow, null, m), p && (f(n) || (n = {}), f(g.partialFill) && (n = e(g.partialFill, n)), a = n.fill || I(r.fill).brighten(-.3).get() || I(a.color || this.color).brighten(-.3).get(), r.fill = a, h.partRect[q](r, A).shadow(g.shadow, null, m)));
        }
      };
      t.prototype.drawPoints = function () {
        var a = this,
          c = a.getAnimationVerb();
        a.points.forEach(function (e) {
          a.drawPoint(e, c);
        });
      };
      t.prototype.getAnimationVerb = function () {
        return this.chart.pointCount < (this.options.animationLimit || 250) ? "animate" : "attr";
      };
      t.prototype.isPointInside = function (c) {
        var e = c.shapeArgs,
          f = c.plotX,
          b = c.plotY;
        return e ? "undefined" !== typeof f && "undefined" !== typeof b && 0 <= b && b <= this.yAxis.len && 0 <= (e.x || 0) + (e.width || 0) && f <= this.xAxis.len : a.prototype.isPointInside.apply(this, arguments);
      };
      t.defaultOptions = e(q.defaultOptions, {
        colorByPoint: !0,
        dataLabels: {
          formatter: function () {
            var a = this.point.partialFill;
            f(a) && (a = a.amount);
            if (g(a) && 0 < a) return c(100 * a) + "%";
          },
          inside: !0,
          verticalAlign: "middle"
        },
        tooltip: {
          headerFormat: '<span style="font-size: 10px">{point.x} - {point.x2}</span><br/>',
          pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.yCategory}</b><br/>'
        },
        borderRadius: 3,
        pointRange: 0
      });
      return t;
    }(q);
    t(H.prototype, {
      type: "xrange",
      parallelArrays: ["x", "x2", "y"],
      requireSorting: !1,
      animate: x.prototype.animate,
      cropShoulder: 1,
      getExtremesFromAll: !0,
      autoIncrement: a.noop,
      buildKDTree: a.noop,
      pointClass: y
    });
    B.registerSeriesType("xrange", H);
    "";
    return H;
  });
  N(a, "Series/Gantt/GanttPoint.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t) {
    var B = this && this.__extends || function () {
        var a = function (t, y) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, q) {
            a.__proto__ = q;
          } || function (a, q) {
            for (var m in q) q.hasOwnProperty(m) && (a[m] = q[m]);
          };
          return a(t, y);
        };
        return function (t, y) {
          function x() {
            this.constructor = t;
          }
          a(t, y);
          t.prototype = null === y ? Object.create(y) : (x.prototype = y.prototype, new x());
        };
      }(),
      E = t.pick;
    return function (a) {
      function t() {
        var t = null !== a && a.apply(this, arguments) || this;
        t.options = void 0;
        t.series = void 0;
        return t;
      }
      B(t, a);
      t.setGanttPointAliases = function (a) {
        function t(q, m) {
          "undefined" !== typeof m && (a[q] = m);
        }
        t("x", E(a.start, a.x));
        t("x2", E(a.end, a.x2));
        t("partialFill", E(a.completed, a.partialFill));
      };
      t.prototype.applyOptions = function (y, x) {
        y = a.prototype.applyOptions.call(this, y, x);
        t.setGanttPointAliases(y);
        return y;
      };
      t.prototype.isValid = function () {
        return ("number" === typeof this.start || "number" === typeof this.x) && ("number" === typeof this.end || "number" === typeof this.x2 || this.milestone);
      };
      return t;
    }(a.seriesTypes.xrange.prototype.pointClass);
  });
  N(a, "Core/Axis/BrokenAxis.js", [a["Extensions/Stacking.js"], a["Core/Utilities.js"]], function (a, t) {
    var B = t.addEvent,
      E = t.find,
      y = t.fireEvent,
      F = t.isArray,
      I = t.isNumber,
      x = t.pick,
      q;
    (function (m) {
      function h() {
        "undefined" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);
      }
      function c() {
        this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);
      }
      function n() {
        var a = this.brokenAxis;
        if (a && a.hasBreaks) {
          for (var c = this.tickPositions, e = this.tickPositions.info, b = [], f = 0; f < c.length; f++) a.isInAnyBreak(c[f]) || b.push(c[f]);
          this.tickPositions = b;
          this.tickPositions.info = e;
        }
      }
      function q() {
        this.brokenAxis || (this.brokenAxis = new M(this));
      }
      function g() {
        var a = this.options.connectNulls,
          c = this.points,
          e = this.xAxis,
          b = this.yAxis;
        if (this.isDirty) for (var f = c.length; f--;) {
          var d = c[f],
            g = !(null === d.y && !1 === a) && (e && e.brokenAxis && e.brokenAxis.isInAnyBreak(d.x, !0) || b && b.brokenAxis && b.brokenAxis.isInAnyBreak(d.y, !0));
          d.visible = g ? !1 : !1 !== d.options.visible;
        }
      }
      function f() {
        this.drawBreaks(this.xAxis, ["x"]);
        this.drawBreaks(this.yAxis, x(this.pointArrayMap, ["y"]));
      }
      function e(a, c) {
        var e = this,
          b = e.points,
          f,
          d,
          g,
          h;
        if (a && a.brokenAxis && a.brokenAxis.hasBreaks) {
          var k = a.brokenAxis;
          c.forEach(function (c) {
            f = k && k.breakArray || [];
            d = a.isXAxis ? a.min : x(e.options.threshold, a.min);
            b.forEach(function (b) {
              h = x(b["stack" + c.toUpperCase()], b[c]);
              f.forEach(function (c) {
                if (I(d) && I(h)) {
                  g = !1;
                  if (d < c.from && h > c.to || d > c.from && h < c.from) g = "pointBreak";else if (d < c.from && h > c.from && h < c.to || d > c.from && h > c.to && h < c.from) g = "pointInBreak";
                  g && y(a, g, {
                    point: b,
                    brk: c
                  });
                }
              });
            });
          });
        }
      }
      function t() {
        var c = this.currentDataGrouping,
          e = c && c.gapSize;
        c = this.points.slice();
        var f = this.yAxis,
          b = this.options.gapSize,
          g = c.length - 1,
          d;
        if (b && 0 < g) for ("value" !== this.options.gapUnit && (b *= this.basePointRange), e && e > b && e >= this.basePointRange && (b = e), d = void 0; g--;) d && !1 !== d.visible || (d = c[g + 1]), e = c[g], !1 !== d.visible && !1 !== e.visible && (d.x - e.x > b && (d = (e.x + d.x) / 2, c.splice(g + 1, 0, {
          isNull: !0,
          x: d
        }), f.stacking && this.options.stacking && (d = f.stacking.stacks[this.stackKey][d] = new a(f, f.options.stackLabels, !1, d, this.stack), d.total = 0)), d = e);
        return this.getGraphPath(c);
      }
      var J = [];
      m.compose = function (a, l) {
        -1 === J.indexOf(a) && (J.push(a), a.keepProps.push("brokenAxis"), B(a, "init", q), B(a, "afterInit", h), B(a, "afterSetTickPositions", n), B(a, "afterSetOptions", c));
        if (-1 === J.indexOf(l)) {
          J.push(l);
          var p = l.prototype;
          p.drawBreaks = e;
          p.gappedPath = t;
          B(l, "afterGeneratePoints", g);
          B(l, "afterRender", f);
        }
        return a;
      };
      var M = function () {
        function a(a) {
          this.hasBreaks = !1;
          this.axis = a;
        }
        a.isInBreak = function (a, c) {
          var b = a.repeat || Infinity,
            e = a.from,
            d = a.to - a.from;
          c = c >= e ? (c - e) % b : b - (e - c) % b;
          return a.inclusive ? c <= d : c < d && 0 !== c;
        };
        a.lin2Val = function (c) {
          var e = this.brokenAxis;
          e = e && e.breakArray;
          if (!e || !I(c)) return c;
          var b;
          for (b = 0; b < e.length; b++) {
            var f = e[b];
            if (f.from >= c) break;else f.to < c ? c += f.len : a.isInBreak(f, c) && (c += f.len);
          }
          return c;
        };
        a.val2Lin = function (c) {
          var e = this.brokenAxis;
          e = e && e.breakArray;
          if (!e || !I(c)) return c;
          var b = c,
            f;
          for (f = 0; f < e.length; f++) {
            var d = e[f];
            if (d.to <= c) b -= d.len;else if (d.from >= c) break;else if (a.isInBreak(d, c)) {
              b -= c - d.from;
              break;
            }
          }
          return b;
        };
        a.prototype.findBreakAt = function (a, c) {
          return E(c, function (b) {
            return b.from < a && a < b.to;
          });
        };
        a.prototype.isInAnyBreak = function (c, e) {
          var b = this.axis,
            f = b.options.breaks || [],
            d = f.length,
            g;
          if (d && I(c)) {
            for (; d--;) if (a.isInBreak(f[d], c)) {
              var h = !0;
              g || (g = x(f[d].showPoints, !b.isXAxis));
            }
            var k = h && e ? h && !g : h;
          }
          return k;
        };
        a.prototype.setBreaks = function (c, e) {
          var b = this,
            f = b.axis,
            d = F(c) && !!c.length;
          f.isDirty = b.hasBreaks !== d;
          b.hasBreaks = d;
          f.options.breaks = f.userOptions.breaks = c;
          f.forceRedraw = !0;
          f.series.forEach(function (a) {
            a.isDirty = !0;
          });
          d || f.val2lin !== a.val2Lin || (delete f.val2lin, delete f.lin2val);
          d && (f.userOptions.ordinal = !1, f.lin2val = a.lin2Val, f.val2lin = a.val2Lin, f.setExtremes = function (a, c, d, e, g) {
            if (b.hasBreaks) {
              for (var k = this.options.breaks || [], h; h = b.findBreakAt(a, k);) a = h.to;
              for (; h = b.findBreakAt(c, k);) c = h.from;
              c < a && (c = a);
            }
            f.constructor.prototype.setExtremes.call(this, a, c, d, e, g);
          }, f.setAxisTranslation = function () {
            f.constructor.prototype.setAxisTranslation.call(this);
            b.unitLength = void 0;
            if (b.hasBreaks) {
              var c = f.options.breaks || [],
                d = [],
                e = [],
                g = x(f.pointRangePadding, 0),
                h = 0,
                r,
                l = f.userMin || f.min,
                n = f.userMax || f.max,
                p;
              c.forEach(function (b) {
                r = b.repeat || Infinity;
                I(l) && I(n) && (a.isInBreak(b, l) && (l += b.to % r - l % r), a.isInBreak(b, n) && (n -= n % r - b.from % r));
              });
              c.forEach(function (a) {
                m = a.from;
                r = a.repeat || Infinity;
                if (I(l) && I(n)) {
                  for (; m - r > l;) m -= r;
                  for (; m < l;) m += r;
                  for (p = m; p < n; p += r) d.push({
                    value: p,
                    move: "in"
                  }), d.push({
                    value: p + a.to - a.from,
                    move: "out",
                    size: a.breakSize
                  });
                }
              });
              d.sort(function (a, b) {
                return a.value === b.value ? ("in" === a.move ? 0 : 1) - ("in" === b.move ? 0 : 1) : a.value - b.value;
              });
              var u = 0;
              var m = l;
              d.forEach(function (a) {
                u += "in" === a.move ? 1 : -1;
                1 === u && "in" === a.move && (m = a.value);
                0 === u && I(m) && (e.push({
                  from: m,
                  to: a.value,
                  len: a.value - m - (a.size || 0)
                }), h += a.value - m - (a.size || 0));
              });
              b.breakArray = e;
              I(l) && I(n) && I(f.min) && (b.unitLength = n - l - h + g, y(f, "afterBreaks"), f.staticScale ? f.transA = f.staticScale : b.unitLength && (f.transA *= (n - f.min + g) / b.unitLength), g && (f.minPixelPadding = f.transA * (f.minPointOffset || 0)), f.min = l, f.max = n);
            }
          });
          x(e, !0) && f.chart.redraw();
        };
        return a;
      }();
      m.Additions = M;
    })(q || (q = {}));
    return q;
  });
  N(a, "Core/Axis/GridAxis.js", [a["Core/Axis/Axis.js"], a["Core/Axis/AxisDefaults.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, t, B, H) {
    var y = B.dateFormats,
      F = H.addEvent,
      E = H.defined,
      x = H.erase,
      q = H.find,
      m = H.isArray,
      h = H.isNumber,
      c = H.merge,
      n = H.pick,
      z = H.timeUnits,
      g = H.wrap,
      f;
    (function (e) {
      function f(a, b) {
        var c = {
          width: 0,
          height: 0
        };
        b.forEach(function (b) {
          b = a[b];
          if (H.isObject(b, !0)) {
            var d = H.isObject(b.label, !0) ? b.label : {};
            b = d.getBBox ? d.getBBox().height : 0;
            d.textStr && !h(d.textPxLength) && (d.textPxLength = d.getBBox().width);
            var e = h(d.textPxLength) ? Math.round(d.textPxLength) : 0;
            d.textStr && (e = Math.round(d.getBBox().width));
            c.height = Math.max(b, c.height);
            c.width = Math.max(e, c.width);
          }
        });
        "treegrid" === this.options.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode && (c.width += this.options.labels.indentation * ((this.treeGrid.mapOfPosToGridNode[-1].height || 0) - 1));
        return c;
      }
      function J() {
        var a = this.grid;
        (a && a.columns || []).forEach(function (a) {
          a.getOffset();
        });
      }
      function y(a) {
        if (!0 === (this.options.grid || {}).enabled) {
          var b = this.axisTitle,
            c = this.height,
            d = this.horiz,
            f = this.left,
            k = this.offset,
            g = this.opposite,
            h = this.options,
            r = this.top,
            l = this.width,
            u = this.tickSize(),
            m = b && b.getBBox().width,
            p = h.title.x,
            q = h.title.y,
            A = n(h.title.margin, d ? 5 : 10);
          b = this.chart.renderer.fontMetrics(h.title.style.fontSize, b).f;
          u = (d ? r + c : f) + (d ? 1 : -1) * (g ? -1 : 1) * (u ? u[0] / 2 : 0) + (this.side === e.Side.bottom ? b : 0);
          a.titlePosition.x = d ? f - (m || 0) / 2 - A + p : u + (g ? l : 0) + k + p;
          a.titlePosition.y = d ? u - (g ? c : 0) + (g ? b : -b) / 2 + k + q : r - A + q;
        }
      }
      function p() {
        var b = this.chart,
          d = this.options.grid;
        d = void 0 === d ? {} : d;
        var e = this.userOptions;
        if (d.enabled) {
          var f = this.options;
          f.labels.align = n(f.labels.align, "center");
          this.categories || (f.showLastLabel = !1);
          this.labelRotation = 0;
          f.labels.rotation = 0;
        }
        if (d.columns) {
          f = this.grid.columns = [];
          for (var k = this.grid.columnIndex = 0; ++k < d.columns.length;) {
            var g = c(e, d.columns[d.columns.length - k - 1], {
              linkedTo: 0,
              type: "category",
              scrollbar: {
                enabled: !1
              }
            });
            delete g.grid.columns;
            g = new a(this.chart, g);
            g.grid.isColumn = !0;
            g.grid.columnIndex = k;
            x(b.axes, g);
            x(b[this.coll], g);
            f.push(g);
          }
        }
      }
      function l() {
        var a = this.grid,
          b = this.options;
        if (!0 === (b.grid || {}).enabled) {
          var c = this.min || 0,
            d = this.max || 0;
          this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions);
          this.rightWall && this.rightWall.destroy();
          if (this.grid && this.grid.isOuterAxis() && this.axisLine) {
            var f = b.lineWidth;
            if (f) {
              f = this.getLinePath(f);
              var k = f[0],
                g = f[1],
                h = ((this.tickSize("tick") || [1])[0] - 1) * (this.side === e.Side.top || this.side === e.Side.left ? -1 : 1);
              "M" === k[0] && "L" === g[0] && (this.horiz ? (k[2] += h, g[2] += h) : (k[1] += h, g[1] += h));
              !this.horiz && this.chart.marginRight && (k = [k, ["L", this.left, k[2] || 0]], h = ["L", this.chart.chartWidth - this.chart.marginRight, this.toPixels(d + this.tickmarkOffset)], g = [["M", g[1] || 0, this.toPixels(d + this.tickmarkOffset)], h], this.grid.upperBorder || 0 === c % 1 || (this.grid.upperBorder = this.grid.renderBorder(k)), this.grid.upperBorder && (this.grid.upperBorder.attr({
                stroke: b.lineColor,
                "stroke-width": b.lineWidth
              }), this.grid.upperBorder.animate({
                d: k
              })), this.grid.lowerBorder || 0 === d % 1 || (this.grid.lowerBorder = this.grid.renderBorder(g)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({
                stroke: b.lineColor,
                "stroke-width": b.lineWidth
              }), this.grid.lowerBorder.animate({
                d: g
              })));
              this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({
                stroke: b.lineColor,
                "stroke-width": b.lineWidth
              }), this.grid.axisLineExtra.animate({
                d: f
              })) : this.grid.axisLineExtra = this.grid.renderBorder(f);
              this.axisLine[this.showAxis ? "show" : "hide"](!0);
            }
          }
          (a && a.columns || []).forEach(function (a) {
            a.render();
          });
          if (!this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar)) {
            a = this.tickmarkOffset;
            b = this.tickPositions[this.tickPositions.length - 1];
            f = this.tickPositions[0];
            for (g = void 0; (g = this.hiddenLabels.pop()) && g.element;) g.show();
            (g = this.ticks[f].label) && (c - f > a ? this.hiddenLabels.push(g.hide()) : g.show());
            (g = this.ticks[b].label) && (b - d > a ? this.hiddenLabels.push(g.hide()) : g.show());
            (c = this.ticks[b].mark) && (b - d < a && 0 < b - d && this.ticks[b].isLast ? c.hide() : this.ticks[b - 1] && c.show());
          }
        }
      }
      function w() {
        var a = this.tickPositions && this.tickPositions.info,
          b = this.options,
          c = this.userOptions.labels || {};
        (b.grid || {}).enabled && (this.horiz ? (this.series.forEach(function (a) {
          a.options.pointRange = 0;
        }), a && b.dateTimeLabelFormats && b.labels && !E(c.align) && (!1 === b.dateTimeLabelFormats[a.unitName].range || 1 < a.count) && (b.labels.align = "left", E(c.x) || (b.labels.x = 3))) : "treegrid" !== this.options.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));
      }
      function b(a) {
        var b = this.options;
        a = a.userOptions;
        var d = b && H.isObject(b.grid, !0) ? b.grid : {};
        if (!0 === d.enabled) {
          var e = c(!0, {
            className: "highcharts-grid-axis " + (a.className || ""),
            dateTimeLabelFormats: {
              hour: {
                list: ["%H:%M", "%H"]
              },
              day: {
                list: ["%A, %e. %B", "%a, %e. %b", "%E"]
              },
              week: {
                list: ["Week %W", "W%W"]
              },
              month: {
                list: ["%B", "%b", "%o"]
              }
            },
            grid: {
              borderWidth: 1
            },
            labels: {
              padding: 2,
              style: {
                fontSize: "13px"
              }
            },
            margin: 0,
            title: {
              text: null,
              reserveSpace: !1,
              rotation: 0
            },
            units: [["millisecond", [1, 10, 100]], ["second", [1, 10]], ["minute", [1, 5, 15]], ["hour", [1, 6]], ["day", [1]], ["week", [1]], ["month", [1]], ["year", null]]
          }, a);
          "xAxis" === this.coll && (E(a.linkedTo) && !E(a.tickPixelInterval) && (e.tickPixelInterval = 350), E(a.tickPixelInterval) || !E(a.linkedTo) || E(a.tickPositioner) || E(a.tickInterval) || (e.tickPositioner = function (a, b) {
            var c = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;
            if (c) {
              for (var d = e.units || [], f = void 0, k = void 0, g = void 0, h = 0; h < d.length; h++) if (d[h][0] === c.unitName) {
                f = h;
                break;
              }
              d[f + 1] ? (g = d[f + 1][0], k = (d[f + 1][1] || [1])[0]) : "year" === c.unitName && (g = "year", k = 10 * c.count);
              c = z[g];
              this.tickInterval = c * k;
              return this.getTimeTicks({
                unitRange: c,
                count: k,
                unitName: g
              }, a, b, this.options.startOfWeek);
            }
          }));
          c(!0, this.options, e);
          this.horiz && (b.minPadding = n(a.minPadding, 0), b.maxPadding = n(a.maxPadding, 0));
          h(b.grid.borderWidth) && (b.tickWidth = b.lineWidth = d.borderWidth);
        }
      }
      function v(a) {
        a = (a = a.userOptions) && a.grid || {};
        var b = a.columns;
        a.enabled && b && c(!0, this.options, b[b.length - 1]);
      }
      function d() {
        (this.grid.columns || []).forEach(function (a) {
          a.setScale();
        });
      }
      function D(a) {
        var b = t.defaultLeftAxisOptions,
          c = this.horiz,
          d = this.maxLabelDimensions,
          e = this.options.grid;
        e = void 0 === e ? {} : e;
        e.enabled && d && (b = 2 * Math.abs(b.labels.x), c = c ? e.cellHeight || b + d.height : b + d.width, m(a.tickSize) ? a.tickSize[0] = c : a.tickSize = [c, 0]);
      }
      function C() {
        this.axes.forEach(function (a) {
          (a.grid && a.grid.columns || []).forEach(function (a) {
            a.setAxisSize();
            a.setAxisTranslation();
          });
        });
      }
      function k(a) {
        var b = this.grid;
        (b.columns || []).forEach(function (b) {
          b.destroy(a.keepEvents);
        });
        b.columns = void 0;
      }
      function K(a) {
        a = a.userOptions || {};
        var b = a.grid || {};
        b.enabled && E(b.borderColor) && (a.tickColor = a.lineColor = b.borderColor);
        this.grid || (this.grid = new V(this));
        this.hiddenLabels = [];
      }
      function O(a) {
        var b = this.label,
          c = this.axis,
          d = c.reversed,
          f = c.chart,
          k = c.options.grid || {},
          g = c.options.labels,
          r = g.align,
          l = e.Side[c.side],
          n = a.tickmarkOffset,
          m = c.tickPositions,
          p = this.pos - n;
        m = h(m[a.index + 1]) ? m[a.index + 1] - n : (c.max || 0) + n;
        var u = c.tickSize("tick");
        n = u ? u[0] : 0;
        u = u ? u[1] / 2 : 0;
        if (!0 === k.enabled) {
          if ("top" === l) {
            k = c.top + c.offset;
            var q = k - n;
          } else "bottom" === l ? (q = f.chartHeight - c.bottom + c.offset, k = q + n) : (k = c.top + c.len - (c.translate(d ? m : p) || 0), q = c.top + c.len - (c.translate(d ? p : m) || 0));
          "right" === l ? (l = f.chartWidth - c.right + c.offset, d = l + n) : "left" === l ? (d = c.left + c.offset, l = d - n) : (l = Math.round(c.left + (c.translate(d ? m : p) || 0)) - u, d = Math.min(Math.round(c.left + (c.translate(d ? p : m) || 0)) - u, c.left + c.len));
          this.slotWidth = d - l;
          a.pos.x = "left" === r ? l : "right" === r ? d : l + (d - l) / 2;
          a.pos.y = q + (k - q) / 2;
          f = f.renderer.fontMetrics(g.style.fontSize, b && b.element);
          b = b ? b.getBBox().height : 0;
          g.useHTML ? a.pos.y += f.b + -(b / 2) : (b = Math.round(b / f.h), a.pos.y += (f.b - (f.h - f.f)) / 2 + -((b - 1) * f.h / 2));
          a.pos.x += c.horiz && g.x || 0;
        }
      }
      function r(a) {
        var b = a.axis,
          d = a.value;
        if (b.options.grid && b.options.grid.enabled) {
          var e = b.tickPositions,
            f = (b.linkedParent || b).series[0],
            k = d === e[0];
          e = d === e[e.length - 1];
          var g = f && q(f.options.data, function (a) {
              return a[b.isXAxis ? "x" : "y"] === d;
            }),
            h = void 0;
          g && f.is("gantt") && (h = c(g), B.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(h));
          a.isFirst = k;
          a.isLast = e;
          a.point = h;
        }
      }
      function A() {
        var a = this.options,
          b = this.categories,
          c = this.tickPositions,
          d = c[0],
          e = c[c.length - 1],
          f = this.linkedParent && this.linkedParent.min || this.min,
          k = this.linkedParent && this.linkedParent.max || this.max,
          g = this.tickInterval;
        !0 !== (a.grid || {}).enabled || b || !this.horiz && !this.isLinked || (d < f && d + g > f && !a.startOnTick && (c[0] = f), e > k && e - g < k && !a.endOnTick && (c[c.length - 1] = k));
      }
      function P(a) {
        var b = this.options.grid;
        return !0 === (void 0 === b ? {} : b).enabled && this.categories ? this.tickInterval : a.apply(this, Array.prototype.slice.call(arguments, 1));
      }
      (function (a) {
        a[a.top = 0] = "top";
        a[a.right = 1] = "right";
        a[a.bottom = 2] = "bottom";
        a[a.left = 3] = "left";
      })(e.Side || (e.Side = {}));
      e.compose = function (a, c, e) {
        -1 === a.keepProps.indexOf("grid") && (a.keepProps.push("grid"), a.prototype.getMaxLabelDimensions = f, g(a.prototype, "unsquish", P), F(a, "init", K), F(a, "afterGetOffset", J), F(a, "afterGetTitlePosition", y), F(a, "afterInit", p), F(a, "afterRender", l), F(a, "afterSetAxisTranslation", w), F(a, "afterSetOptions", b), F(a, "afterSetOptions", v), F(a, "afterSetScale", d), F(a, "afterTickSize", D), F(a, "trimTicks", A), F(a, "destroy", k));
        F(c, "afterSetChartSize", C);
        F(e, "afterGetLabelPosition", O);
        F(e, "labelFormat", r);
        return a;
      };
      var V = function () {
        function a(a) {
          this.axis = a;
        }
        a.prototype.isOuterAxis = function () {
          var a = this.axis,
            b = a.grid.columnIndex,
            c = a.linkedParent && a.linkedParent.grid.columns || a.grid.columns,
            d = b ? a.linkedParent : a,
            e = -1,
            f = 0;
          a.chart[a.coll].forEach(function (b, c) {
            b.side !== a.side || b.options.isInternal || (f = c, b === d && (e = c));
          });
          return f === e && (h(b) ? c.length === b : !0);
        };
        a.prototype.renderBorder = function (a) {
          var b = this.axis,
            c = b.chart.renderer,
            d = b.options;
          a = c.path(a).addClass("highcharts-axis-line").add(b.axisBorder);
          c.styledMode || a.attr({
            stroke: d.lineColor,
            "stroke-width": d.lineWidth,
            zIndex: 7
          });
          return a;
        };
        return a;
      }();
      e.Additions = V;
    })(f || (f = {}));
    y.E = function (a) {
      return this.dateFormat("%a", a, !0).charAt(0);
    };
    y.W = function (a) {
      a = new this.Date(a);
      var c = (this.get("Day", a) + 6) % 7,
        e = new this.Date(a.valueOf());
      this.set("Date", e, this.get("Date", a) - c + 3);
      c = new this.Date(this.get("FullYear", e), 0, 1);
      4 !== this.get("Day", c) && (this.set("Month", a, 0), this.set("Date", a, 1 + (11 - this.get("Day", c)) % 7));
      return (1 + Math.floor((e.valueOf() - c.valueOf()) / 6048E5)).toString();
    };
    "";
    return f;
  });
  N(a, "Gantt/Tree.js", [a["Core/Utilities.js"]], function (a) {
    var t = a.extend,
      B = a.isNumber,
      E = a.pick,
      y = function (a, t) {
        var q = a.reduce(function (a, h) {
          var c = E(h.parent, "");
          "undefined" === typeof a[c] && (a[c] = []);
          a[c].push(h);
          return a;
        }, {});
        Object.keys(q).forEach(function (a, h) {
          var c = q[a];
          "" !== a && -1 === t.indexOf(a) && (c.forEach(function (a) {
            h[""].push(a);
          }), delete h[a]);
        });
        return q;
      },
      F = function (a, x, q, m, h, c) {
        var n = 0,
          z = 0,
          g = c && c.after,
          f = c && c.before;
        x = {
          data: m,
          depth: q - 1,
          id: a,
          level: q,
          parent: x
        };
        var e, G;
        "function" === typeof f && f(x, c);
        f = (h[a] || []).map(function (f) {
          var g = F(f.id, a, q + 1, f, h, c),
            p = f.start;
          f = !0 === f.milestone ? p : f.end;
          e = !B(e) || p < e ? p : e;
          G = !B(G) || f > G ? f : G;
          n = n + 1 + g.descendants;
          z = Math.max(g.height + 1, z);
          return g;
        });
        m && (m.start = E(m.start, e), m.end = E(m.end, G));
        t(x, {
          children: f,
          descendants: n,
          height: z
        });
        "function" === typeof g && g(x, c);
        return x;
      };
    return {
      getListOfParents: y,
      getNode: F,
      getTree: function (a, t) {
        var q = a.map(function (a) {
          return a.id;
        });
        a = y(a, q);
        return F("", null, 1, null, a, t);
      }
    };
  });
  N(a, "Core/Axis/TreeGridTick.js", [a["Core/Utilities.js"]], function (a) {
    var t = a.addEvent,
      B = a.isObject,
      E = a.isNumber,
      y = a.pick,
      F = a.wrap,
      I;
    (function (a) {
      function q() {
        this.treeGrid || (this.treeGrid = new z(this));
      }
      function m(a, c) {
        a = a.treeGrid;
        var e = !a.labelIcon,
          f = c.renderer,
          g = c.xy,
          h = c.options,
          n = h.width || 0,
          l = h.height || 0,
          m = g.x - n / 2 - (h.padding || 0);
        g = g.y - l / 2;
        var b = c.collapsed ? 90 : 180,
          q = c.show && E(g),
          d = a.labelIcon;
        d || (a.labelIcon = d = f.path(f.symbols[h.type](h.x || 0, h.y || 0, n, l)).addClass("highcharts-label-icon").add(c.group));
        d.attr({
          y: q ? 0 : -9999
        });
        f.styledMode || d.attr({
          cursor: "pointer",
          fill: y(c.color, "#666666"),
          "stroke-width": 1,
          stroke: h.lineColor,
          strokeWidth: h.lineWidth || 0
        });
        d[e ? "attr" : "animate"]({
          translateX: m,
          translateY: g,
          rotation: b
        });
      }
      function h(a, c, e, h, n, m, p, l, q) {
        var b = y(this.options && this.options.labels, m);
        m = this.pos;
        var f = this.axis,
          d = "treegrid" === f.options.type;
        a = a.apply(this, [c, e, h, n, b, p, l, q]);
        d && (c = b && B(b.symbol, !0) ? b.symbol : {}, b = b && E(b.indentation) ? b.indentation : 0, m = (m = (f = f.treeGrid.mapOfPosToGridNode) && f[m]) && m.depth || 1, a.x += (c.width || 0) + 2 * (c.padding || 0) + (m - 1) * b);
        return a;
      }
      function c(a) {
        var c = this,
          e = c.pos,
          g = c.axis,
          h = c.label,
          n = g.treeGrid.mapOfPosToGridNode,
          p = g.options,
          l = y(c.options && c.options.labels, p && p.labels),
          q = l && B(l.symbol, !0) ? l.symbol : {},
          b = (n = n && n[e]) && n.depth;
        p = "treegrid" === p.type;
        var v = -1 < g.tickPositions.indexOf(e);
        e = g.chart.styledMode;
        p && n && h && h.element && h.addClass("highcharts-treegrid-node-level-" + b);
        a.apply(c, Array.prototype.slice.call(arguments, 1));
        p && h && h.element && n && n.descendants && 0 < n.descendants && (g = g.treeGrid.isCollapsed(n), m(c, {
          color: !e && h.styles && h.styles.color || "",
          collapsed: g,
          group: h.parentGroup,
          options: q,
          renderer: h.renderer,
          show: v,
          xy: h.xy
        }), q = "highcharts-treegrid-node-" + (g ? "expanded" : "collapsed"), h.addClass("highcharts-treegrid-node-" + (g ? "collapsed" : "expanded")).removeClass(q), e || h.css({
          cursor: "pointer"
        }), [h, c.treeGrid.labelIcon].forEach(function (a) {
          a && !a.attachedTreeGridEvents && (t(a.element, "mouseover", function () {
            h.addClass("highcharts-treegrid-node-active");
            h.renderer.styledMode || h.css({
              textDecoration: "underline"
            });
          }), t(a.element, "mouseout", function () {
            var a = B(l.style) ? l.style : {};
            h.removeClass("highcharts-treegrid-node-active");
            h.renderer.styledMode || h.css({
              textDecoration: a.textDecoration
            });
          }), t(a.element, "click", function () {
            c.treeGrid.toggleCollapse();
          }), a.attachedTreeGridEvents = !0);
        }));
      }
      var n = !1;
      a.compose = function (a) {
        n || (t(a, "init", q), F(a.prototype, "getLabelPosition", h), F(a.prototype, "renderLabel", c), a.prototype.collapse = function (a) {
          this.treeGrid.collapse(a);
        }, a.prototype.expand = function (a) {
          this.treeGrid.expand(a);
        }, a.prototype.toggleCollapse = function (a) {
          this.treeGrid.toggleCollapse(a);
        }, n = !0);
      };
      var z = function () {
        function a(a) {
          this.tick = a;
        }
        a.prototype.collapse = function (a) {
          var c = this.tick,
            f = c.axis,
            g = f.brokenAxis;
          g && f.treeGrid.mapOfPosToGridNode && (c = f.treeGrid.collapse(f.treeGrid.mapOfPosToGridNode[c.pos]), g.setBreaks(c, y(a, !0)));
        };
        a.prototype.expand = function (a) {
          var c = this.tick,
            f = c.axis,
            g = f.brokenAxis;
          g && f.treeGrid.mapOfPosToGridNode && (c = f.treeGrid.expand(f.treeGrid.mapOfPosToGridNode[c.pos]), g.setBreaks(c, y(a, !0)));
        };
        a.prototype.toggleCollapse = function (a) {
          var c = this.tick,
            f = c.axis,
            g = f.brokenAxis;
          g && f.treeGrid.mapOfPosToGridNode && (c = f.treeGrid.toggleCollapse(f.treeGrid.mapOfPosToGridNode[c.pos]), g.setBreaks(c, y(a, !0)));
        };
        return a;
      }();
      a.Additions = z;
    })(I || (I = {}));
    return I;
  });
  N(a, "Series/TreeUtilities.js", [a["Core/Color/Color.js"], a["Core/Utilities.js"]], function (a, t) {
    function B(a, h) {
      var c = h.before,
        n = h.idRoot,
        m = h.mapIdToNode[n],
        g = h.points[a.i],
        f = g && g.options || {},
        e = [],
        t = 0;
      a.levelDynamic = a.level - (!1 !== h.levelIsConstant ? 0 : m.level);
      a.name = q(g && g.name, "");
      a.visible = n === a.id || !0 === h.visible;
      "function" === typeof c && (a = c(a, h));
      a.children.forEach(function (c, f) {
        var g = E({}, h);
        E(g, {
          index: f,
          siblings: a.children.length,
          visible: a.visible
        });
        c = B(c, g);
        e.push(c);
        c.visible && (t += c.val);
      });
      c = q(f.value, t);
      a.visible = 0 <= c && (0 < t || a.visible);
      a.children = e;
      a.childrenTotal = t;
      a.isLeaf = a.visible && !t;
      a.val = c;
      return a;
    }
    var E = t.extend,
      y = t.isArray,
      F = t.isNumber,
      I = t.isObject,
      x = t.merge,
      q = t.pick;
    return {
      getColor: function (m, h) {
        var c = h.index,
          n = h.mapOptionsToLevel,
          t = h.parentColor,
          g = h.parentColorIndex,
          f = h.series,
          e = h.colors,
          x = h.siblings,
          y = f.points,
          B = f.chart.options.chart,
          p;
        if (m) {
          y = y[m.i];
          m = n[m.level] || {};
          if (n = y && m.colorByPoint) {
            var l = y.index % (e ? e.length : B.colorCount);
            var w = e && e[l];
          }
          if (!f.chart.styledMode) {
            e = y && y.options.color;
            B = m && m.color;
            if (p = t) p = (p = m && m.colorVariation) && "brightness" === p.key && c && x ? a.parse(t).brighten(c / x * p.to).get() : t;
            p = q(e, B, w, p, f.color);
          }
          var b = q(y && y.options.colorIndex, m && m.colorIndex, l, g, h.colorIndex);
        }
        return {
          color: p,
          colorIndex: b
        };
      },
      getLevelOptions: function (a) {
        var h = null;
        if (I(a)) {
          h = {};
          var c = F(a.from) ? a.from : 1;
          var n = a.levels;
          var m = {};
          var g = I(a.defaults) ? a.defaults : {};
          y(n) && (m = n.reduce(function (a, e) {
            if (I(e) && F(e.level)) {
              var f = x({}, e);
              var h = q(f.levelIsConstant, g.levelIsConstant);
              delete f.levelIsConstant;
              delete f.level;
              e = e.level + (h ? 0 : c - 1);
              I(a[e]) ? x(!0, a[e], f) : a[e] = f;
            }
            return a;
          }, {}));
          n = F(a.to) ? a.to : 1;
          for (a = 0; a <= n; a++) h[a] = x({}, g, I(m[a]) ? m[a] : {});
        }
        return h;
      },
      setTreeValues: B,
      updateRootId: function (a) {
        if (I(a)) {
          var h = I(a.options) ? a.options : {};
          h = q(a.rootNode, h.rootId, "");
          I(a.userOptions) && (a.userOptions.rootId = h);
          a.rootNode = h;
        }
        return h;
      }
    };
  });
  N(a, "Core/Axis/TreeGridAxis.js", [a["Core/Axis/BrokenAxis.js"], a["Core/Axis/GridAxis.js"], a["Gantt/Tree.js"], a["Core/Axis/TreeGridTick.js"], a["Series/TreeUtilities.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F) {
    var E = y.getLevelOptions,
      x = F.addEvent,
      q = F.find,
      m = F.fireEvent,
      h = F.isArray,
      c = F.isObject,
      n = F.isString,
      z = F.merge,
      g = F.pick,
      f = F.wrap,
      e;
    (function (e) {
      function G(a, b) {
        var c = a.collapseEnd || 0;
        a = a.collapseStart || 0;
        c >= b && (a -= .5);
        return {
          from: a,
          to: c,
          showPoints: !1
        };
      }
      function y(a, b, d) {
        var e = [],
          f = [],
          g = {},
          k = "boolean" === typeof b ? b : !1,
          h = {},
          l = -1;
        a = B.getTree(a, {
          after: function (a) {
            a = h[a.pos];
            var b = 0,
              c = 0;
            a.children.forEach(function (a) {
              c += (a.descendants || 0) + 1;
              b = Math.max((a.height || 0) + 1, b);
            });
            a.descendants = c;
            a.height = b;
            a.collapsed && f.push(a);
          },
          before: function (a) {
            var b = c(a.data, !0) ? a.data : {},
              d = n(b.name) ? b.name : "",
              f = g[a.parent];
            f = c(f, !0) ? h[f.pos] : null;
            var r = function (a) {
                return a.name === d;
              },
              p;
            k && c(f, !0) && (p = q(f.children, r)) ? (r = p.pos, p.nodes.push(a)) : r = l++;
            h[r] || (h[r] = p = {
              depth: f ? f.depth + 1 : 0,
              name: d,
              id: b.id,
              nodes: [a],
              children: [],
              pos: r
            }, -1 !== r && e.push(d), c(f, !0) && f.children.push(p));
            n(a.id) && (g[a.id] = a);
            p && !0 === b.collapsed && (p.collapsed = !0);
            a.pos = r;
          }
        });
        h = function (a, b) {
          var d = function (a, e, f) {
            var g = e + (-1 === e ? 0 : b - 1),
              k = (g - e) / 2,
              h = e + k;
            a.nodes.forEach(function (a) {
              var b = a.data;
              c(b, !0) && (b.y = e + (b.seriesIndex || 0), delete b.seriesIndex);
              a.pos = h;
            });
            f[h] = a;
            a.pos = h;
            a.tickmarkOffset = k + .5;
            a.collapseStart = g + .5;
            a.children.forEach(function (a) {
              d(a, g + 1, f);
              g = (a.collapseEnd || 0) - .5;
            });
            a.collapseEnd = g + .5;
            return f;
          };
          return d(a["-1"], -1, {});
        }(h, d);
        return {
          categories: e,
          mapOfIdToNode: g,
          mapOfPosToGridNode: h,
          collapsedNodes: f,
          tree: a
        };
      }
      function p(a) {
        a.target.axes.filter(function (a) {
          return "treegrid" === a.options.type;
        }).forEach(function (b) {
          var d = b.options || {},
            e = d.labels,
            f = d.uniqueNames;
          d = d.max;
          var g = 0;
          if (!b.treeGrid.mapOfPosToGridNode || b.series.some(function (a) {
            return !a.hasRendered || a.isDirtyData || a.isDirty;
          })) {
            var l = b.series.reduce(function (a, b) {
              b.visible && ((b.options.data || []).forEach(function (d) {
                b.options.keys && b.options.keys.length && (d = b.pointClass.prototype.optionsToObject.call({
                  series: b
                }, d), b.pointClass.setGanttPointAliases(d));
                c(d, !0) && (d.seriesIndex = g, a.push(d));
              }), !0 === f && g++);
              return a;
            }, []);
            if (d && l.length < d) for (var n = l.length; n <= d; n++) l.push({
              name: n + "\u200b"
            });
            d = y(l, f || !1, !0 === f ? g : 1);
            b.categories = d.categories;
            b.treeGrid.mapOfPosToGridNode = d.mapOfPosToGridNode;
            b.hasNames = !0;
            b.treeGrid.tree = d.tree;
            b.series.forEach(function (a) {
              var b = (a.options.data || []).map(function (b) {
                h(b) && a.options.keys && a.options.keys.length && l.forEach(function (a) {
                  0 <= b.indexOf(a.x) && 0 <= b.indexOf(a.x2) && (b = a);
                });
                return c(b, !0) ? z(b) : b;
              });
              a.visible && a.setData(b, !1);
            });
            b.treeGrid.mapOptionsToLevel = E({
              defaults: e,
              from: 1,
              levels: e && e.levels,
              to: b.treeGrid.tree && b.treeGrid.tree.height
            });
            "beforeRender" === a.type && (b.treeGrid.collapsedNodes = d.collapsedNodes);
          }
        });
      }
      function l(a, b) {
        var c = this.treeGrid.mapOptionsToLevel || {},
          d = this.ticks,
          e = d[b],
          f;
        if ("treegrid" === this.options.type && this.treeGrid.mapOfPosToGridNode) {
          var g = this.treeGrid.mapOfPosToGridNode[b];
          (c = c[g.depth]) && (f = {
            labels: c
          });
          !e && v ? d[b] = new v(this, b, void 0, void 0, {
            category: g.name,
            tickmarkOffset: g.tickmarkOffset,
            options: f
          }) : (e.parameters.category = g.name, e.options = f, e.addLabel());
        } else a.apply(this, Array.prototype.slice.call(arguments, 1));
      }
      function w(a, b, c) {
        var e = this,
          f = "treegrid" === c.type;
        e.treeGrid || (e.treeGrid = new d(e));
        f && (x(b, "beforeRender", p), x(b, "beforeRedraw", p), x(b, "addSeries", function (a) {
          a.options.data && (a = y(a.options.data, c.uniqueNames || !1, 1), e.treeGrid.collapsedNodes = (e.treeGrid.collapsedNodes || []).concat(a.collapsedNodes));
        }), x(e, "foundExtremes", function () {
          e.treeGrid.collapsedNodes && e.treeGrid.collapsedNodes.forEach(function (a) {
            var b = e.treeGrid.collapse(a);
            e.brokenAxis && (e.brokenAxis.setBreaks(b, !1), e.treeGrid.collapsedNodes && (e.treeGrid.collapsedNodes = e.treeGrid.collapsedNodes.filter(function (b) {
              return a.collapseStart !== b.collapseStart || a.collapseEnd !== b.collapseEnd;
            })));
          });
        }), x(e, "afterBreaks", function () {
          "yAxis" === e.coll && !e.staticScale && e.chart.options.chart.height && (e.isDirty = !0);
        }), c = z({
          grid: {
            enabled: !0
          },
          labels: {
            align: "left",
            levels: [{
              level: void 0
            }, {
              level: 1,
              style: {
                fontWeight: "bold"
              }
            }],
            symbol: {
              type: "triangle",
              x: -5,
              y: -5,
              height: 10,
              width: 10,
              padding: 5
            }
          },
          uniqueNames: !1
        }, c, {
          reversed: !0,
          grid: {
            columns: void 0
          }
        }));
        a.apply(e, [b, c]);
        f && (e.hasNames = !0, e.options.showLastLabel = !0);
      }
      function b(a) {
        var b = this.options;
        "treegrid" === b.type ? (this.min = g(this.userMin, b.min, this.dataMin), this.max = g(this.userMax, b.max, this.dataMax), m(this, "foundExtremes"), this.setAxisTranslation(), this.tickmarkOffset = .5, this.tickInterval = 1, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : []) : a.apply(this, Array.prototype.slice.call(arguments, 1));
      }
      var v;
      e.compose = function (c, d, e, g) {
        -1 === c.keepProps.indexOf("treeGrid") && (c.keepProps.push("treeGrid"), v = g, f(c.prototype, "generateTick", l), f(c.prototype, "init", w), f(c.prototype, "setTickInterval", b), c.prototype.utils = {
          getNode: B.getNode
        }, t.compose(c, d, g), a.compose(c, e), H.compose(g));
        return c;
      };
      var d = function () {
        function a(a) {
          this.axis = a;
        }
        a.prototype.setCollapsedStatus = function (a) {
          var b = this.axis,
            c = b.chart;
          b.series.forEach(function (b) {
            var d = b.options.data;
            if (a.id && d) {
              var e = c.get(a.id);
              b = d[b.data.indexOf(e)];
              e && b && (e.collapsed = a.collapsed, b.collapsed = a.collapsed);
            }
          });
        };
        a.prototype.collapse = function (a) {
          var b = this.axis,
            c = b.options.breaks || [],
            d = G(a, b.max);
          c.push(d);
          a.collapsed = !0;
          b.treeGrid.setCollapsedStatus(a);
          return c;
        };
        a.prototype.expand = function (a) {
          var b = this.axis,
            c = b.options.breaks || [],
            d = G(a, b.max);
          a.collapsed = !1;
          b.treeGrid.setCollapsedStatus(a);
          return c.reduce(function (a, b) {
            b.to === d.to && b.from === d.from || a.push(b);
            return a;
          }, []);
        };
        a.prototype.getTickPositions = function () {
          var a = this.axis,
            b = Math.floor(a.min / a.tickInterval) * a.tickInterval,
            c = Math.ceil(a.max / a.tickInterval) * a.tickInterval;
          return Object.keys(a.treeGrid.mapOfPosToGridNode || {}).reduce(function (d, e) {
            e = +e;
            !(e >= b && e <= c) || a.brokenAxis && a.brokenAxis.isInAnyBreak(e) || d.push(e);
            return d;
          }, []);
        };
        a.prototype.isCollapsed = function (a) {
          var b = this.axis,
            c = b.options.breaks || [],
            d = G(a, b.max);
          return c.some(function (a) {
            return a.from === d.from && a.to === d.to;
          });
        };
        a.prototype.toggleCollapse = function (a) {
          return this.isCollapsed(a) ? this.expand(a) : this.collapse(a);
        };
        return a;
      }();
      e.Additions = d;
    })(e || (e = {}));
    return e;
  });
  N(a, "Extensions/CurrentDateIndication.js", [a["Core/Axis/Axis.js"], a["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = B.addEvent,
      y = B.merge;
    B = B.wrap;
    var F = {
      color: "#ccd6eb",
      width: 2,
      label: {
        format: "%a, %b %d %Y, %H:%M",
        formatter: function (a, t) {
          return this.axis.chart.time.dateFormat(t || "", a);
        },
        rotation: 0,
        style: {
          fontSize: "10px"
        }
      }
    };
    E(a, "afterSetOptions", function () {
      var a = this.options,
        t = a.currentDateIndicator;
      t && (t = "object" === typeof t ? y(F, t) : y(F), t.value = Date.now(), t.className = "highcharts-current-date-indicator", a.plotLines || (a.plotLines = []), a.plotLines.push(t));
    });
    E(t, "render", function () {
      this.label && this.label.attr({
        text: this.getLabelText(this.options.label)
      });
    });
    B(t.prototype, "getLabelText", function (a, t) {
      var q = this.options;
      return q && q.className && -1 !== q.className.indexOf("highcharts-current-date-indicator") && q.label && "function" === typeof q.label.formatter ? (q.value = Date.now(), q.label.formatter.call(this, q.value, q.label.format)) : a.call(this, t);
    });
  });
  N(a, "Extensions/StaticScale.js", [a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = B.addEvent,
      y = B.defined,
      F = B.isNumber,
      I = B.pick;
    E(a, "afterSetOptions", function () {
      var a = this.chart.options.chart;
      !this.horiz && F(this.options.staticScale) && (!a.height || a.scrollablePlotArea && a.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);
    });
    t.prototype.adjustHeight = function () {
      "adjustHeight" !== this.redrawTrigger && ((this.axes || []).forEach(function (a) {
        var q = a.chart,
          m = !!q.initiatedScale && q.options.animation,
          h = a.options.staticScale;
        if (a.staticScale && y(a.min)) {
          var c = I(a.brokenAxis && a.brokenAxis.unitLength, a.max + a.tickInterval - a.min) * h;
          c = Math.max(c, h);
          h = c - q.plotHeight;
          !q.scrollablePixelsY && 1 <= Math.abs(h) && (q.plotHeight = c, q.redrawTrigger = "adjustHeight", q.setSize(void 0, q.chartHeight + h, m));
          a.series.forEach(function (a) {
            (a = a.sharedClipKey && q.sharedClips[a.sharedClipKey]) && a.attr(q.inverted ? {
              width: q.plotHeight
            } : {
              height: q.plotHeight
            });
          });
        }
      }), this.initiatedScale = !0);
      this.redrawTrigger = null;
    };
    E(t, "render", t.prototype.adjustHeight);
  });
  N(a, "Extensions/ArrowSymbols.js", [a["Core/Renderer/SVG/SVGRenderer.js"]], function (a) {
    function t(a, t, B, x) {
      return [["M", a, t + x / 2], ["L", a + B, t], ["L", a, t + x / 2], ["L", a + B, t + x]];
    }
    function B(a, t, B, x) {
      return [["M", a + B, t], ["L", a, t + x / 2], ["L", a + B, t + x], ["Z"]];
    }
    function E(a, t, E, x) {
      return B(a, t, E / 2, x);
    }
    a = a.prototype.symbols;
    a.arrow = t;
    a["arrow-filled"] = B;
    a["arrow-filled-half"] = E;
    a["arrow-half"] = function (a, B, E, x) {
      return t(a, B, E / 2, x);
    };
    a["triangle-left"] = B;
    a["triangle-left-half"] = E;
    return a;
  });
  N(a, "Gantt/Connection.js", [a["Core/Globals.js"], a["Core/DefaultOptions.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function (a, t, B, H) {
    function y(a) {
      var c = a.shapeArgs;
      return c ? {
        xMin: c.x || 0,
        xMax: (c.x || 0) + (c.width || 0),
        yMin: c.y || 0,
        yMax: (c.y || 0) + (c.height || 0)
      } : (c = a.graphic && a.graphic.getBBox()) ? {
        xMin: a.plotX - c.width / 2,
        xMax: a.plotX + c.width / 2,
        yMin: a.plotY - c.height / 2,
        yMax: a.plotY + c.height / 2
      } : null;
    }
    "";
    var E = H.defined,
      I = H.error,
      x = H.extend,
      q = H.merge,
      m = H.objectEach,
      h = a.deg2rad,
      c = Math.max,
      n = Math.min;
    x(t.defaultOptions, {
      connectors: {
        type: "straight",
        lineWidth: 1,
        marker: {
          enabled: !1,
          align: "center",
          verticalAlign: "middle",
          inside: !1,
          lineWidth: 1
        },
        startMarker: {
          symbol: "diamond"
        },
        endMarker: {
          symbol: "arrow-filled"
        }
      }
    });
    t = function () {
      function a(a, c, e) {
        this.toPoint = this.pathfinder = this.graphics = this.fromPoint = this.chart = void 0;
        this.init(a, c, e);
      }
      a.prototype.init = function (a, c, e) {
        this.fromPoint = a;
        this.toPoint = c;
        this.options = e;
        this.chart = a.series.chart;
        this.pathfinder = this.chart.pathfinder;
      };
      a.prototype.renderPath = function (a, c, e) {
        var f = this.chart,
          g = f.styledMode,
          h = f.pathfinder,
          n = !f.options.chart.forExport && !1 !== e,
          l = this.graphics && this.graphics.path;
        h.group || (h.group = f.renderer.g().addClass("highcharts-pathfinder-group").attr({
          zIndex: -1
        }).add(f.seriesGroup));
        h.group.translate(f.plotLeft, f.plotTop);
        l && l.renderer || (l = f.renderer.path().add(h.group), g || l.attr({
          opacity: 0
        }));
        l.attr(c);
        a = {
          d: a
        };
        g || (a.opacity = 1);
        l[n ? "animate" : "attr"](a, e);
        this.graphics = this.graphics || {};
        this.graphics.path = l;
      };
      a.prototype.addMarker = function (a, c, e) {
        var f = this.fromPoint.series.chart,
          g = f.pathfinder;
        f = f.renderer;
        var n = "start" === a ? this.fromPoint : this.toPoint,
          p = n.getPathfinderAnchorPoint(c);
        if (c.enabled && ((e = "start" === a ? e[1] : e[e.length - 2]) && "M" === e[0] || "L" === e[0])) {
          e = {
            x: e[1],
            y: e[2]
          };
          e = n.getRadiansToVector(e, p);
          p = n.getMarkerVector(e, c.radius, p);
          e = -e / h;
          if (c.width && c.height) {
            var l = c.width;
            var m = c.height;
          } else l = m = 2 * c.radius;
          this.graphics = this.graphics || {};
          p = {
            x: p.x - l / 2,
            y: p.y - m / 2,
            width: l,
            height: m,
            rotation: e,
            rotationOriginX: p.x,
            rotationOriginY: p.y
          };
          this.graphics[a] ? this.graphics[a].animate(p) : (this.graphics[a] = f.symbol(c.symbol).addClass("highcharts-point-connecting-path-" + a + "-marker").attr(p).add(g.group), f.styledMode || this.graphics[a].attr({
            fill: c.color || this.fromPoint.color,
            stroke: c.lineColor,
            "stroke-width": c.lineWidth,
            opacity: 0
          }).animate({
            opacity: 1
          }, n.series.options.animation));
        }
      };
      a.prototype.getPath = function (a) {
        var c = this.pathfinder,
          e = this.chart,
          g = c.algorithms[a.type],
          h = c.chartObstacles;
        if ("function" !== typeof g) return I('"' + a.type + '" is not a Pathfinder algorithm.'), {
          path: [],
          obstacles: []
        };
        g.requiresObstacles && !h && (h = c.chartObstacles = c.getChartObstacles(a), e.options.connectors.algorithmMargin = a.algorithmMargin, c.chartObstacleMetrics = c.getObstacleMetrics(h));
        return g(this.fromPoint.getPathfinderAnchorPoint(a.startMarker), this.toPoint.getPathfinderAnchorPoint(a.endMarker), q({
          chartObstacles: h,
          lineObstacles: c.lineObstacles || [],
          obstacleMetrics: c.chartObstacleMetrics,
          hardBounds: {
            xMin: 0,
            xMax: e.plotWidth,
            yMin: 0,
            yMax: e.plotHeight
          },
          obstacleOptions: {
            margin: a.algorithmMargin
          },
          startDirectionX: c.getAlgorithmStartDirection(a.startMarker)
        }, a));
      };
      a.prototype.render = function () {
        var a = this.fromPoint,
          f = a.series,
          e = f.chart,
          h = e.pathfinder,
          m = q(e.options.connectors, f.options.connectors, a.options.connectors, this.options),
          t = {};
        e.styledMode || (t.stroke = m.lineColor || a.color, t["stroke-width"] = m.lineWidth, m.dashStyle && (t.dashstyle = m.dashStyle));
        t["class"] = "highcharts-point-connecting-path highcharts-color-" + a.colorIndex;
        m = q(t, m);
        E(m.marker.radius) || (m.marker.radius = n(c(Math.ceil((m.algorithmMargin || 8) / 2) - 1, 1), 5));
        a = this.getPath(m);
        e = a.path;
        a.obstacles && (h.lineObstacles = h.lineObstacles || [], h.lineObstacles = h.lineObstacles.concat(a.obstacles));
        this.renderPath(e, t, f.options.animation);
        this.addMarker("start", q(m.marker, m.startMarker), e);
        this.addMarker("end", q(m.marker, m.endMarker), e);
      };
      a.prototype.destroy = function () {
        this.graphics && (m(this.graphics, function (a) {
          a.destroy();
        }), delete this.graphics);
      };
      return a;
    }();
    a.Connection = t;
    x(B.prototype, {
      getPathfinderAnchorPoint: function (a) {
        var c = y(this);
        switch (a.align) {
          case "right":
            var f = "xMax";
            break;
          case "left":
            f = "xMin";
        }
        switch (a.verticalAlign) {
          case "top":
            var e = "yMin";
            break;
          case "bottom":
            e = "yMax";
        }
        return {
          x: f ? c[f] : (c.xMin + c.xMax) / 2,
          y: e ? c[e] : (c.yMin + c.yMax) / 2
        };
      },
      getRadiansToVector: function (a, c) {
        var f;
        E(c) || (f = y(this)) && (c = {
          x: (f.xMin + f.xMax) / 2,
          y: (f.yMin + f.yMax) / 2
        });
        return Math.atan2(c.y - a.y, a.x - c.x);
      },
      getMarkerVector: function (a, c, f) {
        var e = 2 * Math.PI,
          g = y(this),
          h = g.xMax - g.xMin,
          n = g.yMax - g.yMin,
          p = Math.atan2(n, h),
          l = !1;
        h /= 2;
        var m = n / 2,
          b = g.xMin + h;
        g = g.yMin + m;
        for (var q = b, d = g, t = 1, C = 1; a < -Math.PI;) a += e;
        for (; a > Math.PI;) a -= e;
        e = Math.tan(a);
        a > -p && a <= p ? (C = -1, l = !0) : a > p && a <= Math.PI - p ? C = -1 : a > Math.PI - p || a <= -(Math.PI - p) ? (t = -1, l = !0) : t = -1;
        l ? (q += t * h, d += C * h * e) : (q += n / (2 * e) * t, d += C * m);
        f.x !== b && (q = f.x);
        f.y !== g && (d = f.y);
        return {
          x: q + c * Math.cos(a),
          y: d - c * Math.sin(a)
        };
      }
    });
    return t;
  });
  N(a, "Gantt/PathfinderAlgorithms.js", [a["Core/Utilities.js"]], function (a) {
    function t(a, c, n) {
      n = n || 0;
      var h = a.length - 1;
      c -= 1e-7;
      for (var g, f; n <= h;) if (g = h + n >> 1, f = c - a[g].xMin, 0 < f) n = g + 1;else if (0 > f) h = g - 1;else return g;
      return 0 < n ? n - 1 : 0;
    }
    function B(a, c) {
      for (var h = t(a, c.x + 1) + 1; h--;) {
        var m;
        if (m = a[h].xMax >= c.x) m = a[h], m = c.x <= m.xMax && c.x >= m.xMin && c.y <= m.yMax && c.y >= m.yMin;
        if (m) return h;
      }
      return -1;
    }
    function E(a) {
      var c = [];
      if (a.length) {
        c.push(["M", a[0].start.x, a[0].start.y]);
        for (var h = 0; h < a.length; ++h) c.push(["L", a[h].end.x, a[h].end.y]);
      }
      return c;
    }
    function y(a, c) {
      a.yMin = x(a.yMin, c.yMin);
      a.yMax = I(a.yMax, c.yMax);
      a.xMin = x(a.xMin, c.xMin);
      a.xMax = I(a.xMax, c.xMax);
    }
    var F = a.pick,
      I = Math.min,
      x = Math.max,
      q = Math.abs;
    a = function (a, c, n) {
      function h(a, c, b, e, d) {
        a = {
          x: a.x,
          y: a.y
        };
        a[c] = b[e || c] + (d || 0);
        return a;
      }
      function g(a, c, b) {
        var e = q(c[b] - a[b + "Min"]) > q(c[b] - a[b + "Max"]);
        return h(c, b, a, b + (e ? "Max" : "Min"), e ? 1 : -1);
      }
      var f = [],
        e = F(n.startDirectionX, q(c.x - a.x) > q(c.y - a.y)) ? "x" : "y",
        m = n.chartObstacles,
        t = B(m, a);
      n = B(m, c);
      if (-1 < n) {
        var x = m[n];
        n = g(x, c, e);
        x = {
          start: n,
          end: c
        };
        var p = n;
      } else p = c;
      -1 < t && (m = m[t], n = g(m, a, e), f.push({
        start: a,
        end: n
      }), n[e] >= a[e] === n[e] >= p[e] && (e = "y" === e ? "x" : "y", c = a[e] < c[e], f.push({
        start: n,
        end: h(n, e, m, e + (c ? "Max" : "Min"), c ? 1 : -1)
      }), e = "y" === e ? "x" : "y"));
      a = f.length ? f[f.length - 1].end : a;
      n = h(a, e, p);
      f.push({
        start: a,
        end: n
      });
      e = h(n, "y" === e ? "x" : "y", p);
      f.push({
        start: n,
        end: e
      });
      f.push(x);
      return {
        path: E(f),
        obstacles: f
      };
    };
    a.requiresObstacles = !0;
    var m = function (a, c, n) {
      function h(a, b, c) {
        var d,
          e = a.x < b.x ? 1 : -1;
        if (a.x < b.x) {
          var f = a;
          var g = b;
        } else f = b, g = a;
        if (a.y < b.y) {
          var k = a;
          var h = b;
        } else k = b, h = a;
        for (d = 0 > e ? I(t(D, g.x), D.length - 1) : 0; D[d] && (0 < e && D[d].xMin <= g.x || 0 > e && D[d].xMax >= f.x);) {
          if (D[d].xMin <= g.x && D[d].xMax >= f.x && D[d].yMin <= h.y && D[d].yMax >= k.y) return c ? {
            y: a.y,
            x: a.x < b.x ? D[d].xMin - 1 : D[d].xMax + 1,
            obstacle: D[d]
          } : {
            x: a.x,
            y: a.y < b.y ? D[d].yMin - 1 : D[d].yMax + 1,
            obstacle: D[d]
          };
          d += e;
        }
        return b;
      }
      function g(a, b, c, d, e) {
        var f = e.soft,
          g = e.hard,
          k = d ? "x" : "y",
          r = {
            x: b.x,
            y: b.y
          },
          l = {
            x: b.x,
            y: b.y
          };
        e = a[k + "Max"] >= f[k + "Max"];
        f = a[k + "Min"] <= f[k + "Min"];
        var n = a[k + "Max"] >= g[k + "Max"];
        g = a[k + "Min"] <= g[k + "Min"];
        var m = q(a[k + "Min"] - b[k]),
          p = q(a[k + "Max"] - b[k]);
        c = 10 > q(m - p) ? b[k] < c[k] : p < m;
        l[k] = a[k + "Min"];
        r[k] = a[k + "Max"];
        a = h(b, l, d)[k] !== l[k];
        b = h(b, r, d)[k] !== r[k];
        c = a ? b ? c : !0 : b ? !1 : c;
        c = f ? e ? c : !0 : e ? !1 : c;
        return g ? n ? c : !0 : n ? !1 : c;
      }
      function f(a, c, e) {
        if (a.x === c.x && a.y === c.y) return [];
        var k = e ? "x" : "y",
          r = n.obstacleOptions.margin;
        var l = {
          soft: {
            xMin: w,
            xMax: b,
            yMin: v,
            yMax: d
          },
          hard: n.hardBounds
        };
        var m = B(D, a);
        if (-1 < m) {
          m = D[m];
          l = g(m, a, c, e, l);
          y(m, n.hardBounds);
          var q = e ? {
            y: a.y,
            x: m[l ? "xMax" : "xMin"] + (l ? 1 : -1)
          } : {
            x: a.x,
            y: m[l ? "yMax" : "yMin"] + (l ? 1 : -1)
          };
          var t = B(D, q);
          -1 < t && (t = D[t], y(t, n.hardBounds), q[k] = l ? x(m[k + "Max"] - r + 1, (t[k + "Min"] + m[k + "Max"]) / 2) : I(m[k + "Min"] + r - 1, (t[k + "Max"] + m[k + "Min"]) / 2), a.x === q.x && a.y === q.y ? (p && (q[k] = l ? x(m[k + "Max"], t[k + "Max"]) + 1 : I(m[k + "Min"], t[k + "Min"]) - 1), p = !p) : p = !1);
          a = [{
            start: a,
            end: q
          }];
        } else k = h(a, {
          x: e ? c.x : a.x,
          y: e ? a.y : c.y
        }, e), a = [{
          start: a,
          end: {
            x: k.x,
            y: k.y
          }
        }], k[e ? "x" : "y"] !== c[e ? "x" : "y"] && (l = g(k.obstacle, k, c, !e, l), y(k.obstacle, n.hardBounds), l = {
          x: e ? k.x : k.obstacle[l ? "xMax" : "xMin"] + (l ? 1 : -1),
          y: e ? k.obstacle[l ? "yMax" : "yMin"] + (l ? 1 : -1) : k.y
        }, e = !e, a = a.concat(f({
          x: k.x,
          y: k.y
        }, l, e)));
        return a = a.concat(f(a[a.length - 1].end, c, !e));
      }
      function e(a, b, c) {
        var d = I(a.xMax - b.x, b.x - a.xMin) < I(a.yMax - b.y, b.y - a.yMin);
        c = g(a, b, c, d, {
          soft: n.hardBounds,
          hard: n.hardBounds
        });
        return d ? {
          y: b.y,
          x: a[c ? "xMax" : "xMin"] + (c ? 1 : -1)
        } : {
          x: b.x,
          y: a[c ? "yMax" : "yMin"] + (c ? 1 : -1)
        };
      }
      var m = F(n.startDirectionX, q(c.x - a.x) > q(c.y - a.y)),
        J = m ? "x" : "y",
        H = [],
        p = !1,
        l = n.obstacleMetrics,
        w = I(a.x, c.x) - l.maxWidth - 10,
        b = x(a.x, c.x) + l.maxWidth + 10,
        v = I(a.y, c.y) - l.maxHeight - 10,
        d = x(a.y, c.y) + l.maxHeight + 10,
        D = n.chartObstacles;
      var C = t(D, w);
      l = t(D, b);
      D = D.slice(C, l + 1);
      if (-1 < (l = B(D, c))) {
        var k = e(D[l], c, a);
        H.push({
          end: c,
          start: k
        });
        c = k;
      }
      for (; -1 < (l = B(D, c));) C = 0 > c[J] - a[J], k = {
        x: c.x,
        y: c.y
      }, k[J] = D[l][C ? J + "Max" : J + "Min"] + (C ? 1 : -1), H.push({
        end: c,
        start: k
      }), c = k;
      a = f(a, c, m);
      a = a.concat(H.reverse());
      return {
        path: E(a),
        obstacles: a
      };
    };
    m.requiresObstacles = !0;
    return {
      fastAvoid: m,
      straight: function (a, c) {
        return {
          path: [["M", a.x, a.y], ["L", c.x, c.y]],
          obstacles: [{
            start: a,
            end: c
          }]
        };
      },
      simpleConnect: a
    };
  });
  N(a, "Gantt/Pathfinder.js", [a["Gantt/Connection.js"], a["Core/Chart/Chart.js"], a["Core/Globals.js"], a["Core/DefaultOptions.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"], a["Gantt/PathfinderAlgorithms.js"]], function (a, t, B, H, y, F, I) {
    function x(a) {
      var c = a.shapeArgs;
      return c ? {
        xMin: c.x || 0,
        xMax: (c.x || 0) + (c.width || 0),
        yMin: c.y || 0,
        yMax: (c.y || 0) + (c.height || 0)
      } : (c = a.graphic && a.graphic.getBBox()) ? {
        xMin: a.plotX - c.width / 2,
        xMax: a.plotX + c.width / 2,
        yMin: a.plotY - c.height / 2,
        yMax: a.plotY + c.height / 2
      } : null;
    }
    function q(a) {
      for (var c = a.length, e = 0, b, g, d = [], h = function (a, b, c) {
          c = f(c, 10);
          var d = a.yMax + c > b.yMin - c && a.yMin - c < b.yMax + c,
            e = a.xMax + c > b.xMin - c && a.xMin - c < b.xMax + c,
            k = d ? a.xMin > b.xMax ? a.xMin - b.xMax : b.xMin - a.xMax : Infinity,
            g = e ? a.yMin > b.yMax ? a.yMin - b.yMax : b.yMin - a.yMax : Infinity;
          return e && d ? c ? h(a, b, Math.floor(c / 2)) : Infinity : E(k, g);
        }; e < c; ++e) for (b = e + 1; b < c; ++b) g = h(a[e], a[b]), 80 > g && d.push(g);
      d.push(80);
      return G(Math.floor(d.sort(function (a, b) {
        return a - b;
      })[Math.floor(d.length / 10)] / 2 - 1), 1);
    }
    function m(a) {
      if (a.options.pathfinder || a.series.reduce(function (a, c) {
        c.options && g(!0, c.options.connectors = c.options.connectors || {}, c.options.pathfinder);
        return a || c.options && c.options.pathfinder;
      }, !1)) g(!0, a.options.connectors = a.options.connectors || {}, a.options.pathfinder), n('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.');
    }
    "";
    var h = F.addEvent,
      c = F.defined,
      n = F.error,
      z = F.extend,
      g = F.merge,
      f = F.pick,
      e = F.splat,
      G = Math.max,
      E = Math.min;
    z(H.defaultOptions, {
      connectors: {
        type: "straight",
        lineWidth: 1,
        marker: {
          enabled: !1,
          align: "center",
          verticalAlign: "middle",
          inside: !1,
          lineWidth: 1
        },
        startMarker: {
          symbol: "diamond"
        },
        endMarker: {
          symbol: "arrow-filled"
        }
      }
    });
    var M = function () {
      function g(a) {
        this.lineObstacles = this.group = this.connections = this.chartObstacleMetrics = this.chartObstacles = this.chart = void 0;
        this.init(a);
      }
      g.prototype.init = function (a) {
        this.chart = a;
        this.connections = [];
        h(a, "redraw", function () {
          this.pathfinder.update();
        });
      };
      g.prototype.update = function (c) {
        var f = this.chart,
          b = this,
          g = b.connections;
        b.connections = [];
        f.series.forEach(function (c) {
          c.visible && !c.options.isInternal && c.points.forEach(function (c) {
            var d = c.options;
            d && d.dependency && (d.connect = d.dependency);
            var g;
            d = c.options && c.options.connect && e(c.options.connect);
            c.visible && !1 !== c.isInside && d && d.forEach(function (d) {
              g = f.get("string" === typeof d ? d : d.to);
              g instanceof y && g.series.visible && g.visible && !1 !== g.isInside && b.connections.push(new a(c, g, "string" === typeof d ? {} : d));
            });
          });
        });
        for (var d = 0, h = void 0, l = void 0, k = g.length, n = b.connections.length; d < k; ++d) {
          l = !1;
          for (h = 0; h < n; ++h) if (g[d].fromPoint === b.connections[h].fromPoint && g[d].toPoint === b.connections[h].toPoint) {
            b.connections[h].graphics = g[d].graphics;
            l = !0;
            break;
          }
          l || g[d].destroy();
        }
        delete this.chartObstacles;
        delete this.lineObstacles;
        b.renderConnections(c);
      };
      g.prototype.renderConnections = function (a) {
        a ? this.chart.series.forEach(function (a) {
          var b = function () {
            var b = a.chart.pathfinder;
            (b && b.connections || []).forEach(function (b) {
              b.fromPoint && b.fromPoint.series === a && b.render();
            });
            a.pathfinderRemoveRenderEvent && (a.pathfinderRemoveRenderEvent(), delete a.pathfinderRemoveRenderEvent);
          };
          !1 === a.options.animation ? b() : a.pathfinderRemoveRenderEvent = h(a, "afterAnimate", b);
        }) : this.connections.forEach(function (a) {
          a.render();
        });
      };
      g.prototype.getChartObstacles = function (a) {
        for (var e = [], b = this.chart.series, g = f(a.algorithmMargin, 0), d, h = 0, l = b.length; h < l; ++h) if (b[h].visible && !b[h].options.isInternal) {
          var k = 0,
            n = b[h].points.length,
            m = void 0;
          for (m = void 0; k < n; ++k) m = b[h].points[k], m.visible && (m = x(m)) && e.push({
            xMin: m.xMin - g,
            xMax: m.xMax + g,
            yMin: m.yMin - g,
            yMax: m.yMax + g
          });
        }
        e = e.sort(function (a, b) {
          return a.xMin - b.xMin;
        });
        c(a.algorithmMargin) || (d = a.algorithmMargin = q(e), e.forEach(function (a) {
          a.xMin -= d;
          a.xMax += d;
          a.yMin -= d;
          a.yMax += d;
        }));
        return e;
      };
      g.prototype.getObstacleMetrics = function (a) {
        for (var c = 0, b = 0, e, d, f = a.length; f--;) e = a[f].xMax - a[f].xMin, d = a[f].yMax - a[f].yMin, c < e && (c = e), b < d && (b = d);
        return {
          maxHeight: b,
          maxWidth: c
        };
      };
      g.prototype.getAlgorithmStartDirection = function (a) {
        var c = "top" !== a.verticalAlign && "bottom" !== a.verticalAlign;
        return "left" !== a.align && "right" !== a.align ? c ? void 0 : !1 : c ? !0 : void 0;
      };
      return g;
    }();
    M.prototype.algorithms = I;
    B.Pathfinder = M;
    z(y.prototype, {
      getPathfinderAnchorPoint: function (a) {
        var c = x(this);
        switch (a.align) {
          case "right":
            var e = "xMax";
            break;
          case "left":
            e = "xMin";
        }
        switch (a.verticalAlign) {
          case "top":
            var b = "yMin";
            break;
          case "bottom":
            b = "yMax";
        }
        return {
          x: e ? c[e] : (c.xMin + c.xMax) / 2,
          y: b ? c[b] : (c.yMin + c.yMax) / 2
        };
      },
      getRadiansToVector: function (a, e) {
        var f;
        c(e) || (f = x(this)) && (e = {
          x: (f.xMin + f.xMax) / 2,
          y: (f.yMin + f.yMax) / 2
        });
        return Math.atan2(e.y - a.y, a.x - e.x);
      },
      getMarkerVector: function (a, c, e) {
        var b = 2 * Math.PI,
          f = x(this),
          d = f.xMax - f.xMin,
          g = f.yMax - f.yMin,
          h = Math.atan2(g, d),
          k = !1;
        d /= 2;
        var l = g / 2,
          m = f.xMin + d;
        f = f.yMin + l;
        for (var r = m, n = f, p = 1, q = 1; a < -Math.PI;) a += b;
        for (; a > Math.PI;) a -= b;
        b = Math.tan(a);
        a > -h && a <= h ? (q = -1, k = !0) : a > h && a <= Math.PI - h ? q = -1 : a > Math.PI - h || a <= -(Math.PI - h) ? (p = -1, k = !0) : p = -1;
        k ? (r += p * d, n += q * d * b) : (r += g / (2 * b) * p, n += q * l);
        e.x !== m && (r = e.x);
        e.y !== f && (n = e.y);
        return {
          x: r + c * Math.cos(a),
          y: n - c * Math.sin(a)
        };
      }
    });
    t.prototype.callbacks.push(function (a) {
      !1 !== a.options.connectors.enabled && (m(a), this.pathfinder = new M(this), this.pathfinder.update(!0));
    });
    return M;
  });
  N(a, "Series/Gantt/GanttSeries.js", [a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Series/Gantt/GanttPoint.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Axis/Tick.js"], a["Core/Utilities.js"], a["Core/Axis/TreeGridAxis.js"]], function (a, t, B, H, y, F, I) {
    var x = this && this.__extends || function () {
        var a = function (c, f) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
          };
          return a(c, f);
        };
        return function (c, f) {
          function e() {
            this.constructor = c;
          }
          a(c, f);
          c.prototype = null === f ? Object.create(f) : (e.prototype = f.prototype, new e());
        };
      }(),
      q = H.series,
      m = H.seriesTypes.xrange,
      h = F.extend,
      c = F.isNumber,
      n = F.merge;
    I.compose(a, t, q, y);
    a = function (a) {
      function g() {
        var c = null !== a && a.apply(this, arguments) || this;
        c.data = void 0;
        c.options = void 0;
        c.points = void 0;
        return c;
      }
      x(g, a);
      g.prototype.drawPoint = function (a, e) {
        var f = this.options,
          g = this.chart.renderer,
          h = a.shapeArgs,
          n = a.plotY,
          l = a.graphic,
          q = a.selected && "select",
          b = f.stacking && !f.borderRadius;
        if (a.options.milestone) {
          if (c(n) && null !== a.y && !1 !== a.visible) {
            h = g.symbols.diamond(h.x || 0, h.y || 0, h.width || 0, h.height || 0);
            if (l) l[e]({
              d: h
            });else a.graphic = g.path(h).addClass(a.getClassName(), !0).add(a.group || this.group);
            this.chart.styledMode || a.graphic.attr(this.pointAttribs(a, q)).shadow(f.shadow, null, b);
          } else l && (a.graphic = l.destroy());
        } else m.prototype.drawPoint.call(this, a, e);
      };
      g.prototype.translatePoint = function (a) {
        m.prototype.translatePoint.call(this, a);
        if (a.options.milestone) {
          var c = a.shapeArgs;
          var f = c.height || 0;
          a.shapeArgs = {
            x: (c.x || 0) - f / 2,
            y: c.y,
            width: f,
            height: f
          };
        }
      };
      g.defaultOptions = n(m.defaultOptions, {
        grouping: !1,
        dataLabels: {
          enabled: !0
        },
        tooltip: {
          headerFormat: '<span style="font-size: 10px">{series.name}</span><br/>',
          pointFormat: null,
          pointFormatter: function () {
            var a = this.series,
              e = a.xAxis,
              g = a.tooltipOptions.dateTimeLabelFormats,
              h = e.options.startOfWeek,
              n = a.tooltipOptions,
              m = n.xDateFormat,
              l = this.options.milestone,
              q = "<b>" + (this.name || this.yCategory) + "</b>";
            if (n.pointFormat) return this.tooltipFormatter(n.pointFormat);
            !m && c(this.start) && (m = a.chart.time.getDateFormat(e.closestPointRange, this.start, h, g || {}));
            e = a.chart.time.dateFormat(m, this.start);
            a = a.chart.time.dateFormat(m, this.end);
            q += "<br/>";
            return l ? q + (e + "<br/>") : q + ("Start: " + e + "<br/>End: ") + (a + "<br/>");
          }
        },
        connectors: {
          type: "simpleConnect",
          animation: {
            reversed: !0
          },
          startMarker: {
            enabled: !0,
            symbol: "arrow-filled",
            radius: 4,
            fill: "#fa0",
            align: "left"
          },
          endMarker: {
            enabled: !1,
            align: "right"
          }
        }
      });
      return g;
    }(m);
    h(a.prototype, {
      pointArrayMap: ["start", "end", "y"],
      pointClass: B,
      setData: q.prototype.setData
    });
    H.registerSeriesType("gantt", a);
    "";
    return a;
  });
  N(a, "Core/Chart/GanttChart.js", [a["Core/Chart/Chart.js"], a["Core/DefaultOptions.js"], a["Core/Utilities.js"]], function (a, t, B) {
    var E = this && this.__extends || function () {
        var a = function (m, h) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, h) {
            a.__proto__ = h;
          } || function (a, h) {
            for (var c in h) h.hasOwnProperty(c) && (a[c] = h[c]);
          };
          return a(m, h);
        };
        return function (m, h) {
          function c() {
            this.constructor = m;
          }
          a(m, h);
          m.prototype = null === h ? Object.create(h) : (c.prototype = h.prototype, new c());
        };
      }(),
      y = t.getOptions,
      F = B.isArray,
      I = B.merge,
      x = B.splat;
    a = function (a) {
      function m() {
        return null !== a && a.apply(this, arguments) || this;
      }
      E(m, a);
      m.prototype.init = function (h, c) {
        var m = y(),
          q = h.xAxis,
          g = h.yAxis,
          f;
        h.xAxis = h.yAxis = void 0;
        var e = I(!0, {
          chart: {
            type: "gantt"
          },
          title: {
            text: null
          },
          legend: {
            enabled: !1
          },
          navigator: {
            series: {
              type: "gantt"
            },
            yAxis: {
              type: "category"
            }
          }
        }, h, {
          isGantt: !0
        });
        h.xAxis = q;
        h.yAxis = g;
        e.xAxis = (F(h.xAxis) ? h.xAxis : [h.xAxis || {}, {}]).map(function (a, c) {
          1 === c && (f = 0);
          return I(m.xAxis, {
            grid: {
              enabled: !0
            },
            opposite: !0,
            linkedTo: f
          }, a, {
            type: "datetime"
          });
        });
        e.yAxis = x(h.yAxis || {}).map(function (a) {
          return I(m.yAxis, {
            grid: {
              enabled: !0
            },
            staticScale: 50,
            reversed: !0,
            type: a.categories ? a.type : "treegrid"
          }, a);
        });
        a.prototype.init.call(this, e, c);
      };
      return m;
    }(a);
    (function (a) {
      a.ganttChart = function (m, h, c) {
        return new a(m, h, c);
      };
    })(a || (a = {}));
    return a;
  });
  N(a, "Core/Axis/ScrollbarAxis.js", [a["Core/Utilities.js"]], function (a) {
    var t = a.addEvent,
      B = a.defined,
      E = a.pick;
    return function () {
      function a() {}
      a.compose = function (y, H) {
        if (-1 === a.composed.indexOf(y)) a.composed.push(y);else return y;
        var x = function (a) {
          var m = E(a.options && a.options.min, a.min),
            h = E(a.options && a.options.max, a.max);
          return {
            axisMin: m,
            axisMax: h,
            scrollMin: B(a.dataMin) ? Math.min(m, a.min, a.dataMin, E(a.threshold, Infinity)) : m,
            scrollMax: B(a.dataMax) ? Math.max(h, a.max, a.dataMax, E(a.threshold, -Infinity)) : h
          };
        };
        t(y, "afterInit", function () {
          var a = this;
          a.options && a.options.scrollbar && a.options.scrollbar.enabled && (a.options.scrollbar.vertical = !a.horiz, a.options.startOnTick = a.options.endOnTick = !1, a.scrollbar = new H(a.chart.renderer, a.options.scrollbar, a.chart), t(a.scrollbar, "changed", function (m) {
            var h = x(a),
              c = h.axisMax,
              n = h.scrollMin,
              q = h.scrollMax - n;
            B(h.axisMin) && B(c) && (a.horiz && !a.reversed || !a.horiz && a.reversed ? (h = n + q * this.to, n += q * this.from) : (h = n + q * (1 - this.from), n += q * (1 - this.to)), this.shouldUpdateExtremes(m.DOMType) ? a.setExtremes(n, h, !0, "mousemove" !== m.DOMType && "touchmove" !== m.DOMType, m) : this.setRange(this.from, this.to));
          }));
        });
        t(y, "afterRender", function () {
          var a = x(this),
            m = a.scrollMin,
            h = a.scrollMax;
          a = this.scrollbar;
          var c = this.axisTitleMargin + (this.titleOffset || 0),
            n = this.chart.scrollbarsOffsets,
            t = this.options.margin || 0;
          a && (this.horiz ? (this.opposite || (n[1] += c), a.position(this.left, this.top + this.height + 2 + n[1] - (this.opposite ? t : 0), this.width, this.height), this.opposite || (n[1] += t), c = 1) : (this.opposite && (n[0] += c), a.position(a.options.opposite ? this.left + this.width + 2 + n[0] - (this.opposite ? 0 : t) : this.opposite ? 0 : t, this.top, this.width, this.height), this.opposite && (n[0] += t), c = 0), n[c] += a.size + a.options.margin, isNaN(m) || isNaN(h) || !B(this.min) || !B(this.max) || this.min === this.max ? a.setRange(0, 1) : (n = (this.min - m) / (h - m), m = (this.max - m) / (h - m), this.horiz && !this.reversed || !this.horiz && this.reversed ? a.setRange(n, m) : a.setRange(1 - m, 1 - n)));
        });
        t(y, "afterGetOffset", function () {
          var a = this.scrollbar && !this.scrollbar.options.opposite;
          a = this.horiz ? 2 : a ? 3 : 1;
          var m = this.scrollbar;
          m && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[a] += m.size + m.options.margin);
        });
        return y;
      };
      a.composed = [];
      return a;
    }();
  });
  N(a, "Core/ScrollbarDefaults.js", [a["Core/Globals.js"]], function (a) {
    return {
      height: a.isTouchDevice ? 20 : 14,
      barBorderRadius: 0,
      buttonBorderRadius: 0,
      liveRedraw: void 0,
      margin: 10,
      minWidth: 6,
      opposite: !0,
      step: .2,
      zIndex: 3,
      barBackgroundColor: "#cccccc",
      barBorderWidth: 1,
      barBorderColor: "#cccccc",
      buttonArrowColor: "#333333",
      buttonBackgroundColor: "#e6e6e6",
      buttonBorderColor: "#cccccc",
      buttonBorderWidth: 1,
      rifleColor: "#333333",
      trackBackgroundColor: "#f2f2f2",
      trackBorderColor: "#f2f2f2",
      trackBorderWidth: 1
    };
  });
  N(a, "Core/Scrollbar.js", [a["Core/DefaultOptions.js"], a["Core/Globals.js"], a["Core/Axis/ScrollbarAxis.js"], a["Core/ScrollbarDefaults.js"], a["Core/Utilities.js"]], function (a, t, B, H, y) {
    var E = a.defaultOptions,
      I = y.addEvent,
      x = y.correctFloat,
      q = y.defined,
      m = y.destroyObjectProperties,
      h = y.fireEvent,
      c = y.merge,
      n = y.pick,
      z = y.removeEvent;
    a = function () {
      function a(a, c, g) {
        this._events = [];
        this.chart = void 0;
        this.from = this.chartY = this.chartX = 0;
        this.scrollbar = this.renderer = this.options = this.group = void 0;
        this.scrollbarButtons = [];
        this.scrollbarGroup = void 0;
        this.scrollbarLeft = 0;
        this.scrollbarRifles = void 0;
        this.scrollbarStrokeWidth = 1;
        this.to = this.size = this.scrollbarTop = 0;
        this.track = void 0;
        this.trackBorderWidth = 1;
        this.userOptions = void 0;
        this.y = this.x = 0;
        this.init(a, c, g);
      }
      a.compose = function (c) {
        B.compose(c, a);
      };
      a.swapXY = function (a, c) {
        c && a.forEach(function (a) {
          for (var c = a.length, e, f = 0; f < c; f += 2) e = a[f + 1], "number" === typeof e && (a[f + 1] = a[f + 2], a[f + 2] = e);
        });
        return a;
      };
      a.prototype.addEvents = function () {
        var a = this.options.inverted ? [1, 0] : [0, 1],
          c = this.scrollbarButtons,
          g = this.scrollbarGroup.element,
          h = this.track.element,
          m = this.mouseDownHandler.bind(this),
          n = this.mouseMoveHandler.bind(this),
          l = this.mouseUpHandler.bind(this);
        a = [[c[a[0]].element, "click", this.buttonToMinClick.bind(this)], [c[a[1]].element, "click", this.buttonToMaxClick.bind(this)], [h, "click", this.trackClick.bind(this)], [g, "mousedown", m], [g.ownerDocument, "mousemove", n], [g.ownerDocument, "mouseup", l]];
        t.hasTouch && a.push([g, "touchstart", m], [g.ownerDocument, "touchmove", n], [g.ownerDocument, "touchend", l]);
        a.forEach(function (a) {
          I.apply(null, a);
        });
        this._events = a;
      };
      a.prototype.buttonToMaxClick = function (a) {
        var c = (this.to - this.from) * n(this.options.step, .2);
        this.updatePosition(this.from + c, this.to + c);
        h(this, "changed", {
          from: this.from,
          to: this.to,
          trigger: "scrollbar",
          DOMEvent: a
        });
      };
      a.prototype.buttonToMinClick = function (a) {
        var c = x(this.to - this.from) * n(this.options.step, .2);
        this.updatePosition(x(this.from - c), x(this.to - c));
        h(this, "changed", {
          from: this.from,
          to: this.to,
          trigger: "scrollbar",
          DOMEvent: a
        });
      };
      a.prototype.cursorToScrollbarPosition = function (a) {
        var c = this.options;
        c = c.minWidth > this.calculatedWidth ? c.minWidth : 0;
        return {
          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - c),
          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - c)
        };
      };
      a.prototype.destroy = function () {
        var a = this,
          c = a.chart.scroller;
        a.removeEvents();
        ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function (c) {
          a[c] && a[c].destroy && (a[c] = a[c].destroy());
        });
        c && a === c.scrollbar && (c.scrollbar = null, m(c.scrollbarButtons));
      };
      a.prototype.drawScrollbarButton = function (c) {
        var e = this.renderer,
          f = this.scrollbarButtons,
          g = this.options,
          h = this.size,
          m = e.g().add(this.group);
        f.push(m);
        m = e.rect().addClass("highcharts-scrollbar-button").add(m);
        this.chart.styledMode || m.attr({
          stroke: g.buttonBorderColor,
          "stroke-width": g.buttonBorderWidth,
          fill: g.buttonBackgroundColor
        });
        m.attr(m.crisp({
          x: -.5,
          y: -.5,
          width: h + 1,
          height: h + 1,
          r: g.buttonBorderRadius
        }, m.strokeWidth()));
        m = e.path(a.swapXY([["M", h / 2 + (c ? -1 : 1), h / 2 - 3], ["L", h / 2 + (c ? -1 : 1), h / 2 + 3], ["L", h / 2 + (c ? 2 : -2), h / 2]], g.vertical)).addClass("highcharts-scrollbar-arrow").add(f[c]);
        this.chart.styledMode || m.attr({
          fill: g.buttonArrowColor
        });
      };
      a.prototype.init = function (a, e, g) {
        this.scrollbarButtons = [];
        this.renderer = a;
        this.userOptions = e;
        this.options = c(H, E.scrollbar, e);
        this.chart = g;
        this.size = n(this.options.size, this.options.height);
        e.enabled && (this.render(), this.addEvents());
      };
      a.prototype.mouseDownHandler = function (a) {
        a = this.chart.pointer.normalize(a);
        a = this.cursorToScrollbarPosition(a);
        this.chartX = a.chartX;
        this.chartY = a.chartY;
        this.initPositions = [this.from, this.to];
        this.grabbedCenter = !0;
      };
      a.prototype.mouseMoveHandler = function (a) {
        var c = this.chart.pointer.normalize(a),
          f = this.options.vertical ? "chartY" : "chartX",
          g = this.initPositions || [];
        !this.grabbedCenter || a.touches && 0 === a.touches[0][f] || (c = this.cursorToScrollbarPosition(c)[f], f = this[f], f = c - f, this.hasDragged = !0, this.updatePosition(g[0] + f, g[1] + f), this.hasDragged && h(this, "changed", {
          from: this.from,
          to: this.to,
          trigger: "scrollbar",
          DOMType: a.type,
          DOMEvent: a
        }));
      };
      a.prototype.mouseUpHandler = function (a) {
        this.hasDragged && h(this, "changed", {
          from: this.from,
          to: this.to,
          trigger: "scrollbar",
          DOMType: a.type,
          DOMEvent: a
        });
        this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
      };
      a.prototype.position = function (a, c, g, h) {
        var e = this.options.vertical,
          f = this.rendered ? "animate" : "attr",
          l = 0;
        this.x = a;
        this.y = c + this.trackBorderWidth;
        this.width = g;
        this.xOffset = this.height = h;
        this.yOffset = l;
        e ? (this.width = this.yOffset = g = l = this.size, this.xOffset = c = 0, this.barWidth = h - 2 * g, this.x = a += this.options.margin) : (this.height = this.xOffset = h = c = this.size, this.barWidth = g - 2 * h, this.y += this.options.margin);
        this.group[f]({
          translateX: a,
          translateY: this.y
        });
        this.track[f]({
          width: g,
          height: h
        });
        this.scrollbarButtons[1][f]({
          translateX: e ? 0 : g - c,
          translateY: e ? h - l : 0
        });
      };
      a.prototype.removeEvents = function () {
        this._events.forEach(function (a) {
          z.apply(null, a);
        });
        this._events.length = 0;
      };
      a.prototype.render = function () {
        var c = this.renderer,
          e = this.options,
          g = this.size,
          h = this.chart.styledMode,
          m = c.g("scrollbar").attr({
            zIndex: e.zIndex,
            translateY: -99999
          }).add();
        this.group = m;
        this.track = c.rect().addClass("highcharts-scrollbar-track").attr({
          x: 0,
          r: e.trackBorderRadius || 0,
          height: g,
          width: g
        }).add(m);
        h || this.track.attr({
          fill: e.trackBackgroundColor,
          stroke: e.trackBorderColor,
          "stroke-width": e.trackBorderWidth
        });
        this.trackBorderWidth = this.track.strokeWidth();
        this.track.attr({
          y: -this.trackBorderWidth % 2 / 2
        });
        this.scrollbarGroup = c.g().add(m);
        this.scrollbar = c.rect().addClass("highcharts-scrollbar-thumb").attr({
          height: g,
          width: g,
          r: e.barBorderRadius || 0
        }).add(this.scrollbarGroup);
        this.scrollbarRifles = c.path(a.swapXY([["M", -3, g / 4], ["L", -3, 2 * g / 3], ["M", 0, g / 4], ["L", 0, 2 * g / 3], ["M", 3, g / 4], ["L", 3, 2 * g / 3]], e.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);
        h || (this.scrollbar.attr({
          fill: e.barBackgroundColor,
          stroke: e.barBorderColor,
          "stroke-width": e.barBorderWidth
        }), this.scrollbarRifles.attr({
          stroke: e.rifleColor,
          "stroke-width": 1
        }));
        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();
        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);
        this.drawScrollbarButton(0);
        this.drawScrollbarButton(1);
      };
      a.prototype.setRange = function (a, c) {
        var e = this.options,
          f = e.vertical,
          g = e.minWidth,
          h = this.barWidth,
          l = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
        if (q(h)) {
          var m = h * Math.min(c, 1);
          a = Math.max(a, 0);
          var b = Math.ceil(h * a);
          this.calculatedWidth = m = x(m - b);
          m < g && (b = (h - g + m) * a, m = g);
          g = Math.floor(b + this.xOffset + this.yOffset);
          h = m / 2 - .5;
          this.from = a;
          this.to = c;
          f ? (this.scrollbarGroup[l]({
            translateY: g
          }), this.scrollbar[l]({
            height: m
          }), this.scrollbarRifles[l]({
            translateY: h
          }), this.scrollbarTop = g, this.scrollbarLeft = 0) : (this.scrollbarGroup[l]({
            translateX: g
          }), this.scrollbar[l]({
            width: m
          }), this.scrollbarRifles[l]({
            translateX: h
          }), this.scrollbarLeft = g, this.scrollbarTop = 0);
          12 >= m ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0);
          !1 === e.showFull && (0 >= a && 1 <= c ? this.group.hide() : this.group.show());
          this.rendered = !0;
        }
      };
      a.prototype.shouldUpdateExtremes = function (a) {
        return n(this.options.liveRedraw, t.svg && !t.isTouchDevice && !this.chart.isBoosting) || "mouseup" === a || "touchend" === a || !q(a);
      };
      a.prototype.trackClick = function (a) {
        var c = this.chart.pointer.normalize(a),
          f = this.to - this.from,
          g = this.y + this.scrollbarTop,
          m = this.x + this.scrollbarLeft;
        this.options.vertical && c.chartY > g || !this.options.vertical && c.chartX > m ? this.updatePosition(this.from + f, this.to + f) : this.updatePosition(this.from - f, this.to - f);
        h(this, "changed", {
          from: this.from,
          to: this.to,
          trigger: "scrollbar",
          DOMEvent: a
        });
      };
      a.prototype.update = function (a) {
        this.destroy();
        this.init(this.chart.renderer, c(!0, this.options, a), this.chart);
      };
      a.prototype.updatePosition = function (a, c) {
        1 < c && (a = x(1 - x(c - a)), c = 1);
        0 > a && (c = x(c - a), a = 0);
        this.from = a;
        this.to = c;
      };
      a.defaultOptions = H;
      return a;
    }();
    E.scrollbar = c(!0, a.defaultOptions, E.scrollbar);
    return a;
  });
  N(a, "Extensions/RangeSelector.js", [a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Globals.js"], a["Core/DefaultOptions.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F) {
    function E(a) {
      if (-1 !== a.indexOf("%L")) return "text";
      var b = "aAdewbBmoyY".split("").some(function (b) {
          return -1 !== a.indexOf("%" + b);
        }),
        c = "HkIlMS".split("").some(function (b) {
          return -1 !== a.indexOf("%" + b);
        });
      return b && c ? "datetime-local" : b ? "date" : c ? "time" : "text";
    }
    var x = H.defaultOptions,
      q = F.addEvent,
      m = F.createElement,
      h = F.css,
      c = F.defined,
      n = F.destroyObjectProperties,
      z = F.discardElement,
      g = F.extend,
      f = F.find,
      e = F.fireEvent,
      G = F.isNumber,
      J = F.merge,
      M = F.objectEach,
      p = F.pad,
      l = F.pick,
      w = F.pInt,
      b = F.splat;
    g(x, {
      rangeSelector: {
        allButtonsEnabled: !1,
        buttons: void 0,
        buttonSpacing: 5,
        dropdown: "responsive",
        enabled: void 0,
        verticalAlign: "top",
        buttonTheme: {
          width: 28,
          height: 18,
          padding: 2,
          zIndex: 7
        },
        floating: !1,
        x: 0,
        y: 0,
        height: void 0,
        inputBoxBorderColor: "none",
        inputBoxHeight: 17,
        inputBoxWidth: void 0,
        inputDateFormat: "%b %e, %Y",
        inputDateParser: void 0,
        inputEditDateFormat: "%Y-%m-%d",
        inputEnabled: !0,
        inputPosition: {
          align: "right",
          x: 0,
          y: 0
        },
        inputSpacing: 5,
        selected: void 0,
        buttonPosition: {
          align: "left",
          x: 0,
          y: 0
        },
        inputStyle: {
          color: "#335cad",
          cursor: "pointer"
        },
        labelStyle: {
          color: "#666666"
        }
      }
    });
    g(x.lang, {
      rangeSelectorZoom: "Zoom",
      rangeSelectorFrom: "",
      rangeSelectorTo: "\u2192"
    });
    var v = function () {
      function d(a) {
        this.buttons = void 0;
        this.buttonOptions = d.prototype.defaultButtons;
        this.initialButtonGroupWidth = 0;
        this.options = void 0;
        this.chart = a;
        this.init(a);
      }
      d.prototype.clickButton = function (d, f) {
        var g = this.chart,
          k = this.buttonOptions[d],
          h = g.xAxis[0],
          m = g.scroller && g.scroller.getUnionExtremes() || h || {},
          n = m.dataMin,
          p = m.dataMax,
          t = h && Math.round(Math.min(h.max, l(p, h.max))),
          v = k.type;
        m = k._range;
        var w,
          x = k.dataGrouping;
        if (null !== n && null !== p) {
          g.fixedRange = m;
          this.setSelected(d);
          x && (this.forcedDataGrouping = !0, a.prototype.setDataGrouping.call(h || {
            chart: this.chart
          }, x, !1), this.frozenStates = k.preserveDataGrouping);
          if ("month" === v || "year" === v) {
            if (h) {
              v = {
                range: k,
                max: t,
                chart: g,
                dataMin: n,
                dataMax: p
              };
              var y = h.minFromRange.call(v);
              G(v.newMax) && (t = v.newMax);
            } else m = k;
          } else if (m) y = Math.max(t - m, n), t = Math.min(y + m, p);else if ("ytd" === v) {
            if (h) "undefined" === typeof p && (n = Number.MAX_VALUE, p = Number.MIN_VALUE, g.series.forEach(function (a) {
              a = a.xData;
              n = Math.min(a[0], n);
              p = Math.max(a[a.length - 1], p);
            }), f = !1), t = this.getYTDExtremes(p, n, g.time.useUTC), y = w = t.min, t = t.max;else {
              this.deferredYTDClick = d;
              return;
            }
          } else "all" === v && h && (g.navigator && g.navigator.baseSeries[0] && (g.navigator.baseSeries[0].xAxis.options.range = void 0), y = n, t = p);
          c(y) && (y += k._offsetMin);
          c(t) && (t += k._offsetMax);
          this.dropdown && (this.dropdown.selectedIndex = d + 1);
          if (h) h.setExtremes(y, t, l(f, !0), void 0, {
            trigger: "rangeSelectorButton",
            rangeSelectorButton: k
          });else {
            var z = b(g.options.xAxis)[0];
            var C = z.range;
            z.range = m;
            var K = z.min;
            z.min = w;
            q(g, "load", function () {
              z.range = C;
              z.min = K;
            });
          }
          e(this, "afterBtnClick");
        }
      };
      d.prototype.setSelected = function (a) {
        this.selected = this.options.selected = a;
      };
      d.prototype.init = function (a) {
        var b = this,
          c = a.options.rangeSelector,
          d = c.buttons || b.defaultButtons.slice(),
          f = c.selected,
          g = function () {
            var a = b.minInput,
              c = b.maxInput;
            a && a.blur && e(a, "blur");
            c && c.blur && e(c, "blur");
          };
        b.chart = a;
        b.options = c;
        b.buttons = [];
        b.buttonOptions = d;
        this.eventsToUnbind = [];
        this.eventsToUnbind.push(q(a.container, "mousedown", g));
        this.eventsToUnbind.push(q(a, "resize", g));
        d.forEach(b.computeButtonRange);
        "undefined" !== typeof f && d[f] && this.clickButton(f, !1);
        this.eventsToUnbind.push(q(a, "load", function () {
          a.xAxis && a.xAxis[0] && q(a.xAxis[0], "setExtremes", function (c) {
            this.max - this.min !== a.fixedRange && "rangeSelectorButton" !== c.trigger && "updatedData" !== c.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);
          });
        }));
      };
      d.prototype.updateButtonStates = function () {
        var a = this,
          b = this.chart,
          c = this.dropdown,
          d = b.xAxis[0],
          e = Math.round(d.max - d.min),
          f = !d.hasVisibleSeries,
          g = b.scroller && b.scroller.getUnionExtremes() || d,
          h = g.dataMin,
          l = g.dataMax;
        b = a.getYTDExtremes(l, h, b.time.useUTC);
        var m = b.min,
          n = b.max,
          p = a.selected,
          q = G(p),
          t = a.options.allButtonsEnabled,
          v = a.buttons;
        a.buttonOptions.forEach(function (b, g) {
          var k = b._range,
            r = b.type,
            u = b.count || 1,
            A = v[g],
            w = 0,
            x = b._offsetMax - b._offsetMin;
          b = g === p;
          var y = k > l - h,
            z = k < d.minRange,
            C = !1,
            B = !1;
          k = k === e;
          ("month" === r || "year" === r) && e + 36E5 >= 864E5 * {
            month: 28,
            year: 365
          }[r] * u - x && e - 36E5 <= 864E5 * {
            month: 31,
            year: 366
          }[r] * u + x ? k = !0 : "ytd" === r ? (k = n - m + x === e, C = !b) : "all" === r && (k = d.max - d.min >= l - h, B = !b && q && k);
          r = !t && (y || z || B || f);
          u = b && k || k && !q && !C || b && a.frozenStates;
          r ? w = 3 : u && (q = !0, w = 2);
          A.state !== w && (A.setState(w), c && (c.options[g + 1].disabled = r, 2 === w && (c.selectedIndex = g + 1)), 0 === w && p === g && a.setSelected());
        });
      };
      d.prototype.computeButtonRange = function (a) {
        var b = a.type,
          c = a.count || 1,
          d = {
            millisecond: 1,
            second: 1E3,
            minute: 6E4,
            hour: 36E5,
            day: 864E5,
            week: 6048E5
          };
        if (d[b]) a._range = d[b] * c;else if ("month" === b || "year" === b) a._range = 864E5 * {
          month: 30,
          year: 365
        }[b] * c;
        a._offsetMin = l(a.offsetMin, 0);
        a._offsetMax = l(a.offsetMax, 0);
        a._range += a._offsetMax - a._offsetMin;
      };
      d.prototype.getInputValue = function (a) {
        a = "min" === a ? this.minInput : this.maxInput;
        var b = this.chart.options.rangeSelector,
          c = this.chart.time;
        return a ? ("text" === a.type && b.inputDateParser || this.defaultInputDateParser)(a.value, c.useUTC, c) : 0;
      };
      d.prototype.setInputValue = function (a, b) {
        var d = this.options,
          e = this.chart.time,
          f = "min" === a ? this.minInput : this.maxInput;
        a = "min" === a ? this.minDateBox : this.maxDateBox;
        if (f) {
          var g = f.getAttribute("data-hc-time");
          g = c(g) ? Number(g) : void 0;
          c(b) && (c(g) && f.setAttribute("data-hc-time-previous", g), f.setAttribute("data-hc-time", b), g = b);
          f.value = e.dateFormat(this.inputTypeFormats[f.type] || d.inputEditDateFormat, g);
          a && a.attr({
            text: e.dateFormat(d.inputDateFormat, g)
          });
        }
      };
      d.prototype.setInputExtremes = function (a, b, c) {
        if (a = "min" === a ? this.minInput : this.maxInput) {
          var d = this.inputTypeFormats[a.type],
            e = this.chart.time;
          d && (b = e.dateFormat(d, b), a.min !== b && (a.min = b), c = e.dateFormat(d, c), a.max !== c && (a.max = c));
        }
      };
      d.prototype.showInput = function (a) {
        var b = "min" === a ? this.minDateBox : this.maxDateBox;
        if ((a = "min" === a ? this.minInput : this.maxInput) && b && this.inputGroup) {
          var c = "text" === a.type,
            d = this.inputGroup,
            e = d.translateX;
          d = d.translateY;
          var f = this.options.inputBoxWidth;
          h(a, {
            width: c ? b.width + (f ? -2 : 20) + "px" : "auto",
            height: c ? b.height - 2 + "px" : "auto",
            border: "2px solid silver"
          });
          c && f ? h(a, {
            left: e + b.x + "px",
            top: d + "px"
          }) : h(a, {
            left: Math.min(Math.round(b.x + e - (a.offsetWidth - b.width) / 2), this.chart.chartWidth - a.offsetWidth) + "px",
            top: d - (a.offsetHeight - b.height) / 2 + "px"
          });
        }
      };
      d.prototype.hideInput = function (a) {
        (a = "min" === a ? this.minInput : this.maxInput) && h(a, {
          top: "-9999em",
          border: 0,
          width: "1px",
          height: "1px"
        });
      };
      d.prototype.defaultInputDateParser = function (a, b, c) {
        var d = a.split("/").join("-").split(" ").join("T");
        -1 === d.indexOf("T") && (d += "T00:00");
        if (b) d += "Z";else {
          var e;
          if (e = B.isSafari) e = d, e = !(6 < e.length && (e.lastIndexOf("-") === e.length - 6 || e.lastIndexOf("+") === e.length - 6));
          e && (e = new Date(d).getTimezoneOffset() / 60, d += 0 >= e ? "+" + p(-e) + ":00" : "-" + p(e) + ":00");
        }
        d = Date.parse(d);
        G(d) || (a = a.split("-"), d = Date.UTC(w(a[0]), w(a[1]) - 1, w(a[2])));
        c && b && G(d) && (d += c.getTimezoneOffset(d));
        return d;
      };
      d.prototype.drawInput = function (a) {
        function b() {
          var b = f.getInputValue(a),
            d = c.xAxis[0],
            e = c.scroller && c.scroller.xAxis ? c.scroller.xAxis : d,
            g = e.dataMin;
          e = e.dataMax;
          var h = f.maxInput,
            k = f.minInput;
          b !== Number(t.getAttribute("data-hc-time-previous")) && G(b) && (t.setAttribute("data-hc-time-previous", b), p && h && G(g) ? b > Number(h.getAttribute("data-hc-time")) ? b = void 0 : b < g && (b = g) : k && G(e) && (b < Number(k.getAttribute("data-hc-time")) ? b = void 0 : b > e && (b = e)), "undefined" !== typeof b && d.setExtremes(p ? b : d.min, p ? d.max : b, void 0, void 0, {
            trigger: "rangeSelectorInput"
          }));
        }
        var c = this.chart,
          d = this.div,
          e = this.inputGroup,
          f = this,
          k = c.renderer.style || {},
          l = c.renderer,
          n = c.options.rangeSelector,
          p = "min" === a,
          q = x.lang[p ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
        q = l.label(q, 0).addClass("highcharts-range-label").attr({
          padding: q ? 2 : 0,
          height: q ? n.inputBoxHeight : 0
        }).add(e);
        l = l.label("", 0).addClass("highcharts-range-input").attr({
          padding: 2,
          width: n.inputBoxWidth,
          height: n.inputBoxHeight,
          "text-align": "center"
        }).on("click", function () {
          f.showInput(a);
          f[a + "Input"].focus();
        });
        c.styledMode || l.attr({
          stroke: n.inputBoxBorderColor,
          "stroke-width": 1
        });
        l.add(e);
        var t = m("input", {
          name: a,
          className: "highcharts-range-selector"
        }, void 0, d);
        t.setAttribute("type", E(n.inputDateFormat || "%b %e, %Y"));
        c.styledMode || (q.css(J(k, n.labelStyle)), l.css(J({
          color: "#333333"
        }, k, n.inputStyle)), h(t, g({
          position: "absolute",
          border: 0,
          boxShadow: "0 0 15px rgba(0,0,0,0.3)",
          width: "1px",
          height: "1px",
          padding: 0,
          textAlign: "center",
          fontSize: k.fontSize,
          fontFamily: k.fontFamily,
          top: "-9999em"
        }, n.inputStyle)));
        t.onfocus = function () {
          f.showInput(a);
        };
        t.onblur = function () {
          t === B.doc.activeElement && b();
          f.hideInput(a);
          f.setInputValue(a);
          t.blur();
        };
        var v = !1;
        t.onchange = function () {
          v || (b(), f.hideInput(a), t.blur());
        };
        t.onkeypress = function (a) {
          13 === a.keyCode && b();
        };
        t.onkeydown = function (a) {
          v = !0;
          38 !== a.keyCode && 40 !== a.keyCode || b();
        };
        t.onkeyup = function () {
          v = !1;
        };
        return {
          dateBox: l,
          input: t,
          label: q
        };
      };
      d.prototype.getPosition = function () {
        var a = this.chart,
          b = a.options.rangeSelector;
        a = "top" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;
        return {
          buttonTop: a + b.buttonPosition.y,
          inputTop: a + b.inputPosition.y - 10
        };
      };
      d.prototype.getYTDExtremes = function (a, b, c) {
        var d = this.chart.time,
          e = new d.Date(a),
          f = d.get("FullYear", e);
        c = c ? d.Date.UTC(f, 0, 1) : +new d.Date(f, 0, 1);
        b = Math.max(b, c);
        e = e.getTime();
        return {
          max: Math.min(a || e, e),
          min: b
        };
      };
      d.prototype.render = function (a, b) {
        var d = this.chart,
          e = d.renderer,
          f = d.container,
          g = d.options,
          h = g.rangeSelector,
          k = l(g.chart.style && g.chart.style.zIndex, 0) + 1;
        g = h.inputEnabled;
        if (!1 !== h.enabled) {
          this.rendered || (this.group = e.g("range-selector-group").attr({
            zIndex: 7
          }).add(), this.div = m("div", void 0, {
            position: "relative",
            height: 0,
            zIndex: k
          }), this.buttonOptions.length && this.renderButtons(), f.parentNode && f.parentNode.insertBefore(this.div, f), g && (this.inputGroup = e.g("input-group").add(this.group), e = this.drawInput("min"), this.minDateBox = e.dateBox, this.minLabel = e.label, this.minInput = e.input, e = this.drawInput("max"), this.maxDateBox = e.dateBox, this.maxLabel = e.label, this.maxInput = e.input));
          if (g && (this.setInputValue("min", a), this.setInputValue("max", b), a = d.scroller && d.scroller.getUnionExtremes() || d.xAxis[0] || {}, c(a.dataMin) && c(a.dataMax) && (d = d.xAxis[0].minRange || 0, this.setInputExtremes("min", a.dataMin, Math.min(a.dataMax, this.getInputValue("max")) - d), this.setInputExtremes("max", Math.max(a.dataMin, this.getInputValue("min")) + d, a.dataMax)), this.inputGroup)) {
            var n = 0;
            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {
              if (a) {
                var b = a.getBBox().width;
                b && (a.attr({
                  x: n
                }), n += b + h.inputSpacing);
              }
            });
          }
          this.alignElements();
          this.rendered = !0;
        }
      };
      d.prototype.renderButtons = function () {
        var a = this,
          b = this.buttons,
          c = this.options,
          d = x.lang,
          f = this.chart.renderer,
          g = J(c.buttonTheme),
          h = g && g.states,
          n = g.width || 28;
        delete g.width;
        delete g.states;
        this.buttonGroup = f.g("range-selector-buttons").add(this.group);
        var p = this.dropdown = m("select", void 0, {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: 0,
          border: 0,
          top: "-9999em",
          cursor: "pointer",
          opacity: .0001
        }, this.div);
        q(p, "touchstart", function () {
          p.style.fontSize = "16px";
        });
        [[B.isMS ? "mouseover" : "mouseenter"], [B.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(function (c) {
          var d = c[0],
            f = c[1];
          q(p, d, function () {
            var c = b[a.currentButtonIndex()];
            c && e(c.element, f || d);
          });
        });
        this.zoomText = f.label(d && d.rangeSelectorZoom || "", 0).attr({
          padding: c.buttonTheme.padding,
          height: c.buttonTheme.height,
          paddingLeft: 0,
          paddingRight: 0
        }).add(this.buttonGroup);
        this.chart.styledMode || (this.zoomText.css(c.labelStyle), g["stroke-width"] = l(g["stroke-width"], 0));
        m("option", {
          textContent: this.zoomText.textStr,
          disabled: !0
        }, void 0, p);
        this.buttonOptions.forEach(function (c, d) {
          m("option", {
            textContent: c.title || c.text
          }, void 0, p);
          b[d] = f.button(c.text, 0, 0, function (b) {
            var e = c.events && c.events.click,
              f;
            e && (f = e.call(c, b));
            !1 !== f && a.clickButton(d);
            a.isActive = !0;
          }, g, h && h.hover, h && h.select, h && h.disabled).attr({
            "text-align": "center",
            width: n
          }).add(a.buttonGroup);
          c.title && b[d].attr("title", c.title);
        });
      };
      d.prototype.alignElements = function () {
        var a = this,
          b = this.buttonGroup,
          c = this.buttons,
          d = this.chart,
          e = this.group,
          f = this.inputGroup,
          g = this.options,
          h = this.zoomText,
          m = d.options,
          n = m.exporting && !1 !== m.exporting.enabled && m.navigation && m.navigation.buttonOptions;
        m = g.buttonPosition;
        var p = g.inputPosition,
          q = g.verticalAlign,
          t = function (b, c) {
            return n && a.titleCollision(d) && "top" === q && "right" === c.align && c.y - b.getBBox().height - 12 < (n.y || 0) + (n.height || 0) + d.spacing[0] ? -40 : 0;
          },
          v = d.plotLeft;
        if (e && m && p) {
          var w = m.x - d.spacing[3];
          if (b) {
            this.positionButtons();
            if (!this.initialButtonGroupWidth) {
              var x = 0;
              h && (x += h.getBBox().width + 5);
              c.forEach(function (a, b) {
                x += a.width;
                b !== c.length - 1 && (x += g.buttonSpacing);
              });
              this.initialButtonGroupWidth = x;
            }
            v -= d.spacing[3];
            this.updateButtonStates();
            h = t(b, m);
            this.alignButtonGroup(h);
            e.placed = b.placed = d.hasLoaded;
          }
          b = 0;
          f && (b = t(f, p), "left" === p.align ? w = v : "right" === p.align && (w = -Math.max(d.axisOffset[1], -b)), f.align({
            y: p.y,
            width: f.getBBox().width,
            align: p.align,
            x: p.x + w - 2
          }, !0, d.spacingBox), f.placed = d.hasLoaded);
          this.handleCollision(b);
          e.align({
            verticalAlign: q
          }, !0, d.spacingBox);
          f = e.alignAttr.translateY;
          b = e.getBBox().height + 20;
          t = 0;
          "bottom" === q && (t = (t = d.legend && d.legend.options) && "bottom" === t.verticalAlign && t.enabled && !t.floating ? d.legend.legendHeight + l(t.margin, 10) : 0, b = b + t - 20, t = f - b - (g.floating ? 0 : g.y) - (d.titleOffset ? d.titleOffset[2] : 0) - 10);
          if ("top" === q) g.floating && (t = 0), d.titleOffset && d.titleOffset[0] && (t = d.titleOffset[0]), t += d.margin[0] - d.spacing[0] || 0;else if ("middle" === q) if (p.y === m.y) t = f;else if (p.y || m.y) t = 0 > p.y || 0 > m.y ? t - Math.min(p.y, m.y) : f - b;
          e.translate(g.x, g.y + Math.floor(t));
          m = this.minInput;
          p = this.maxInput;
          f = this.dropdown;
          g.inputEnabled && m && p && (m.style.marginTop = e.translateY + "px", p.style.marginTop = e.translateY + "px");
          f && (f.style.marginTop = e.translateY + "px");
        }
      };
      d.prototype.alignButtonGroup = function (a, b) {
        var c = this.chart,
          d = this.buttonGroup,
          e = this.options.buttonPosition,
          f = c.plotLeft - c.spacing[3],
          g = e.x - c.spacing[3];
        "right" === e.align ? g += a - f : "center" === e.align && (g -= f / 2);
        d && d.align({
          y: e.y,
          width: l(b, this.initialButtonGroupWidth),
          align: e.align,
          x: g
        }, !0, c.spacingBox);
      };
      d.prototype.positionButtons = function () {
        var a = this.buttons,
          b = this.chart,
          c = this.options,
          d = this.zoomText,
          e = b.hasLoaded ? "animate" : "attr",
          f = c.buttonPosition,
          g = b.plotLeft,
          h = g;
        d && "hidden" !== d.visibility && (d[e]({
          x: l(g + f.x, g)
        }), h += f.x + d.getBBox().width + 5);
        this.buttonOptions.forEach(function (b, d) {
          if ("hidden" !== a[d].visibility) a[d][e]({
            x: h
          }), h += a[d].width + c.buttonSpacing;else a[d][e]({
            x: g
          });
        });
      };
      d.prototype.handleCollision = function (a) {
        var b = this,
          c = this.chart,
          d = this.buttonGroup,
          e = this.inputGroup,
          f = this.options,
          g = f.buttonPosition,
          h = f.dropdown,
          k = f.inputPosition;
        f = function () {
          var a = 0;
          b.buttons.forEach(function (b) {
            b = b.getBBox();
            b.width > a && (a = b.width);
          });
          return a;
        };
        var l = function (b) {
            if (e && d) {
              var c = e.alignAttr.translateX + e.alignOptions.x - a + e.getBBox().x + 2,
                f = e.alignOptions.width,
                h = d.alignAttr.translateX + d.getBBox().x;
              return h + b > c && c + f > h && g.y < k.y + e.getBBox().height;
            }
            return !1;
          },
          m = function () {
            e && d && e.attr({
              translateX: e.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),
              translateY: e.alignAttr.translateY + d.getBBox().height + 10
            });
          };
        if (d) {
          if ("always" === h) {
            this.collapseButtons(a);
            l(f()) && m();
            return;
          }
          "never" === h && this.expandButtons();
        }
        e && d ? k.align === g.align || l(this.initialButtonGroupWidth + 20) ? "responsive" === h ? (this.collapseButtons(a), l(f()) && m()) : m() : "responsive" === h && this.expandButtons() : d && "responsive" === h && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());
      };
      d.prototype.collapseButtons = function (a) {
        var b = this.buttons,
          c = this.buttonOptions,
          d = this.chart,
          e = this.dropdown,
          f = this.options,
          g = this.zoomText,
          h = d.userOptions.rangeSelector && d.userOptions.rangeSelector.buttonTheme || {},
          k = function (a) {
            return {
              text: a ? a + " \u25be" : "\u25be",
              width: "auto",
              paddingLeft: l(f.buttonTheme.paddingLeft, h.padding, 8),
              paddingRight: l(f.buttonTheme.paddingRight, h.padding, 8)
            };
          };
        g && g.hide();
        var m = !1;
        c.forEach(function (a, c) {
          c = b[c];
          2 !== c.state ? c.hide() : (c.show(), c.attr(k(a.text)), m = !0);
        });
        m || (e && (e.selectedIndex = 0), b[0].show(), b[0].attr(k(this.zoomText && this.zoomText.textStr)));
        c = f.buttonPosition.align;
        this.positionButtons();
        "right" !== c && "center" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);
        this.showDropdown();
      };
      d.prototype.expandButtons = function () {
        var a = this.buttons,
          b = this.buttonOptions,
          c = this.options,
          d = this.zoomText;
        this.hideDropdown();
        d && d.show();
        b.forEach(function (b, d) {
          d = a[d];
          d.show();
          d.attr({
            text: b.text,
            width: c.buttonTheme.width || 28,
            paddingLeft: l(c.buttonTheme.paddingLeft, "unset"),
            paddingRight: l(c.buttonTheme.paddingRight, "unset")
          });
          2 > d.state && d.setState(0);
        });
        this.positionButtons();
      };
      d.prototype.currentButtonIndex = function () {
        var a = this.dropdown;
        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;
      };
      d.prototype.showDropdown = function () {
        var a = this.buttonGroup,
          b = this.buttons,
          c = this.chart,
          d = this.dropdown;
        if (a && d) {
          var e = a.translateX;
          a = a.translateY;
          b = b[this.currentButtonIndex()].getBBox();
          h(d, {
            left: c.plotLeft + e + "px",
            top: a + .5 + "px",
            width: b.width + "px",
            height: b.height + "px"
          });
          this.hasVisibleDropdown = !0;
        }
      };
      d.prototype.hideDropdown = function () {
        var a = this.dropdown;
        a && (h(a, {
          top: "-9999em",
          width: "1px",
          height: "1px"
        }), this.hasVisibleDropdown = !1);
      };
      d.prototype.getHeight = function () {
        var a = this.options,
          b = this.group,
          c = a.y,
          d = a.buttonPosition.y,
          e = a.inputPosition.y;
        if (a.height) return a.height;
        this.alignElements();
        a = b ? b.getBBox(!0).height + 13 + c : 0;
        b = Math.min(e, d);
        if (0 > e && 0 > d || 0 < e && 0 < d) a += Math.abs(b);
        return a;
      };
      d.prototype.titleCollision = function (a) {
        return !(a.options.title.text || a.options.subtitle.text);
      };
      d.prototype.update = function (a) {
        var b = this.chart;
        J(!0, b.options.rangeSelector, a);
        this.destroy();
        this.init(b);
        this.render();
      };
      d.prototype.destroy = function () {
        var a = this,
          b = a.minInput,
          c = a.maxInput;
        a.eventsToUnbind && (a.eventsToUnbind.forEach(function (a) {
          return a();
        }), a.eventsToUnbind = void 0);
        n(a.buttons);
        b && (b.onfocus = b.onblur = b.onchange = null);
        c && (c.onfocus = c.onblur = c.onchange = null);
        M(a, function (b, c) {
          b && "chart" !== c && (b instanceof y ? b.destroy() : b instanceof window.HTMLElement && z(b));
          b !== d.prototype[c] && (a[c] = null);
        }, this);
      };
      return d;
    }();
    v.prototype.defaultButtons = [{
      type: "month",
      count: 1,
      text: "1m",
      title: "View 1 month"
    }, {
      type: "month",
      count: 3,
      text: "3m",
      title: "View 3 months"
    }, {
      type: "month",
      count: 6,
      text: "6m",
      title: "View 6 months"
    }, {
      type: "ytd",
      text: "YTD",
      title: "View year to date"
    }, {
      type: "year",
      count: 1,
      text: "1y",
      title: "View 1 year"
    }, {
      type: "all",
      text: "All",
      title: "View all"
    }];
    v.prototype.inputTypeFormats = {
      "datetime-local": "%Y-%m-%dT%H:%M:%S",
      date: "%Y-%m-%d",
      time: "%H:%M:%S"
    };
    a.prototype.minFromRange = function () {
      var a = this.range,
        b = a.type,
        c = this.max,
        d = this.chart.time,
        e = function (a, c) {
          var e = "year" === b ? "FullYear" : "Month",
            f = new d.Date(a),
            g = d.get(e, f);
          d.set(e, f, g + c);
          g === d.get(e, f) && d.set("Date", f, 0);
          return f.getTime() - a;
        };
      if (G(a)) {
        var f = c - a;
        var g = a;
      } else f = c + e(c, -a.count), this.chart && (this.chart.fixedRange = c - f);
      var h = l(this.dataMin, Number.MIN_VALUE);
      G(f) || (f = h);
      f <= h && (f = h, "undefined" === typeof g && (g = e(f, a.count)), this.newMax = Math.min(f + g, this.dataMax));
      G(c) || (f = void 0);
      return f;
    };
    if (!B.RangeSelector) {
      var d = [],
        D = function (a) {
          function b() {
            e && (c = a.xAxis[0].getExtremes(), g = a.legend, l = e && e.options.verticalAlign, G(c.min) && e.render(c.min, c.max), g.display && "top" === l && l === g.options.verticalAlign && (h = J(a.spacingBox), h.y = "vertical" === g.options.layout ? a.plotTop : h.y + e.getHeight(), g.group.placed = !1, g.align(h)));
          }
          var c,
            e = a.rangeSelector,
            g,
            h,
            l;
          e && (f(d, function (b) {
            return b[0] === a;
          }) || d.push([a, [q(a.xAxis[0], "afterSetExtremes", function (a) {
            e && e.render(a.min, a.max);
          }), q(a, "redraw", b)]]), b());
        };
      q(t, "afterGetContainer", function () {
        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new v(this));
      });
      q(t, "beforeRender", function () {
        var a = this.axes,
          b = this.rangeSelector;
        b && (G(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {
          a.updateNames();
          a.setScale();
        }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || ("bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0)));
      });
      q(t, "update", function (a) {
        var b = a.options.rangeSelector;
        a = this.rangeSelector;
        var d = this.extraBottomMargin,
          e = this.extraTopMargin;
        b && b.enabled && !c(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new v(this));
        this.extraTopMargin = this.extraBottomMargin = !1;
        a && (D(this), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || ("bottom" === b ? this.extraBottomMargin = !0 : "middle" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== d || this.extraTopMargin !== e) && (this.isDirtyBox = !0);
      });
      q(t, "render", function () {
        var a = this.rangeSelector;
        a && !a.options.floating && (a.render(), a = a.options.verticalAlign, "bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0));
      });
      q(t, "getMargins", function () {
        var a = this.rangeSelector;
        a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));
      });
      t.prototype.callbacks.push(D);
      q(t, "destroy", function () {
        for (var a = 0; a < d.length; a++) {
          var b = d[a];
          if (b[0] === this) {
            b[1].forEach(function (a) {
              return a();
            });
            d.splice(a, 1);
            break;
          }
        }
      });
      B.RangeSelector = v;
    }
    return v;
  });
  N(a, "Core/Axis/NavigatorAxis.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, t) {
    var B = a.isTouchDevice,
      E = t.addEvent,
      y = t.correctFloat,
      F = t.defined,
      I = t.isNumber,
      x = t.pick,
      q = function () {
        function a(a) {
          this.axis = a;
        }
        a.prototype.destroy = function () {
          this.axis = void 0;
        };
        a.prototype.toFixedRange = function (a, c, m, q) {
          var g = this.axis,
            f = g.chart;
          f = f && f.fixedRange;
          var e = (g.pointRange || 0) / 2;
          a = x(m, g.translate(a, !0, !g.horiz));
          c = x(q, g.translate(c, !0, !g.horiz));
          g = f && (c - a) / f;
          F(m) || (a = y(a + e));
          F(q) || (c = y(c - e));
          .7 < g && 1.3 > g && (q ? a = c - f : c = a + f);
          I(a) && I(c) || (a = c = void 0);
          return {
            min: a,
            max: c
          };
        };
        return a;
      }();
    return function () {
      function a() {}
      a.compose = function (a) {
        a.keepProps.push("navigatorAxis");
        E(a, "init", function () {
          this.navigatorAxis || (this.navigatorAxis = new q(this));
        });
        E(a, "zoom", function (a) {
          var c = this.chart.options,
            h = c.navigator,
            g = this.navigatorAxis,
            f = c.chart.pinchType,
            e = c.rangeSelector;
          c = c.chart.zoomType;
          this.isXAxis && (h && h.enabled || e && e.enabled) && ("y" === c ? a.zoomed = !1 : (!B && "xy" === c || B && "xy" === f) && this.options.range && (h = g.previousZoom, F(a.newMin) ? g.previousZoom = [this.min, this.max] : h && (a.newMin = h[0], a.newMax = h[1], g.previousZoom = void 0)));
          "undefined" !== typeof a.zoomed && a.preventDefault();
        });
      };
      a.AdditionsClass = q;
      return a;
    }();
  });
  N(a, "Core/Navigator.js", [a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Axis/NavigatorAxis.js"], a["Core/DefaultOptions.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Scrollbar.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, t, B, H, y, F, I, x, q, m, h) {
    B = B.parse;
    var c = H.hasTouch,
      n = H.isTouchDevice,
      z = F.defaultOptions,
      g = h.addEvent,
      f = h.clamp,
      e = h.correctFloat,
      E = h.defined,
      J = h.destroyObjectProperties,
      M = h.erase,
      p = h.extend,
      l = h.find,
      w = h.isArray,
      b = h.isNumber,
      v = h.merge,
      d = h.pick,
      D = h.removeEvent,
      C = h.splat,
      k = function (a) {
        for (var c = [], d = 1; d < arguments.length; d++) c[d - 1] = arguments[d];
        c = [].filter.call(c, b);
        if (c.length) return Math[a].apply(0, c);
      };
    F = "undefined" === typeof m.seriesTypes.areaspline ? "line" : "areaspline";
    p(z, {
      navigator: {
        height: 40,
        margin: 25,
        maskInside: !0,
        handles: {
          width: 7,
          height: 15,
          symbols: ["navigator-handle", "navigator-handle"],
          enabled: !0,
          lineWidth: 1,
          backgroundColor: "#f2f2f2",
          borderColor: "#999999"
        },
        maskFill: B("#6685c2").setOpacity(.3).get(),
        outlineColor: "#cccccc",
        outlineWidth: 1,
        series: {
          type: F,
          fillOpacity: .05,
          lineWidth: 1,
          compare: null,
          dataGrouping: {
            approximation: "average",
            enabled: !0,
            groupPixelWidth: 2,
            firstAnchor: "firstPoint",
            anchor: "middle",
            lastAnchor: "lastPoint",
            units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]]
          },
          dataLabels: {
            enabled: !1,
            zIndex: 2
          },
          id: "highcharts-navigator-series",
          className: "highcharts-navigator-series",
          lineColor: null,
          marker: {
            enabled: !1
          },
          threshold: null
        },
        xAxis: {
          overscroll: 0,
          className: "highcharts-navigator-xaxis",
          tickLength: 0,
          lineWidth: 0,
          gridLineColor: "#e6e6e6",
          gridLineWidth: 1,
          tickPixelInterval: 200,
          labels: {
            align: "left",
            style: {
              color: "#999999"
            },
            x: 3,
            y: -4
          },
          crosshair: !1
        },
        yAxis: {
          className: "highcharts-navigator-yaxis",
          gridLineWidth: 0,
          startOnTick: !1,
          endOnTick: !1,
          minPadding: .1,
          maxPadding: .1,
          labels: {
            enabled: !1
          },
          crosshair: !1,
          title: {
            text: null
          },
          tickLength: 0,
          tickWidth: 0
        }
      }
    });
    I.getRendererType().prototype.symbols["navigator-handle"] = function (a, b, c, d, e) {
      a = (e && e.width || 0) / 2;
      b = Math.round(a / 3) + .5;
      e = e && e.height || 0;
      return [["M", -a - 1, .5], ["L", a, .5], ["L", a, e + .5], ["L", -a - 1, e + .5], ["L", -a - 1, .5], ["M", -b, 4], ["L", -b, e - 3], ["M", b - 1, 4], ["L", b - 1, e - 3]];
    };
    var K = function () {
      function h(a) {
        this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;
        this.init(a);
      }
      h.prototype.drawHandle = function (a, b, c, d) {
        var e = this.navigatorOptions.handles.height;
        this.handles[b][d](c ? {
          translateX: Math.round(this.left + this.height / 2),
          translateY: Math.round(this.top + parseInt(a, 10) + .5 - e)
        } : {
          translateX: Math.round(this.left + parseInt(a, 10)),
          translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)
        });
      };
      h.prototype.drawOutline = function (a, b, c, d) {
        var e = this.navigatorOptions.maskInside,
          f = this.outline.strokeWidth(),
          g = f / 2,
          h = f % 2 / 2;
        f = this.outlineHeight;
        var k = this.scrollbarHeight || 0,
          l = this.size,
          m = this.left - k,
          n = this.top;
        c ? (m -= g, c = n + b + h, b = n + a + h, h = [["M", m + f, n - k - h], ["L", m + f, c], ["L", m, c], ["L", m, b], ["L", m + f, b], ["L", m + f, n + l + k]], e && h.push(["M", m + f, c - g], ["L", m + f, b + g])) : (a += m + k - h, b += m + k - h, n += g, h = [["M", m, n], ["L", a, n], ["L", a, n + f], ["L", b, n + f], ["L", b, n], ["L", m + l + 2 * k, n]], e && h.push(["M", a - g, n], ["L", b + g, n]));
        this.outline[d]({
          d: h
        });
      };
      h.prototype.drawMasks = function (a, b, c, d) {
        var e = this.left,
          f = this.top,
          g = this.height;
        if (c) {
          var h = [e, e, e];
          var k = [f, f + a, f + b];
          var l = [g, g, g];
          var m = [a, b - a, this.size - b];
        } else h = [e, e + a, e + b], k = [f, f, f], l = [a, b - a, this.size - b], m = [g, g, g];
        this.shades.forEach(function (a, b) {
          a[d]({
            x: h[b],
            y: k[b],
            width: l[b],
            height: m[b]
          });
        });
      };
      h.prototype.renderElements = function () {
        var a = this,
          b = a.navigatorOptions,
          c = b.maskInside,
          d = a.chart,
          e = d.renderer,
          f,
          g = {
            cursor: d.inverted ? "ns-resize" : "ew-resize"
          };
        a.navigatorGroup = f = e.g("navigator").attr({
          zIndex: 8,
          visibility: "hidden"
        }).add();
        [!c, c, !c].forEach(function (c, h) {
          a.shades[h] = e.rect().addClass("highcharts-navigator-mask" + (1 === h ? "-inside" : "-outside")).add(f);
          d.styledMode || a.shades[h].attr({
            fill: c ? b.maskFill : "rgba(0,0,0,0)"
          }).css(1 === h && g);
        });
        a.outline = e.path().addClass("highcharts-navigator-outline").add(f);
        d.styledMode || a.outline.attr({
          "stroke-width": b.outlineWidth,
          stroke: b.outlineColor
        });
        b.handles.enabled && [0, 1].forEach(function (c) {
          b.handles.inverted = d.inverted;
          a.handles[c] = e.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);
          a.handles[c].attr({
            zIndex: 7 - c
          }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][c]).add(f);
          if (!d.styledMode) {
            var h = b.handles;
            a.handles[c].attr({
              fill: h.backgroundColor,
              stroke: h.borderColor,
              "stroke-width": h.lineWidth
            }).css(g);
          }
        });
      };
      h.prototype.update = function (a) {
        (this.series || []).forEach(function (a) {
          a.baseSeries && delete a.baseSeries.navigatorSeries;
        });
        this.destroy();
        v(!0, this.chart.options.navigator, this.options, a);
        this.init(this.chart);
      };
      h.prototype.render = function (a, c, g, h) {
        var k = this.chart,
          l = this.scrollbarHeight,
          m,
          n = this.xAxis,
          r = n.pointRange || 0;
        var p = n.navigatorAxis.fake ? k.xAxis[0] : n;
        var q = this.navigatorEnabled,
          t,
          v = this.rendered;
        var A = k.inverted;
        var w = k.xAxis[0].minRange,
          x = k.xAxis[0].options.maxRange;
        if (!this.hasDragged || E(g)) {
          a = e(a - r / 2);
          c = e(c + r / 2);
          if (!b(a) || !b(c)) if (v) g = 0, h = d(n.width, p.width);else return;
          this.left = d(n.left, k.plotLeft + l + (A ? k.plotWidth : 0));
          this.size = t = m = d(n.len, (A ? k.plotHeight : k.plotWidth) - 2 * l);
          k = A ? l : m + 2 * l;
          g = d(g, n.toPixels(a, !0));
          h = d(h, n.toPixels(c, !0));
          b(g) && Infinity !== Math.abs(g) || (g = 0, h = k);
          a = n.toValue(g, !0);
          c = n.toValue(h, !0);
          var y = Math.abs(e(c - a));
          y < w ? this.grabbedLeft ? g = n.toPixels(c - w - r, !0) : this.grabbedRight && (h = n.toPixels(a + w + r, !0)) : E(x) && e(y - r) > x && (this.grabbedLeft ? g = n.toPixels(c - x - r, !0) : this.grabbedRight && (h = n.toPixels(a + x + r, !0)));
          this.zoomedMax = f(Math.max(g, h), 0, t);
          this.zoomedMin = f(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(g, h), 0, t);
          this.range = this.zoomedMax - this.zoomedMin;
          t = Math.round(this.zoomedMax);
          g = Math.round(this.zoomedMin);
          q && (this.navigatorGroup.attr({
            visibility: "visible"
          }), v = v && !this.hasDragged ? "animate" : "attr", this.drawMasks(g, t, A, v), this.drawOutline(g, t, A, v), this.navigatorOptions.handles.enabled && (this.drawHandle(g, 0, A, v), this.drawHandle(t, 1, A, v)));
          this.scrollbar && (A ? (A = this.top - l, p = this.left - l + (q || !p.opposite ? 0 : (p.titleOffset || 0) + p.axisTitleMargin), l = m + 2 * l) : (A = this.top + (q ? this.height : -l), p = this.left - l), this.scrollbar.position(p, A, k, l), this.scrollbar.setRange(this.zoomedMin / (m || 1), this.zoomedMax / (m || 1)));
          this.rendered = !0;
        }
      };
      h.prototype.addMouseEvents = function () {
        var a = this,
          b = a.chart,
          d = b.container,
          e = [],
          f,
          h;
        a.mouseMoveHandler = f = function (b) {
          a.onMouseMove(b);
        };
        a.mouseUpHandler = h = function (b) {
          a.onMouseUp(b);
        };
        e = a.getPartsEvents("mousedown");
        e.push(g(b.renderTo, "mousemove", f), g(d.ownerDocument, "mouseup", h));
        c && (e.push(g(b.renderTo, "touchmove", f), g(d.ownerDocument, "touchend", h)), e.concat(a.getPartsEvents("touchstart")));
        a.eventsToUnbind = e;
        a.series && a.series[0] && e.push(g(a.series[0].xAxis, "foundExtremes", function () {
          b.navigator.modifyNavigatorAxisExtremes();
        }));
      };
      h.prototype.getPartsEvents = function (a) {
        var b = this,
          c = [];
        ["shades", "handles"].forEach(function (d) {
          b[d].forEach(function (e, f) {
            c.push(g(e.element, a, function (a) {
              b[d + "Mousedown"](a, f);
            }));
          });
        });
        return c;
      };
      h.prototype.shadesMousedown = function (a, b) {
        a = this.chart.pointer.normalize(a);
        var c = this.chart,
          d = this.xAxis,
          e = this.zoomedMin,
          f = this.left,
          g = this.size,
          h = this.range,
          k = a.chartX;
        c.inverted && (k = a.chartY, f = this.top);
        if (1 === b) this.grabbedCenter = k, this.fixedWidth = h, this.dragOffset = k - e;else {
          a = k - f - h / 2;
          if (0 === b) a = Math.max(0, a);else if (2 === b && a + h >= g) if (a = g - h, this.reversedExtremes) {
            a -= h;
            var l = this.getUnionExtremes().dataMin;
          } else var m = this.getUnionExtremes().dataMax;
          a !== e && (this.fixedWidth = h, b = d.navigatorAxis.toFixedRange(a, a + h, l, m), E(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {
            trigger: "navigator"
          }));
        }
      };
      h.prototype.handlesMousedown = function (a, b) {
        this.chart.pointer.normalize(a);
        a = this.chart;
        var c = a.xAxis[0],
          d = this.reversedExtremes;
        0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);
        a.fixedRange = null;
      };
      h.prototype.onMouseMove = function (a) {
        var b = this,
          c = b.chart,
          e = b.left,
          f = b.navigatorSize,
          g = b.range,
          h = b.dragOffset,
          k = c.inverted;
        a.touches && 0 === a.touches[0].pageX || (a = c.pointer.normalize(a), c = a.chartX, k && (e = b.top, c = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, c - e, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, c - e)) : b.grabbedCenter && (b.hasDragged = !0, c < h ? c = h : c > f + h - g && (c = f + h - g), b.render(0, 0, c - h, c - h + g)), b.hasDragged && b.scrollbar && d(b.scrollbar.options.liveRedraw, H.svg && !n && !this.chart.isBoosting) && (a.DOMType = a.type, setTimeout(function () {
          b.onMouseUp(a);
        }, 0)));
      };
      h.prototype.onMouseUp = function (a) {
        var c = this.chart,
          d = this.xAxis,
          e = this.scrollbar,
          f = a.DOMEvent || a,
          g = c.inverted,
          h = this.rendered && !this.hasDragged ? "animate" : "attr";
        if (this.hasDragged && (!e || !e.hasDragged) || "scrollbar" === a.trigger) {
          e = this.getUnionExtremes();
          if (this.zoomedMin === this.otherHandlePos) var k = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var l = this.fixedExtreme;
          this.zoomedMax === this.size && (l = this.reversedExtremes ? e.dataMin : e.dataMax);
          0 === this.zoomedMin && (k = this.reversedExtremes ? e.dataMax : e.dataMin);
          d = d.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, k, l);
          E(d.min) && c.xAxis[0].setExtremes(Math.min(d.min, d.max), Math.max(d.min, d.max), !0, this.hasDragged ? !1 : null, {
            trigger: "navigator",
            triggerOp: "navigator-drag",
            DOMEvent: f
          });
        }
        "mousemove" !== a.DOMType && "touchmove" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);
        this.navigatorEnabled && b(this.zoomedMin) && b(this.zoomedMax) && (c = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(c, a, g, h), this.outline && this.drawOutline(c, a, g, h), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(c, 0, g, h), this.drawHandle(a, 1, g, h)));
      };
      h.prototype.removeEvents = function () {
        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {
          a();
        }), this.eventsToUnbind = void 0);
        this.removeBaseSeriesEvents();
      };
      h.prototype.removeBaseSeriesEvents = function () {
        var a = this.baseSeries || [];
        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {
          D(a, "updatedData", this.updatedDataHandler);
        }, this), a[0].xAxis && D(a[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
      };
      h.prototype.init = function (b) {
        var c = b.options,
          e = c.navigator,
          f = e.enabled,
          h = c.scrollbar,
          l = h.enabled;
        c = f ? e.height : 0;
        var m = l ? h.height : 0;
        this.handles = [];
        this.shades = [];
        this.chart = b;
        this.setBaseSeries();
        this.height = c;
        this.scrollbarHeight = m;
        this.scrollbarEnabled = l;
        this.navigatorEnabled = f;
        this.navigatorOptions = e;
        this.scrollbarOptions = h;
        this.outlineHeight = c + m;
        this.opposite = d(e.opposite, !(f || !b.inverted));
        var n = this;
        f = n.baseSeries;
        h = b.xAxis.length;
        l = b.yAxis.length;
        var p = f && f[0] && f[0].xAxis || b.xAxis[0] || {
          options: {}
        };
        b.isDirtyBox = !0;
        n.navigatorEnabled ? (n.xAxis = new a(b, v({
          breaks: p.options.breaks,
          ordinal: p.options.ordinal
        }, e.xAxis, {
          id: "navigator-x-axis",
          yAxis: "navigator-y-axis",
          isX: !0,
          type: "datetime",
          index: h,
          isInternal: !0,
          offset: 0,
          keepOrdinalPadding: !0,
          startOnTick: !1,
          endOnTick: !1,
          minPadding: 0,
          maxPadding: 0,
          zoomEnabled: !1
        }, b.inverted ? {
          offsets: [m, 0, -m, 0],
          width: c
        } : {
          offsets: [0, -m, 0, m],
          height: c
        })), n.yAxis = new a(b, v(e.yAxis, {
          id: "navigator-y-axis",
          alignTicks: !1,
          offset: 0,
          index: l,
          isInternal: !0,
          reversed: d(e.yAxis && e.yAxis.reversed, b.yAxis[0] && b.yAxis[0].reversed, !1),
          zoomEnabled: !1
        }, b.inverted ? {
          width: c
        } : {
          height: c
        })), f || e.series.data ? n.updateNavigatorSeries(!1) : 0 === b.series.length && (n.unbindRedraw = g(b, "beforeRedraw", function () {
          0 < b.series.length && !n.series && (n.setBaseSeries(), n.unbindRedraw());
        })), n.reversedExtremes = b.inverted && !n.xAxis.reversed || !b.inverted && n.xAxis.reversed, n.renderElements(), n.addMouseEvents()) : (n.xAxis = {
          chart: b,
          navigatorAxis: {
            fake: !0
          },
          translate: function (a, c) {
            var d = b.xAxis[0],
              e = d.getExtremes(),
              f = d.len - 2 * m,
              g = k("min", d.options.min, e.dataMin);
            d = k("max", d.options.max, e.dataMax) - g;
            return c ? a * d / f + g : f * (a - g) / d;
          },
          toPixels: function (a) {
            return this.translate(a);
          },
          toValue: function (a) {
            return this.translate(a, !0);
          }
        }, n.xAxis.navigatorAxis.axis = n.xAxis, n.xAxis.navigatorAxis.toFixedRange = y.AdditionsClass.prototype.toFixedRange.bind(n.xAxis.navigatorAxis));
        b.options.scrollbar.enabled && (b.scrollbar = n.scrollbar = new x(b.renderer, v(b.options.scrollbar, {
          margin: n.navigatorEnabled ? 0 : 10,
          vertical: b.inverted
        }), b), g(n.scrollbar, "changed", function (a) {
          var b = n.size,
            c = b * this.to;
          b *= this.from;
          n.hasDragged = n.scrollbar.hasDragged;
          n.render(0, 0, b, c);
          this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {
            n.onMouseUp(a);
          });
        }));
        n.addBaseSeriesEvents();
        n.addChartEvents();
      };
      h.prototype.getUnionExtremes = function (a) {
        var b = this.chart.xAxis[0],
          c = this.xAxis,
          e = c.options,
          f = b.options,
          g;
        a && null === b.dataMin || (g = {
          dataMin: d(e && e.min, k("min", f.min, b.dataMin, c.dataMin, c.min)),
          dataMax: d(e && e.max, k("max", f.max, b.dataMax, c.dataMax, c.max))
        });
        return g;
      };
      h.prototype.setBaseSeries = function (a, b) {
        var c = this.chart,
          d = this.baseSeries = [];
        a = a || c.options && c.options.navigator.baseSeries || (c.series.length ? l(c.series, function (a) {
          return !a.options.isInternal;
        }).index : 0);
        (c.series || []).forEach(function (b, c) {
          b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || d.push(b);
        });
        this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, b);
      };
      h.prototype.updateNavigatorSeries = function (a, b) {
        var c = this,
          e = c.chart,
          f = c.baseSeries,
          g,
          h,
          k = c.navigatorOptions.series,
          l,
          m = {
            enableMouseTracking: !1,
            index: null,
            linkedTo: null,
            group: "nav",
            padXAxis: !1,
            xAxis: "navigator-x-axis",
            yAxis: "navigator-y-axis",
            showInLegend: !1,
            stacking: void 0,
            isInternal: !0,
            states: {
              inactive: {
                opacity: 1
              }
            }
          },
          n = c.series = (c.series || []).filter(function (a) {
            var b = a.baseSeries;
            return 0 > f.indexOf(b) ? (b && (D(b, "updatedData", c.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;
          });
        f && f.length && f.forEach(function (a) {
          var r = a.navigatorSeries,
            q = p({
              color: a.color,
              visible: a.visible
            }, w(k) ? z.navigator.series : k);
          r && !1 === c.navigatorOptions.adaptToUpdatedData || (m.name = "Navigator " + f.length, g = a.options || {}, l = g.navigatorOptions || {}, q.dataLabels = C(q.dataLabels), h = v(g, m, q, l), h.pointRange = d(q.pointRange, l.pointRange, z.plotOptions[h.type || "line"].pointRange), q = l.data || q.data, c.hasNavigatorData = c.hasNavigatorData || !!q, h.data = q || g.data && g.data.slice(0), r && r.options ? r.update(h, b) : (a.navigatorSeries = e.initSeries(h), a.navigatorSeries.baseSeries = a, n.push(a.navigatorSeries)));
        });
        if (k.data && (!f || !f.length) || w(k)) c.hasNavigatorData = !1, k = C(k), k.forEach(function (a, b) {
          m.name = "Navigator " + (n.length + 1);
          h = v(z.navigator.series, {
            color: e.series[b] && !e.series[b].options.isInternal && e.series[b].color || e.options.colors[b] || e.options.colors[0]
          }, m, a);
          h.data = a.data;
          h.data && (c.hasNavigatorData = !0, n.push(e.initSeries(h)));
        });
        a && this.addBaseSeriesEvents();
      };
      h.prototype.addBaseSeriesEvents = function () {
        var a = this,
          b = a.baseSeries || [];
        b[0] && b[0].xAxis && b[0].eventsToUnbind.push(g(b[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
        b.forEach(function (b) {
          b.eventsToUnbind.push(g(b, "show", function () {
            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);
          }));
          b.eventsToUnbind.push(g(b, "hide", function () {
            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);
          }));
          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(g(b, "updatedData", this.updatedDataHandler));
          b.eventsToUnbind.push(g(b, "remove", function () {
            this.navigatorSeries && (M(a.series, this.navigatorSeries), E(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);
          }));
        }, this);
      };
      h.prototype.getBaseSeriesMin = function (a) {
        return this.baseSeries.reduce(function (a, b) {
          return Math.min(a, b.xData ? b.xData[0] : a);
        }, a);
      };
      h.prototype.modifyNavigatorAxisExtremes = function () {
        var a = this.xAxis,
          b;
        "undefined" !== typeof a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));
      };
      h.prototype.modifyBaseAxisExtremes = function () {
        var a = this.chart.navigator,
          c = this.getExtremes(),
          e = c.dataMin,
          f = c.dataMax;
        c = c.max - c.min;
        var g = a.stickToMin,
          h = a.stickToMax,
          k = d(this.options.overscroll, 0),
          l = a.series && a.series[0],
          m = !!this.setExtremes;
        if (!this.eventArgs || "rangeSelectorButton" !== this.eventArgs.trigger) {
          if (g) {
            var n = e;
            var p = n + c;
          }
          h && (p = f + k, g || (n = Math.max(e, p - c, a.getBaseSeriesMin(l && l.xData ? l.xData[0] : -Number.MAX_VALUE))));
          m && (g || h) && b(n) && (this.min = this.userMin = n, this.max = this.userMax = p);
        }
        a.stickToMin = a.stickToMax = null;
      };
      h.prototype.updatedDataHandler = function () {
        var a = this.chart.navigator,
          b = this.navigatorSeries;
        a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);
        a.stickToMin = a.shouldStickToMin(this, a);
        b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));
      };
      h.prototype.shouldStickToMin = function (a, c) {
        c = c.getBaseSeriesMin(a.xData[0]);
        var d = a.xAxis;
        a = d.max;
        var e = d.min;
        d = d.options.range;
        return b(a) && b(e) ? d && 0 < a - c ? a - c < d : e <= c : !1;
      };
      h.prototype.addChartEvents = function () {
        this.eventsToUnbind || (this.eventsToUnbind = []);
        this.eventsToUnbind.push(g(this.chart, "redraw", function () {
          var a = this.navigator,
            b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);
          b && a.render(b.min, b.max);
        }), g(this.chart, "getMargins", function () {
          var a = this.navigator,
            b = a.opposite ? "plotTop" : "marginBottom";
          this.inverted && (b = a.opposite ? "marginRight" : "plotLeft");
          this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;
        }));
      };
      h.prototype.destroy = function () {
        this.removeEvents();
        this.xAxis && (M(this.chart.xAxis, this.xAxis), M(this.chart.axes, this.xAxis));
        this.yAxis && (M(this.chart.yAxis, this.yAxis), M(this.chart.axes, this.yAxis));
        (this.series || []).forEach(function (a) {
          a.destroy && a.destroy();
        });
        "series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" ").forEach(function (a) {
          this[a] && this[a].destroy && this[a].destroy();
          this[a] = null;
        }, this);
        [this.handles].forEach(function (a) {
          J(a);
        }, this);
      };
      return h;
    }();
    H.Navigator || (H.Navigator = K, y.compose(a), g(t, "beforeShowResetZoom", function () {
      var a = this.options,
        b = a.navigator,
        c = a.rangeSelector;
      if ((b && b.enabled || c && c.enabled) && (!n && "x" === a.chart.zoomType || n && "x" === a.chart.pinchType)) return !1;
    }), g(t, "beforeRender", function () {
      var a = this.options;
      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new K(this);
    }), g(t, "afterSetChartSize", function () {
      var a = this.legend,
        b = this.navigator;
      if (b) {
        var c = a && a.options;
        var e = b.xAxis;
        var f = b.yAxis;
        var g = b.scrollbarHeight;
        this.inverted ? (b.left = b.opposite ? this.chartWidth - g - b.height : this.spacing[3] + g, b.top = this.plotTop + g) : (b.left = d(e.left, this.plotLeft + g), b.top = b.navigatorOptions.top || this.chartHeight - b.height - g - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && "bottom" === c.verticalAlign && "proximate" !== c.layout && c.enabled && !c.floating ? a.legendHeight + d(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));
        e && f && (this.inverted ? e.options.left = f.options.left = b.left : e.options.top = f.options.top = b.top, e.setAxisSize(), f.setAxisSize());
      }
    }), g(t, "update", function (a) {
      var b = a.options.navigator || {},
        c = a.options.scrollbar || {};
      this.navigator || this.scroller || !b.enabled && !c.enabled || (v(!0, this.options.navigator, b), v(!0, this.options.scrollbar, c), delete a.options.navigator, delete a.options.scrollbar);
    }), g(t, "afterUpdate", function (a) {
      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new K(this), d(a.redraw, !0) && this.redraw(a.animation));
    }), g(t, "afterAddSeries", function () {
      this.navigator && this.navigator.setBaseSeries(null, !1);
    }), g(q, "afterUpdate", function () {
      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);
    }), t.prototype.callbacks.push(function (a) {
      var b = a.navigator;
      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));
    }));
    H.Navigator = K;
    return H.Navigator;
  });
  N(a, "masters/modules/gantt.src.js", [a["Core/Globals.js"], a["Core/Chart/GanttChart.js"], a["Core/Scrollbar.js"]], function (a, t, B) {
    a.Scrollbar = B;
    a.GanttChart = t;
    a.ganttChart = t.ganttChart;
    B.compose(a.Axis);
  });
  N(a, "masters/highcharts-gantt.src.js", [a["masters/highcharts.src.js"]], function (a) {
    a.product = "Highcharts Gantt";
    return a;
  });
  a["masters/highcharts-gantt.src.js"]._modules = a;
  return a["masters/highcharts-gantt.src.js"];
});
//# sourceMappingURL=highcharts-gantt.js.map

/***/ }),

/***/ 93470:
/*!***********************************************!*\
  !*** ./node_modules/highcharts/highcharts.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highcharts JS v9.3.3 (2022-02-01)

 (c) 2009-2021 Torstein Honsi

 License: www.highcharts.com/license
*/


(function (Z, M) {
   true && module.exports ? (M["default"] = M, module.exports = Z.document ? M(Z) : M) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return M(Z);
  }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);
})("undefined" !== typeof window ? window : this, function (Z) {
  function M(v, a, z, F) {
    v.hasOwnProperty(a) || (v[a] = F.apply(null, z));
  }
  var a = {};
  M(a, "Core/Globals.js", [], function () {
    var v = "undefined" !== typeof Z ? Z : "undefined" !== typeof window ? window : {},
      a;
    (function (a) {
      a.SVG_NS = "http://www.w3.org/2000/svg";
      a.product = "Highcharts";
      a.version = "9.3.3";
      a.win = v;
      a.doc = a.win.document;
      a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, "svg").createSVGRect;
      a.userAgent = a.win.navigator && a.win.navigator.userAgent || "";
      a.isChrome = -1 !== a.userAgent.indexOf("Chrome");
      a.isFirefox = -1 !== a.userAgent.indexOf("Firefox");
      a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;
      a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf("Safari");
      a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);
      a.isWebKit = -1 !== a.userAgent.indexOf("AppleWebKit");
      a.deg2rad = 2 * Math.PI / 360;
      a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split("Firefox/")[1], 10);
      a.hasTouch = !!a.win.TouchEvent;
      a.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
      a.noop = function () {};
      a.supportsPassiveEvents = function () {
        var v = !1;
        if (!a.isMS) {
          var u = Object.defineProperty({}, "passive", {
            get: function () {
              v = !0;
            }
          });
          a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener("testPassive", a.noop, u), a.win.removeEventListener("testPassive", a.noop, u));
        }
        return v;
      }();
      a.charts = [];
      a.dateFormats = {};
      a.seriesTypes = {};
      a.symbolSizes = {};
      a.chartCount = 0;
    })(a || (a = {}));
    "";
    return a;
  });
  M(a, "Core/Utilities.js", [a["Core/Globals.js"]], function (a) {
    function v(m, b, d, g) {
      var D = b ? "Highcharts error" : "Highcharts warning";
      32 === m && (m = D + ": Deprecated member");
      var x = n(m),
        c = x ? D + " #" + m + ": www.highcharts.com/errors/" + m + "/" : m.toString();
      if ("undefined" !== typeof g) {
        var r = "";
        x && (c += "?");
        B(g, function (m, b) {
          r += "\n - " + b + ": " + m;
          x && (c += encodeURI(b) + "=" + encodeURI(m));
        });
        c += r;
      }
      J(a, "displayError", {
        chart: d,
        code: m,
        message: c,
        params: g
      }, function () {
        if (b) throw Error(c);
        l.console && -1 === v.messages.indexOf(c) && console.warn(c);
      });
      v.messages.push(c);
    }
    function z(m, b) {
      var d = {};
      B(m, function (D, x) {
        if (H(m[x], !0) && !m.nodeType && b[x]) D = z(m[x], b[x]), Object.keys(D).length && (d[x] = D);else if (H(m[x]) || m[x] !== b[x]) d[x] = m[x];
      });
      return d;
    }
    function F(m, b) {
      return parseInt(m, b || 10);
    }
    function y(m) {
      return "string" === typeof m;
    }
    function G(m) {
      m = Object.prototype.toString.call(m);
      return "[object Array]" === m || "[object Array Iterator]" === m;
    }
    function H(m, b) {
      return !!m && "object" === typeof m && (!b || !G(m));
    }
    function A(m) {
      return H(m) && "number" === typeof m.nodeType;
    }
    function q(m) {
      var b = m && m.constructor;
      return !(!H(m, !0) || A(m) || !b || !b.name || "Object" === b.name);
    }
    function n(m) {
      return "number" === typeof m && !isNaN(m) && Infinity > m && -Infinity < m;
    }
    function k(m) {
      return "undefined" !== typeof m && null !== m;
    }
    function e(m, b, d) {
      var D;
      y(b) ? k(d) ? m.setAttribute(b, d) : m && m.getAttribute && ((D = m.getAttribute(b)) || "class" !== b || (D = m.getAttribute(b + "Name"))) : B(b, function (b, d) {
        k(b) ? m.setAttribute(d, b) : m.removeAttribute(d);
      });
      return D;
    }
    function c(b, d) {
      var m;
      b || (b = {});
      for (m in d) b[m] = d[m];
      return b;
    }
    function h() {
      for (var b = arguments, d = b.length, x = 0; x < d; x++) {
        var g = b[x];
        if ("undefined" !== typeof g && null !== g) return g;
      }
    }
    function f(b, d) {
      a.isMS && !a.svg && d && "undefined" !== typeof d.opacity && (d.filter = "alpha(opacity=" + 100 * d.opacity + ")");
      c(b.style, d);
    }
    function w(b, d) {
      return 1E14 < b ? b : parseFloat(b.toPrecision(d || 14));
    }
    function p(b, d, x) {
      var m = a.getStyle || p;
      if ("width" === d) return d = Math.min(b.offsetWidth, b.scrollWidth), x = b.getBoundingClientRect && b.getBoundingClientRect().width, x < d && x >= d - 1 && (d = Math.floor(x)), Math.max(0, d - (m(b, "padding-left", !0) || 0) - (m(b, "padding-right", !0) || 0));
      if ("height" === d) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - (m(b, "padding-top", !0) || 0) - (m(b, "padding-bottom", !0) || 0));
      l.getComputedStyle || v(27, !0);
      if (b = l.getComputedStyle(b, void 0)) {
        var g = b.getPropertyValue(d);
        h(x, "opacity" !== d) && (g = F(g));
      }
      return g;
    }
    function B(b, d, g) {
      for (var m in b) Object.hasOwnProperty.call(b, m) && d.call(g || b[m], b[m], m, b);
    }
    function t(b, d, g) {
      function m(d, m) {
        var L = b.removeEventListener || a.removeEventListenerPolyfill;
        L && L.call(b, d, m, !1);
      }
      function x(g) {
        var x;
        if (b.nodeName) {
          if (d) {
            var L = {};
            L[d] = !0;
          } else L = g;
          B(L, function (b, d) {
            if (g[d]) for (x = g[d].length; x--;) m(d, g[d][x].fn);
          });
        }
      }
      var D = "function" === typeof b && b.prototype || b;
      if (Object.hasOwnProperty.call(D, "hcEvents")) {
        var l = D.hcEvents;
        d ? (D = l[d] || [], g ? (l[d] = D.filter(function (b) {
          return g !== b.fn;
        }), m(d, g)) : (x(l), l[d] = [])) : (x(l), delete D.hcEvents);
      }
    }
    function J(b, d, g, l) {
      g = g || {};
      if (r.createEvent && (b.dispatchEvent || b.fireEvent && b !== a)) {
        var m = r.createEvent("Events");
        m.initEvent(d, !0, !0);
        g = c(m, g);
        b.dispatchEvent ? b.dispatchEvent(g) : b.fireEvent(d, g);
      } else if (b.hcEvents) {
        g.target || c(g, {
          preventDefault: function () {
            g.defaultPrevented = !0;
          },
          target: b,
          type: d
        });
        m = [];
        for (var x = b, D = !1; x.hcEvents;) Object.hasOwnProperty.call(x, "hcEvents") && x.hcEvents[d] && (m.length && (D = !0), m.unshift.apply(m, x.hcEvents[d])), x = Object.getPrototypeOf(x);
        D && m.sort(function (b, d) {
          return b.order - d.order;
        });
        m.forEach(function (d) {
          !1 === d.fn.call(b, g) && g.preventDefault();
        });
      }
      l && !g.defaultPrevented && l.call(b, g);
    }
    var C = a.charts,
      r = a.doc,
      l = a.win;
    (v || (v = {})).messages = [];
    Math.easeInOutSine = function (b) {
      return -.5 * (Math.cos(Math.PI * b) - 1);
    };
    var b = Array.prototype.find ? function (b, d) {
      return b.find(d);
    } : function (b, d) {
      var m,
        g = b.length;
      for (m = 0; m < g; m++) if (d(b[m], m)) return b[m];
    };
    B({
      map: "map",
      each: "forEach",
      grep: "filter",
      reduce: "reduce",
      some: "some"
    }, function (b, d) {
      a[d] = function (m) {
        var g;
        v(32, !1, void 0, (g = {}, g["Highcharts." + d] = "use Array." + b, g));
        return Array.prototype[b].apply(m, [].slice.call(arguments, 1));
      };
    });
    var g,
      d = function () {
        var b = Math.random().toString(36).substring(2, 9) + "-",
          d = 0;
        return function () {
          return "highcharts-" + (g ? "" : b) + d++;
        };
      }();
    l.jQuery && (l.jQuery.fn.highcharts = function () {
      var b = [].slice.call(arguments);
      if (this[0]) return b[0] ? (new a[y(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : C[e(this[0], "data-highcharts-chart")];
    });
    b = {
      addEvent: function (b, d, g, l) {
        void 0 === l && (l = {});
        var m = "function" === typeof b && b.prototype || b;
        Object.hasOwnProperty.call(m, "hcEvents") || (m.hcEvents = {});
        m = m.hcEvents;
        a.Point && b instanceof a.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
        var x = b.addEventListener || a.addEventListenerPolyfill;
        x && x.call(b, d, g, a.supportsPassiveEvents ? {
          passive: void 0 === l.passive ? -1 !== d.indexOf("touch") : l.passive,
          capture: !1
        } : !1);
        m[d] || (m[d] = []);
        m[d].push({
          fn: g,
          order: "number" === typeof l.order ? l.order : Infinity
        });
        m[d].sort(function (b, d) {
          return b.order - d.order;
        });
        return function () {
          t(b, d, g);
        };
      },
      arrayMax: function (b) {
        for (var d = b.length, m = b[0]; d--;) b[d] > m && (m = b[d]);
        return m;
      },
      arrayMin: function (b) {
        for (var d = b.length, m = b[0]; d--;) b[d] < m && (m = b[d]);
        return m;
      },
      attr: e,
      clamp: function (b, d, g) {
        return b > d ? b < g ? b : g : d;
      },
      cleanRecursively: z,
      clearTimeout: function (b) {
        k(b) && clearTimeout(b);
      },
      correctFloat: w,
      createElement: function (b, d, g, l, e) {
        b = r.createElement(b);
        d && c(b, d);
        e && f(b, {
          padding: "0",
          border: "none",
          margin: "0"
        });
        g && f(b, g);
        l && l.appendChild(b);
        return b;
      },
      css: f,
      defined: k,
      destroyObjectProperties: function (b, d) {
        B(b, function (m, g) {
          m && m !== d && m.destroy && m.destroy();
          delete b[g];
        });
      },
      discardElement: function (b) {
        b && b.parentElement && b.parentElement.removeChild(b);
      },
      erase: function (b, d) {
        for (var m = b.length; m--;) if (b[m] === d) {
          b.splice(m, 1);
          break;
        }
      },
      error: v,
      extend: c,
      extendClass: function (b, d) {
        var m = function () {};
        m.prototype = new b();
        c(m.prototype, d);
        return m;
      },
      find: b,
      fireEvent: J,
      getMagnitude: function (b) {
        return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
      },
      getNestedProperty: function (b, d) {
        for (b = b.split("."); b.length && k(d);) {
          var m = b.shift();
          if ("undefined" === typeof m || "__proto__" === m) return;
          d = d[m];
          if (!k(d) || "function" === typeof d || "number" === typeof d.nodeType || d === l) return;
        }
        return d;
      },
      getStyle: p,
      inArray: function (b, d, g) {
        v(32, !1, void 0, {
          "Highcharts.inArray": "use Array.indexOf"
        });
        return d.indexOf(b, g);
      },
      isArray: G,
      isClass: q,
      isDOMElement: A,
      isFunction: function (b) {
        return "function" === typeof b;
      },
      isNumber: n,
      isObject: H,
      isString: y,
      keys: function (b) {
        v(32, !1, void 0, {
          "Highcharts.keys": "use Object.keys"
        });
        return Object.keys(b);
      },
      merge: function () {
        var b,
          d = arguments,
          g = {},
          l = function (b, d) {
            "object" !== typeof b && (b = {});
            B(d, function (m, g) {
              "__proto__" !== g && "constructor" !== g && (!H(m, !0) || q(m) || A(m) ? b[g] = d[g] : b[g] = l(b[g] || {}, m));
            });
            return b;
          };
        !0 === d[0] && (g = d[1], d = Array.prototype.slice.call(d, 2));
        var c = d.length;
        for (b = 0; b < c; b++) g = l(g, d[b]);
        return g;
      },
      normalizeTickInterval: function (b, d, g, l, c) {
        var m = b;
        g = h(g, 1);
        var r = b / g;
        d || (d = c ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === l && (1 === g ? d = d.filter(function (b) {
          return 0 === b % 1;
        }) : .1 >= g && (d = [1 / g])));
        for (l = 0; l < d.length && !(m = d[l], c && m * g >= b || !c && r <= (d[l] + (d[l + 1] || d[l])) / 2); l++);
        return m = w(m * g, -Math.round(Math.log(.001) / Math.LN10));
      },
      objectEach: B,
      offset: function (b) {
        var d = r.documentElement;
        b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {
          top: 0,
          left: 0,
          width: 0,
          height: 0
        };
        return {
          top: b.top + (l.pageYOffset || d.scrollTop) - (d.clientTop || 0),
          left: b.left + (l.pageXOffset || d.scrollLeft) - (d.clientLeft || 0),
          width: b.width,
          height: b.height
        };
      },
      pad: function (b, d, g) {
        return Array((d || 2) + 1 - String(b).replace("-", "").length).join(g || "0") + b;
      },
      pick: h,
      pInt: F,
      relativeLength: function (b, d, g) {
        return /%$/.test(b) ? d * parseFloat(b) / 100 + (g || 0) : parseFloat(b);
      },
      removeEvent: t,
      splat: function (b) {
        return G(b) ? b : [b];
      },
      stableSort: function (b, d) {
        var g = b.length,
          m,
          l;
        for (l = 0; l < g; l++) b[l].safeI = l;
        b.sort(function (b, g) {
          m = d(b, g);
          return 0 === m ? b.safeI - g.safeI : m;
        });
        for (l = 0; l < g; l++) delete b[l].safeI;
      },
      syncTimeout: function (b, d, g) {
        if (0 < d) return setTimeout(b, d, g);
        b.call(0, g);
        return -1;
      },
      timeUnits: {
        millisecond: 1,
        second: 1E3,
        minute: 6E4,
        hour: 36E5,
        day: 864E5,
        week: 6048E5,
        month: 24192E5,
        year: 314496E5
      },
      uniqueKey: d,
      useSerialIds: function (b) {
        return g = h(b, g);
      },
      wrap: function (b, d, g) {
        var m = b[d];
        b[d] = function () {
          var b = Array.prototype.slice.call(arguments),
            d = arguments,
            l = this;
          l.proceed = function () {
            m.apply(l, arguments.length ? arguments : d);
          };
          b.unshift(m);
          b = g.apply(this, b);
          l.proceed = null;
          return b;
        };
      }
    };
    "";
    return b;
  });
  M(a, "Core/Chart/ChartDefaults.js", [], function () {
    return {
      panning: {
        enabled: !1,
        type: "x"
      },
      styledMode: !1,
      borderRadius: 0,
      colorCount: 10,
      defaultSeriesType: "line",
      ignoreHiddenSeries: !0,
      spacing: [10, 10, 15, 10],
      resetZoomButton: {
        theme: {
          zIndex: 6
        },
        position: {
          align: "right",
          x: -10,
          y: 10
        }
      },
      zoomBySingleTouch: !1,
      width: null,
      height: null,
      borderColor: "#335cad",
      backgroundColor: "#ffffff",
      plotBorderColor: "#cccccc"
    };
  });
  M(a, "Core/Color/Color.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, u) {
    var v = u.isNumber,
      F = u.merge,
      y = u.pInt;
    u = function () {
      function u(v) {
        this.rgba = [NaN, NaN, NaN, NaN];
        this.input = v;
        var A = a.Color;
        if (A && A !== u) return new A(v);
        if (!(this instanceof u)) return new u(v);
        this.init(v);
      }
      u.parse = function (a) {
        return a ? new u(a) : u.None;
      };
      u.prototype.init = function (a) {
        var A;
        if ("object" === typeof a && "undefined" !== typeof a.stops) this.stops = a.stops.map(function (e) {
          return new u(e[1]);
        });else if ("string" === typeof a) {
          this.input = a = u.names[a.toLowerCase()] || a;
          if ("#" === a.charAt(0)) {
            var q = a.length;
            var n = parseInt(a.substr(1), 16);
            7 === q ? A = [(n & 16711680) >> 16, (n & 65280) >> 8, n & 255, 1] : 4 === q && (A = [(n & 3840) >> 4 | (n & 3840) >> 8, (n & 240) >> 4 | n & 240, (n & 15) << 4 | n & 15, 1]);
          }
          if (!A) for (n = u.parsers.length; n-- && !A;) {
            var k = u.parsers[n];
            (q = k.regex.exec(a)) && (A = k.parse(q));
          }
        }
        A && (this.rgba = A);
      };
      u.prototype.get = function (a) {
        var A = this.input,
          q = this.rgba;
        if ("object" === typeof A && "undefined" !== typeof this.stops) {
          var n = F(A);
          n.stops = [].slice.call(n.stops);
          this.stops.forEach(function (k, e) {
            n.stops[e] = [n.stops[e][0], k.get(a)];
          });
          return n;
        }
        return q && v(q[0]) ? "rgb" === a || !a && 1 === q[3] ? "rgb(" + q[0] + "," + q[1] + "," + q[2] + ")" : "a" === a ? "" + q[3] : "rgba(" + q.join(",") + ")" : A;
      };
      u.prototype.brighten = function (a) {
        var A = this.rgba;
        if (this.stops) this.stops.forEach(function (n) {
          n.brighten(a);
        });else if (v(a) && 0 !== a) for (var q = 0; 3 > q; q++) A[q] += y(255 * a), 0 > A[q] && (A[q] = 0), 255 < A[q] && (A[q] = 255);
        return this;
      };
      u.prototype.setOpacity = function (a) {
        this.rgba[3] = a;
        return this;
      };
      u.prototype.tweenTo = function (a, A) {
        var q = this.rgba,
          n = a.rgba;
        if (!v(q[0]) || !v(n[0])) return a.input || "none";
        a = 1 !== n[3] || 1 !== q[3];
        return (a ? "rgba(" : "rgb(") + Math.round(n[0] + (q[0] - n[0]) * (1 - A)) + "," + Math.round(n[1] + (q[1] - n[1]) * (1 - A)) + "," + Math.round(n[2] + (q[2] - n[2]) * (1 - A)) + (a ? "," + (n[3] + (q[3] - n[3]) * (1 - A)) : "") + ")";
      };
      u.names = {
        white: "#ffffff",
        black: "#000000"
      };
      u.parsers = [{
        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        parse: function (a) {
          return [y(a[1]), y(a[2]), y(a[3]), parseFloat(a[4], 10)];
        }
      }, {
        regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
        parse: function (a) {
          return [y(a[1]), y(a[2]), y(a[3]), 1];
        }
      }];
      u.None = new u("");
      return u;
    }();
    "";
    return u;
  });
  M(a, "Core/Color/Palettes.js", [], function () {
    return {
      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ")
    };
  });
  M(a, "Core/Time.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, u) {
    var v = a.win,
      F = u.defined,
      y = u.error,
      G = u.extend,
      H = u.isObject,
      A = u.merge,
      q = u.objectEach,
      n = u.pad,
      k = u.pick,
      e = u.splat,
      c = u.timeUnits,
      h = a.isSafari && v.Intl && v.Intl.DateTimeFormat.prototype.formatRange,
      f = a.isSafari && v.Intl && !v.Intl.DateTimeFormat.prototype.formatRange;
    u = function () {
      function w(c) {
        this.options = {};
        this.variableTimezone = this.useUTC = !1;
        this.Date = v.Date;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.update(c);
      }
      w.prototype.get = function (c, e) {
        if (this.variableTimezone || this.timezoneOffset) {
          var p = e.getTime(),
            f = p - this.getTimezoneOffset(e);
          e.setTime(f);
          c = e["getUTC" + c]();
          e.setTime(p);
          return c;
        }
        return this.useUTC ? e["getUTC" + c]() : e["get" + c]();
      };
      w.prototype.set = function (c, e, f) {
        if (this.variableTimezone || this.timezoneOffset) {
          if ("Milliseconds" === c || "Seconds" === c || "Minutes" === c && 0 === this.getTimezoneOffset(e) % 36E5) return e["setUTC" + c](f);
          var p = this.getTimezoneOffset(e);
          p = e.getTime() - p;
          e.setTime(p);
          e["setUTC" + c](f);
          c = this.getTimezoneOffset(e);
          p = e.getTime() + c;
          return e.setTime(p);
        }
        return this.useUTC || h && "FullYear" === c ? e["setUTC" + c](f) : e["set" + c](f);
      };
      w.prototype.update = function (c) {
        var e = k(c && c.useUTC, !0);
        this.options = c = A(!0, this.options || {}, c);
        this.Date = c.Date || v.Date || Date;
        this.timezoneOffset = (this.useUTC = e) && c.timezoneOffset;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.variableTimezone = e && !(!c.getTimezoneOffset && !c.timezone);
      };
      w.prototype.makeTime = function (c, e, h, w, C, r) {
        if (this.useUTC) {
          var l = this.Date.UTC.apply(0, arguments);
          var b = this.getTimezoneOffset(l);
          l += b;
          var g = this.getTimezoneOffset(l);
          b !== g ? l += g - b : b - 36E5 !== this.getTimezoneOffset(l - 36E5) || f || (l -= 36E5);
        } else l = new this.Date(c, e, k(h, 1), k(w, 0), k(C, 0), k(r, 0)).getTime();
        return l;
      };
      w.prototype.timezoneOffsetFunction = function () {
        var c = this,
          e = this.options,
          f = e.getTimezoneOffset,
          h = e.moment || v.moment;
        if (!this.useUTC) return function (c) {
          return 6E4 * new Date(c.toString()).getTimezoneOffset();
        };
        if (e.timezone) {
          if (h) return function (c) {
            return 6E4 * -h.tz(c, e.timezone).utcOffset();
          };
          y(25);
        }
        return this.useUTC && f ? function (c) {
          return 6E4 * f(c.valueOf());
        } : function () {
          return 6E4 * (c.timezoneOffset || 0);
        };
      };
      w.prototype.dateFormat = function (c, e, f) {
        if (!F(e) || isNaN(e)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || "";
        c = k(c, "%Y-%m-%d %H:%M:%S");
        var p = this,
          h = new this.Date(e),
          r = this.get("Hours", h),
          l = this.get("Day", h),
          b = this.get("Date", h),
          g = this.get("Month", h),
          d = this.get("FullYear", h),
          m = a.defaultOptions.lang,
          D = m && m.weekdays,
          x = m && m.shortWeekdays;
        h = G({
          a: x ? x[l] : D[l].substr(0, 3),
          A: D[l],
          d: n(b),
          e: n(b, 2, " "),
          w: l,
          b: m.shortMonths[g],
          B: m.months[g],
          m: n(g + 1),
          o: g + 1,
          y: d.toString().substr(2, 2),
          Y: d,
          H: n(r),
          k: r,
          I: n(r % 12 || 12),
          l: r % 12 || 12,
          M: n(this.get("Minutes", h)),
          p: 12 > r ? "AM" : "PM",
          P: 12 > r ? "am" : "pm",
          S: n(h.getSeconds()),
          L: n(Math.floor(e % 1E3), 3)
        }, a.dateFormats);
        q(h, function (b, d) {
          for (; -1 !== c.indexOf("%" + d);) c = c.replace("%" + d, "function" === typeof b ? b.call(p, e) : b);
        });
        return f ? c.substr(0, 1).toUpperCase() + c.substr(1) : c;
      };
      w.prototype.resolveDTLFormat = function (c) {
        return H(c, !0) ? c : (c = e(c), {
          main: c[0],
          from: c[1],
          to: c[2]
        });
      };
      w.prototype.getTimeTicks = function (e, h, f, w) {
        var p = this,
          r = [],
          l = {},
          b = new p.Date(h),
          g = e.unitRange,
          d = e.count || 1,
          m;
        w = k(w, 1);
        if (F(h)) {
          p.set("Milliseconds", b, g >= c.second ? 0 : d * Math.floor(p.get("Milliseconds", b) / d));
          g >= c.second && p.set("Seconds", b, g >= c.minute ? 0 : d * Math.floor(p.get("Seconds", b) / d));
          g >= c.minute && p.set("Minutes", b, g >= c.hour ? 0 : d * Math.floor(p.get("Minutes", b) / d));
          g >= c.hour && p.set("Hours", b, g >= c.day ? 0 : d * Math.floor(p.get("Hours", b) / d));
          g >= c.day && p.set("Date", b, g >= c.month ? 1 : Math.max(1, d * Math.floor(p.get("Date", b) / d)));
          if (g >= c.month) {
            p.set("Month", b, g >= c.year ? 0 : d * Math.floor(p.get("Month", b) / d));
            var D = p.get("FullYear", b);
          }
          g >= c.year && p.set("FullYear", b, D - D % d);
          g === c.week && (D = p.get("Day", b), p.set("Date", b, p.get("Date", b) - D + w + (D < w ? -7 : 0)));
          D = p.get("FullYear", b);
          w = p.get("Month", b);
          var x = p.get("Date", b),
            t = p.get("Hours", b);
          h = b.getTime();
          !p.variableTimezone && p.useUTC || !F(f) || (m = f - h > 4 * c.month || p.getTimezoneOffset(h) !== p.getTimezoneOffset(f));
          h = b.getTime();
          for (b = 1; h < f;) r.push(h), h = g === c.year ? p.makeTime(D + b * d, 0) : g === c.month ? p.makeTime(D, w + b * d) : !m || g !== c.day && g !== c.week ? m && g === c.hour && 1 < d ? p.makeTime(D, w, x, t + b * d) : h + g * d : p.makeTime(D, w, x + b * d * (g === c.day ? 1 : 7)), b++;
          r.push(h);
          g <= c.hour && 1E4 > r.length && r.forEach(function (b) {
            0 === b % 18E5 && "000000000" === p.dateFormat("%H%M%S%L", b) && (l[b] = "day");
          });
        }
        r.info = G(e, {
          higherRanks: l,
          totalRange: g * d
        });
        return r;
      };
      w.prototype.getDateFormat = function (e, h, f, w) {
        var p = this.dateFormat("%m-%d %H:%M:%S.%L", h),
          r = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          },
          l = "millisecond";
        for (b in c) {
          if (e === c.week && +this.dateFormat("%w", h) === f && "00:00:00.000" === p.substr(6)) {
            var b = "week";
            break;
          }
          if (c[b] > e) {
            b = l;
            break;
          }
          if (r[b] && p.substr(r[b]) !== "01-01 00:00:00.000".substr(r[b])) break;
          "week" !== b && (l = b);
        }
        if (b) var g = this.resolveDTLFormat(w[b]).main;
        return g;
      };
      return w;
    }();
    "";
    return u;
  });
  M(a, "Core/DefaultOptions.js", [a["Core/Chart/ChartDefaults.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palettes.js"], a["Core/Time.js"], a["Core/Utilities.js"]], function (a, u, z, F, y, G) {
    u = u.parse;
    var v = G.merge,
      A = {
        colors: F.colors,
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
          loading: "Loading...",
          months: "January February March April May June July August September October November December".split(" "),
          shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
          weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
          decimalPoint: ".",
          numericSymbols: "kMGTPE".split(""),
          resetZoom: "Reset zoom",
          resetZoomTitle: "Reset zoom level 1:1",
          thousandsSep: " "
        },
        global: {},
        time: {
          Date: void 0,
          getTimezoneOffset: void 0,
          timezone: void 0,
          timezoneOffset: 0,
          useUTC: !0
        },
        chart: a,
        title: {
          text: "Chart title",
          align: "center",
          margin: 15,
          widthAdjust: -44
        },
        subtitle: {
          text: "",
          align: "center",
          widthAdjust: -44
        },
        caption: {
          margin: 15,
          text: "",
          align: "left",
          verticalAlign: "bottom"
        },
        plotOptions: {},
        labels: {
          style: {
            position: "absolute",
            color: "#333333"
          }
        },
        legend: {
          enabled: !0,
          align: "center",
          alignColumns: !0,
          className: "highcharts-no-tooltip",
          layout: "horizontal",
          labelFormatter: function () {
            return this.name;
          },
          borderColor: "#999999",
          borderRadius: 0,
          navigation: {
            activeColor: "#003399",
            inactiveColor: "#cccccc"
          },
          itemStyle: {
            color: "#333333",
            cursor: "pointer",
            fontSize: "12px",
            fontWeight: "bold",
            textOverflow: "ellipsis"
          },
          itemHoverStyle: {
            color: "#000000"
          },
          itemHiddenStyle: {
            color: "#cccccc"
          },
          shadow: !1,
          itemCheckboxStyle: {
            position: "absolute",
            width: "13px",
            height: "13px"
          },
          squareSymbol: !0,
          symbolPadding: 5,
          verticalAlign: "bottom",
          x: 0,
          y: 0,
          title: {
            style: {
              fontWeight: "bold"
            }
          }
        },
        loading: {
          labelStyle: {
            fontWeight: "bold",
            position: "relative",
            top: "45%"
          },
          style: {
            position: "absolute",
            backgroundColor: "#ffffff",
            opacity: .5,
            textAlign: "center"
          }
        },
        tooltip: {
          enabled: !0,
          animation: z.svg,
          borderRadius: 3,
          dateTimeLabelFormats: {
            millisecond: "%A, %b %e, %H:%M:%S.%L",
            second: "%A, %b %e, %H:%M:%S",
            minute: "%A, %b %e, %H:%M",
            hour: "%A, %b %e, %H:%M",
            day: "%A, %b %e, %Y",
            week: "Week from %A, %b %e, %Y",
            month: "%B %Y",
            year: "%Y"
          },
          footerFormat: "",
          headerShape: "callout",
          hideDelay: 500,
          padding: 8,
          shape: "callout",
          shared: !1,
          snap: z.isTouchDevice ? 25 : 10,
          headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
          pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
          backgroundColor: u("#f7f7f7").setOpacity(.85).get(),
          borderWidth: 1,
          shadow: !0,
          stickOnContact: !1,
          style: {
            color: "#333333",
            cursor: "default",
            fontSize: "12px",
            whiteSpace: "nowrap"
          },
          useHTML: !1
        },
        credits: {
          enabled: !0,
          href: "https://www.highcharts.com?credits",
          position: {
            align: "right",
            x: -10,
            verticalAlign: "bottom",
            y: -5
          },
          style: {
            cursor: "pointer",
            color: "#999999",
            fontSize: "9px"
          },
          text: "Highcharts.com"
        }
      };
    A.chart.styledMode = !1;
    "";
    var q = new y(v(A.global, A.time));
    a = {
      defaultOptions: A,
      defaultTime: q,
      getOptions: function () {
        return A;
      },
      setOptions: function (n) {
        v(!0, A, n);
        if (n.time || n.global) z.time ? z.time.update(v(A.global, A.time, n.global, n.time)) : z.time = q;
        return A;
      }
    };
    "";
    return a;
  });
  M(a, "Core/Animation/Fx.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = a.parse,
      y = u.win,
      G = z.isNumber,
      H = z.objectEach;
    return function () {
      function a(a, n, k) {
        this.pos = NaN;
        this.options = n;
        this.elem = a;
        this.prop = k;
      }
      a.prototype.dSetter = function () {
        var a = this.paths,
          n = a && a[0];
        a = a && a[1];
        var k = this.now || 0,
          e = [];
        if (1 !== k && n && a) {
          if (n.length === a.length && 1 > k) for (var c = 0; c < a.length; c++) {
            for (var h = n[c], f = a[c], w = [], p = 0; p < f.length; p++) {
              var B = h[p],
                t = f[p];
              G(B) && G(t) && ("A" !== f[0] || 4 !== p && 5 !== p) ? w[p] = B + k * (t - B) : w[p] = t;
            }
            e.push(w);
          } else e = a;
        } else e = this.toD || [];
        this.elem.attr("d", e, void 0, !0);
      };
      a.prototype.update = function () {
        var a = this.elem,
          n = this.prop,
          k = this.now,
          e = this.options.step;
        if (this[n + "Setter"]) this[n + "Setter"]();else a.attr ? a.element && a.attr(n, k, null, !0) : a.style[n] = k + this.unit;
        e && e.call(a, k, this);
      };
      a.prototype.run = function (q, n, k) {
        var e = this,
          c = e.options,
          h = function (c) {
            return h.stopped ? !1 : e.step(c);
          },
          f = y.requestAnimationFrame || function (c) {
            setTimeout(c, 13);
          },
          w = function () {
            for (var c = 0; c < a.timers.length; c++) a.timers[c]() || a.timers.splice(c--, 1);
            a.timers.length && f(w);
          };
        q !== n || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = q, this.end = n, this.unit = k, this.now = this.start, this.pos = 0, h.elem = this.elem, h.prop = this.prop, h() && 1 === a.timers.push(h) && f(w)) : (delete c.curAnim[this.prop], c.complete && 0 === Object.keys(c.curAnim).length && c.complete.call(this.elem));
      };
      a.prototype.step = function (a) {
        var n = +new Date(),
          k = this.options,
          e = this.elem,
          c = k.complete,
          h = k.duration,
          f = k.curAnim;
        if (e.attr && !e.element) a = !1;else if (a || n >= h + this.startTime) {
          this.now = this.end;
          this.pos = 1;
          this.update();
          var w = f[this.prop] = !0;
          H(f, function (c) {
            !0 !== c && (w = !1);
          });
          w && c && c.call(e);
          a = !1;
        } else this.pos = k.easing((n - this.startTime) / h), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a = !0;
        return a;
      };
      a.prototype.initPath = function (a, n, k) {
        function e(c, e) {
          for (; c.length < J;) {
            var l = c[0],
              b = e[J - c.length];
            b && "M" === l[0] && (c[0] = "C" === b[0] ? ["C", l[1], l[2], l[1], l[2], l[1], l[2]] : ["L", l[1], l[2]]);
            c.unshift(l);
            w && (l = c.pop(), c.push(c[c.length - 1], l));
          }
        }
        function c(c, e) {
          for (; c.length < J;) if (e = c[Math.floor(c.length / p) - 1].slice(), "C" === e[0] && (e[1] = e[5], e[2] = e[6]), w) {
            var l = c[Math.floor(c.length / p)].slice();
            c.splice(c.length / 2, 0, e, l);
          } else c.push(e);
        }
        var h = a.startX,
          f = a.endX;
        k = k.slice();
        var w = a.isArea,
          p = w ? 2 : 1;
        n = n && n.slice();
        if (!n) return [k, k];
        if (h && f && f.length) {
          for (a = 0; a < h.length; a++) if (h[a] === f[0]) {
            var B = a;
            break;
          } else if (h[0] === f[f.length - h.length + a]) {
            B = a;
            var t = !0;
            break;
          } else if (h[h.length - 1] === f[f.length - h.length + a]) {
            B = h.length - a;
            break;
          }
          "undefined" === typeof B && (n = []);
        }
        if (n.length && G(B)) {
          var J = k.length + B * p;
          t ? (e(n, k), c(k, n)) : (e(k, n), c(n, k));
        }
        return [n, k];
      };
      a.prototype.fillSetter = function () {
        a.prototype.strokeSetter.apply(this, arguments);
      };
      a.prototype.strokeSetter = function () {
        this.elem.attr(this.prop, v(this.start).tweenTo(v(this.end), this.pos), void 0, !0);
      };
      a.timers = [];
      return a;
    }();
  });
  M(a, "Core/Animation/AnimationUtilities.js", [a["Core/Animation/Fx.js"], a["Core/Utilities.js"]], function (a, u) {
    function v(c) {
      return q(c) ? n({
        duration: 500,
        defer: 0
      }, c) : {
        duration: c ? 500 : 0,
        defer: 0
      };
    }
    function F(c, e) {
      for (var h = a.timers.length; h--;) a.timers[h].elem !== c || e && e !== a.timers[h].prop || (a.timers[h].stopped = !0);
    }
    var y = u.defined,
      G = u.getStyle,
      H = u.isArray,
      A = u.isNumber,
      q = u.isObject,
      n = u.merge,
      k = u.objectEach,
      e = u.pick;
    return {
      animate: function (c, e, f) {
        var h,
          p = "",
          B,
          t;
        if (!q(f)) {
          var J = arguments;
          f = {
            duration: J[2],
            easing: J[3],
            complete: J[4]
          };
        }
        A(f.duration) || (f.duration = 400);
        f.easing = "function" === typeof f.easing ? f.easing : Math[f.easing] || Math.easeInOutSine;
        f.curAnim = n(e);
        k(e, function (k, r) {
          F(c, r);
          t = new a(c, f, r);
          B = void 0;
          "d" === r && H(e.d) ? (t.paths = t.initPath(c, c.pathArray, e.d), t.toD = e.d, h = 0, B = 1) : c.attr ? h = c.attr(r) : (h = parseFloat(G(c, r)) || 0, "opacity" !== r && (p = "px"));
          B || (B = k);
          "string" === typeof B && B.match("px") && (B = B.replace(/px/g, ""));
          t.run(h, B, p);
        });
      },
      animObject: v,
      getDeferredAnimation: function (c, e, f) {
        var h = v(e),
          p = 0,
          a = 0;
        (f ? [f] : c.series).forEach(function (c) {
          c = v(c.options.animation);
          p = e && y(e.defer) ? h.defer : Math.max(p, c.duration + c.defer);
          a = Math.min(h.duration, c.duration);
        });
        c.renderer.forExport && (p = 0);
        return {
          defer: Math.max(0, p - a),
          duration: Math.min(p, a)
        };
      },
      setAnimation: function (c, h) {
        h.renderer.globalAnimation = e(c, h.options.chart.animation, !0);
      },
      stop: F
    };
  });
  M(a, "Core/Renderer/HTML/AST.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, u) {
    var v = a.SVG_NS,
      F = u.attr,
      y = u.createElement,
      G = u.error,
      H = u.isFunction,
      A = u.isString,
      q = u.objectEach,
      n = u.splat,
      k = (u = a.win.trustedTypes) && H(u.createPolicy) && u.createPolicy("highcharts", {
        createHTML: function (c) {
          return c;
        }
      }),
      e = k ? k.createHTML("") : "";
    try {
      var c = !!new DOMParser().parseFromString(e, "text/html");
    } catch (h) {
      c = !1;
    }
    H = function () {
      function h(c) {
        this.nodes = "string" === typeof c ? this.parseMarkup(c) : c;
      }
      h.filterUserAttributes = function (c) {
        q(c, function (e, p) {
          var f = !0;
          -1 === h.allowedAttributes.indexOf(p) && (f = !1);
          -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(p) && (f = A(e) && h.allowedReferences.some(function (c) {
            return 0 === e.indexOf(c);
          }));
          f || (G("Highcharts warning: Invalid attribute '" + p + "' in config"), delete c[p]);
        });
        return c;
      };
      h.setElementHTML = function (c, e) {
        c.innerHTML = h.emptyHTML;
        e && new h(e).addToDOM(c);
      };
      h.prototype.addToDOM = function (c) {
        function e(c, f) {
          var p;
          n(c).forEach(function (c) {
            var t = c.tagName,
              r = c.textContent ? a.doc.createTextNode(c.textContent) : void 0;
            if (t) if ("#text" === t) var l = r;else if (-1 !== h.allowedTags.indexOf(t)) {
              t = a.doc.createElementNS("svg" === t ? v : f.namespaceURI || v, t);
              var b = c.attributes || {};
              q(c, function (c, d) {
                "tagName" !== d && "attributes" !== d && "children" !== d && "textContent" !== d && (b[d] = c);
              });
              F(t, h.filterUserAttributes(b));
              r && t.appendChild(r);
              e(c.children || [], t);
              l = t;
            } else G("Highcharts warning: Invalid tagName " + t + " in config");
            l && f.appendChild(l);
            p = l;
          });
          return p;
        }
        return e(this.nodes, c);
      };
      h.prototype.parseMarkup = function (e) {
        var h = [];
        e = e.trim();
        if (c) e = new DOMParser().parseFromString(k ? k.createHTML(e) : e, "text/html");else {
          var p = y("div");
          p.innerHTML = e;
          e = {
            body: p
          };
        }
        var f = function (c, e) {
          var h = c.nodeName.toLowerCase(),
            r = {
              tagName: h
            };
          "#text" === h && (r.textContent = c.textContent || "");
          if (h = c.attributes) {
            var l = {};
            [].forEach.call(h, function (b) {
              l[b.name] = b.value;
            });
            r.attributes = l;
          }
          if (c.childNodes.length) {
            var b = [];
            [].forEach.call(c.childNodes, function (c) {
              f(c, b);
            });
            b.length && (r.children = b);
          }
          e.push(r);
        };
        [].forEach.call(e.body.childNodes, function (c) {
          return f(c, h);
        });
        return h;
      };
      h.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex".split(" ");
      h.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
      h.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
      h.emptyHTML = e;
      return h;
    }();
    "";
    return H;
  });
  M(a, "Core/FormatUtilities.js", [a["Core/DefaultOptions.js"], a["Core/Utilities.js"]], function (a, u) {
    function v(a, k, e, c) {
      a = +a || 0;
      k = +k;
      var h = F.lang,
        f = (a.toString().split(".")[1] || "").split("e")[0].length,
        w = a.toString().split("e"),
        p = k;
      if (-1 === k) k = Math.min(f, 20);else if (!H(k)) k = 2;else if (k && w[1] && 0 > w[1]) {
        var B = k + +w[1];
        0 <= B ? (w[0] = (+w[0]).toExponential(B).split("e")[0], k = B) : (w[0] = w[0].split(".")[0] || 0, a = 20 > k ? (w[0] * Math.pow(10, w[1])).toFixed(k) : 0, w[1] = 0);
      }
      B = (Math.abs(w[1] ? w[0] : a) + Math.pow(10, -Math.max(k, f) - 1)).toFixed(k);
      f = String(q(B));
      var t = 3 < f.length ? f.length % 3 : 0;
      e = A(e, h.decimalPoint);
      c = A(c, h.thousandsSep);
      a = (0 > a ? "-" : "") + (t ? f.substr(0, t) + c : "");
      a = 0 > +w[1] && !p ? "0" : a + f.substr(t).replace(/(\d{3})(?=\d)/g, "$1" + c);
      k && (a += e + B.slice(-k));
      w[1] && 0 !== +a && (a += "e" + w[1]);
      return a;
    }
    var F = a.defaultOptions,
      y = a.defaultTime,
      G = u.getNestedProperty,
      H = u.isNumber,
      A = u.pick,
      q = u.pInt;
    return {
      dateFormat: function (a, k, e) {
        return y.dateFormat(a, k, e);
      },
      format: function (a, k, e) {
        var c = "{",
          h = !1,
          f = /f$/,
          w = /\.([0-9])/,
          p = F.lang,
          B = e && e.time || y;
        e = e && e.numberFormatter || v;
        for (var t = []; a;) {
          var J = a.indexOf(c);
          if (-1 === J) break;
          var C = a.slice(0, J);
          if (h) {
            C = C.split(":");
            c = G(C.shift() || "", k);
            if (C.length && "number" === typeof c) if (C = C.join(":"), f.test(C)) {
              var r = parseInt((C.match(w) || ["", "-1"])[1], 10);
              null !== c && (c = e(c, r, p.decimalPoint, -1 < C.indexOf(",") ? p.thousandsSep : ""));
            } else c = B.dateFormat(C, c);
            t.push(c);
          } else t.push(C);
          a = a.slice(J + 1);
          c = (h = !h) ? "}" : "{";
        }
        t.push(a);
        return t.join("");
      },
      numberFormat: v
    };
  });
  M(a, "Core/Renderer/RendererUtilities.js", [a["Core/Utilities.js"]], function (a) {
    var v = a.clamp,
      z = a.pick,
      F = a.stableSort,
      y;
    (function (a) {
      function u(a, q, n) {
        var k = a,
          e = k.reducedLen || q,
          c = function (c, e) {
            return (e.rank || 0) - (c.rank || 0);
          },
          h = function (c, e) {
            return c.target - e.target;
          },
          f,
          w = !0,
          p = [],
          B = 0;
        for (f = a.length; f--;) B += a[f].size;
        if (B > e) {
          F(a, c);
          for (B = f = 0; B <= e;) B += a[f].size, f++;
          p = a.splice(f - 1, a.length);
        }
        F(a, h);
        for (a = a.map(function (c) {
          return {
            size: c.size,
            targets: [c.target],
            align: z(c.align, .5)
          };
        }); w;) {
          for (f = a.length; f--;) e = a[f], c = (Math.min.apply(0, e.targets) + Math.max.apply(0, e.targets)) / 2, e.pos = v(c - e.size * e.align, 0, q - e.size);
          f = a.length;
          for (w = !1; f--;) 0 < f && a[f - 1].pos + a[f - 1].size > a[f].pos && (a[f - 1].size += a[f].size, a[f - 1].targets = a[f - 1].targets.concat(a[f].targets), a[f - 1].align = .5, a[f - 1].pos + a[f - 1].size > q && (a[f - 1].pos = q - a[f - 1].size), a.splice(f, 1), w = !0);
        }
        k.push.apply(k, p);
        f = 0;
        a.some(function (c) {
          var e = 0;
          return (c.targets || []).some(function () {
            k[f].pos = c.pos + e;
            if ("undefined" !== typeof n && Math.abs(k[f].pos - k[f].target) > n) return k.slice(0, f + 1).forEach(function (c) {
              return delete c.pos;
            }), k.reducedLen = (k.reducedLen || q) - .1 * q, k.reducedLen > .1 * q && u(k, q, n), !0;
            e += k[f].size;
            f++;
            return !1;
          });
        });
        F(k, h);
        return k;
      }
      a.distribute = u;
    })(y || (y = {}));
    return y;
  });
  M(a, "Core/Renderer/SVG/SVGElement.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Renderer/HTML/AST.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, u, z, F, y) {
    var v = a.animate,
      H = a.animObject,
      A = a.stop,
      q = F.deg2rad,
      n = F.doc,
      k = F.noop,
      e = F.svg,
      c = F.SVG_NS,
      h = F.win,
      f = y.addEvent,
      w = y.attr,
      p = y.createElement,
      B = y.css,
      t = y.defined,
      J = y.erase,
      C = y.extend,
      r = y.fireEvent,
      l = y.isArray,
      b = y.isFunction,
      g = y.isNumber,
      d = y.isString,
      m = y.merge,
      D = y.objectEach,
      x = y.pick,
      I = y.pInt,
      P = y.syncTimeout,
      S = y.uniqueKey;
    a = function () {
      function a() {
        this.element = void 0;
        this.onEvents = {};
        this.opacity = 1;
        this.renderer = void 0;
        this.SVG_NS = c;
        this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
      }
      a.prototype._defaultGetter = function (b) {
        b = x(this[b + "Value"], this[b], this.element ? this.element.getAttribute(b) : null, 0);
        /^[\-0-9\.]+$/.test(b) && (b = parseFloat(b));
        return b;
      };
      a.prototype._defaultSetter = function (b, d, c) {
        c.setAttribute(d, b);
      };
      a.prototype.add = function (b) {
        var d = this.renderer,
          c = this.element;
        b && (this.parentGroup = b);
        this.parentInverted = b && b.inverted;
        "undefined" !== typeof this.textStr && "text" === this.element.nodeName && d.buildText(this);
        this.added = !0;
        if (!b || b.handleZ || this.zIndex) var g = this.zIndexSetter();
        g || (b ? b.element : d.box).appendChild(c);
        if (this.onAdd) this.onAdd();
        return this;
      };
      a.prototype.addClass = function (b, d) {
        var c = d ? "" : this.attr("class") || "";
        b = (b || "").split(/ /g).reduce(function (b, d) {
          -1 === c.indexOf(d) && b.push(d);
          return b;
        }, c ? [c] : []).join(" ");
        b !== c && this.attr("class", b);
        return this;
      };
      a.prototype.afterSetters = function () {
        this.doTransform && (this.updateTransform(), this.doTransform = !1);
      };
      a.prototype.align = function (b, c, g) {
        var m = {},
          L = this.renderer,
          e = L.alignedObjects,
          l,
          a,
          E;
        if (b) {
          if (this.alignOptions = b, this.alignByTranslate = c, !g || d(g)) this.alignTo = l = g || "renderer", J(e, this), e.push(this), g = void 0;
        } else b = this.alignOptions, c = this.alignByTranslate, l = this.alignTo;
        g = x(g, L[l], "scrollablePlotBox" === l ? L.plotBox : void 0, L);
        l = b.align;
        var r = b.verticalAlign;
        L = (g.x || 0) + (b.x || 0);
        e = (g.y || 0) + (b.y || 0);
        "right" === l ? a = 1 : "center" === l && (a = 2);
        a && (L += (g.width - (b.width || 0)) / a);
        m[c ? "translateX" : "x"] = Math.round(L);
        "bottom" === r ? E = 1 : "middle" === r && (E = 2);
        E && (e += (g.height - (b.height || 0)) / E);
        m[c ? "translateY" : "y"] = Math.round(e);
        this[this.placed ? "animate" : "attr"](m);
        this.placed = !0;
        this.alignAttr = m;
        return this;
      };
      a.prototype.alignSetter = function (b) {
        var d = {
          left: "start",
          center: "middle",
          right: "end"
        };
        d[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", d[b]));
      };
      a.prototype.animate = function (b, d, c) {
        var g = this,
          m = H(x(d, this.renderer.globalAnimation, !0));
        d = m.defer;
        x(n.hidden, n.msHidden, n.webkitHidden, !1) && (m.duration = 0);
        0 !== m.duration ? (c && (m.complete = c), P(function () {
          g.element && v(g, b, m);
        }, d)) : (this.attr(b, void 0, c), D(b, function (b, d) {
          m.step && m.step.call(this, b, {
            prop: d,
            pos: 1,
            elem: this
          });
        }, this));
        return this;
      };
      a.prototype.applyTextOutline = function (b) {
        var d = this.element;
        -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(d.style.fill)));
        var g = b.split(" ");
        b = g[g.length - 1];
        if ((g = g[0]) && "none" !== g && F.svg) {
          this.fakeTS = !0;
          this.ySetter = this.xSetter;
          g = g.replace(/(^[\d\.]+)(.*?)$/g, function (b, d, c) {
            return 2 * Number(d) + c;
          });
          this.removeTextOutline();
          var m = n.createElementNS(c, "tspan");
          w(m, {
            "class": "highcharts-text-outline",
            fill: b,
            stroke: b,
            "stroke-width": g,
            "stroke-linejoin": "round"
          });
          [].forEach.call(d.childNodes, function (b) {
            var d = b.cloneNode(!0);
            d.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (b) {
              return d.removeAttribute(b);
            });
            m.appendChild(d);
          });
          var e = n.createElementNS(c, "tspan");
          e.textContent = "\u200b";
          ["x", "y"].forEach(function (b) {
            var c = d.getAttribute(b);
            c && e.setAttribute(b, c);
          });
          m.appendChild(e);
          d.insertBefore(m, d.firstChild);
        }
      };
      a.prototype.attr = function (b, d, c, g) {
        var m = this.element,
          e = this.symbolCustomAttribs,
          L,
          l = this,
          E,
          a;
        if ("string" === typeof b && "undefined" !== typeof d) {
          var K = b;
          b = {};
          b[K] = d;
        }
        "string" === typeof b ? l = (this[b + "Getter"] || this._defaultGetter).call(this, b, m) : (D(b, function (d, c) {
          E = !1;
          g || A(this, c);
          this.symbolName && -1 !== e.indexOf(c) && (L || (this.symbolAttr(b), L = !0), E = !0);
          !this.rotation || "x" !== c && "y" !== c || (this.doTransform = !0);
          E || (a = this[c + "Setter"] || this._defaultSetter, a.call(this, d, c, m), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(c) && this.updateShadows(c, d, a));
        }, this), this.afterSetters());
        c && c.call(this);
        return l;
      };
      a.prototype.clip = function (b) {
        return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
      };
      a.prototype.crisp = function (b, d) {
        d = d || b.strokeWidth || 0;
        var c = Math.round(d) % 2 / 2;
        b.x = Math.floor(b.x || this.x || 0) + c;
        b.y = Math.floor(b.y || this.y || 0) + c;
        b.width = Math.floor((b.width || this.width || 0) - 2 * c);
        b.height = Math.floor((b.height || this.height || 0) - 2 * c);
        t(b.strokeWidth) && (b.strokeWidth = d);
        return b;
      };
      a.prototype.complexColor = function (b, d, c) {
        var g = this.renderer,
          e,
          L,
          a,
          h,
          E,
          x,
          p,
          f,
          k,
          w,
          B = [],
          I;
        r(this.renderer, "complexColor", {
          args: arguments
        }, function () {
          b.radialGradient ? L = "radialGradient" : b.linearGradient && (L = "linearGradient");
          if (L) {
            a = b[L];
            E = g.gradients;
            x = b.stops;
            k = c.radialReference;
            l(a) && (b[L] = a = {
              x1: a[0],
              y1: a[1],
              x2: a[2],
              y2: a[3],
              gradientUnits: "userSpaceOnUse"
            });
            "radialGradient" === L && k && !t(a.gradientUnits) && (h = a, a = m(a, g.getRadialAttr(k, h), {
              gradientUnits: "userSpaceOnUse"
            }));
            D(a, function (b, d) {
              "id" !== d && B.push(d, b);
            });
            D(x, function (b) {
              B.push(b);
            });
            B = B.join(",");
            if (E[B]) w = E[B].attr("id");else {
              a.id = w = S();
              var K = E[B] = g.createElement(L).attr(a).add(g.defs);
              K.radAttr = h;
              K.stops = [];
              x.forEach(function (b) {
                0 === b[1].indexOf("rgba") ? (e = z.parse(b[1]), p = e.get("rgb"), f = e.get("a")) : (p = b[1], f = 1);
                b = g.createElement("stop").attr({
                  offset: b[0],
                  "stop-color": p,
                  "stop-opacity": f
                }).add(K);
                K.stops.push(b);
              });
            }
            I = "url(" + g.url + "#" + w + ")";
            c.setAttribute(d, I);
            c.gradient = B;
            b.toString = function () {
              return I;
            };
          }
        });
      };
      a.prototype.css = function (b) {
        var d = this.styles,
          c = {},
          g = this.element,
          m = ["textOutline", "textOverflow", "width"],
          a = "",
          l = !d;
        b && b.color && (b.fill = b.color);
        d && D(b, function (b, g) {
          d && d[g] !== b && (c[g] = b, l = !0);
        });
        if (l) {
          d && (b = C(d, c));
          if (b) if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === g.nodeName.toLowerCase() && b.width) var r = this.textWidth = I(b.width);
          this.styles = b;
          r && !e && this.renderer.forExport && delete b.width;
          if (g.namespaceURI === this.SVG_NS) {
            var E = function (b, d) {
              return "-" + d.toLowerCase();
            };
            D(b, function (b, d) {
              -1 === m.indexOf(d) && (a += d.replace(/([A-Z])/g, E) + ":" + b + ";");
            });
            a && w(g, "style", a);
          } else B(g, b);
          this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));
        }
        return this;
      };
      a.prototype.dashstyleSetter = function (b) {
        var d = this["stroke-width"];
        "inherit" === d && (d = 1);
        if (b = b && b.toLowerCase()) {
          var c = b.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
          for (b = c.length; b--;) c[b] = "" + I(c[b]) * x(d, NaN);
          b = c.join(",").replace(/NaN/g, "none");
          this.element.setAttribute("stroke-dasharray", b);
        }
      };
      a.prototype.destroy = function () {
        var b = this,
          d = b.element || {},
          c = b.renderer,
          g = d.ownerSVGElement,
          m = c.isSVG && "SPAN" === d.nodeName && b.parentGroup || void 0;
        d.onclick = d.onmouseout = d.onmouseover = d.onmousemove = d.point = null;
        A(b);
        if (b.clipPath && g) {
          var e = b.clipPath;
          [].forEach.call(g.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
            -1 < b.getAttribute("clip-path").indexOf(e.element.id) && b.removeAttribute("clip-path");
          });
          b.clipPath = e.destroy();
        }
        if (b.stops) {
          for (g = 0; g < b.stops.length; g++) b.stops[g].destroy();
          b.stops.length = 0;
          b.stops = void 0;
        }
        b.safeRemoveChild(d);
        for (c.styledMode || b.destroyShadows(); m && m.div && 0 === m.div.childNodes.length;) d = m.parentGroup, b.safeRemoveChild(m.div), delete m.div, m = d;
        b.alignTo && J(c.alignedObjects, b);
        D(b, function (d, c) {
          b[c] && b[c].parentGroup === b && b[c].destroy && b[c].destroy();
          delete b[c];
        });
      };
      a.prototype.destroyShadows = function () {
        (this.shadows || []).forEach(function (b) {
          this.safeRemoveChild(b);
        }, this);
        this.shadows = void 0;
      };
      a.prototype.destroyTextPath = function (b, d) {
        var c = b.getElementsByTagName("text")[0];
        if (c) {
          if (c.removeAttribute("dx"), c.removeAttribute("dy"), d.element.setAttribute("id", ""), this.textPathWrapper && c.getElementsByTagName("textPath").length) {
            for (b = this.textPathWrapper.element.childNodes; b.length;) c.appendChild(b[0]);
            c.removeChild(this.textPathWrapper.element);
          }
        } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");
        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
      };
      a.prototype.dSetter = function (b, d, c) {
        l(b) && ("string" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, d, c) {
          return d && d.join ? (c ? b + " " : "") + d.join(" ") : (d || "").toString();
        }, ""));
        /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
        this[d] !== b && (c.setAttribute(d, b), this[d] = b);
      };
      a.prototype.fadeOut = function (b) {
        var d = this;
        d.animate({
          opacity: 0
        }, {
          duration: x(b, 150),
          complete: function () {
            d.attr({
              y: -9999
            }).hide();
          }
        });
      };
      a.prototype.fillSetter = function (b, d, c) {
        "string" === typeof b ? c.setAttribute(d, b) : b && this.complexColor(b, d, c);
      };
      a.prototype.getBBox = function (d, c) {
        var g = this.renderer,
          m = this.element,
          e = this.styles,
          l = this.textStr,
          r = g.cache,
          h = g.cacheKeys,
          E = m.namespaceURI === this.SVG_NS;
        c = x(c, this.rotation, 0);
        var p = g.styledMode ? m && a.prototype.getStyle.call(m, "font-size") : e && e.fontSize,
          f;
        if (t(l)) {
          var D = l.toString();
          -1 === D.indexOf("<") && (D = D.replace(/[0-9]/g, "0"));
          D += ["", c, p, this.textWidth, e && e.textOverflow, e && e.fontWeight].join();
        }
        D && !d && (f = r[D]);
        if (!f) {
          if (E || g.forExport) {
            try {
              var k = this.fakeTS && function (b) {
                var d = m.querySelector(".highcharts-text-outline");
                d && B(d, {
                  display: b
                });
              };
              b(k) && k("none");
              f = m.getBBox ? C({}, m.getBBox()) : {
                width: m.offsetWidth,
                height: m.offsetHeight
              };
              b(k) && k("");
            } catch (X) {
              "";
            }
            if (!f || 0 > f.width) f = {
              width: 0,
              height: 0
            };
          } else f = this.htmlGetBBox();
          g.isSVG && (d = f.width, g = f.height, E && (f.height = g = {
            "11px,17": 14,
            "13px,20": 16
          }[(p || "") + "," + Math.round(g)] || g), c && (E = c * q, f.width = Math.abs(g * Math.sin(E)) + Math.abs(d * Math.cos(E)), f.height = Math.abs(g * Math.cos(E)) + Math.abs(d * Math.sin(E))));
          if (D && ("" === l || 0 < f.height)) {
            for (; 250 < h.length;) delete r[h.shift()];
            r[D] || h.push(D);
            r[D] = f;
          }
        }
        return f;
      };
      a.prototype.getStyle = function (b) {
        return h.getComputedStyle(this.element || this, "").getPropertyValue(b);
      };
      a.prototype.hasClass = function (b) {
        return -1 !== ("" + this.attr("class")).split(" ").indexOf(b);
      };
      a.prototype.hide = function (b) {
        b ? this.attr({
          y: -9999
        }) : this.attr({
          visibility: "hidden"
        });
        return this;
      };
      a.prototype.htmlGetBBox = function () {
        return {
          height: 0,
          width: 0,
          x: 0,
          y: 0
        };
      };
      a.prototype.init = function (b, d) {
        this.element = "span" === d ? p(d) : n.createElementNS(this.SVG_NS, d);
        this.renderer = b;
        r(this, "afterInit");
      };
      a.prototype.invert = function (b) {
        this.inverted = b;
        this.updateTransform();
        return this;
      };
      a.prototype.on = function (b, d) {
        var c = this.onEvents;
        if (c[b]) c[b]();
        c[b] = f(this.element, b, d);
        return this;
      };
      a.prototype.opacitySetter = function (b, d, c) {
        this.opacity = b = Number(Number(b).toFixed(3));
        c.setAttribute(d, b);
      };
      a.prototype.removeClass = function (b) {
        return this.attr("class", ("" + this.attr("class")).replace(d(b) ? new RegExp("(^| )" + b + "( |$)") : b, " ").replace(/ +/g, " ").trim());
      };
      a.prototype.removeTextOutline = function () {
        var b = this.element.querySelector("tspan.highcharts-text-outline");
        b && this.safeRemoveChild(b);
      };
      a.prototype.safeRemoveChild = function (b) {
        var d = b.parentNode;
        d && d.removeChild(b);
      };
      a.prototype.setRadialReference = function (b) {
        var d = this.element.gradient && this.renderer.gradients[this.element.gradient];
        this.element.radialReference = b;
        d && d.radAttr && d.animate(this.renderer.getRadialAttr(b, d.radAttr));
        return this;
      };
      a.prototype.setTextPath = function (b, d) {
        var c = this.element,
          e = this.text ? this.text.element : c,
          a = {
            textAnchor: "text-anchor"
          },
          l = !1,
          r = this.textPathWrapper,
          x = !r;
        d = m(!0, {
          enabled: !0,
          attributes: {
            dy: -5,
            startOffset: "50%",
            textAnchor: "middle"
          }
        }, d);
        var E = u.filterUserAttributes(d.attributes);
        if (b && d && d.enabled) {
          r && null === r.element.parentNode ? (x = !0, r = r.destroy()) : r && this.removeTextOutline.call(r.parentGroup);
          this.options && this.options.padding && (E.dx = -this.options.padding);
          r || (this.textPathWrapper = r = this.renderer.createElement("textPath"), l = !0);
          var p = r.element;
          (d = b.element.getAttribute("id")) || b.element.setAttribute("id", d = S());
          if (x) for (e.setAttribute("y", 0), g(E.dx) && e.setAttribute("x", -E.dx), b = [].slice.call(e.childNodes), x = 0; x < b.length; x++) {
            var f = b[x];
            f.nodeType !== h.Node.TEXT_NODE && "tspan" !== f.nodeName || p.appendChild(f);
          }
          l && r && r.add({
            element: e
          });
          p.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + d);
          t(E.dy) && (p.parentNode.setAttribute("dy", E.dy), delete E.dy);
          t(E.dx) && (p.parentNode.setAttribute("dx", E.dx), delete E.dx);
          D(E, function (b, d) {
            p.setAttribute(a[d] || d, b);
          });
          c.removeAttribute("transform");
          this.removeTextOutline.call(r);
          this.text && !this.renderer.styledMode && this.attr({
            fill: "none",
            "stroke-width": 0
          });
          this.applyTextOutline = this.updateTransform = k;
        } else r && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(c, b), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));
        return this;
      };
      a.prototype.shadow = function (b, d, c) {
        var g = [],
          m = this.element,
          e = this.oldShadowOptions,
          a = {
            color: "#000000",
            offsetX: this.parentInverted ? -1 : 1,
            offsetY: this.parentInverted ? -1 : 1,
            opacity: .15,
            width: 3
          },
          l = !1,
          E;
        !0 === b ? E = a : "object" === typeof b && (E = C(a, b));
        E && (E && e && D(E, function (b, d) {
          b !== e[d] && (l = !0);
        }), l && this.destroyShadows(), this.oldShadowOptions = E);
        if (!E) this.destroyShadows();else if (!this.shadows) {
          var L = E.opacity / E.width;
          var r = this.parentInverted ? "translate(" + E.offsetY + ", " + E.offsetX + ")" : "translate(" + E.offsetX + ", " + E.offsetY + ")";
          for (a = 1; a <= E.width; a++) {
            var h = m.cloneNode(!1);
            var x = 2 * E.width + 1 - 2 * a;
            w(h, {
              stroke: b.color || "#000000",
              "stroke-opacity": L * a,
              "stroke-width": x,
              transform: r,
              fill: "none"
            });
            h.setAttribute("class", (h.getAttribute("class") || "") + " highcharts-shadow");
            c && (w(h, "height", Math.max(w(h, "height") - x, 0)), h.cutHeight = x);
            d ? d.element.appendChild(h) : m.parentNode && m.parentNode.insertBefore(h, m);
            g.push(h);
          }
          this.shadows = g;
        }
        return this;
      };
      a.prototype.show = function (b) {
        return this.attr({
          visibility: b ? "inherit" : "visible"
        });
      };
      a.prototype.strokeSetter = function (b, d, c) {
        this[d] = b;
        this.stroke && this["stroke-width"] ? (a.prototype.fillSetter.call(this, this.stroke, "stroke", c), c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === d && 0 === b && this.hasStroke ? (c.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
      };
      a.prototype.strokeWidth = function () {
        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
        var b = this.getStyle("stroke-width"),
          d = 0;
        if (b.indexOf("px") === b.length - 2) d = I(b);else if ("" !== b) {
          var g = n.createElementNS(c, "rect");
          w(g, {
            width: b,
            "stroke-width": 0
          });
          this.element.parentNode.appendChild(g);
          d = g.getBBox().width;
          g.parentNode.removeChild(g);
        }
        return d;
      };
      a.prototype.symbolAttr = function (b) {
        var d = this;
        "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (c) {
          d[c] = x(b[c], d[c]);
        });
        d.attr({
          d: d.renderer.symbols[d.symbolName](d.x, d.y, d.width, d.height, d)
        });
      };
      a.prototype.textSetter = function (b) {
        b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
      };
      a.prototype.titleSetter = function (b) {
        var d = this.element,
          c = d.getElementsByTagName("title")[0] || n.createElementNS(this.SVG_NS, "title");
        d.insertBefore ? d.insertBefore(c, d.firstChild) : d.appendChild(c);
        c.textContent = String(x(b, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
      };
      a.prototype.toFront = function () {
        var b = this.element;
        b.parentNode.appendChild(b);
        return this;
      };
      a.prototype.translate = function (b, d) {
        return this.attr({
          translateX: b,
          translateY: d
        });
      };
      a.prototype.updateShadows = function (b, d, c) {
        var g = this.shadows;
        if (g) for (var m = g.length; m--;) c.call(g[m], "height" === b ? Math.max(d - (g[m].cutHeight || 0), 0) : "d" === b ? this.d : d, b, g[m]);
      };
      a.prototype.updateTransform = function () {
        var b = this.scaleX,
          d = this.scaleY,
          c = this.inverted,
          g = this.rotation,
          m = this.matrix,
          e = this.element,
          a = this.translateX || 0,
          l = this.translateY || 0;
        c && (a += this.width, l += this.height);
        a = ["translate(" + a + "," + l + ")"];
        t(m) && a.push("matrix(" + m.join(",") + ")");
        c ? a.push("rotate(90) scale(-1,1)") : g && a.push("rotate(" + g + " " + x(this.rotationOriginX, e.getAttribute("x"), 0) + " " + x(this.rotationOriginY, e.getAttribute("y") || 0) + ")");
        (t(b) || t(d)) && a.push("scale(" + x(b, 1) + " " + x(d, 1) + ")");
        a.length && e.setAttribute("transform", a.join(" "));
      };
      a.prototype.visibilitySetter = function (b, d, c) {
        "inherit" === b ? c.removeAttribute(d) : this[d] !== b && c.setAttribute(d, b);
        this[d] = b;
      };
      a.prototype.xGetter = function (b) {
        "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
        return this._defaultGetter(b);
      };
      a.prototype.zIndexSetter = function (b, d) {
        var c = this.renderer,
          g = this.parentGroup,
          m = (g || c).element || c.box,
          e = this.element;
        c = m === c.box;
        var a = !1;
        var l = this.added;
        var E;
        t(b) ? (e.setAttribute("data-z-index", b), b = +b, this[d] === b && (l = !1)) : t(this[d]) && e.removeAttribute("data-z-index");
        this[d] = b;
        if (l) {
          (b = this.zIndex) && g && (g.handleZ = !0);
          d = m.childNodes;
          for (E = d.length - 1; 0 <= E && !a; E--) {
            g = d[E];
            l = g.getAttribute("data-z-index");
            var r = !t(l);
            if (g !== e) if (0 > b && r && !c && !E) m.insertBefore(e, d[E]), a = !0;else if (I(l) <= b || r && (!t(b) || 0 <= b)) m.insertBefore(e, d[E + 1] || null), a = !0;
          }
          a || (m.insertBefore(e, d[c ? 3 : 0] || null), a = !0);
        }
        return a;
      };
      return a;
    }();
    a.prototype["stroke-widthSetter"] = a.prototype.strokeSetter;
    a.prototype.yGetter = a.prototype.xGetter;
    a.prototype.matrixSetter = a.prototype.rotationOriginXSetter = a.prototype.rotationOriginYSetter = a.prototype.rotationSetter = a.prototype.scaleXSetter = a.prototype.scaleYSetter = a.prototype.translateXSetter = a.prototype.translateYSetter = a.prototype.verticalAlignSetter = function (b, d) {
      this[d] = b;
      this.doTransform = !0;
    };
    "";
    return a;
  });
  M(a, "Core/Renderer/RendererRegistry.js", [a["Core/Globals.js"]], function (a) {
    var v;
    (function (v) {
      v.rendererTypes = {};
      var u;
      v.getRendererType = function (a) {
        void 0 === a && (a = u);
        return v.rendererTypes[a] || v.rendererTypes[u];
      };
      v.registerRendererType = function (y, z, H) {
        v.rendererTypes[y] = z;
        if (!u || H) u = y, a.Renderer = z;
      };
    })(v || (v = {}));
    return v;
  });
  M(a, "Core/Renderer/SVG/SVGLabel.js", [a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, u) {
    var v = this && this.__extends || function () {
        var a = function (k, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (c, e) {
            c.__proto__ = e;
          } || function (c, e) {
            for (var a in e) e.hasOwnProperty(a) && (c[a] = e[a]);
          };
          return a(k, e);
        };
        return function (k, e) {
          function c() {
            this.constructor = k;
          }
          a(k, e);
          k.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());
        };
      }(),
      F = u.defined,
      y = u.extend,
      G = u.isNumber,
      H = u.merge,
      A = u.pick,
      q = u.removeEvent;
    return function (n) {
      function k(e, c, a, f, w, p, B, t, J, C) {
        var r = n.call(this) || this;
        r.paddingLeftSetter = r.paddingSetter;
        r.paddingRightSetter = r.paddingSetter;
        r.init(e, "g");
        r.textStr = c;
        r.x = a;
        r.y = f;
        r.anchorX = p;
        r.anchorY = B;
        r.baseline = J;
        r.className = C;
        r.addClass("button" === C ? "highcharts-no-tooltip" : "highcharts-label");
        C && r.addClass("highcharts-" + C);
        r.text = e.text(void 0, 0, 0, t).attr({
          zIndex: 1
        });
        var l;
        "string" === typeof w && ((l = /^url\((.*?)\)$/.test(w)) || r.renderer.symbols[w]) && (r.symbolKey = w);
        r.bBox = k.emptyBBox;
        r.padding = 3;
        r.baselineOffset = 0;
        r.needsBox = e.styledMode || l;
        r.deferredAttr = {};
        r.alignFactor = 0;
        return r;
      }
      v(k, n);
      k.prototype.alignSetter = function (e) {
        e = {
          left: 0,
          center: .5,
          right: 1
        }[e];
        e !== this.alignFactor && (this.alignFactor = e, this.bBox && G(this.xSetting) && this.attr({
          x: this.xSetting
        }));
      };
      k.prototype.anchorXSetter = function (e, c) {
        this.anchorX = e;
        this.boxAttr(c, Math.round(e) - this.getCrispAdjust() - this.xSetting);
      };
      k.prototype.anchorYSetter = function (e, c) {
        this.anchorY = e;
        this.boxAttr(c, e - this.ySetting);
      };
      k.prototype.boxAttr = function (e, c) {
        this.box ? this.box.attr(e, c) : this.deferredAttr[e] = c;
      };
      k.prototype.css = function (e) {
        if (e) {
          var c = {};
          e = H(e);
          k.textProps.forEach(function (a) {
            "undefined" !== typeof e[a] && (c[a] = e[a], delete e[a]);
          });
          this.text.css(c);
          var h = ("width" in c);
          "fontSize" in c || "fontWeight" in c ? this.updateTextPadding() : h && this.updateBoxSize();
        }
        return a.prototype.css.call(this, e);
      };
      k.prototype.destroy = function () {
        q(this.element, "mouseenter");
        q(this.element, "mouseleave");
        this.text && this.text.destroy();
        this.box && (this.box = this.box.destroy());
        a.prototype.destroy.call(this);
      };
      k.prototype.fillSetter = function (e, c) {
        e && (this.needsBox = !0);
        this.fill = e;
        this.boxAttr(c, e);
      };
      k.prototype.getBBox = function () {
        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
        var e = this.padding,
          c = A(this.paddingLeft, e);
        return {
          width: this.width,
          height: this.height,
          x: this.bBox.x - c,
          y: this.bBox.y - e
        };
      };
      k.prototype.getCrispAdjust = function () {
        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
      };
      k.prototype.heightSetter = function (e) {
        this.heightSetting = e;
      };
      k.prototype.onAdd = function () {
        var e = this.textStr;
        this.text.add(this);
        this.attr({
          text: F(e) ? e : "",
          x: this.x,
          y: this.y
        });
        this.box && F(this.anchorX) && this.attr({
          anchorX: this.anchorX,
          anchorY: this.anchorY
        });
      };
      k.prototype.paddingSetter = function (e, c) {
        G(e) ? e !== this[c] && (this[c] = e, this.updateTextPadding()) : this[c] = void 0;
      };
      k.prototype.rSetter = function (e, c) {
        this.boxAttr(c, e);
      };
      k.prototype.shadow = function (e) {
        e && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(e));
        return this;
      };
      k.prototype.strokeSetter = function (e, c) {
        this.stroke = e;
        this.boxAttr(c, e);
      };
      k.prototype["stroke-widthSetter"] = function (e, c) {
        e && (this.needsBox = !0);
        this["stroke-width"] = e;
        this.boxAttr(c, e);
      };
      k.prototype["text-alignSetter"] = function (e) {
        this.textAlign = e;
      };
      k.prototype.textSetter = function (e) {
        "undefined" !== typeof e && this.text.attr({
          text: e
        });
        this.updateTextPadding();
      };
      k.prototype.updateBoxSize = function () {
        var e = this.text.element.style,
          c = {},
          a = this.padding,
          f = this.bBox = G(this.widthSetting) && G(this.heightSetting) && !this.textAlign || !F(this.text.textStr) ? k.emptyBBox : this.text.getBBox();
        this.width = this.getPaddedWidth();
        this.height = (this.heightSetting || f.height || 0) + 2 * a;
        e = this.renderer.fontMetrics(e && e.fontSize, this.text);
        this.baselineOffset = a + Math.min((this.text.firstLineMetrics || e).b, f.height || Infinity);
        this.heightSetting && (this.baselineOffset += (this.heightSetting - e.h) / 2);
        this.needsBox && (this.box || (a = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), a.add(this)), a = this.getCrispAdjust(), c.x = a, c.y = (this.baseline ? -this.baselineOffset : 0) + a, c.width = Math.round(this.width), c.height = Math.round(this.height), this.box.attr(y(c, this.deferredAttr)), this.deferredAttr = {});
      };
      k.prototype.updateTextPadding = function () {
        var a = this.text;
        this.updateBoxSize();
        var c = this.baseline ? 0 : this.baselineOffset,
          h = A(this.paddingLeft, this.padding);
        F(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (h += {
          center: .5,
          right: 1
        }[this.textAlign] * (this.widthSetting - this.bBox.width));
        if (h !== a.x || c !== a.y) a.attr("x", h), a.hasBoxWidthChanged && (this.bBox = a.getBBox(!0)), "undefined" !== typeof c && a.attr("y", c);
        a.x = h;
        a.y = c;
      };
      k.prototype.widthSetter = function (a) {
        this.widthSetting = G(a) ? a : void 0;
      };
      k.prototype.getPaddedWidth = function () {
        var a = this.padding,
          c = A(this.paddingLeft, a);
        a = A(this.paddingRight, a);
        return (this.widthSetting || this.bBox.width || 0) + c + a;
      };
      k.prototype.xSetter = function (a) {
        this.x = a;
        this.alignFactor && (a -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
        this.xSetting = Math.round(a);
        this.attr("translateX", this.xSetting);
      };
      k.prototype.ySetter = function (a) {
        this.ySetting = this.y = Math.round(a);
        this.attr("translateY", this.ySetting);
      };
      k.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      };
      k.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
      return k;
    }(a);
  });
  M(a, "Core/Renderer/SVG/Symbols.js", [a["Core/Utilities.js"]], function (a) {
    function v(a, q, n, k, e) {
      var c = [];
      if (e) {
        var h = e.start || 0,
          f = H(e.r, n);
        n = H(e.r, k || n);
        var w = (e.end || 0) - .001;
        k = e.innerR;
        var p = H(e.open, .001 > Math.abs((e.end || 0) - h - 2 * Math.PI)),
          B = Math.cos(h),
          t = Math.sin(h),
          J = Math.cos(w),
          C = Math.sin(w);
        h = H(e.longArc, .001 > w - h - Math.PI ? 0 : 1);
        c.push(["M", a + f * B, q + n * t], ["A", f, n, 0, h, H(e.clockwise, 1), a + f * J, q + n * C]);
        y(k) && c.push(p ? ["M", a + k * J, q + k * C] : ["L", a + k * J, q + k * C], ["A", k, k, 0, h, y(e.clockwise) ? 1 - e.clockwise : 0, a + k * B, q + k * t]);
        p || c.push(["Z"]);
      }
      return c;
    }
    function z(a, q, n, k, e) {
      return e && e.r ? F(a, q, n, k, e) : [["M", a, q], ["L", a + n, q], ["L", a + n, q + k], ["L", a, q + k], ["Z"]];
    }
    function F(a, q, n, k, e) {
      e = e && e.r || 0;
      return [["M", a + e, q], ["L", a + n - e, q], ["C", a + n, q, a + n, q, a + n, q + e], ["L", a + n, q + k - e], ["C", a + n, q + k, a + n, q + k, a + n - e, q + k], ["L", a + e, q + k], ["C", a, q + k, a, q + k, a, q + k - e], ["L", a, q + e], ["C", a, q, a, q, a + e, q]];
    }
    var y = a.defined,
      G = a.isNumber,
      H = a.pick;
    return {
      arc: v,
      callout: function (a, q, n, k, e) {
        var c = Math.min(e && e.r || 0, n, k),
          h = c + 6,
          f = e && e.anchorX;
        e = e && e.anchorY || 0;
        var w = F(a, q, n, k, {
          r: c
        });
        if (!G(f)) return w;
        a + f >= n ? e > q + h && e < q + k - h ? w.splice(3, 1, ["L", a + n, e - 6], ["L", a + n + 6, e], ["L", a + n, e + 6], ["L", a + n, q + k - c]) : w.splice(3, 1, ["L", a + n, k / 2], ["L", f, e], ["L", a + n, k / 2], ["L", a + n, q + k - c]) : 0 >= a + f ? e > q + h && e < q + k - h ? w.splice(7, 1, ["L", a, e + 6], ["L", a - 6, e], ["L", a, e - 6], ["L", a, q + c]) : w.splice(7, 1, ["L", a, k / 2], ["L", f, e], ["L", a, k / 2], ["L", a, q + c]) : e && e > k && f > a + h && f < a + n - h ? w.splice(5, 1, ["L", f + 6, q + k], ["L", f, q + k + 6], ["L", f - 6, q + k], ["L", a + c, q + k]) : e && 0 > e && f > a + h && f < a + n - h && w.splice(1, 1, ["L", f - 6, q], ["L", f, q - 6], ["L", f + 6, q], ["L", n - c, q]);
        return w;
      },
      circle: function (a, q, n, k) {
        return v(a + n / 2, q + k / 2, n / 2, k / 2, {
          start: .5 * Math.PI,
          end: 2.5 * Math.PI,
          open: !1
        });
      },
      diamond: function (a, q, n, k) {
        return [["M", a + n / 2, q], ["L", a + n, q + k / 2], ["L", a + n / 2, q + k], ["L", a, q + k / 2], ["Z"]];
      },
      rect: z,
      roundedRect: F,
      square: z,
      triangle: function (a, q, n, k) {
        return [["M", a + n / 2, q], ["L", a + n, q + k], ["L", a, q + k], ["Z"]];
      },
      "triangle-down": function (a, q, n, k) {
        return [["M", a, q], ["L", a + n, q], ["L", a + n / 2, q + k], ["Z"]];
      }
    };
  });
  M(a, "Core/Renderer/SVG/TextBuilder.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = u.doc,
      y = u.SVG_NS,
      G = u.win,
      H = z.attr,
      A = z.isString,
      q = z.objectEach,
      n = z.pick;
    return function () {
      function k(a) {
        var c = a.styles;
        this.renderer = a.renderer;
        this.svgElement = a;
        this.width = a.textWidth;
        this.textLineHeight = c && c.lineHeight;
        this.textOutline = c && c.textOutline;
        this.ellipsis = !(!c || "ellipsis" !== c.textOverflow);
        this.noWrap = !(!c || "nowrap" !== c.whiteSpace);
        this.fontSize = c && c.fontSize;
      }
      k.prototype.buildSVG = function () {
        var e = this.svgElement,
          c = e.element,
          h = e.renderer,
          f = n(e.textStr, "").toString(),
          k = -1 !== f.indexOf("<"),
          p = c.childNodes;
        h = this.width && !e.added && h.box;
        var B = /<br.*?>/g,
          t = [f, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();
        if (t !== e.textCache) {
          e.textCache = t;
          delete e.actualWidth;
          for (t = p.length; t--;) c.removeChild(p[t]);
          k || this.ellipsis || this.width || -1 !== f.indexOf(" ") && (!this.noWrap || B.test(f)) ? "" !== f && (h && h.appendChild(c), f = new a(f), this.modifyTree(f.nodes), f.addToDOM(e.element), this.modifyDOM(), this.ellipsis && -1 !== (c.textContent || "").indexOf("\u2026") && e.attr("title", this.unescapeEntities(e.textStr || "", ["&lt;", "&gt;"])), h && h.removeChild(c)) : c.appendChild(v.createTextNode(this.unescapeEntities(f)));
          A(this.textOutline) && e.applyTextOutline && e.applyTextOutline(this.textOutline);
        }
      };
      k.prototype.modifyDOM = function () {
        var a = this,
          c = this.svgElement,
          h = H(c.element, "x");
        c.firstLineMetrics = void 0;
        for (var f; f = c.element.firstChild;) if (/^[\s\u200B]*$/.test(f.textContent || " ")) c.element.removeChild(f);else break;
        [].forEach.call(c.element.querySelectorAll("tspan.highcharts-br"), function (e, p) {
          e.nextSibling && e.previousSibling && (0 === p && 1 === e.previousSibling.nodeType && (c.firstLineMetrics = c.renderer.fontMetrics(void 0, e.previousSibling)), H(e, {
            dy: a.getLineHeight(e.nextSibling),
            x: h
          }));
        });
        var k = this.width || 0;
        if (k) {
          var p = function (e, p) {
              var f = e.textContent || "",
                r = f.replace(/([^\^])-/g, "$1- ").split(" "),
                l = !a.noWrap && (1 < r.length || 1 < c.element.childNodes.length),
                b = a.getLineHeight(p),
                g = 0,
                d = c.actualWidth;
              if (a.ellipsis) f && a.truncate(e, f, void 0, 0, Math.max(0, k - parseInt(a.fontSize || 12, 10)), function (b, d) {
                return b.substring(0, d) + "\u2026";
              });else if (l) {
                f = [];
                for (l = []; p.firstChild && p.firstChild !== e;) l.push(p.firstChild), p.removeChild(p.firstChild);
                for (; r.length;) r.length && !a.noWrap && 0 < g && (f.push(e.textContent || ""), e.textContent = r.join(" ").replace(/- /g, "-")), a.truncate(e, void 0, r, 0 === g ? d || 0 : 0, k, function (b, d) {
                  return r.slice(0, d).join(" ").replace(/- /g, "-");
                }), d = c.actualWidth, g++;
                l.forEach(function (b) {
                  p.insertBefore(b, e);
                });
                f.forEach(function (d) {
                  p.insertBefore(v.createTextNode(d), e);
                  d = v.createElementNS(y, "tspan");
                  d.textContent = "\u200b";
                  H(d, {
                    dy: b,
                    x: h
                  });
                  p.insertBefore(d, e);
                });
              }
            },
            B = function (a) {
              [].slice.call(a.childNodes).forEach(function (e) {
                e.nodeType === G.Node.TEXT_NODE ? p(e, a) : (-1 !== e.className.baseVal.indexOf("highcharts-br") && (c.actualWidth = 0), B(e));
              });
            };
          B(c.element);
        }
      };
      k.prototype.getLineHeight = function (a) {
        var c;
        a = a.nodeType === G.Node.TEXT_NODE ? a.parentElement : a;
        this.renderer.styledMode || (c = a && /(px|em)$/.test(a.style.fontSize) ? a.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(c, a || this.svgElement.element).h;
      };
      k.prototype.modifyTree = function (a) {
        var c = this,
          e = function (h, k) {
            var p = h.attributes;
            p = void 0 === p ? {} : p;
            var f = h.children,
              t = h.tagName,
              w = c.renderer.styledMode;
            if ("b" === t || "strong" === t) w ? p["class"] = "highcharts-strong" : p.style = "font-weight:bold;" + (p.style || "");else if ("i" === t || "em" === t) w ? p["class"] = "highcharts-emphasized" : p.style = "font-style:italic;" + (p.style || "");
            A(p.style) && (p.style = p.style.replace(/(;| |^)color([ :])/, "$1fill$2"));
            "br" === t ? (p["class"] = "highcharts-br", h.textContent = "\u200b", (k = a[k + 1]) && k.textContent && (k.textContent = k.textContent.replace(/^ +/gm, ""))) : "a" === t && f && f.some(function (c) {
              return "#text" === c.tagName;
            }) && (h.children = [{
              children: f,
              tagName: "tspan"
            }]);
            "#text" !== t && "a" !== t && (h.tagName = "tspan");
            h.attributes = p;
            f && f.filter(function (c) {
              return "#text" !== c.tagName;
            }).forEach(e);
          };
        a.forEach(e);
      };
      k.prototype.truncate = function (a, c, h, f, k, p) {
        var e = this.svgElement,
          t = e.renderer,
          w = e.rotation,
          n = [],
          r = h ? 1 : 0,
          l = (c || h || "").length,
          b = l,
          g,
          d = function (b, d) {
            d = d || b;
            var g = a.parentNode;
            if (g && "undefined" === typeof n[d]) if (g.getSubStringLength) try {
              n[d] = f + g.getSubStringLength(0, h ? d + 1 : d);
            } catch (P) {
              "";
            } else t.getSpanWidth && (a.textContent = p(c || h, b), n[d] = f + t.getSpanWidth(e, a));
            return n[d];
          };
        e.rotation = 0;
        var m = d(a.textContent.length);
        if (f + m > k) {
          for (; r <= l;) b = Math.ceil((r + l) / 2), h && (g = p(h, b)), m = d(b, g && g.length - 1), r === l ? r = l + 1 : m > k ? l = b - 1 : r = b;
          0 === l ? a.textContent = "" : c && l === c.length - 1 || (a.textContent = g || p(c || h, b));
        }
        h && h.splice(0, b);
        e.actualWidth = m;
        e.rotation = w;
      };
      k.prototype.unescapeEntities = function (a, c) {
        q(this.renderer.escapes, function (e, f) {
          c && -1 !== c.indexOf(e) || (a = a.toString().replace(new RegExp(e, "g"), f));
        });
        return a;
      };
      return k;
    }();
  });
  M(a, "Core/Renderer/SVG/SVGRenderer.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGLabel.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Renderer/SVG/TextBuilder.js"], a["Core/Utilities.js"]], function (a, u, z, F, y, G, H, A, q) {
    var n = z.charts,
      k = z.deg2rad,
      e = z.doc,
      c = z.isFirefox,
      h = z.isMS,
      f = z.isWebKit,
      w = z.noop,
      p = z.SVG_NS,
      B = z.symbolSizes,
      t = z.win,
      J = q.addEvent,
      C = q.attr,
      r = q.createElement,
      l = q.css,
      b = q.defined,
      g = q.destroyObjectProperties,
      d = q.extend,
      m = q.isArray,
      D = q.isNumber,
      x = q.isObject,
      I = q.isString,
      P = q.merge,
      v = q.pick,
      O = q.pInt,
      U = q.uniqueKey,
      Y;
    z = function () {
      function L(b, d, a, c, g, m, e) {
        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
        this.init(b, d, a, c, g, m, e);
      }
      L.prototype.init = function (b, d, a, g, m, E, L) {
        var r = this.createElement("svg").attr({
            version: "1.1",
            "class": "highcharts-root"
          }),
          K = r.element;
        L || r.css(this.getStyle(g));
        b.appendChild(K);
        C(b, "dir", "ltr");
        -1 === b.innerHTML.indexOf("xmlns") && C(K, "xmlns", this.SVG_NS);
        this.isSVG = !0;
        this.box = K;
        this.boxWrapper = r;
        this.alignedObjects = [];
        this.url = this.getReferenceURL();
        this.createElement("desc").add().element.appendChild(e.createTextNode("Created with Highcharts 9.3.3"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = E;
        this.forExport = m;
        this.styledMode = L;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(d, a, !1);
        var p;
        c && b.getBoundingClientRect && (d = function () {
          l(b, {
            left: 0,
            top: 0
          });
          p = b.getBoundingClientRect();
          l(b, {
            left: Math.ceil(p.left) - p.left + "px",
            top: Math.ceil(p.top) - p.top + "px"
          });
        }, d(), this.unSubPixelFix = J(t, "resize", d));
      };
      L.prototype.definition = function (b) {
        return new a([b]).addToDOM(this.defs.element);
      };
      L.prototype.getReferenceURL = function () {
        if ((c || f) && e.getElementsByTagName("base").length) {
          if (!b(Y)) {
            var d = U();
            d = new a([{
              tagName: "svg",
              attributes: {
                width: 8,
                height: 8
              },
              children: [{
                tagName: "defs",
                children: [{
                  tagName: "clipPath",
                  attributes: {
                    id: d
                  },
                  children: [{
                    tagName: "rect",
                    attributes: {
                      width: 4,
                      height: 4
                    }
                  }]
                }]
              }, {
                tagName: "rect",
                attributes: {
                  id: "hitme",
                  width: 8,
                  height: 8,
                  "clip-path": "url(#" + d + ")",
                  fill: "rgba(0,0,0,0.001)"
                }
              }]
            }]).addToDOM(e.body);
            l(d, {
              position: "fixed",
              top: 0,
              left: 0,
              zIndex: 9E5
            });
            var g = e.elementFromPoint(6, 6);
            Y = "hitme" === (g && g.id);
            e.body.removeChild(d);
          }
          if (Y) return t.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
        }
        return "";
      };
      L.prototype.getStyle = function (b) {
        return this.style = d({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: "12px"
        }, b);
      };
      L.prototype.setStyle = function (b) {
        this.boxWrapper.css(this.getStyle(b));
      };
      L.prototype.isHidden = function () {
        return !this.boxWrapper.getBBox().width;
      };
      L.prototype.destroy = function () {
        var b = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        g(this.gradients || {});
        this.gradients = null;
        b && (this.defs = b.destroy());
        this.unSubPixelFix && this.unSubPixelFix();
        return this.alignedObjects = null;
      };
      L.prototype.createElement = function (b) {
        var d = new this.Element();
        d.init(this, b);
        return d;
      };
      L.prototype.getRadialAttr = function (b, d) {
        return {
          cx: b[0] - b[2] / 2 + (d.cx || 0) * b[2],
          cy: b[1] - b[2] / 2 + (d.cy || 0) * b[2],
          r: (d.r || 0) * b[2]
        };
      };
      L.prototype.buildText = function (b) {
        new A(b).buildSVG();
      };
      L.prototype.getContrast = function (b) {
        b = u.parse(b).rgba;
        b[0] *= 1;
        b[1] *= 1.2;
        b[2] *= .5;
        return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
      };
      L.prototype.button = function (b, c, g, m, e, l, L, r, p, x) {
        var E = this.label(b, c, g, p, void 0, void 0, x, void 0, "button"),
          f = this.styledMode,
          K = 0,
          D = e ? P(e) : {};
        b = D && D.style || {};
        D = a.filterUserAttributes(D);
        E.attr(P({
          padding: 8,
          r: 2
        }, D));
        if (!f) {
          D = P({
            fill: "#f7f7f7",
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontWeight: "normal"
            }
          }, {
            style: b
          }, D);
          var k = D.style;
          delete D.style;
          l = P(D, {
            fill: "#e6e6e6"
          }, a.filterUserAttributes(l || {}));
          var N = l.style;
          delete l.style;
          L = P(D, {
            fill: "#e6ebf5",
            style: {
              color: "#000000",
              fontWeight: "bold"
            }
          }, a.filterUserAttributes(L || {}));
          var w = L.style;
          delete L.style;
          r = P(D, {
            style: {
              color: "#cccccc"
            }
          }, a.filterUserAttributes(r || {}));
          var t = r.style;
          delete r.style;
        }
        J(E.element, h ? "mouseover" : "mouseenter", function () {
          3 !== K && E.setState(1);
        });
        J(E.element, h ? "mouseout" : "mouseleave", function () {
          3 !== K && E.setState(K);
        });
        E.setState = function (b) {
          1 !== b && (E.state = K = b);
          E.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
          f || E.attr([D, l, L, r][b || 0]).css([k, N, w, t][b || 0]);
        };
        f || E.attr(D).css(d({
          cursor: "default"
        }, k));
        return E.on("touchstart", function (b) {
          return b.stopPropagation();
        }).on("click", function (b) {
          3 !== K && m.call(E, b);
        });
      };
      L.prototype.crispLine = function (d, a, c) {
        void 0 === c && (c = "round");
        var g = d[0],
          m = d[1];
        b(g[1]) && g[1] === m[1] && (g[1] = m[1] = Math[c](g[1]) - a % 2 / 2);
        b(g[2]) && g[2] === m[2] && (g[2] = m[2] = Math[c](g[2]) + a % 2 / 2);
        return d;
      };
      L.prototype.path = function (b) {
        var a = this.styledMode ? {} : {
          fill: "none"
        };
        m(b) ? a.d = b : x(b) && d(a, b);
        return this.createElement("path").attr(a);
      };
      L.prototype.circle = function (b, d, a) {
        b = x(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: d,
          r: a
        };
        d = this.createElement("circle");
        d.xSetter = d.ySetter = function (b, d, a) {
          a.setAttribute("c" + d, b);
        };
        return d.attr(b);
      };
      L.prototype.arc = function (b, d, a, c, g, m) {
        x(b) ? (c = b, d = c.y, a = c.r, b = c.x) : c = {
          innerR: c,
          start: g,
          end: m
        };
        b = this.symbol("arc", b, d, a, a, c);
        b.r = a;
        return b;
      };
      L.prototype.rect = function (b, d, a, c, g, m) {
        g = x(b) ? b.r : g;
        var e = this.createElement("rect");
        b = x(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: d,
          width: Math.max(a, 0),
          height: Math.max(c, 0)
        };
        this.styledMode || ("undefined" !== typeof m && (b["stroke-width"] = m, b = e.crisp(b)), b.fill = "none");
        g && (b.r = g);
        e.rSetter = function (b, d, a) {
          e.r = b;
          C(a, {
            rx: b,
            ry: b
          });
        };
        e.rGetter = function () {
          return e.r || 0;
        };
        return e.attr(b);
      };
      L.prototype.setSize = function (b, d, a) {
        this.width = b;
        this.height = d;
        this.boxWrapper.animate({
          width: b,
          height: d
        }, {
          step: function () {
            this.attr({
              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
            });
          },
          duration: v(a, !0) ? void 0 : 0
        });
        this.alignElements();
      };
      L.prototype.g = function (b) {
        var d = this.createElement("g");
        return b ? d.attr({
          "class": "highcharts-" + b
        }) : d;
      };
      L.prototype.image = function (b, d, a, c, g, m) {
        var e = {
            preserveAspectRatio: "none"
          },
          l = function (b, d) {
            b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", d) : b.setAttribute("hc-svg-href", d);
          };
        D(d) && (e.x = d);
        D(a) && (e.y = a);
        D(c) && (e.width = c);
        D(g) && (e.height = g);
        var E = this.createElement("image").attr(e);
        d = function (d) {
          l(E.element, b);
          m.call(E, d);
        };
        m ? (l(E.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), a = new t.Image(), J(a, "load", d), a.src = b, a.complete && d({})) : l(E.element, b);
        return E;
      };
      L.prototype.symbol = function (a, c, g, m, L, E) {
        var p = this,
          h = /^url\((.*?)\)$/,
          x = h.test(a),
          f = !x && (this.symbols[a] ? a : "circle"),
          D = f && this.symbols[f],
          k;
        if (D) {
          "number" === typeof c && (k = D.call(this.symbols, Math.round(c || 0), Math.round(g || 0), m || 0, L || 0, E));
          var K = this.path(k);
          p.styledMode || K.attr("fill", "none");
          d(K, {
            symbolName: f || void 0,
            x: c,
            y: g,
            width: m,
            height: L
          });
          E && d(K, E);
        } else if (x) {
          var w = a.match(h)[1];
          var t = K = this.image(w);
          t.imgwidth = v(B[w] && B[w].width, E && E.width);
          t.imgheight = v(B[w] && B[w].height, E && E.height);
          var I = function (b) {
            return b.attr({
              width: b.width,
              height: b.height
            });
          };
          ["width", "height"].forEach(function (d) {
            t[d + "Setter"] = function (d, a) {
              var c = this["img" + a];
              this[a] = d;
              b(c) && (E && "within" === E.backgroundSize && this.width && this.height && (c = Math.round(c * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(a, c), this.alignByTranslate || (d = ((this[a] || 0) - c) / 2, this.attr("width" === a ? {
                translateX: d
              } : {
                translateY: d
              })));
            };
          });
          b(c) && t.attr({
            x: c,
            y: g
          });
          t.isImg = !0;
          b(t.imgwidth) && b(t.imgheight) ? I(t) : (t.attr({
            width: 0,
            height: 0
          }), r("img", {
            onload: function () {
              var b = n[p.chartIndex];
              0 === this.width && (l(this, {
                position: "absolute",
                top: "-999em"
              }), e.body.appendChild(this));
              B[w] = {
                width: this.width,
                height: this.height
              };
              t.imgwidth = this.width;
              t.imgheight = this.height;
              t.element && I(t);
              this.parentNode && this.parentNode.removeChild(this);
              p.imgCount--;
              if (!p.imgCount && b && !b.hasLoaded) b.onload();
            },
            src: w
          }), this.imgCount++);
        }
        return K;
      };
      L.prototype.clipRect = function (b, d, a, c) {
        var g = U() + "-",
          m = this.createElement("clipPath").attr({
            id: g
          }).add(this.defs);
        b = this.rect(b, d, a, c, 0).add(m);
        b.id = g;
        b.clipPath = m;
        b.count = 0;
        return b;
      };
      L.prototype.text = function (d, a, c, g) {
        var m = {};
        if (g && (this.allowHTML || !this.forExport)) return this.html(d, a, c);
        m.x = Math.round(a || 0);
        c && (m.y = Math.round(c));
        b(d) && (m.text = d);
        d = this.createElement("text").attr(m);
        if (!g || this.forExport && !this.allowHTML) d.xSetter = function (b, d, a) {
          for (var c = a.getElementsByTagName("tspan"), g = a.getAttribute(d), m = 0, e; m < c.length; m++) e = c[m], e.getAttribute(d) === g && e.setAttribute(d, b);
          a.setAttribute(d, b);
        };
        return d;
      };
      L.prototype.fontMetrics = function (b, d) {
        b = !this.styledMode && /px/.test(b) || !t.getComputedStyle ? b || d && d.style && d.style.fontSize || this.style && this.style.fontSize : d && y.prototype.getStyle.call(d, "font-size");
        b = /px/.test(b) ? O(b) : 12;
        d = 24 > b ? b + 3 : Math.round(1.2 * b);
        return {
          h: d,
          b: Math.round(.8 * d),
          f: b
        };
      };
      L.prototype.rotCorr = function (b, d, a) {
        var c = b;
        d && a && (c = Math.max(c * Math.cos(d * k), 4));
        return {
          x: -b / 3 * Math.sin(d * k),
          y: c
        };
      };
      L.prototype.pathToSegments = function (b) {
        for (var d = [], a = [], c = {
            A: 8,
            C: 7,
            H: 2,
            L: 3,
            M: 3,
            Q: 5,
            S: 5,
            T: 3,
            V: 2
          }, g = 0; g < b.length; g++) I(a[0]) && D(b[g]) && a.length === c[a[0].toUpperCase()] && b.splice(g, 0, a[0].replace("M", "L").replace("m", "l")), "string" === typeof b[g] && (a.length && d.push(a.slice(0)), a.length = 0), a.push(b[g]);
        d.push(a.slice(0));
        return d;
      };
      L.prototype.label = function (b, d, a, c, g, m, e, l, L) {
        return new G(this, b, d, a, c, g, m, e, l, L);
      };
      L.prototype.alignElements = function () {
        this.alignedObjects.forEach(function (b) {
          return b.align();
        });
      };
      return L;
    }();
    d(z.prototype, {
      Element: y,
      SVG_NS: p,
      escapes: {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      },
      symbols: H,
      draw: w
    });
    F.registerRendererType("svg", z, !0);
    "";
    return z;
  });
  M(a, "Core/Renderer/HTML/HTMLElement.js", [a["Core/Globals.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = this && this.__extends || function () {
        var a = function (c, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
          };
          return a(c, e);
        };
        return function (c, e) {
          function p() {
            this.constructor = c;
          }
          a(c, e);
          c.prototype = null === e ? Object.create(e) : (p.prototype = e.prototype, new p());
        };
      }(),
      y = a.isFirefox,
      G = a.isMS,
      H = a.isWebKit,
      A = a.win,
      q = z.css,
      n = z.defined,
      k = z.extend,
      e = z.pick,
      c = z.pInt;
    return function (a) {
      function h() {
        return null !== a && a.apply(this, arguments) || this;
      }
      v(h, a);
      h.compose = function (a) {
        if (-1 === h.composedClasses.indexOf(a)) {
          h.composedClasses.push(a);
          var c = h.prototype,
            e = a.prototype;
          e.getSpanCorrection = c.getSpanCorrection;
          e.htmlCss = c.htmlCss;
          e.htmlGetBBox = c.htmlGetBBox;
          e.htmlUpdateTransform = c.htmlUpdateTransform;
          e.setSpanRotation = c.setSpanRotation;
        }
        return a;
      };
      h.prototype.getSpanCorrection = function (a, c, e) {
        this.xCorr = -a * e;
        this.yCorr = -c;
      };
      h.prototype.htmlCss = function (a) {
        var c = "SPAN" === this.element.tagName && a && "width" in a,
          h = e(c && a.width, void 0);
        if (c) {
          delete a.width;
          this.textWidth = h;
          var f = !0;
        }
        a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
        this.styles = k(this.styles, a);
        q(this.element, a);
        f && this.htmlUpdateTransform();
        return this;
      };
      h.prototype.htmlGetBBox = function () {
        var a = this.element;
        return {
          x: a.offsetLeft,
          y: a.offsetTop,
          width: a.offsetWidth,
          height: a.offsetHeight
        };
      };
      h.prototype.htmlUpdateTransform = function () {
        if (this.added) {
          var a = this.renderer,
            e = this.element,
            h = this.translateX || 0,
            f = this.translateY || 0,
            k = this.x || 0,
            C = this.y || 0,
            r = this.textAlign || "left",
            l = {
              left: 0,
              center: .5,
              right: 1
            }[r],
            b = this.styles;
          b = b && b.whiteSpace;
          q(e, {
            marginLeft: h,
            marginTop: f
          });
          !a.styledMode && this.shadows && this.shadows.forEach(function (b) {
            q(b, {
              marginLeft: h + 1,
              marginTop: f + 1
            });
          });
          this.inverted && [].forEach.call(e.childNodes, function (b) {
            a.invertChild(b, e);
          });
          if ("SPAN" === e.tagName) {
            var g = this.rotation,
              d = this.textWidth && c(this.textWidth),
              m = [g, r, e.innerHTML, this.textWidth, this.textAlign].join(),
              D = void 0;
            D = !1;
            if (d !== this.oldTextWidth) {
              if (this.textPxLength) var x = this.textPxLength;else q(e, {
                width: "",
                whiteSpace: b || "nowrap"
              }), x = e.offsetWidth;
              (d > this.oldTextWidth || x > d) && (/[ \-]/.test(e.textContent || e.innerText) || "ellipsis" === e.style.textOverflow) && (q(e, {
                width: x > d || g ? d + "px" : "auto",
                display: "block",
                whiteSpace: b || "normal"
              }), this.oldTextWidth = d, D = !0);
            }
            this.hasBoxWidthChanged = D;
            m !== this.cTT && (D = a.fontMetrics(e.style.fontSize, e).b, !n(g) || g === (this.oldRotation || 0) && r === this.oldAlign || this.setSpanRotation(g, l, D), this.getSpanCorrection(!n(g) && this.textPxLength || e.offsetWidth, D, l, g, r));
            q(e, {
              left: k + (this.xCorr || 0) + "px",
              top: C + (this.yCorr || 0) + "px"
            });
            this.cTT = m;
            this.oldRotation = g;
            this.oldAlign = r;
          }
        } else this.alignOnAdd = !0;
      };
      h.prototype.setSpanRotation = function (a, c, e) {
        var h = {},
          p = G && !/Edge/.test(A.navigator.userAgent) ? "-ms-transform" : H ? "-webkit-transform" : y ? "MozTransform" : A.opera ? "-o-transform" : void 0;
        p && (h[p] = h.transform = "rotate(" + a + "deg)", h[p + (y ? "Origin" : "-origin")] = h.transformOrigin = 100 * c + "% " + e + "px", q(this.element, h));
      };
      h.composedClasses = [];
      return h;
    }(u);
  });
  M(a, "Core/Renderer/HTML/HTMLRenderer.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function (a, u, z, F) {
    var v = this && this.__extends || function () {
        var a = function (k, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, e) {
            a.__proto__ = e;
          } || function (a, e) {
            for (var c in e) e.hasOwnProperty(c) && (a[c] = e[c]);
          };
          return a(k, e);
        };
        return function (k, e) {
          function c() {
            this.constructor = k;
          }
          a(k, e);
          k.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());
        };
      }(),
      G = F.attr,
      H = F.createElement,
      A = F.extend,
      q = F.pick;
    return function (n) {
      function k() {
        return null !== n && n.apply(this, arguments) || this;
      }
      v(k, n);
      k.compose = function (a) {
        -1 === k.composedClasses.indexOf(a) && (k.composedClasses.push(a), a.prototype.html = k.prototype.html);
        return a;
      };
      k.prototype.html = function (e, c, h) {
        var f = this.createElement("span"),
          k = f.element,
          p = f.renderer,
          n = p.isSVG,
          t = function (a, c) {
            ["opacity", "visibility"].forEach(function (e) {
              a[e + "Setter"] = function (l, b, g) {
                var d = a.div ? a.div.style : c;
                u.prototype[e + "Setter"].call(this, l, b, g);
                d && (d[b] = l);
              };
            });
            a.addedSetters = !0;
          };
        f.textSetter = function (c) {
          c !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, q(c, "")), this.textStr = c, f.doTransform = !0);
        };
        n && t(f, f.element.style);
        f.xSetter = f.ySetter = f.alignSetter = f.rotationSetter = function (a, c) {
          "align" === c ? f.alignValue = f.textAlign = a : f[c] = a;
          f.doTransform = !0;
        };
        f.afterSetters = function () {
          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
        };
        f.attr({
          text: e,
          x: Math.round(c),
          y: Math.round(h)
        }).css({
          position: "absolute"
        });
        p.styledMode || f.css({
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize
        });
        k.style.whiteSpace = "nowrap";
        f.css = f.htmlCss;
        n && (f.add = function (a) {
          var c = p.box.parentNode,
            e = [];
          if (this.parentGroup = a) {
            var l = a.div;
            if (!l) {
              for (; a;) e.push(a), a = a.parentGroup;
              e.reverse().forEach(function (b) {
                function a(d, a) {
                  b[a] = d;
                  "translateX" === a ? r.left = d + "px" : r.top = d + "px";
                  b.doTransform = !0;
                }
                var d = G(b.element, "class"),
                  m = b.styles || {};
                l = b.div = b.div || H("div", d ? {
                  className: d
                } : void 0, {
                  position: "absolute",
                  left: (b.translateX || 0) + "px",
                  top: (b.translateY || 0) + "px",
                  display: b.display,
                  opacity: b.opacity,
                  cursor: m.cursor,
                  pointerEvents: m.pointerEvents,
                  visibility: b.visibility
                }, l || c);
                var r = l.style;
                A(b, {
                  classSetter: function (b) {
                    return function (d) {
                      this.element.setAttribute("class", d);
                      b.className = d;
                    };
                  }(l),
                  on: function () {
                    e[0].div && f.on.apply({
                      element: e[0].div,
                      onEvents: b.onEvents
                    }, arguments);
                    return b;
                  },
                  translateXSetter: a,
                  translateYSetter: a
                });
                b.addedSetters || t(b);
              });
            }
          } else l = c;
          l.appendChild(k);
          f.added = !0;
          f.alignOnAdd && f.htmlUpdateTransform();
          return f;
        });
        return f;
      };
      k.composedClasses = [];
      return k;
    }(z);
  });
  M(a, "Core/Axis/AxisDefaults.js", [], function () {
    var a;
    (function (a) {
      a.defaultXAxisOptions = {
        alignTicks: !0,
        allowDecimals: void 0,
        panningEnabled: !0,
        zIndex: 2,
        zoomEnabled: !0,
        dateTimeLabelFormats: {
          millisecond: {
            main: "%H:%M:%S.%L",
            range: !1
          },
          second: {
            main: "%H:%M:%S",
            range: !1
          },
          minute: {
            main: "%H:%M",
            range: !1
          },
          hour: {
            main: "%H:%M",
            range: !1
          },
          day: {
            main: "%e. %b"
          },
          week: {
            main: "%e. %b"
          },
          month: {
            main: "%b '%y"
          },
          year: {
            main: "%Y"
          }
        },
        endOnTick: !1,
        gridLineDashStyle: "Solid",
        gridZIndex: 1,
        labels: {
          autoRotation: void 0,
          autoRotationLimit: 80,
          distance: void 0,
          enabled: !0,
          indentation: 10,
          overflow: "justify",
          padding: 5,
          reserveSpace: void 0,
          rotation: void 0,
          staggerLines: 0,
          step: 0,
          useHTML: !1,
          x: 0,
          zIndex: 7,
          style: {
            color: "#666666",
            cursor: "default",
            fontSize: "11px"
          }
        },
        maxPadding: .01,
        minorGridLineDashStyle: "Solid",
        minorTickLength: 2,
        minorTickPosition: "outside",
        minPadding: .01,
        offset: void 0,
        opposite: !1,
        reversed: void 0,
        reversedStacks: !1,
        showEmpty: !0,
        showFirstLabel: !0,
        showLastLabel: !0,
        startOfWeek: 1,
        startOnTick: !1,
        tickLength: 10,
        tickPixelInterval: 100,
        tickmarkPlacement: "between",
        tickPosition: "outside",
        title: {
          align: "middle",
          rotation: 0,
          useHTML: !1,
          x: 0,
          y: 0,
          style: {
            color: "#666666"
          }
        },
        type: "linear",
        uniqueNames: !0,
        visible: !0,
        minorGridLineColor: "#f2f2f2",
        minorGridLineWidth: 1,
        minorTickColor: "#999999",
        lineColor: "#ccd6eb",
        lineWidth: 1,
        gridLineColor: "#e6e6e6",
        gridLineWidth: void 0,
        tickColor: "#ccd6eb"
      };
      a.defaultYAxisOptions = {
        reversedStacks: !0,
        endOnTick: !0,
        maxPadding: .05,
        minPadding: .05,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {
          x: -8
        },
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          animation: {},
          allowOverlap: !1,
          enabled: !1,
          crop: !0,
          overflow: "justify",
          formatter: function () {
            var a = this.axis.chart.numberFormatter;
            return a(this.total, -1);
          },
          style: {
            color: "#000000",
            fontSize: "11px",
            fontWeight: "bold",
            textOutline: "1px contrast"
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
      };
      a.defaultLeftAxisOptions = {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      };
      a.defaultRightAxisOptions = {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      };
      a.defaultBottomAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
      a.defaultTopAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
    })(a || (a = {}));
    return a;
  });
  M(a, "Core/Foundation.js", [a["Core/Utilities.js"]], function (a) {
    var v = a.addEvent,
      z = a.isFunction,
      F = a.objectEach,
      y = a.removeEvent,
      G;
    (function (a) {
      a.registerEventOptions = function (a, q) {
        a.eventOptions = a.eventOptions || {};
        F(q.events, function (n, k) {
          a.eventOptions[k] !== n && (a.eventOptions[k] && (y(a, k, a.eventOptions[k]), delete a.eventOptions[k]), z(n) && (a.eventOptions[k] = n, v(a, k, n)));
        });
      };
    })(G || (G = {}));
    return G;
  });
  M(a, "Core/Axis/Tick.js", [a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = u.deg2rad,
      y = z.clamp,
      G = z.correctFloat,
      H = z.defined,
      A = z.destroyObjectProperties,
      q = z.extend,
      n = z.fireEvent,
      k = z.isNumber,
      e = z.merge,
      c = z.objectEach,
      h = z.pick;
    u = function () {
      function f(a, c, e, h, f) {
        this.isNewLabel = this.isNew = !0;
        this.axis = a;
        this.pos = c;
        this.type = e || "";
        this.parameters = f || {};
        this.tickmarkOffset = this.parameters.tickmarkOffset;
        this.options = this.parameters.options;
        n(this, "init");
        e || h || this.addLabel();
      }
      f.prototype.addLabel = function () {
        var c = this,
          e = c.axis,
          f = e.options,
          t = e.chart,
          J = e.categories,
          C = e.logarithmic,
          r = e.names,
          l = c.pos,
          b = h(c.options && c.options.labels, f.labels),
          g = e.tickPositions,
          d = l === g[0],
          m = l === g[g.length - 1],
          D = (!b.step || 1 === b.step) && 1 === e.tickInterval;
        g = g.info;
        var x = c.label,
          I;
        J = this.parameters.category || (J ? h(J[l], r[l], l) : l);
        C && k(J) && (J = G(C.lin2log(J)));
        if (e.dateTime) if (g) {
          var P = t.time.resolveDTLFormat(f.dateTimeLabelFormats[!f.grid && g.higherRanks[l] || g.unitName]);
          var v = P.main;
        } else k(J) && (v = e.dateTime.getXDateFormat(J, f.dateTimeLabelFormats || {}));
        c.isFirst = d;
        c.isLast = m;
        var O = {
          axis: e,
          chart: t,
          dateTimeLabelFormat: v,
          isFirst: d,
          isLast: m,
          pos: l,
          tick: c,
          tickPositionInfo: g,
          value: J
        };
        n(this, "labelFormat", O);
        var u = function (d) {
          return b.formatter ? b.formatter.call(d, d) : b.format ? (d.text = e.defaultLabelFormatter.call(d), a.format(b.format, d, t)) : e.defaultLabelFormatter.call(d, d);
        };
        f = u.call(O, O);
        var A = P && P.list;
        c.shortenLabel = A ? function () {
          for (I = 0; I < A.length; I++) if (q(O, {
            dateTimeLabelFormat: A[I]
          }), x.attr({
            text: u.call(O, O)
          }), x.getBBox().width < e.getSlotWidth(c) - 2 * b.padding) return;
          x.attr({
            text: ""
          });
        } : void 0;
        D && e._addedPlotLB && c.moveLabel(f, b);
        H(x) || c.movedLabel ? x && x.textStr !== f && !D && (!x.textWidth || b.style.width || x.styles.width || x.css({
          width: null
        }), x.attr({
          text: f
        }), x.textPxLength = x.getBBox().width) : (c.label = x = c.createLabel({
          x: 0,
          y: 0
        }, f, b), c.rotation = 0);
      };
      f.prototype.createLabel = function (a, c, h) {
        var f = this.axis,
          p = f.chart;
        if (a = H(c) && h.enabled ? p.renderer.text(c, a.x, a.y, h.useHTML).add(f.labelGroup) : null) p.styledMode || a.css(e(h.style)), a.textPxLength = a.getBBox().width;
        return a;
      };
      f.prototype.destroy = function () {
        A(this, this.axis);
      };
      f.prototype.getPosition = function (a, c, e, h) {
        var f = this.axis,
          p = f.chart,
          r = h && p.oldChartHeight || p.chartHeight;
        a = {
          x: a ? G(f.translate(c + e, null, null, h) + f.transB) : f.left + f.offset + (f.opposite ? (h && p.oldChartWidth || p.chartWidth) - f.right - f.left : 0),
          y: a ? r - f.bottom + f.offset - (f.opposite ? f.height : 0) : G(r - f.translate(c + e, null, null, h) - f.transB)
        };
        a.y = y(a.y, -1E5, 1E5);
        n(this, "afterGetPosition", {
          pos: a
        });
        return a;
      };
      f.prototype.getLabelPosition = function (a, c, e, h, f, k, r, l) {
        var b = this.axis,
          g = b.transA,
          d = b.isLinked && b.linkedParent ? b.linkedParent.reversed : b.reversed,
          m = b.staggerLines,
          D = b.tickRotCorr || {
            x: 0,
            y: 0
          },
          x = h || b.reserveSpaceDefault ? 0 : -b.labelOffset * ("center" === b.labelAlign ? .5 : 1),
          p = {},
          t = f.y;
        H(t) || (t = 0 === b.side ? e.rotation ? -8 : -e.getBBox().height : 2 === b.side ? D.y + 8 : Math.cos(e.rotation * v) * (D.y - e.getBBox(!1, 0).height / 2));
        a = a + f.x + x + D.x - (k && h ? k * g * (d ? -1 : 1) : 0);
        c = c + t - (k && !h ? k * g * (d ? 1 : -1) : 0);
        m && (e = r / (l || 1) % m, b.opposite && (e = m - e - 1), c += b.labelOffset / m * e);
        p.x = a;
        p.y = Math.round(c);
        n(this, "afterGetLabelPosition", {
          pos: p,
          tickmarkOffset: k,
          index: r
        });
        return p;
      };
      f.prototype.getLabelSize = function () {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
      };
      f.prototype.getMarkPath = function (a, c, e, h, f, k) {
        return k.crispLine([["M", a, c], ["L", a + (f ? 0 : -e), c + (f ? e : 0)]], h);
      };
      f.prototype.handleOverflow = function (a) {
        var c = this.axis,
          e = c.options.labels,
          f = a.x,
          k = c.chart.chartWidth,
          n = c.chart.spacing,
          r = h(c.labelLeft, Math.min(c.pos, n[3]));
        n = h(c.labelRight, Math.max(c.isRadial ? 0 : c.pos + c.len, k - n[1]));
        var l = this.label,
          b = this.rotation,
          g = {
            left: 0,
            center: .5,
            right: 1
          }[c.labelAlign || l.attr("align")],
          d = l.getBBox().width,
          m = c.getSlotWidth(this),
          D = {},
          x = m,
          I = 1,
          w;
        if (b || "justify" !== e.overflow) 0 > b && f - g * d < r ? w = Math.round(f / Math.cos(b * v) - r) : 0 < b && f + g * d > n && (w = Math.round((k - f) / Math.cos(b * v)));else if (k = f + (1 - g) * d, f - g * d < r ? x = a.x + x * (1 - g) - r : k > n && (x = n - a.x + x * g, I = -1), x = Math.min(m, x), x < m && "center" === c.labelAlign && (a.x += I * (m - x - g * (m - Math.min(d, x)))), d > x || c.autoRotation && (l.styles || {}).width) w = x;
        w && (this.shortenLabel ? this.shortenLabel() : (D.width = Math.floor(w) + "px", (e.style || {}).textOverflow || (D.textOverflow = "ellipsis"), l.css(D)));
      };
      f.prototype.moveLabel = function (a, e) {
        var h = this,
          f = h.label,
          k = h.axis,
          p = k.reversed,
          r = !1;
        f && f.textStr === a ? (h.movedLabel = f, r = !0, delete h.label) : c(k.ticks, function (b) {
          r || b.isNew || b === h || !b.label || b.label.textStr !== a || (h.movedLabel = b.label, r = !0, b.labelPos = h.movedLabel.xy, delete b.label);
        });
        if (!r && (h.labelPos || f)) {
          var l = h.labelPos || f.xy;
          f = k.horiz ? p ? 0 : k.width + k.left : l.x;
          k = k.horiz ? l.y : p ? k.width + k.left : 0;
          h.movedLabel = h.createLabel({
            x: f,
            y: k
          }, a, e);
          h.movedLabel && h.movedLabel.attr({
            opacity: 0
          });
        }
      };
      f.prototype.render = function (a, c, e) {
        var f = this.axis,
          k = f.horiz,
          p = this.pos,
          r = h(this.tickmarkOffset, f.tickmarkOffset);
        p = this.getPosition(k, p, r, c);
        r = p.x;
        var l = p.y;
        f = k && r === f.pos + f.len || !k && l === f.pos ? -1 : 1;
        k = h(e, this.label && this.label.newOpacity, 1);
        e = h(e, 1);
        this.isActive = !0;
        this.renderGridLine(c, e, f);
        this.renderMark(p, e, f);
        this.renderLabel(p, c, k, a);
        this.isNew = !1;
        n(this, "afterRender");
      };
      f.prototype.renderGridLine = function (a, c, e) {
        var f = this.axis,
          k = f.options,
          p = {},
          r = this.pos,
          l = this.type,
          b = h(this.tickmarkOffset, f.tickmarkOffset),
          g = f.chart.renderer,
          d = this.gridLine,
          m = k.gridLineWidth,
          D = k.gridLineColor,
          x = k.gridLineDashStyle;
        "minor" === this.type && (m = k.minorGridLineWidth, D = k.minorGridLineColor, x = k.minorGridLineDashStyle);
        d || (f.chart.styledMode || (p.stroke = D, p["stroke-width"] = m || 0, p.dashstyle = x), l || (p.zIndex = 1), a && (c = 0), this.gridLine = d = g.path().attr(p).addClass("highcharts-" + (l ? l + "-" : "") + "grid-line").add(f.gridGroup));
        if (d && (e = f.getPlotLinePath({
          value: r + b,
          lineWidth: d.strokeWidth() * e,
          force: "pass",
          old: a
        }))) d[a || this.isNew ? "attr" : "animate"]({
          d: e,
          opacity: c
        });
      };
      f.prototype.renderMark = function (a, c, e) {
        var f = this.axis,
          k = f.options,
          p = f.chart.renderer,
          r = this.type,
          l = f.tickSize(r ? r + "Tick" : "tick"),
          b = a.x;
        a = a.y;
        var g = h(k["minor" !== r ? "tickWidth" : "minorTickWidth"], !r && f.isXAxis ? 1 : 0);
        k = k["minor" !== r ? "tickColor" : "minorTickColor"];
        var d = this.mark,
          m = !d;
        l && (f.opposite && (l[0] = -l[0]), d || (this.mark = d = p.path().addClass("highcharts-" + (r ? r + "-" : "") + "tick").add(f.axisGroup), f.chart.styledMode || d.attr({
          stroke: k,
          "stroke-width": g
        })), d[m ? "attr" : "animate"]({
          d: this.getMarkPath(b, a, l[0], d.strokeWidth() * e, f.horiz, p),
          opacity: c
        }));
      };
      f.prototype.renderLabel = function (a, c, e, f) {
        var p = this.axis,
          n = p.horiz,
          r = p.options,
          l = this.label,
          b = r.labels,
          g = b.step;
        p = h(this.tickmarkOffset, p.tickmarkOffset);
        var d = a.x;
        a = a.y;
        var m = !0;
        l && k(d) && (l.xy = a = this.getLabelPosition(d, a, l, n, b, p, f, g), this.isFirst && !this.isLast && !r.showFirstLabel || this.isLast && !this.isFirst && !r.showLastLabel ? m = !1 : !n || b.step || b.rotation || c || 0 === e || this.handleOverflow(a), g && f % g && (m = !1), m && k(a.y) ? (a.opacity = e, l[this.isNewLabel ? "attr" : "animate"](a), this.isNewLabel = !1) : (l.attr("y", -9999), this.isNewLabel = !0));
      };
      f.prototype.replaceMovedLabel = function () {
        var a = this.label,
          c = this.axis,
          e = c.reversed;
        if (a && !this.isNew) {
          var f = c.horiz ? e ? c.left : c.width + c.left : a.xy.x;
          e = c.horiz ? a.xy.y : e ? c.width + c.top : c.top;
          a.animate({
            x: f,
            y: e,
            opacity: 0
          }, void 0, a.destroy);
          delete this.label;
        }
        c.isDirty = !0;
        this.label = this.movedLabel;
        delete this.movedLabel;
      };
      return f;
    }();
    "";
    return u;
  });
  M(a, "Core/Axis/Axis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/AxisDefaults.js"], a["Core/Color/Color.js"], a["Core/DefaultOptions.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Axis/Tick.js"], a["Core/Utilities.js"]], function (a, u, z, F, y, G, H, A) {
    var q = a.animObject,
      n = F.defaultOptions,
      k = y.registerEventOptions,
      e = G.deg2rad,
      c = A.arrayMax,
      h = A.arrayMin,
      f = A.clamp,
      w = A.correctFloat,
      p = A.defined,
      B = A.destroyObjectProperties,
      t = A.erase,
      J = A.error,
      C = A.extend,
      r = A.fireEvent,
      l = A.getMagnitude,
      b = A.isArray,
      g = A.isNumber,
      d = A.isString,
      m = A.merge,
      D = A.normalizeTickInterval,
      x = A.objectEach,
      I = A.pick,
      P = A.relativeLength,
      v = A.removeEvent,
      O = A.splat,
      U = A.syncTimeout;
    a = function () {
      function a(b, d) {
        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;
        this.init(b, d);
      }
      a.prototype.init = function (b, d) {
        var a = d.isX;
        this.chart = b;
        this.horiz = b.inverted && !this.isZAxis ? !a : a;
        this.isXAxis = a;
        this.coll = this.coll || (a ? "xAxis" : "yAxis");
        r(this, "init", {
          userOptions: d
        });
        this.opposite = I(d.opposite, this.opposite);
        this.side = I(d.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
        this.setOptions(d);
        var c = this.options,
          e = c.labels,
          m = c.type;
        this.userOptions = d;
        this.minPixelPadding = 0;
        this.reversed = I(c.reversed, this.reversed);
        this.visible = c.visible;
        this.zoomEnabled = c.zoomEnabled;
        this.hasNames = "category" === m || !0 === c.categories;
        this.categories = c.categories || this.hasNames;
        this.names || (this.names = [], this.names.keys = {});
        this.plotLinesAndBandsGroups = {};
        this.positiveValuesOnly = !!this.logarithmic;
        this.isLinked = p(c.linkedTo);
        this.ticks = {};
        this.labelEdge = [];
        this.minorTicks = {};
        this.plotLinesAndBands = [];
        this.alternateBands = {};
        this.len = 0;
        this.minRange = this.userMinRange = c.minRange || c.maxZoom;
        this.range = c.range;
        this.offset = c.offset || 0;
        this.min = this.max = null;
        d = I(c.crosshair, O(b.options.tooltip.crosshairs)[a ? 0 : 1]);
        this.crosshair = !0 === d ? {} : d;
        -1 === b.axes.indexOf(this) && (a ? b.axes.splice(b.xAxis.length, 0, this) : b.axes.push(this), b[this.coll].push(this));
        this.series = this.series || [];
        b.inverted && !this.isZAxis && a && "undefined" === typeof this.reversed && (this.reversed = !0);
        this.labelRotation = g(e.rotation) ? e.rotation : void 0;
        k(this, c);
        r(this, "afterInit");
      };
      a.prototype.setOptions = function (b) {
        this.options = m(u.defaultXAxisOptions, "yAxis" === this.coll && u.defaultYAxisOptions, [u.defaultTopAxisOptions, u.defaultRightAxisOptions, u.defaultBottomAxisOptions, u.defaultLeftAxisOptions][this.side], m(n[this.coll], b));
        r(this, "afterSetOptions", {
          userOptions: b
        });
      };
      a.prototype.defaultLabelFormatter = function (b) {
        var d = this.axis;
        b = this.chart.numberFormatter;
        var a = g(this.value) ? this.value : NaN,
          c = d.chart.time,
          e = this.dateTimeLabelFormat,
          m = n.lang,
          l = m.numericSymbols;
        m = m.numericSymbolMagnitude || 1E3;
        var f = d.logarithmic ? Math.abs(a) : d.tickInterval,
          h = l && l.length;
        if (d.categories) var r = "" + this.value;else if (e) r = c.dateFormat(e, a);else if (h && 1E3 <= f) for (; h-- && "undefined" === typeof r;) d = Math.pow(m, h + 1), f >= d && 0 === 10 * a % d && null !== l[h] && 0 !== a && (r = b(a / d, -1) + l[h]);
        "undefined" === typeof r && (r = 1E4 <= Math.abs(a) ? b(a, -1) : b(a, -1, void 0, ""));
        return r;
      };
      a.prototype.getSeriesExtremes = function () {
        var b = this,
          d = b.chart,
          a;
        r(this, "getSeriesExtremes", null, function () {
          b.hasVisibleSeries = !1;
          b.dataMin = b.dataMax = b.threshold = null;
          b.softThreshold = !b.isXAxis;
          b.stacking && b.stacking.buildStacks();
          b.series.forEach(function (c) {
            if (c.visible || !d.options.chart.ignoreHiddenSeries) {
              var e = c.options,
                m = e.threshold;
              b.hasVisibleSeries = !0;
              b.positiveValuesOnly && 0 >= m && (m = null);
              if (b.isXAxis) {
                if (e = c.xData, e.length) {
                  e = b.logarithmic ? e.filter(b.validatePositiveValue) : e;
                  a = c.getXExtremes(e);
                  var l = a.min;
                  var f = a.max;
                  g(l) || l instanceof Date || (e = e.filter(g), a = c.getXExtremes(e), l = a.min, f = a.max);
                  e.length && (b.dataMin = Math.min(I(b.dataMin, l), l), b.dataMax = Math.max(I(b.dataMax, f), f));
                }
              } else if (c = c.applyExtremes(), g(c.dataMin) && (l = c.dataMin, b.dataMin = Math.min(I(b.dataMin, l), l)), g(c.dataMax) && (f = c.dataMax, b.dataMax = Math.max(I(b.dataMax, f), f)), p(m) && (b.threshold = m), !e.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;
            }
          });
        });
        r(this, "afterGetSeriesExtremes");
      };
      a.prototype.translate = function (b, d, a, c, e, m) {
        var l = this.linkedParent || this,
          f = c && l.old ? l.old.min : l.min,
          r = l.minPixelPadding;
        e = (l.isOrdinal || l.brokenAxis && l.brokenAxis.hasBreaks || l.logarithmic && e) && l.lin2val;
        var h = 1,
          k = 0;
        c = c && l.old ? l.old.transA : l.transA;
        c || (c = l.transA);
        a && (h *= -1, k = l.len);
        l.reversed && (h *= -1, k -= h * (l.sector || l.len));
        d ? (b = (b * h + k - r) / c + f, e && (b = l.lin2val(b))) : (e && (b = l.val2lin(b)), b = g(f) ? h * (b - f) * c + k + h * r + (g(m) ? c * m : 0) : void 0);
        return b;
      };
      a.prototype.toPixels = function (b, d) {
        return this.translate(b, !1, !this.horiz, null, !0) + (d ? 0 : this.pos);
      };
      a.prototype.toValue = function (b, d) {
        return this.translate(b - (d ? 0 : this.pos), !0, !this.horiz, null, !0);
      };
      a.prototype.getPlotLinePath = function (b) {
        function d(b, d, a) {
          if ("pass" !== n && b < d || b > a) n ? b = f(b, d, a) : B = !0;
          return b;
        }
        var a = this,
          c = a.chart,
          e = a.left,
          m = a.top,
          l = b.old,
          h = b.value,
          k = b.lineWidth,
          x = l && c.oldChartHeight || c.chartHeight,
          D = l && c.oldChartWidth || c.chartWidth,
          L = a.transB,
          p = b.translatedValue,
          n = b.force,
          t,
          C,
          w,
          q,
          B;
        b = {
          value: h,
          lineWidth: k,
          old: l,
          force: n,
          acrossPanes: b.acrossPanes,
          translatedValue: p
        };
        r(this, "getPlotLinePath", b, function (b) {
          p = I(p, a.translate(h, null, null, l));
          p = f(p, -1E5, 1E5);
          t = w = Math.round(p + L);
          C = q = Math.round(x - p - L);
          g(p) ? a.horiz ? (C = m, q = x - a.bottom, t = w = d(t, e, e + a.width)) : (t = e, w = D - a.right, C = q = d(C, m, m + a.height)) : (B = !0, n = !1);
          b.path = B && !n ? null : c.renderer.crispLine([["M", t, C], ["L", w, q]], k || 1);
        });
        return b.path;
      };
      a.prototype.getLinearTickPositions = function (b, d, a) {
        var c = w(Math.floor(d / b) * b);
        a = w(Math.ceil(a / b) * b);
        var e = [],
          g;
        w(c + b) === c && (g = 20);
        if (this.single) return [d];
        for (d = c; d <= a;) {
          e.push(d);
          d = w(d + b, g);
          if (d === m) break;
          var m = d;
        }
        return e;
      };
      a.prototype.getMinorTickInterval = function () {
        var b = this.options;
        return !0 === b.minorTicks ? I(b.minorTickInterval, "auto") : !1 === b.minorTicks ? null : b.minorTickInterval;
      };
      a.prototype.getMinorTickPositions = function () {
        var b = this.options,
          d = this.tickPositions,
          a = this.minorTickInterval,
          c = this.pointRangePadding || 0,
          e = this.min - c;
        c = this.max + c;
        var g = c - e,
          m = [];
        if (g && g / a < this.len / 3) {
          var l = this.logarithmic;
          if (l) this.paddedTicks.forEach(function (b, d, c) {
            d && m.push.apply(m, l.getLogTickPositions(a, c[d - 1], c[d], !0));
          });else if (this.dateTime && "auto" === this.getMinorTickInterval()) m = m.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(a), e, c, b.startOfWeek));else for (b = e + (d[0] - e) % a; b <= c && b !== m[0]; b += a) m.push(b);
        }
        0 !== m.length && this.trimTicks(m);
        return m;
      };
      a.prototype.adjustForMinRange = function () {
        var b = this.options,
          d = this.logarithmic,
          a = this.min,
          e = this.max,
          g = 0,
          m,
          l,
          f,
          r;
        this.isXAxis && "undefined" === typeof this.minRange && !d && (p(b.min) || p(b.max) || p(b.floor) || p(b.ceiling) ? this.minRange = null : (this.series.forEach(function (b) {
          f = b.xData;
          r = b.xIncrement ? 1 : f.length - 1;
          if (1 < f.length) for (m = r; 0 < m; m--) if (l = f[m] - f[m - 1], !g || l < g) g = l;
        }), this.minRange = Math.min(5 * g, this.dataMax - this.dataMin)));
        if (e - a < this.minRange) {
          var k = this.dataMax - this.dataMin >= this.minRange;
          var x = this.minRange;
          var D = (x - e + a) / 2;
          D = [a - D, I(b.min, a - D)];
          k && (D[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
          a = c(D);
          e = [a + x, I(b.max, a + x)];
          k && (e[2] = d ? d.log2lin(this.dataMax) : this.dataMax);
          e = h(e);
          e - a < x && (D[0] = e - x, D[1] = I(b.min, e - x), a = c(D));
        }
        this.min = a;
        this.max = e;
      };
      a.prototype.getClosest = function () {
        var b;
        this.categories ? b = 1 : this.series.forEach(function (d) {
          var a = d.closestPointRange,
            c = d.visible || !d.chart.options.chart.ignoreHiddenSeries;
          !d.noSharedTooltip && p(a) && c && (b = p(b) ? Math.min(b, a) : a);
        });
        return b;
      };
      a.prototype.nameToX = function (d) {
        var a = b(this.categories),
          c = a ? this.categories : this.names,
          e = d.options.x;
        d.series.requireSorting = !1;
        p(e) || (e = this.options.uniqueNames ? a ? c.indexOf(d.name) : I(c.keys[d.name], -1) : d.series.autoIncrement());
        if (-1 === e) {
          if (!a) var g = c.length;
        } else g = e;
        "undefined" !== typeof g && (this.names[g] = d.name, this.names.keys[d.name] = g);
        return g;
      };
      a.prototype.updateNames = function () {
        var b = this,
          d = this.names;
        0 < d.length && (Object.keys(d.keys).forEach(function (b) {
          delete d.keys[b];
        }), d.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (d) {
          d.xIncrement = null;
          if (!d.points || d.isDirtyData) b.max = Math.max(b.max, d.xData.length - 1), d.processData(), d.generatePoints();
          d.data.forEach(function (a, c) {
            if (a && a.options && "undefined" !== typeof a.name) {
              var e = b.nameToX(a);
              "undefined" !== typeof e && e !== a.x && (a.x = e, d.xData[c] = e);
            }
          });
        }));
      };
      a.prototype.setAxisTranslation = function () {
        var b = this,
          a = b.max - b.min,
          c = b.linkedParent,
          e = !!b.categories,
          g = b.isXAxis,
          m = b.axisPointRange || 0,
          l = 0,
          f = 0,
          h = b.transA;
        if (g || e || m) {
          var k = b.getClosest();
          c ? (l = c.minPointOffset, f = c.pointRangePadding) : b.series.forEach(function (a) {
            var c = e ? 1 : g ? I(a.options.pointRange, k, 0) : b.axisPointRange || 0,
              h = a.options.pointPlacement;
            m = Math.max(m, c);
            if (!b.single || e) a = a.is("xrange") ? !g : g, l = Math.max(l, a && d(h) ? 0 : c / 2), f = Math.max(f, a && "on" === h ? 0 : c);
          });
          c = b.ordinal && b.ordinal.slope && k ? b.ordinal.slope / k : 1;
          b.minPointOffset = l *= c;
          b.pointRangePadding = f *= c;
          b.pointRange = Math.min(m, b.single && e ? 1 : a);
          g && (b.closestPointRange = k);
        }
        b.translationSlope = b.transA = h = b.staticScale || b.len / (a + f || 1);
        b.transB = b.horiz ? b.left : b.bottom;
        b.minPixelPadding = h * l;
        r(this, "afterSetAxisTranslation");
      };
      a.prototype.minFromRange = function () {
        return this.max - this.range;
      };
      a.prototype.setTickInterval = function (b) {
        var d = this.chart,
          a = this.logarithmic,
          c = this.options,
          e = this.isXAxis,
          m = this.isLinked,
          f = c.tickPixelInterval,
          h = this.categories,
          k = this.softThreshold,
          x = c.maxPadding,
          L = c.minPadding,
          n = g(c.tickInterval) && 0 <= c.tickInterval ? c.tickInterval : void 0,
          t = g(this.threshold) ? this.threshold : null;
        this.dateTime || h || m || this.getTickAmount();
        var C = I(this.userMin, c.min);
        var q = I(this.userMax, c.max);
        if (m) {
          this.linkedParent = d[this.coll][c.linkedTo];
          var B = this.linkedParent.getExtremes();
          this.min = I(B.min, B.dataMin);
          this.max = I(B.max, B.dataMax);
          c.type !== this.linkedParent.options.type && J(11, 1, d);
        } else {
          if (k && p(t)) if (this.dataMin >= t) B = t, L = 0;else if (this.dataMax <= t) {
            var P = t;
            x = 0;
          }
          this.min = I(C, B, this.dataMin);
          this.max = I(q, P, this.dataMax);
        }
        a && (this.positiveValuesOnly && !b && 0 >= Math.min(this.min, I(this.dataMin, this.min)) && J(10, 1, d), this.min = w(a.log2lin(this.min), 16), this.max = w(a.log2lin(this.max), 16));
        this.range && p(this.max) && (this.userMin = this.min = C = Math.max(this.dataMin, this.minFromRange()), this.userMax = q = this.max, this.range = null);
        r(this, "foundExtremes");
        this.beforePadding && this.beforePadding();
        this.adjustForMinRange();
        !(h || this.axisPointRange || this.stacking && this.stacking.usePercentage || m) && p(this.min) && p(this.max) && (d = this.max - this.min) && (!p(C) && L && (this.min -= d * L), !p(q) && x && (this.max += d * x));
        g(this.userMin) || (g(c.softMin) && c.softMin < this.min && (this.min = C = c.softMin), g(c.floor) && (this.min = Math.max(this.min, c.floor)));
        g(this.userMax) || (g(c.softMax) && c.softMax > this.max && (this.max = q = c.softMax), g(c.ceiling) && (this.max = Math.min(this.max, c.ceiling)));
        k && p(this.dataMin) && (t = t || 0, !p(C) && this.min < t && this.dataMin >= t ? this.min = this.options.minRange ? Math.min(t, this.max - this.minRange) : t : !p(q) && this.max > t && this.dataMax <= t && (this.max = this.options.minRange ? Math.max(t, this.min + this.minRange) : t));
        g(this.min) && g(this.max) && !this.chart.polar && this.min > this.max && (p(this.options.min) ? this.max = this.min : p(this.options.max) && (this.min = this.max));
        this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : m && this.linkedParent && !n && f === this.linkedParent.options.tickPixelInterval ? n = this.linkedParent.tickInterval : I(n, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, h ? 1 : (this.max - this.min) * f / Math.max(this.len, f));
        if (e && !b) {
          var v = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
          this.series.forEach(function (b) {
            b.forceCrop = b.forceCropping && b.forceCropping();
            b.processData(v);
          });
          r(this, "postProcessData", {
            hasExtemesChanged: v
          });
        }
        this.setAxisTranslation();
        r(this, "initialAxisTranslation");
        this.pointRange && !n && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
        b = I(c.minTickInterval, this.dateTime && !this.series.some(function (b) {
          return b.noSharedTooltip;
        }) ? this.closestPointRange : 0);
        !n && this.tickInterval < b && (this.tickInterval = b);
        this.dateTime || this.logarithmic || n || (this.tickInterval = D(this.tickInterval, void 0, l(this.tickInterval), I(c.allowDecimals, .5 > this.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));
        this.tickAmount || (this.tickInterval = this.unsquish());
        this.setTickPositions();
      };
      a.prototype.setTickPositions = function () {
        var b = this.options,
          d = b.tickPositions,
          a = this.getMinorTickInterval(),
          c = this.hasVerticalPanning(),
          e = "colorAxis" === this.coll,
          g = (e || !c) && b.startOnTick;
        c = (e || !c) && b.endOnTick;
        e = b.tickPositioner;
        this.tickmarkOffset = this.categories && "between" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
        this.minorTickInterval = "auto" === a && this.tickInterval ? this.tickInterval / 5 : a;
        this.single = this.min === this.max && p(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);
        this.tickPositions = a = d && d.slice();
        !a && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? a = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (a = [this.min, this.max], J(19, !1, this.chart)), a.length > this.len && (a = [a[0], a.pop()], a[0] === a[1] && (a.length = 1)), this.tickPositions = a, e && (e = e.apply(this, [this.min, this.max]))) && (this.tickPositions = a = e);
        this.paddedTicks = a.slice(0);
        this.trimTicks(a, g, c);
        this.isLinked || (this.single && 2 > a.length && !this.categories && !this.series.some(function (b) {
          return b.is("heatmap") && "between" === b.options.pointPlacement;
        }) && (this.min -= .5, this.max += .5), d || e || this.adjustTickAmount());
        r(this, "afterSetTickPositions");
      };
      a.prototype.trimTicks = function (b, d, a) {
        var c = b[0],
          e = b[b.length - 1],
          g = !this.isOrdinal && this.minPointOffset || 0;
        r(this, "trimTicks");
        if (!this.isLinked) {
          if (d && -Infinity !== c) this.min = c;else for (; this.min - g > b[0];) b.shift();
          if (a) this.max = e;else for (; this.max + g < b[b.length - 1];) b.pop();
          0 === b.length && p(c) && !this.options.tickPositions && b.push((e + c) / 2);
        }
      };
      a.prototype.alignToOthers = function () {
        var b = {},
          d = this.options,
          a;
        !1 !== this.chart.options.chart.alignTicks && d.alignTicks && !1 !== d.startOnTick && !1 !== d.endOnTick && !this.logarithmic && this.chart[this.coll].forEach(function (d) {
          var c = d.options;
          c = [d.horiz ? c.left : c.top, c.width, c.height, c.pane].join();
          d.series.length && (b[c] ? a = !0 : b[c] = 1);
        });
        return a;
      };
      a.prototype.getTickAmount = function () {
        var b = this.options,
          d = b.tickPixelInterval,
          a = b.tickAmount;
        !p(b.tickInterval) && !a && this.len < d && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (a = 2);
        !a && this.alignToOthers() && (a = Math.ceil(this.len / d) + 1);
        4 > a && (this.finalTickAmt = a, a = 5);
        this.tickAmount = a;
      };
      a.prototype.adjustTickAmount = function () {
        var b = this.options,
          d = this.tickInterval,
          a = this.tickPositions,
          c = this.tickAmount,
          e = this.finalTickAmt,
          m = a && a.length,
          l = I(this.threshold, this.softThreshold ? 0 : null);
        if (this.hasData() && g(this.min) && g(this.max)) {
          if (m < c) {
            for (; a.length < c;) a.length % 2 || this.min === l ? a.push(w(a[a.length - 1] + d)) : a.unshift(w(a[0] - d));
            this.transA *= (m - 1) / (c - 1);
            this.min = b.startOnTick ? a[0] : Math.min(this.min, a[0]);
            this.max = b.endOnTick ? a[a.length - 1] : Math.max(this.max, a[a.length - 1]);
          } else m > c && (this.tickInterval *= 2, this.setTickPositions());
          if (p(e)) {
            for (d = b = a.length; d--;) (3 === e && 1 === d % 2 || 2 >= e && 0 < d && d < b - 1) && a.splice(d, 1);
            this.finalTickAmt = void 0;
          }
        }
      };
      a.prototype.setScale = function () {
        var b = !1,
          d = !1;
        this.series.forEach(function (a) {
          b = b || a.isDirtyData || a.isDirty;
          d = d || a.xAxis && a.xAxis.isDirty || !1;
        });
        this.setAxisSize();
        var a = this.len !== (this.old && this.old.len);
        a || b || d || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = a || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
        b && this.panningState && (this.panningState.isDirty = !0);
        r(this, "afterSetScale");
      };
      a.prototype.setExtremes = function (b, d, a, c, e) {
        var g = this,
          m = g.chart;
        a = I(a, !0);
        g.series.forEach(function (b) {
          delete b.kdTree;
        });
        e = C(e, {
          min: b,
          max: d
        });
        r(g, "setExtremes", e, function () {
          g.userMin = b;
          g.userMax = d;
          g.eventArgs = e;
          a && m.redraw(c);
        });
      };
      a.prototype.zoom = function (b, d) {
        var a = this,
          c = this.dataMin,
          e = this.dataMax,
          g = this.options,
          m = Math.min(c, I(g.min, c)),
          l = Math.max(e, I(g.max, e));
        b = {
          newMin: b,
          newMax: d
        };
        r(this, "zoom", b, function (b) {
          var d = b.newMin,
            g = b.newMax;
          if (d !== a.min || g !== a.max) a.allowZoomOutside || (p(c) && (d < m && (d = m), d > l && (d = l)), p(e) && (g < m && (g = m), g > l && (g = l))), a.displayBtn = "undefined" !== typeof d || "undefined" !== typeof g, a.setExtremes(d, g, !1, void 0, {
            trigger: "zoom"
          });
          b.zoomed = !0;
        });
        return b.zoomed;
      };
      a.prototype.setAxisSize = function () {
        var b = this.chart,
          d = this.options,
          a = d.offsets || [0, 0, 0, 0],
          c = this.horiz,
          e = this.width = Math.round(P(I(d.width, b.plotWidth - a[3] + a[1]), b.plotWidth)),
          g = this.height = Math.round(P(I(d.height, b.plotHeight - a[0] + a[2]), b.plotHeight)),
          m = this.top = Math.round(P(I(d.top, b.plotTop + a[0]), b.plotHeight, b.plotTop));
        d = this.left = Math.round(P(I(d.left, b.plotLeft + a[3]), b.plotWidth, b.plotLeft));
        this.bottom = b.chartHeight - g - m;
        this.right = b.chartWidth - e - d;
        this.len = Math.max(c ? e : g, 0);
        this.pos = c ? d : m;
      };
      a.prototype.getExtremes = function () {
        var b = this.logarithmic;
        return {
          min: b ? w(b.lin2log(this.min)) : this.min,
          max: b ? w(b.lin2log(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        };
      };
      a.prototype.getThreshold = function (b) {
        var d = this.logarithmic,
          a = d ? d.lin2log(this.min) : this.min;
        d = d ? d.lin2log(this.max) : this.max;
        null === b || -Infinity === b ? b = a : Infinity === b ? b = d : a > b ? b = a : d < b && (b = d);
        return this.translate(b, 0, 1, 0, 1);
      };
      a.prototype.autoLabelAlign = function (b) {
        var d = (I(b, 0) - 90 * this.side + 720) % 360;
        b = {
          align: "center"
        };
        r(this, "autoLabelAlign", b, function (b) {
          15 < d && 165 > d ? b.align = "right" : 195 < d && 345 > d && (b.align = "left");
        });
        return b.align;
      };
      a.prototype.tickSize = function (b) {
        var d = this.options,
          a = I(d["tick" === b ? "tickWidth" : "minorTickWidth"], "tick" === b && this.isXAxis && !this.categories ? 1 : 0),
          c = d["tick" === b ? "tickLength" : "minorTickLength"];
        if (a && c) {
          "inside" === d[b + "Position"] && (c = -c);
          var e = [c, a];
        }
        b = {
          tickSize: e
        };
        r(this, "afterTickSize", b);
        return b.tickSize;
      };
      a.prototype.labelMetrics = function () {
        var b = this.tickPositions && this.tickPositions[0] || 0;
        return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);
      };
      a.prototype.unsquish = function () {
        var b = this.options.labels,
          d = this.horiz,
          a = this.tickInterval,
          c = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a),
          m = b.rotation,
          l = this.labelMetrics(),
          f = Math.max(this.max - this.min, 0),
          h = function (b) {
            var d = b / (c || 1);
            d = 1 < d ? Math.ceil(d) : 1;
            d * a > f && Infinity !== b && Infinity !== c && f && (d = Math.ceil(f / a));
            return w(d * a);
          },
          r = a,
          k,
          x,
          D = Number.MAX_VALUE;
        if (d) {
          if (!b.staggerLines && !b.step) if (g(m)) var p = [m];else c < b.autoRotationLimit && (p = b.autoRotation);
          p && p.forEach(function (b) {
            if (b === m || b && -90 <= b && 90 >= b) {
              x = h(Math.abs(l.h / Math.sin(e * b)));
              var d = x + Math.abs(b / 360);
              d < D && (D = d, k = b, r = x);
            }
          });
        } else b.step || (r = h(l.h));
        this.autoRotation = p;
        this.labelRotation = I(k, g(m) ? m : 0);
        return r;
      };
      a.prototype.getSlotWidth = function (b) {
        var d = this.chart,
          a = this.horiz,
          c = this.options.labels,
          e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
          m = d.margin[3];
        if (b && g(b.slotWidth)) return b.slotWidth;
        if (a && 2 > c.step) return c.rotation ? 0 : (this.staggerLines || 1) * this.len / e;
        if (!a) {
          b = c.style.width;
          if (void 0 !== b) return parseInt(String(b), 10);
          if (m) return m - d.spacing[3];
        }
        return .33 * d.chartWidth;
      };
      a.prototype.renderUnsquish = function () {
        var b = this.chart,
          a = b.renderer,
          c = this.tickPositions,
          e = this.ticks,
          g = this.options.labels,
          m = g.style,
          l = this.horiz,
          f = this.getSlotWidth(),
          h = Math.max(1, Math.round(f - 2 * g.padding)),
          r = {},
          k = this.labelMetrics(),
          x = m.textOverflow,
          D = 0;
        d(g.rotation) || (r.rotation = g.rotation || 0);
        c.forEach(function (b) {
          b = e[b];
          b.movedLabel && b.replaceMovedLabel();
          b && b.label && b.label.textPxLength > D && (D = b.label.textPxLength);
        });
        this.maxLabelLength = D;
        if (this.autoRotation) D > h && D > k.h ? r.rotation = this.labelRotation : this.labelRotation = 0;else if (f) {
          var p = h;
          if (!x) {
            var n = "clip";
            for (h = c.length; !l && h--;) {
              var I = c[h];
              if (I = e[I].label) I.styles && "ellipsis" === I.styles.textOverflow ? I.css({
                textOverflow: "clip"
              }) : I.textPxLength > f && I.css({
                width: f + "px"
              }), I.getBBox().height > this.len / c.length - (k.h - k.f) && (I.specificTextOverflow = "ellipsis");
            }
          }
        }
        r.rotation && (p = D > .5 * b.chartHeight ? .33 * b.chartHeight : D, x || (n = "ellipsis"));
        if (this.labelAlign = g.align || this.autoLabelAlign(this.labelRotation)) r.align = this.labelAlign;
        c.forEach(function (b) {
          var d = (b = e[b]) && b.label,
            a = m.width,
            c = {};
          d && (d.attr(r), b.shortenLabel ? b.shortenLabel() : p && !a && "nowrap" !== m.whiteSpace && (p < d.textPxLength || "SPAN" === d.element.tagName) ? (c.width = p + "px", x || (c.textOverflow = d.specificTextOverflow || n), d.css(c)) : d.styles && d.styles.width && !c.width && !a && d.css({
            width: null
          }), delete d.specificTextOverflow, b.rotation = r.rotation);
        }, this);
        this.tickRotCorr = a.rotCorr(k.b, this.labelRotation || 0, 0 !== this.side);
      };
      a.prototype.hasData = function () {
        return this.series.some(function (b) {
          return b.hasData();
        }) || this.options.showEmpty && p(this.min) && p(this.max);
      };
      a.prototype.addTitle = function (b) {
        var d = this.chart.renderer,
          a = this.horiz,
          c = this.opposite,
          e = this.options.title,
          g = this.chart.styledMode,
          l;
        this.axisTitle || ((l = e.textAlign) || (l = (a ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: c ? "right" : "left",
          middle: "center",
          high: c ? "left" : "right"
        })[e.align]), this.axisTitle = d.text(e.text || "", 0, 0, e.useHTML).attr({
          zIndex: 7,
          rotation: e.rotation,
          align: l
        }).addClass("highcharts-axis-title"), g || this.axisTitle.css(m(e.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
        g || e.style.width || this.isRadial || this.axisTitle.css({
          width: this.len + "px"
        });
        this.axisTitle[b ? "show" : "hide"](b);
      };
      a.prototype.generateTick = function (b) {
        var d = this.ticks;
        d[b] ? d[b].addLabel() : d[b] = new H(this, b);
      };
      a.prototype.getOffset = function () {
        var b = this,
          d = this,
          a = d.chart,
          c = d.horiz,
          e = d.options,
          g = d.side,
          m = d.ticks,
          l = d.tickPositions,
          f = d.coll,
          h = d.axisParent,
          k = a.renderer,
          D = a.inverted && !d.isZAxis ? [1, 0, 3, 2][g] : g,
          n = d.hasData(),
          t = e.title,
          C = e.labels,
          q = a.axisOffset;
        a = a.clipOffset;
        var w = [-1, 1, 1, -1][g],
          B = e.className,
          P,
          J = 0,
          ja = 0,
          ca = 0;
        d.showAxis = P = n || e.showEmpty;
        d.staggerLines = d.horiz && C.staggerLines || void 0;
        if (!d.axisGroup) {
          var v = function (d, a, c) {
            return k.g(d).attr({
              zIndex: c
            }).addClass("highcharts-" + f.toLowerCase() + a + " " + (b.isRadial ? "highcharts-radial-axis" + a + " " : "") + (B || "")).add(h);
          };
          d.gridGroup = v("grid", "-grid", e.gridZIndex);
          d.axisGroup = v("axis", "", e.zIndex);
          d.labelGroup = v("axis-labels", "-labels", C.zIndex);
        }
        n || d.isLinked ? (l.forEach(function (b) {
          d.generateTick(b);
        }), d.renderUnsquish(), d.reserveSpaceDefault = 0 === g || 2 === g || {
          1: "left",
          3: "right"
        }[g] === d.labelAlign, I(C.reserveSpace, "center" === d.labelAlign ? !0 : null, d.reserveSpaceDefault) && l.forEach(function (b) {
          ca = Math.max(m[b].getLabelSize(), ca);
        }), d.staggerLines && (ca *= d.staggerLines), d.labelOffset = ca * (d.opposite ? -1 : 1)) : x(m, function (b, d) {
          b.destroy();
          delete m[d];
        });
        if (t && t.text && !1 !== t.enabled && (d.addTitle(P), P && !1 !== t.reserveSpace)) {
          d.titleOffset = J = d.axisTitle.getBBox()[c ? "height" : "width"];
          var O = t.offset;
          ja = p(O) ? 0 : I(t.margin, c ? 5 : 10);
        }
        d.renderLine();
        d.offset = w * I(e.offset, q[g] ? q[g] + (e.margin || 0) : 0);
        d.tickRotCorr = d.tickRotCorr || {
          x: 0,
          y: 0
        };
        t = 0 === g ? -d.labelMetrics().h : 2 === g ? d.tickRotCorr.y : 0;
        n = Math.abs(ca) + ja;
        ca && (n = n - t + w * (c ? I(C.y, d.tickRotCorr.y + 8 * w) : C.x));
        d.axisTitleMargin = I(O, n);
        d.getMaxLabelDimensions && (d.maxLabelDimensions = d.getMaxLabelDimensions(m, l));
        "colorAxis" !== f && (c = this.tickSize("tick"), q[g] = Math.max(q[g], (d.axisTitleMargin || 0) + J + w * d.offset, n, l && l.length && c ? c[0] + w * d.offset : 0), e = !d.axisLine || e.offset ? 0 : 2 * Math.floor(d.axisLine.strokeWidth() / 2), a[D] = Math.max(a[D], e));
        r(this, "afterGetOffset");
      };
      a.prototype.getLinePath = function (b) {
        var d = this.chart,
          a = this.opposite,
          c = this.offset,
          e = this.horiz,
          g = this.left + (a ? this.width : 0) + c;
        c = d.chartHeight - this.bottom - (a ? this.height : 0) + c;
        a && (b *= -1);
        return d.renderer.crispLine([["M", e ? this.left : g, e ? c : this.top], ["L", e ? d.chartWidth - this.right : g, e ? c : d.chartHeight - this.bottom]], b);
      };
      a.prototype.renderLine = function () {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        }));
      };
      a.prototype.getTitlePosition = function () {
        var b = this.horiz,
          d = this.left,
          a = this.top,
          c = this.len,
          e = this.options.title,
          g = b ? d : a,
          m = this.opposite,
          l = this.offset,
          f = e.x,
          h = e.y,
          k = this.axisTitle,
          x = this.chart.renderer.fontMetrics(e.style.fontSize, k);
        k = Math.max(k.getBBox(null, 0).height - x.h - 1, 0);
        c = {
          low: g + (b ? 0 : c),
          middle: g + c / 2,
          high: g + (b ? c : 0)
        }[e.align];
        d = (b ? a + this.height : d) + (b ? 1 : -1) * (m ? -1 : 1) * this.axisTitleMargin + [-k, k, x.f, -k][this.side];
        b = {
          x: b ? c + f : d + (m ? this.width : 0) + l + f,
          y: b ? d + h - (m ? this.height : 0) + l : c + h
        };
        r(this, "afterGetTitlePosition", {
          titlePosition: b
        });
        return b;
      };
      a.prototype.renderMinorTick = function (b, d) {
        var a = this.minorTicks;
        a[b] || (a[b] = new H(this, b, "minor"));
        d && a[b].isNew && a[b].render(null, !0);
        a[b].render(null, !1, 1);
      };
      a.prototype.renderTick = function (b, d, a) {
        var c = this.ticks;
        if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) c[b] || (c[b] = new H(this, b)), a && c[b].isNew && c[b].render(d, !0, -1), c[b].render(d);
      };
      a.prototype.render = function () {
        var b = this,
          d = b.chart,
          a = b.logarithmic,
          c = b.options,
          e = b.isLinked,
          m = b.tickPositions,
          l = b.axisTitle,
          f = b.ticks,
          h = b.minorTicks,
          k = b.alternateBands,
          D = c.stackLabels,
          p = c.alternateGridColor,
          n = b.tickmarkOffset,
          I = b.axisLine,
          t = b.showAxis,
          C = q(d.renderer.globalAnimation),
          w,
          B;
        b.labelEdge.length = 0;
        b.overlap = !1;
        [f, h, k].forEach(function (b) {
          x(b, function (b) {
            b.isActive = !1;
          });
        });
        if (b.hasData() || e) {
          var P = b.chart.hasRendered && b.old && g(b.old.min);
          b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (d) {
            b.renderMinorTick(d, P);
          });
          m.length && (m.forEach(function (d, a) {
            b.renderTick(d, a, P);
          }), n && (0 === b.min || b.single) && (f[-1] || (f[-1] = new H(b, -1, null, !0)), f[-1].render(-1)));
          p && m.forEach(function (c, e) {
            B = "undefined" !== typeof m[e + 1] ? m[e + 1] + n : b.max - n;
            0 === e % 2 && c < b.max && B <= b.max + (d.polar ? -n : n) && (k[c] || (k[c] = new G.PlotLineOrBand(b)), w = c + n, k[c].options = {
              from: a ? a.lin2log(w) : w,
              to: a ? a.lin2log(B) : B,
              color: p,
              className: "highcharts-alternate-grid"
            }, k[c].render(), k[c].isActive = !0);
          });
          b._addedPlotLB || (b._addedPlotLB = !0, (c.plotLines || []).concat(c.plotBands || []).forEach(function (d) {
            b.addPlotBandOrLine(d);
          }));
        }
        [f, h, k].forEach(function (b) {
          var a = [],
            c = C.duration;
          x(b, function (b, d) {
            b.isActive || (b.render(d, !1, 0), b.isActive = !1, a.push(d));
          });
          U(function () {
            for (var d = a.length; d--;) b[a[d]] && !b[a[d]].isActive && (b[a[d]].destroy(), delete b[a[d]]);
          }, b !== k && d.hasRendered && c ? c : 0);
        });
        I && (I[I.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(I.strokeWidth())
        }), I.isPlaced = !0, I[t ? "show" : "hide"](t));
        l && t && (c = b.getTitlePosition(), g(c.y) ? (l[l.isNew ? "attr" : "animate"](c), l.isNew = !1) : (l.attr("y", -9999), l.isNew = !0));
        D && D.enabled && b.stacking && b.stacking.renderStackTotals();
        b.old = {
          len: b.len,
          max: b.max,
          min: b.min,
          transA: b.transA,
          userMax: b.userMax,
          userMin: b.userMin
        };
        b.isDirty = !1;
        r(this, "afterRender");
      };
      a.prototype.redraw = function () {
        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {
          b.render();
        }));
        this.series.forEach(function (b) {
          b.isDirty = !0;
        });
      };
      a.prototype.getKeepProps = function () {
        return this.keepProps || a.keepProps;
      };
      a.prototype.destroy = function (b) {
        var d = this,
          a = d.plotLinesAndBands,
          c = this.eventOptions;
        r(this, "destroy", {
          keepEvents: b
        });
        b || v(d);
        [d.ticks, d.minorTicks, d.alternateBands].forEach(function (b) {
          B(b);
        });
        if (a) for (b = a.length; b--;) a[b].destroy();
        "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (b) {
          d[b] && (d[b] = d[b].destroy());
        });
        for (var e in d.plotLinesAndBandsGroups) d.plotLinesAndBandsGroups[e] = d.plotLinesAndBandsGroups[e].destroy();
        x(d, function (b, a) {
          -1 === d.getKeepProps().indexOf(a) && delete d[a];
        });
        this.eventOptions = c;
      };
      a.prototype.drawCrosshair = function (b, d) {
        var a = this.crosshair,
          c = I(a && a.snap, !0),
          e = this.chart,
          g,
          m = this.cross;
        r(this, "drawCrosshair", {
          e: b,
          point: d
        });
        b || (b = this.cross && this.cross.e);
        if (a && !1 !== (p(d) || !c)) {
          c ? p(d) && (g = I("colorAxis" !== this.coll ? d.crosshairPos : null, this.isXAxis ? d.plotX : this.len - d.plotY)) : g = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);
          if (p(g)) {
            var l = {
              value: d && (this.isXAxis ? d.x : I(d.stackY, d.y)),
              translatedValue: g
            };
            e.polar && C(l, {
              isCrosshair: !0,
              chartX: b && b.chartX,
              chartY: b && b.chartY,
              point: d
            });
            l = this.getPlotLinePath(l) || null;
          }
          if (!p(l)) {
            this.hideCrosshair();
            return;
          }
          c = this.categories && !this.isRadial;
          m || (this.cross = m = e.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (c ? "category " : "thin ") + (a.className || "")).attr({
            zIndex: I(a.zIndex, 2)
          }).add(), e.styledMode || (m.attr({
            stroke: a.color || (c ? z.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
            "stroke-width": I(a.width, 1)
          }).css({
            "pointer-events": "none"
          }), a.dashStyle && m.attr({
            dashstyle: a.dashStyle
          })));
          m.show().attr({
            d: l
          });
          c && !a.width && m.attr({
            "stroke-width": this.transA
          });
          this.cross.e = b;
        } else this.hideCrosshair();
        r(this, "afterDrawCrosshair", {
          e: b,
          point: d
        });
      };
      a.prototype.hideCrosshair = function () {
        this.cross && this.cross.hide();
        r(this, "afterHideCrosshair");
      };
      a.prototype.hasVerticalPanning = function () {
        var b = this.chart.options.chart.panning;
        return !!(b && b.enabled && /y/.test(b.type));
      };
      a.prototype.validatePositiveValue = function (b) {
        return g(b) && 0 < b;
      };
      a.prototype.update = function (b, d) {
        var a = this.chart;
        b = m(this.userOptions, b);
        this.destroy(!0);
        this.init(a, b);
        a.isDirtyBox = !0;
        I(d, !0) && a.redraw();
      };
      a.prototype.remove = function (b) {
        for (var d = this.chart, a = this.coll, c = this.series, e = c.length; e--;) c[e] && c[e].remove(!1);
        t(d.axes, this);
        t(d[a], this);
        d[a].forEach(function (b, d) {
          b.options.index = b.userOptions.index = d;
        });
        this.destroy();
        d.isDirtyBox = !0;
        I(b, !0) && d.redraw();
      };
      a.prototype.setTitle = function (b, d) {
        this.update({
          title: b
        }, d);
      };
      a.prototype.setCategories = function (b, d) {
        this.update({
          categories: b
        }, d);
      };
      a.defaultOptions = u.defaultXAxisOptions;
      a.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
      return a;
    }();
    "";
    return a;
  });
  M(a, "Core/Axis/DateTimeAxis.js", [a["Core/Utilities.js"]], function (a) {
    var v = a.addEvent,
      z = a.getMagnitude,
      F = a.normalizeTickInterval,
      y = a.timeUnits,
      G;
    (function (a) {
      function u() {
        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
      }
      function q(a) {
        "datetime" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new k(this));
      }
      var n = [];
      a.compose = function (a) {
        -1 === n.indexOf(a) && (n.push(a), a.keepProps.push("dateTime"), a.prototype.getTimeTicks = u, v(a, "init", q));
        return a;
      };
      var k = function () {
        function a(a) {
          this.axis = a;
        }
        a.prototype.normalizeTimeTickInterval = function (a, e) {
          var c = e || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
          e = c[c.length - 1];
          var h = y[e[0]],
            k = e[1],
            n;
          for (n = 0; n < c.length && !(e = c[n], h = y[e[0]], k = e[1], c[n + 1] && a <= (h * k[k.length - 1] + y[c[n + 1][0]]) / 2); n++);
          h === y.year && a < 5 * h && (k = [1, 2, 5]);
          a = F(a / h, k, "year" === e[0] ? Math.max(z(a / h), 1) : 1);
          return {
            unitRange: h,
            count: a,
            unitName: e[0]
          };
        };
        a.prototype.getXDateFormat = function (a, e) {
          var c = this.axis;
          return c.closestPointRange ? c.chart.time.getDateFormat(c.closestPointRange, a, c.options.startOfWeek, e) || e.year : e.day;
        };
        return a;
      }();
      a.Additions = k;
    })(G || (G = {}));
    return G;
  });
  M(a, "Core/Axis/LogarithmicAxis.js", [a["Core/Utilities.js"]], function (a) {
    var v = a.addEvent,
      z = a.getMagnitude,
      F = a.normalizeTickInterval,
      y = a.pick,
      G;
    (function (a) {
      function u(a) {
        var c = this.logarithmic;
        "logarithmic" !== a.userOptions.type ? this.logarithmic = void 0 : c || (this.logarithmic = new k(this));
      }
      function q() {
        var a = this.logarithmic;
        a && (this.lin2val = function (c) {
          return a.lin2log(c);
        }, this.val2lin = function (c) {
          return a.log2lin(c);
        });
      }
      var n = [];
      a.compose = function (a) {
        -1 === n.indexOf(a) && (n.push(a), a.keepProps.push("logarithmic"), v(a, "init", u), v(a, "afterInit", q));
        return a;
      };
      var k = function () {
        function a(a) {
          this.axis = a;
        }
        a.prototype.getLogTickPositions = function (a, e, f, k) {
          var c = this.axis,
            h = c.len,
            n = c.options,
            q = [];
          k || (this.minorAutoInterval = void 0);
          if (.5 <= a) a = Math.round(a), q = c.getLinearTickPositions(a, e, f);else if (.08 <= a) {
            var C = Math.floor(e),
              r,
              l = n = void 0;
            for (h = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; C < f + 1 && !l; C++) {
              var b = h.length;
              for (r = 0; r < b && !l; r++) {
                var g = this.log2lin(this.lin2log(C) * h[r]);
                g > e && (!k || n <= f) && "undefined" !== typeof n && q.push(n);
                n > f && (l = !0);
                n = g;
              }
            }
          } else e = this.lin2log(e), f = this.lin2log(f), a = k ? c.getMinorTickInterval() : n.tickInterval, a = y("auto" === a ? null : a, this.minorAutoInterval, n.tickPixelInterval / (k ? 5 : 1) * (f - e) / ((k ? h / c.tickPositions.length : h) || 1)), a = F(a, void 0, z(a)), q = c.getLinearTickPositions(a, e, f).map(this.log2lin), k || (this.minorAutoInterval = a / 5);
          k || (c.tickInterval = a);
          return q;
        };
        a.prototype.lin2log = function (a) {
          return Math.pow(10, a);
        };
        a.prototype.log2lin = function (a) {
          return Math.log(a) / Math.LN10;
        };
        return a;
      }();
      a.Additions = k;
    })(G || (G = {}));
    return G;
  });
  M(a, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [a["Core/Utilities.js"]], function (a) {
    var v = a.erase,
      z = a.extend,
      F = a.isNumber,
      y;
    (function (a) {
      var u = [],
        A;
      a.compose = function (a, k) {
        A || (A = a);
        -1 === u.indexOf(k) && (u.push(k), z(k.prototype, q.prototype));
        return k;
      };
      var q = function () {
        function a() {}
        a.prototype.getPlotBandPath = function (a, e, c) {
          void 0 === c && (c = this.options);
          var h = this.getPlotLinePath({
              value: e,
              force: !0,
              acrossPanes: c.acrossPanes
            }),
            f = [],
            k = this.horiz;
          e = !F(this.min) || !F(this.max) || a < this.min && e < this.min || a > this.max && e > this.max;
          a = this.getPlotLinePath({
            value: a,
            force: !0,
            acrossPanes: c.acrossPanes
          });
          c = 1;
          if (a && h) {
            if (e) {
              var p = a.toString() === h.toString();
              c = 0;
            }
            for (e = 0; e < a.length; e += 2) {
              var n = a[e],
                t = a[e + 1],
                q = h[e],
                C = h[e + 1];
              "M" !== n[0] && "L" !== n[0] || "M" !== t[0] && "L" !== t[0] || "M" !== q[0] && "L" !== q[0] || "M" !== C[0] && "L" !== C[0] || (k && q[1] === n[1] ? (q[1] += c, C[1] += c) : k || q[2] !== n[2] || (q[2] += c, C[2] += c), f.push(["M", n[1], n[2]], ["L", t[1], t[2]], ["L", C[1], C[2]], ["L", q[1], q[2]], ["Z"]));
              f.isFlat = p;
            }
          }
          return f;
        };
        a.prototype.addPlotBand = function (a) {
          return this.addPlotBandOrLine(a, "plotBands");
        };
        a.prototype.addPlotLine = function (a) {
          return this.addPlotBandOrLine(a, "plotLines");
        };
        a.prototype.addPlotBandOrLine = function (a, e) {
          var c = this,
            h = this.userOptions,
            f = new A(this, a);
          this.visible && (f = f.render());
          if (f) {
            this._addedPlotLB || (this._addedPlotLB = !0, (h.plotLines || []).concat(h.plotBands || []).forEach(function (a) {
              c.addPlotBandOrLine(a);
            }));
            if (e) {
              var k = h[e] || [];
              k.push(a);
              h[e] = k;
            }
            this.plotLinesAndBands.push(f);
          }
          return f;
        };
        a.prototype.removePlotBandOrLine = function (a) {
          var e = this.plotLinesAndBands,
            c = this.options,
            h = this.userOptions;
          if (e) {
            for (var f = e.length; f--;) e[f].id === a && e[f].destroy();
            [c.plotLines || [], h.plotLines || [], c.plotBands || [], h.plotBands || []].forEach(function (c) {
              for (f = c.length; f--;) (c[f] || {}).id === a && v(c, c[f]);
            });
          }
        };
        a.prototype.removePlotBand = function (a) {
          this.removePlotBandOrLine(a);
        };
        a.prototype.removePlotLine = function (a) {
          this.removePlotBandOrLine(a);
        };
        return a;
      }();
    })(y || (y = {}));
    return y;
  });
  M(a, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [a["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], a["Core/Utilities.js"]], function (a, u) {
    var v = u.arrayMax,
      F = u.arrayMin,
      y = u.defined,
      G = u.destroyObjectProperties,
      H = u.erase,
      A = u.fireEvent,
      q = u.merge,
      n = u.objectEach,
      k = u.pick;
    u = function () {
      function e(a, e) {
        this.axis = a;
        e && (this.options = e, this.id = e.id);
      }
      e.compose = function (c) {
        return a.compose(e, c);
      };
      e.prototype.render = function () {
        A(this, "render");
        var a = this,
          e = a.axis,
          f = e.horiz,
          w = e.logarithmic,
          p = a.options,
          B = p.color,
          t = k(p.zIndex, 0),
          v = p.events,
          C = {},
          r = e.chart.renderer,
          l = p.label,
          b = a.label,
          g = p.to,
          d = p.from,
          m = p.value,
          D = a.svgElem,
          x = [],
          I = y(d) && y(g);
        x = y(m);
        var P = !D,
          S = {
            "class": "highcharts-plot-" + (I ? "band " : "line ") + (p.className || "")
          },
          O = I ? "bands" : "lines";
        w && (d = w.log2lin(d), g = w.log2lin(g), m = w.log2lin(m));
        e.chart.styledMode || (x ? (S.stroke = B || "#999999", S["stroke-width"] = k(p.width, 1), p.dashStyle && (S.dashstyle = p.dashStyle)) : I && (S.fill = B || "#e6ebf5", p.borderWidth && (S.stroke = p.borderColor, S["stroke-width"] = p.borderWidth)));
        C.zIndex = t;
        O += "-" + t;
        (w = e.plotLinesAndBandsGroups[O]) || (e.plotLinesAndBandsGroups[O] = w = r.g("plot-" + O).attr(C).add());
        P && (a.svgElem = D = r.path().attr(S).add(w));
        if (x) x = e.getPlotLinePath({
          value: m,
          lineWidth: D.strokeWidth(),
          acrossPanes: p.acrossPanes
        });else if (I) x = e.getPlotBandPath(d, g, p);else return;
        !a.eventsAdded && v && (n(v, function (b, d) {
          D.on(d, function (b) {
            v[d].apply(a, [b]);
          });
        }), a.eventsAdded = !0);
        (P || !D.d) && x && x.length ? D.attr({
          d: x
        }) : D && (x ? (D.show(!0), D.animate({
          d: x
        })) : D.d && (D.hide(), b && (a.label = b = b.destroy())));
        l && (y(l.text) || y(l.formatter)) && x && x.length && 0 < e.width && 0 < e.height && !x.isFlat ? (l = q({
          align: f && I && "center",
          x: f ? !I && 4 : 10,
          verticalAlign: !f && I && "middle",
          y: f ? I ? 16 : 10 : I ? 6 : -4,
          rotation: f && !I && 90
        }, l), this.renderLabel(l, x, I, t)) : b && b.hide();
        return a;
      };
      e.prototype.renderLabel = function (a, e, f, k) {
        var c = this.axis,
          h = c.chart.renderer,
          n = this.label;
        n || (this.label = n = h.text(this.getLabelText(a), 0, 0, a.useHTML).attr({
          align: a.textAlign || a.align,
          rotation: a.rotation,
          "class": "highcharts-plot-" + (f ? "band" : "line") + "-label " + (a.className || ""),
          zIndex: k
        }).add(), c.chart.styledMode || n.css(q({
          textOverflow: "ellipsis"
        }, a.style)));
        k = e.xBounds || [e[0][1], e[1][1], f ? e[2][1] : e[0][1]];
        e = e.yBounds || [e[0][2], e[1][2], f ? e[2][2] : e[0][2]];
        f = F(k);
        h = F(e);
        n.align(a, !1, {
          x: f,
          y: h,
          width: v(k) - f,
          height: v(e) - h
        });
        n.alignValue && "left" !== n.alignValue || n.css({
          width: (90 === n.rotation ? c.height - (n.alignAttr.y - c.top) : c.width - (n.alignAttr.x - c.left)) + "px"
        });
        n.show(!0);
      };
      e.prototype.getLabelText = function (a) {
        return y(a.formatter) ? a.formatter.call(this) : a.text;
      };
      e.prototype.destroy = function () {
        H(this.axis.plotLinesAndBands, this);
        delete this.axis;
        G(this);
      };
      return e;
    }();
    "";
    "";
    return u;
  });
  M(a, "Core/Tooltip.js", [a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function (a, u, z, F, y) {
    var v = a.format,
      H = u.doc,
      A = z.distribute,
      q = y.addEvent,
      n = y.clamp,
      k = y.css,
      e = y.defined,
      c = y.discardElement,
      h = y.extend,
      f = y.fireEvent,
      w = y.isArray,
      p = y.isNumber,
      B = y.isString,
      t = y.merge,
      J = y.pick,
      C = y.splat,
      r = y.syncTimeout;
    a = function () {
      function a(b, a) {
        this.allowShared = !0;
        this.container = void 0;
        this.crosshairs = [];
        this.distance = 0;
        this.isHidden = !0;
        this.isSticky = !1;
        this.now = {};
        this.options = {};
        this.outside = !1;
        this.chart = b;
        this.init(b, a);
      }
      a.prototype.applyFilter = function () {
        var b = this.chart;
        b.renderer.definition({
          tagName: "filter",
          attributes: {
            id: "drop-shadow-" + b.index,
            opacity: .5
          },
          children: [{
            tagName: "feGaussianBlur",
            attributes: {
              "in": "SourceAlpha",
              stdDeviation: 1
            }
          }, {
            tagName: "feOffset",
            attributes: {
              dx: 1,
              dy: 1
            }
          }, {
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncA",
              attributes: {
                type: "linear",
                slope: .3
              }
            }]
          }, {
            tagName: "feMerge",
            children: [{
              tagName: "feMergeNode"
            }, {
              tagName: "feMergeNode",
              attributes: {
                "in": "SourceGraphic"
              }
            }]
          }]
        });
      };
      a.prototype.bodyFormatter = function (b) {
        return b.map(function (b) {
          var a = b.series.tooltipOptions;
          return (a[(b.point.formatPrefix || "point") + "Formatter"] || b.point.tooltipFormatter).call(b.point, a[(b.point.formatPrefix || "point") + "Format"] || "");
        });
      };
      a.prototype.cleanSplit = function (b) {
        this.chart.series.forEach(function (a) {
          var d = a && a.tt;
          d && (!d.isActive || b ? a.tt = d.destroy() : d.isActive = !1);
        });
      };
      a.prototype.defaultFormatter = function (b) {
        var a = this.points || C(this);
        var d = [b.tooltipFooterHeaderFormatter(a[0])];
        d = d.concat(b.bodyFormatter(a));
        d.push(b.tooltipFooterHeaderFormatter(a[0], !0));
        return d;
      };
      a.prototype.destroy = function () {
        this.label && (this.label = this.label.destroy());
        this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());
        this.renderer && (this.renderer = this.renderer.destroy(), c(this.container));
        y.clearTimeout(this.hideTimer);
        y.clearTimeout(this.tooltipTimeout);
      };
      a.prototype.getAnchor = function (b, a) {
        var d = this.chart,
          c = d.pointer,
          e = d.inverted,
          g = d.plotTop,
          l = d.plotLeft,
          f,
          r,
          h = 0,
          k = 0;
        b = C(b);
        this.followPointer && a ? ("undefined" === typeof a.chartX && (a = c.normalize(a)), c = [a.chartX - l, a.chartY - g]) : b[0].tooltipPos ? c = b[0].tooltipPos : (b.forEach(function (b) {
          f = b.series.yAxis;
          r = b.series.xAxis;
          h += b.plotX || 0;
          k += b.plotLow ? (b.plotLow + (b.plotHigh || 0)) / 2 : b.plotY || 0;
          r && f && (e ? (h += g + d.plotHeight - r.len - r.pos, k += l + d.plotWidth - f.len - f.pos) : (h += r.pos - l, k += f.pos - g));
        }), h /= b.length, k /= b.length, c = [e ? d.plotWidth - k : h, e ? d.plotHeight - h : k], this.shared && 1 < b.length && a && (e ? c[0] = a.chartX - l : c[1] = a.chartY - g));
        return c.map(Math.round);
      };
      a.prototype.getLabel = function () {
        var b = this,
          a = this.chart.styledMode,
          d = this.options,
          c = this.split && this.allowShared,
          l = "tooltip" + (e(d.className) ? " " + d.className : ""),
          f = d.style.pointerEvents || (!this.followPointer && d.stickOnContact ? "auto" : "none"),
          r = function () {
            b.inContact = !0;
          },
          h = function (a) {
            var d = b.chart.hoverSeries;
            b.inContact = b.shouldStickOnContact() && b.chart.pointer.inClass(a.relatedTarget, "highcharts-tooltip");
            if (!b.inContact && d && d.onMouseOut) d.onMouseOut();
          },
          p,
          n = this.chart.renderer;
        if (b.label) {
          var t = !b.label.hasClass("highcharts-label");
          (c && !t || !c && t) && b.destroy();
        }
        if (!this.label) {
          if (this.outside) {
            t = this.chart.options.chart.style;
            var C = F.getRendererType();
            this.container = p = u.doc.createElement("div");
            p.className = "highcharts-tooltip-container";
            k(p, {
              position: "absolute",
              top: "1px",
              pointerEvents: f,
              zIndex: Math.max(this.options.style.zIndex || 0, (t && t.zIndex || 0) + 3)
            });
            q(p, "mouseenter", r);
            q(p, "mouseleave", h);
            u.doc.body.appendChild(p);
            this.renderer = n = new C(p, 0, 0, t, void 0, void 0, n.styledMode);
          }
          c ? this.label = n.g(l) : (this.label = n.label("", 0, 0, d.shape, void 0, void 0, d.useHTML, void 0, l).attr({
            padding: d.padding,
            r: d.borderRadius
          }), a || this.label.attr({
            fill: d.backgroundColor,
            "stroke-width": d.borderWidth
          }).css(d.style).css({
            pointerEvents: f
          }).shadow(d.shadow));
          a && d.shadow && (this.applyFilter(), this.label.attr({
            filter: "url(#drop-shadow-" + this.chart.index + ")"
          }));
          if (b.outside && !b.split) {
            var B = this.label,
              w = B.xSetter,
              v = B.ySetter;
            B.xSetter = function (a) {
              w.call(B, b.distance);
              p.style.left = a + "px";
            };
            B.ySetter = function (a) {
              v.call(B, b.distance);
              p.style.top = a + "px";
            };
          }
          this.label.on("mouseenter", r).on("mouseleave", h).attr({
            zIndex: 8
          }).add();
        }
        return this.label;
      };
      a.prototype.getPosition = function (b, a, d) {
        var c = this.chart,
          e = this.distance,
          g = {},
          l = c.inverted && d.h || 0,
          f = this.outside,
          r = f ? H.documentElement.clientWidth - 2 * e : c.chartWidth,
          h = f ? Math.max(H.body.scrollHeight, H.documentElement.scrollHeight, H.body.offsetHeight, H.documentElement.offsetHeight, H.documentElement.clientHeight) : c.chartHeight,
          k = c.pointer.getChartPosition(),
          p = function (g) {
            var m = "x" === g;
            return [g, m ? r : h, m ? b : a].concat(f ? [m ? b * k.scaleX : a * k.scaleY, m ? k.left - e + (d.plotX + c.plotLeft) * k.scaleX : k.top - e + (d.plotY + c.plotTop) * k.scaleY, 0, m ? r : h] : [m ? b : a, m ? d.plotX + c.plotLeft : d.plotY + c.plotTop, m ? c.plotLeft : c.plotTop, m ? c.plotLeft + c.plotWidth : c.plotTop + c.plotHeight]);
          },
          n = p("y"),
          t = p("x"),
          C;
        p = !!d.negative;
        !c.polar && c.hoverSeries && c.hoverSeries.yAxis && c.hoverSeries.yAxis.reversed && (p = !p);
        var q = !this.followPointer && J(d.ttBelow, !c.inverted === p),
          B = function (b, a, d, c, m, r, h) {
            var x = f ? "y" === b ? e * k.scaleY : e * k.scaleX : e,
              D = (d - c) / 2,
              p = c < m - e,
              E = m + e + c < a,
              n = m - x - d + D;
            m = m + x - D;
            if (q && E) g[b] = m;else if (!q && p) g[b] = n;else if (p) g[b] = Math.min(h - c, 0 > n - l ? n : n - l);else if (E) g[b] = Math.max(r, m + l + d > a ? m : m + l);else return !1;
          },
          w = function (b, a, d, c, m) {
            var l;
            m < e || m > a - e ? l = !1 : g[b] = m < d / 2 ? 1 : m > a - c / 2 ? a - c - 2 : m - d / 2;
            return l;
          },
          E = function (b) {
            var a = n;
            n = t;
            t = a;
            C = b;
          },
          T = function () {
            !1 !== B.apply(0, n) ? !1 !== w.apply(0, t) || C || (E(!0), T()) : C ? g.x = g.y = 0 : (E(!0), T());
          };
        (c.inverted || 1 < this.len) && E();
        T();
        return g;
      };
      a.prototype.hide = function (b) {
        var a = this;
        y.clearTimeout(this.hideTimer);
        b = J(b, this.options.hideDelay);
        this.isHidden || (this.hideTimer = r(function () {
          a.getLabel().fadeOut(b ? void 0 : b);
          a.isHidden = !0;
        }, b));
      };
      a.prototype.init = function (b, a) {
        this.chart = b;
        this.options = a;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.split = a.split && !b.inverted && !b.polar;
        this.shared = a.shared || this.split;
        this.outside = J(a.outside, !(!b.scrollablePixelsX && !b.scrollablePixelsY));
      };
      a.prototype.shouldStickOnContact = function () {
        return !(this.followPointer || !this.options.stickOnContact);
      };
      a.prototype.isStickyOnContact = function () {
        return !(!this.shouldStickOnContact() || !this.inContact);
      };
      a.prototype.move = function (b, a, d, c) {
        var e = this,
          g = e.now,
          m = !1 !== e.options.animation && !e.isHidden && (1 < Math.abs(b - g.x) || 1 < Math.abs(a - g.y)),
          l = e.followPointer || 1 < e.len;
        h(g, {
          x: m ? (2 * g.x + b) / 3 : b,
          y: m ? (g.y + a) / 2 : a,
          anchorX: l ? void 0 : m ? (2 * g.anchorX + d) / 3 : d,
          anchorY: l ? void 0 : m ? (g.anchorY + c) / 2 : c
        });
        e.getLabel().attr(g);
        e.drawTracker();
        m && (y.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
          e && e.move(b, a, d, c);
        }, 32));
      };
      a.prototype.refresh = function (b, a) {
        var d = this.chart,
          c = this.options,
          e = C(b),
          g = e[0],
          l = [],
          r = c.formatter || this.defaultFormatter,
          h = this.shared,
          k = d.styledMode,
          p = {};
        if (c.enabled) {
          y.clearTimeout(this.hideTimer);
          this.allowShared = !(!w(b) && b.series && b.series.noSharedTooltip);
          this.followPointer = !this.split && g.series.tooltipOptions.followPointer;
          b = this.getAnchor(b, a);
          var n = b[0],
            t = b[1];
          h && this.allowShared ? (d.pointer.applyInactiveState(e), e.forEach(function (b) {
            b.setState("hover");
            l.push(b.getLabelConfig());
          }), p = {
            x: g.category,
            y: g.y
          }, p.points = l) : p = g.getLabelConfig();
          this.len = l.length;
          r = r.call(p, this);
          h = g.series;
          this.distance = J(h.tooltipOptions.distance, 16);
          if (!1 === r) this.hide();else {
            if (this.split && this.allowShared) this.renderSplit(r, e);else {
              var q = n,
                B = t;
              a && d.pointer.isDirectTouch && (q = a.chartX - d.plotLeft, B = a.chartY - d.plotTop);
              if (d.polar || !1 === h.options.clip || e.some(function (b) {
                return b.series.shouldShowTooltip(q, B);
              })) a = this.getLabel(), c.style.width && !k || a.css({
                width: this.chart.spacingBox.width + "px"
              }), a.attr({
                text: r && r.join ? r.join("") : r
              }), a.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + J(g.colorIndex, h.colorIndex)), k || a.attr({
                stroke: c.borderColor || g.color || h.color || "#666666"
              }), this.updatePosition({
                plotX: n,
                plotY: t,
                negative: g.negative,
                ttBelow: g.ttBelow,
                h: b[2] || 0
              });else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({
              opacity: 1
            }).show();
            this.isHidden = !1;
          }
          f(this, "refresh");
        }
      };
      a.prototype.renderSplit = function (b, a) {
        function d(b, a, d, e, g) {
          void 0 === g && (g = !0);
          d ? (a = X ? 0 : G, b = n(b - e / 2, N.left, N.right - e - (c.outside ? R : 0))) : (a -= z, b = g ? b - e - y : b + y, b = n(b, g ? b : N.left, N.right));
          return {
            x: b,
            y: a
          };
        }
        var c = this,
          e = c.chart,
          g = c.chart,
          l = g.chartWidth,
          f = g.chartHeight,
          r = g.plotHeight,
          k = g.plotLeft,
          p = g.plotTop,
          t = g.pointer,
          C = g.scrollablePixelsY;
        C = void 0 === C ? 0 : C;
        var q = g.scrollablePixelsX,
          w = g.scrollingContainer;
        w = void 0 === w ? {
          scrollLeft: 0,
          scrollTop: 0
        } : w;
        var v = w.scrollLeft;
        w = w.scrollTop;
        var u = g.styledMode,
          y = c.distance,
          E = c.options,
          T = c.options.positioner,
          N = c.outside && "number" !== typeof q ? H.documentElement.getBoundingClientRect() : {
            left: v,
            right: v + l,
            top: w,
            bottom: w + f
          },
          V = c.getLabel(),
          W = this.renderer || e.renderer,
          X = !(!e.xAxis[0] || !e.xAxis[0].opposite);
        e = t.getChartPosition();
        var R = e.left;
        e = e.top;
        var z = p + w,
          aa = 0,
          G = r - C;
        B(b) && (b = [!1, b]);
        b = b.slice(0, a.length + 1).reduce(function (b, e, g) {
          if (!1 !== e && "" !== e) {
            g = a[g - 1] || {
              isHeader: !0,
              plotX: a[0].plotX,
              plotY: r,
              series: {}
            };
            var m = g.isHeader,
              l = m ? c : g.series;
            e = e.toString();
            var f = l.tt,
              h = g.isHeader;
            var x = g.series;
            var D = "highcharts-color-" + J(g.colorIndex, x.colorIndex, "none");
            f || (f = {
              padding: E.padding,
              r: E.borderRadius
            }, u || (f.fill = E.backgroundColor, f["stroke-width"] = E.borderWidth), f = W.label("", 0, 0, E[h ? "headerShape" : "shape"], void 0, void 0, E.useHTML).addClass((h ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + D).attr(f).add(V));
            f.isActive = !0;
            f.attr({
              text: e
            });
            u || f.css(E.style).shadow(E.shadow).attr({
              stroke: E.borderColor || g.color || x.color || "#333333"
            });
            l = l.tt = f;
            h = l.getBBox();
            e = h.width + l.strokeWidth();
            m && (aa = h.height, G += aa, X && (z -= aa));
            x = g.plotX;
            x = void 0 === x ? 0 : x;
            D = g.plotY;
            D = void 0 === D ? 0 : D;
            f = g.series;
            if (g.isHeader) {
              x = k + x;
              var t = p + r / 2;
            } else {
              var I = f.xAxis,
                C = f.yAxis;
              x = I.pos + n(x, -y, I.len + y);
              f.shouldShowTooltip(0, C.pos - p + D, {
                ignoreX: !0
              }) && (t = C.pos + D);
            }
            x = n(x, N.left - y, N.right + y);
            "number" === typeof t ? (h = h.height + 1, D = T ? T.call(c, e, h, g) : d(x, t, m, e), b.push({
              align: T ? 0 : void 0,
              anchorX: x,
              anchorY: t,
              boxWidth: e,
              point: g,
              rank: J(D.rank, m ? 1 : 0),
              size: h,
              target: D.y,
              tt: l,
              x: D.x
            })) : l.isActive = !1;
          }
          return b;
        }, []);
        !T && b.some(function (b) {
          var a = (c.outside ? R : 0) + b.anchorX;
          return a < N.left && a + b.boxWidth < N.right ? !0 : a < R - N.left + b.boxWidth && N.right - a > a;
        }) && (b = b.map(function (b) {
          var a = d(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
          return h(b, {
            target: a.y,
            x: a.x
          });
        }));
        c.cleanSplit();
        A(b, G);
        var F = R,
          ba = R;
        b.forEach(function (b) {
          var a = b.x,
            d = b.boxWidth;
          b = b.isHeader;
          b || (c.outside && R + a < F && (F = R + a), !b && c.outside && F + d > ba && (ba = R + a));
        });
        b.forEach(function (b) {
          var a = b.x,
            d = b.anchorX,
            e = b.pos,
            g = b.point.isHeader;
          e = {
            visibility: "undefined" === typeof e ? "hidden" : "inherit",
            x: a,
            y: e + z,
            anchorX: d,
            anchorY: b.anchorY
          };
          if (c.outside && a < d) {
            var m = R - F;
            0 < m && (g || (e.x = a + m, e.anchorX = d + m), g && (e.x = (ba - F) / 2, e.anchorX = d + m));
          }
          b.tt.attr(e);
        });
        b = c.container;
        C = c.renderer;
        c.outside && b && C && (g = V.getBBox(), C.setSize(g.width + g.x, g.height + g.y, !1), b.style.left = F + "px", b.style.top = e + "px");
      };
      a.prototype.drawTracker = function () {
        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
          var b = this.chart,
            a = this.label,
            d = this.shared ? b.hoverPoints : b.hoverPoint;
          if (a && d) {
            var c = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
            d = this.getAnchor(d);
            var e = a.getBBox();
            d[0] += b.plotLeft - a.translateX;
            d[1] += b.plotTop - a.translateY;
            c.x = Math.min(0, d[0]);
            c.y = Math.min(0, d[1]);
            c.width = 0 > d[0] ? Math.max(Math.abs(d[0]), e.width - d[0]) : Math.max(Math.abs(d[0]), e.width);
            c.height = 0 > d[1] ? Math.max(Math.abs(d[1]), e.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), e.height);
            this.tracker ? this.tracker.attr(c) : (this.tracker = a.renderer.rect(c).addClass("highcharts-tracker").add(a), b.styledMode || this.tracker.attr({
              fill: "rgba(0,0,0,0)"
            }));
          }
        }
      };
      a.prototype.styledModeFormat = function (b) {
        return b.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
      };
      a.prototype.tooltipFooterHeaderFormatter = function (b, a) {
        var d = b.series,
          c = d.tooltipOptions,
          e = d.xAxis,
          g = e && e.dateTime;
        e = {
          isFooter: a,
          labelConfig: b
        };
        var l = c.xDateFormat,
          r = c[a ? "footerFormat" : "headerFormat"];
        f(this, "headerFormatter", e, function (a) {
          g && !l && p(b.key) && (l = g.getXDateFormat(b.key, c.dateTimeLabelFormats));
          g && l && (b.point && b.point.tooltipDateKeys || ["key"]).forEach(function (b) {
            r = r.replace("{point." + b + "}", "{point." + b + ":" + l + "}");
          });
          d.chart.styledMode && (r = this.styledModeFormat(r));
          a.text = v(r, {
            point: b,
            series: d
          }, this.chart);
        });
        return e.text;
      };
      a.prototype.update = function (b) {
        this.destroy();
        t(!0, this.chart.options.tooltip.userOptions, b);
        this.init(this.chart, t(!0, this.options, b));
      };
      a.prototype.updatePosition = function (b) {
        var a = this.chart,
          d = this.options,
          c = a.pointer,
          e = this.getLabel();
        c = c.getChartPosition();
        var l = (d.positioner || this.getPosition).call(this, e.width, e.height, b),
          f = b.plotX + a.plotLeft;
        b = b.plotY + a.plotTop;
        if (this.outside) {
          d = d.borderWidth + 2 * this.distance;
          this.renderer.setSize(e.width + d, e.height + d, !1);
          if (1 !== c.scaleX || 1 !== c.scaleY) k(this.container, {
            transform: "scale(" + c.scaleX + ", " + c.scaleY + ")"
          }), f *= c.scaleX, b *= c.scaleY;
          f += c.left - l.x;
          b += c.top - l.y;
        }
        this.move(Math.round(l.x), Math.round(l.y || 0), f, b);
      };
      return a;
    }();
    "";
    return a;
  });
  M(a, "Core/Series/Point.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Animation/AnimationUtilities.js"], a["Core/DefaultOptions.js"], a["Core/FormatUtilities.js"], a["Core/Utilities.js"]], function (a, u, z, F, y) {
    var v = u.animObject,
      H = z.defaultOptions,
      A = F.format,
      q = y.addEvent,
      n = y.defined,
      k = y.erase,
      e = y.extend,
      c = y.fireEvent,
      h = y.getNestedProperty,
      f = y.isArray,
      w = y.isFunction,
      p = y.isNumber,
      B = y.isObject,
      t = y.merge,
      J = y.objectEach,
      C = y.pick,
      r = y.syncTimeout,
      l = y.removeEvent,
      b = y.uniqueKey;
    u = function () {
      function g() {
        this.colorIndex = this.category = void 0;
        this.formatPrefix = "point";
        this.id = void 0;
        this.isNull = !1;
        this.percentage = this.options = this.name = void 0;
        this.selected = !1;
        this.total = this.series = void 0;
        this.visible = !0;
        this.x = void 0;
      }
      g.prototype.animateBeforeDestroy = function () {
        var b = this,
          a = {
            x: b.startXPos,
            opacity: 0
          },
          c = b.getGraphicalProps();
        c.singular.forEach(function (d) {
          b[d] = b[d].animate("dataLabel" === d ? {
            x: b[d].startXPos,
            y: b[d].startYPos,
            opacity: 0
          } : a);
        });
        c.plural.forEach(function (a) {
          b[a].forEach(function (a) {
            a.element && a.animate(e({
              x: b.startXPos
            }, a.startYPos ? {
              x: a.startXPos,
              y: a.startYPos
            } : {}));
          });
        });
      };
      g.prototype.applyOptions = function (b, a) {
        var d = this.series,
          c = d.options.pointValKey || d.pointValKey;
        b = g.prototype.optionsToObject.call(this, b);
        e(this, b);
        this.options = this.options ? e(this.options, b) : b;
        b.group && delete this.group;
        b.dataLabels && delete this.dataLabels;
        c && (this.y = g.prototype.getNestedProperty.call(this, c));
        this.formatPrefix = (this.isNull = C(this.isValid && !this.isValid(), null === this.x || !p(this.y))) ? "null" : "point";
        this.selected && (this.state = "select");
        "name" in this && "undefined" === typeof a && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));
        "undefined" === typeof this.x && d ? this.x = "undefined" === typeof a ? d.autoIncrement() : a : p(b.x) && d.options.relativeXValue && (this.x = d.autoIncrement(b.x));
        return this;
      };
      g.prototype.destroy = function () {
        function b() {
          if (a.graphic || a.dataLabel || a.dataLabels) l(a), a.destroyElements();
          for (h in a) a[h] = null;
        }
        var a = this,
          c = a.series,
          e = c.chart;
        c = c.options.dataSorting;
        var g = e.hoverPoints,
          f = v(a.series.chart.renderer.globalAnimation),
          h;
        a.legendItem && e.legend.destroyItem(a);
        g && (a.setState(), k(g, a), g.length || (e.hoverPoints = null));
        if (a === e.hoverPoint) a.onMouseOut();
        c && c.enabled ? (this.animateBeforeDestroy(), r(b, f.duration)) : b();
        e.pointCount--;
      };
      g.prototype.destroyElements = function (b) {
        var a = this;
        b = a.getGraphicalProps(b);
        b.singular.forEach(function (b) {
          a[b] = a[b].destroy();
        });
        b.plural.forEach(function (b) {
          a[b].forEach(function (b) {
            b.element && b.destroy();
          });
          delete a[b];
        });
      };
      g.prototype.firePointEvent = function (b, a, e) {
        var d = this,
          g = this.series.options;
        (g.point.events[b] || d.options && d.options.events && d.options.events[b]) && d.importEvents();
        "click" === b && g.allowPointSelect && (e = function (b) {
          d.select && d.select(null, b.ctrlKey || b.metaKey || b.shiftKey);
        });
        c(d, b, a, e);
      };
      g.prototype.getClassName = function () {
        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
      };
      g.prototype.getGraphicalProps = function (b) {
        var a = this,
          d = [],
          c = {
            singular: [],
            plural: []
          },
          e;
        b = b || {
          graphic: 1,
          dataLabel: 1
        };
        b.graphic && d.push("graphic", "upperGraphic", "shadowGroup");
        b.dataLabel && d.push("dataLabel", "dataLabelUpper", "connector");
        for (e = d.length; e--;) {
          var g = d[e];
          a[g] && c.singular.push(g);
        }
        ["dataLabel", "connector"].forEach(function (d) {
          var e = d + "s";
          b[d] && a[e] && c.plural.push(e);
        });
        return c;
      };
      g.prototype.getLabelConfig = function () {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      };
      g.prototype.getNestedProperty = function (b) {
        if (b) return 0 === b.indexOf("custom.") ? h(b, this.options) : this[b];
      };
      g.prototype.getZone = function () {
        var b = this.series,
          a = b.zones;
        b = b.zoneAxis || "y";
        var c,
          e = 0;
        for (c = a[e]; this[b] >= c.value;) c = a[++e];
        this.nonZonedColor || (this.nonZonedColor = this.color);
        this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;
        return c;
      };
      g.prototype.hasNewShapeType = function () {
        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
      };
      g.prototype.init = function (a, e, g) {
        this.series = a;
        this.applyOptions(e, g);
        this.id = n(this.id) ? this.id : b();
        this.resolveColor();
        a.chart.pointCount++;
        c(this, "afterInit");
        return this;
      };
      g.prototype.optionsToObject = function (b) {
        var a = this.series,
          d = a.options.keys,
          c = d || a.pointArrayMap || ["y"],
          e = c.length,
          l = {},
          r = 0,
          h = 0;
        if (p(b) || null === b) l[c[0]] = b;else if (f(b)) for (!d && b.length > e && (a = typeof b[0], "string" === a ? l.name = b[0] : "number" === a && (l.x = b[0]), r++); h < e;) d && "undefined" === typeof b[r] || (0 < c[h].indexOf(".") ? g.prototype.setNestedProperty(l, b[r], c[h]) : l[c[h]] = b[r]), r++, h++;else "object" === typeof b && (l = b, b.dataLabels && (a._hasPointLabels = !0), b.marker && (a._hasPointMarkers = !0));
        return l;
      };
      g.prototype.resolveColor = function () {
        var b = this.series,
          a = b.chart.styledMode;
        var c = b.chart.options.chart.colorCount;
        delete this.nonZonedColor;
        if (b.options.colorByPoint) {
          if (!a) {
            c = b.options.colors || b.chart.options.colors;
            var e = c[b.colorCounter];
            c = c.length;
          }
          a = b.colorCounter;
          b.colorCounter++;
          b.colorCounter === c && (b.colorCounter = 0);
        } else a || (e = b.color), a = b.colorIndex;
        this.colorIndex = C(this.options.colorIndex, a);
        this.color = C(this.options.color, e);
      };
      g.prototype.setNestedProperty = function (b, a, c) {
        c.split(".").reduce(function (b, d, c, e) {
          b[d] = e.length - 1 === c ? a : B(b[d], !0) ? b[d] : {};
          return b[d];
        }, b);
        return b;
      };
      g.prototype.tooltipFormatter = function (b) {
        var a = this.series,
          d = a.tooltipOptions,
          c = C(d.valueDecimals, ""),
          e = d.valuePrefix || "",
          g = d.valueSuffix || "";
        a.chart.styledMode && (b = a.chart.tooltip.styledModeFormat(b));
        (a.pointArrayMap || ["y"]).forEach(function (a) {
          a = "{point." + a;
          if (e || g) b = b.replace(RegExp(a + "}", "g"), e + a + "}" + g);
          b = b.replace(RegExp(a + "}", "g"), a + ":,." + c + "f}");
        });
        return A(b, {
          point: this,
          series: this.series
        }, a.chart);
      };
      g.prototype.update = function (b, a, c, e) {
        function d() {
          g.applyOptions(b);
          var d = m && g.hasDummyGraphic;
          d = null === g.y ? !d : d;
          m && d && (g.graphic = m.destroy(), delete g.hasDummyGraphic);
          B(b, !0) && (m && m.element && b && b.marker && "undefined" !== typeof b.marker.symbol && (g.graphic = m.destroy()), b && b.dataLabels && g.dataLabel && (g.dataLabel = g.dataLabel.destroy()), g.connector && (g.connector = g.connector.destroy()));
          h = g.index;
          l.updateParallelArrays(g, h);
          r.data[h] = B(r.data[h], !0) || B(b, !0) ? g.options : C(b, r.data[h]);
          l.isDirty = l.isDirtyData = !0;
          !l.fixedBox && l.hasCartesianSeries && (f.isDirtyBox = !0);
          "point" === r.legendType && (f.isDirtyLegend = !0);
          a && f.redraw(c);
        }
        var g = this,
          l = g.series,
          m = g.graphic,
          f = l.chart,
          r = l.options,
          h;
        a = C(a, !0);
        !1 === e ? d() : g.firePointEvent("update", {
          options: b
        }, d);
      };
      g.prototype.remove = function (b, a) {
        this.series.removePoint(this.series.data.indexOf(this), b, a);
      };
      g.prototype.select = function (b, a) {
        var d = this,
          c = d.series,
          e = c.chart;
        this.selectedStaging = b = C(b, !d.selected);
        d.firePointEvent(b ? "select" : "unselect", {
          accumulate: a
        }, function () {
          d.selected = d.options.selected = b;
          c.options.data[c.data.indexOf(d)] = d.options;
          d.setState(b && "select");
          a || e.getSelectedPoints().forEach(function (b) {
            var a = b.series;
            b.selected && b !== d && (b.selected = b.options.selected = !1, a.options.data[a.data.indexOf(b)] = b.options, b.setState(e.hoverPoints && a.options.inactiveOtherPoints ? "inactive" : ""), b.firePointEvent("unselect"));
          });
        });
        delete this.selectedStaging;
      };
      g.prototype.onMouseOver = function (b) {
        var a = this.series.chart,
          d = a.pointer;
        b = b ? d.normalize(b) : d.getChartCoordinatesFromPoint(this, a.inverted);
        d.runPointActions(b, this);
      };
      g.prototype.onMouseOut = function () {
        var b = this.series.chart;
        this.firePointEvent("mouseOut");
        this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function (b) {
          b.setState();
        });
        b.hoverPoints = b.hoverPoint = null;
      };
      g.prototype.importEvents = function () {
        if (!this.hasImportedEvents) {
          var b = this,
            a = t(b.series.options.point, b.options).events;
          b.events = a;
          J(a, function (a, d) {
            w(a) && q(b, d, a);
          });
          this.hasImportedEvents = !0;
        }
      };
      g.prototype.setState = function (b, g) {
        var d = this.series,
          l = this.state,
          m = d.options.states[b || "normal"] || {},
          f = H.plotOptions[d.type].marker && d.options.marker,
          r = f && !1 === f.enabled,
          h = f && f.states && f.states[b || "normal"] || {},
          k = !1 === h.enabled,
          n = this.marker || {},
          t = d.chart,
          q = f && d.markerAttribs,
          w = d.halo,
          B,
          v = d.stateMarkerGraphic;
        b = b || "";
        if (!(b === this.state && !g || this.selected && "select" !== b || !1 === m.enabled || b && (k || r && !1 === h.enabled) || b && n.states && n.states[b] && !1 === n.states[b].enabled)) {
          this.state = b;
          q && (B = d.markerAttribs(this, b));
          if (this.graphic && !this.hasDummyGraphic) {
            l && this.graphic.removeClass("highcharts-point-" + l);
            b && this.graphic.addClass("highcharts-point-" + b);
            if (!t.styledMode) {
              var J = d.pointAttribs(this, b);
              var E = C(t.options.chart.animation, m.animation);
              d.options.inactiveOtherPoints && p(J.opacity) && ((this.dataLabels || []).forEach(function (b) {
                b && b.animate({
                  opacity: J.opacity
                }, E);
              }), this.connector && this.connector.animate({
                opacity: J.opacity
              }, E));
              this.graphic.animate(J, E);
            }
            B && this.graphic.animate(B, C(t.options.chart.animation, h.animation, f.animation));
            v && v.hide();
          } else {
            if (b && h) {
              l = n.symbol || d.symbol;
              v && v.currentSymbol !== l && (v = v.destroy());
              if (B) if (v) v[g ? "animate" : "attr"]({
                x: B.x,
                y: B.y
              });else l && (d.stateMarkerGraphic = v = t.renderer.symbol(l, B.x, B.y, B.width, B.height).add(d.markerGroup), v.currentSymbol = l);
              !t.styledMode && v && "inactive" !== this.state && v.attr(d.pointAttribs(this, b));
            }
            v && (v[b && this.isInside ? "show" : "hide"](), v.element.point = this, v.addClass(this.getClassName(), !0));
          }
          m = m.halo;
          B = (v = this.graphic || v) && v.visibility || "inherit";
          m && m.size && v && "hidden" !== B && !this.isCluster ? (w || (d.halo = w = t.renderer.path().add(v.parentGroup)), w.show()[g ? "animate" : "attr"]({
            d: this.haloPath(m.size)
          }), w.attr({
            "class": "highcharts-halo highcharts-color-" + C(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: B,
            zIndex: -1
          }), w.point = this, t.styledMode || w.attr(e({
            fill: this.color || d.color,
            "fill-opacity": m.opacity
          }, a.filterUserAttributes(m.attributes || {})))) : w && w.point && w.point.haloPath && w.animate({
            d: w.point.haloPath(0)
          }, null, w.hide);
          c(this, "afterSetState", {
            state: b
          });
        }
      };
      g.prototype.haloPath = function (b) {
        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - b, this.plotY - b, 2 * b, 2 * b);
      };
      return g;
    }();
    "";
    return u;
  });
  M(a, "Core/Pointer.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Tooltip.js"], a["Core/Utilities.js"]], function (a, u, z, F) {
    var v = a.parse,
      G = u.charts,
      H = u.noop,
      A = F.addEvent,
      q = F.attr,
      n = F.css,
      k = F.defined,
      e = F.extend,
      c = F.find,
      h = F.fireEvent,
      f = F.isNumber,
      w = F.isObject,
      p = F.objectEach,
      B = F.offset,
      t = F.pick,
      J = F.splat;
    a = function () {
      function a(a, c) {
        this.lastValidTouch = {};
        this.pinchDown = [];
        this.runChartClick = !1;
        this.eventsToUnbind = [];
        this.chart = a;
        this.hasDragged = !1;
        this.options = c;
        this.init(a, c);
      }
      a.prototype.applyInactiveState = function (a) {
        var c = [],
          b;
        (a || []).forEach(function (a) {
          b = a.series;
          c.push(b);
          b.linkedParent && c.push(b.linkedParent);
          b.linkedSeries && (c = c.concat(b.linkedSeries));
          b.navigatorSeries && c.push(b.navigatorSeries);
        });
        this.chart.series.forEach(function (b) {
          -1 === c.indexOf(b) ? b.setState("inactive", !0) : b.options.inactiveOtherPoints && b.setAllPointsToState("inactive");
        });
      };
      a.prototype.destroy = function () {
        var c = this;
        this.eventsToUnbind.forEach(function (a) {
          return a();
        });
        this.eventsToUnbind = [];
        u.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
        clearInterval(c.tooltipTimeout);
        p(c, function (a, b) {
          c[b] = void 0;
        });
      };
      a.prototype.drag = function (a) {
        var c = this.chart,
          b = c.options.chart,
          e = this.zoomHor,
          d = this.zoomVert,
          m = c.plotLeft,
          f = c.plotTop,
          h = c.plotWidth,
          r = c.plotHeight,
          k = this.mouseDownX || 0,
          p = this.mouseDownY || 0,
          n = w(b.panning) ? b.panning && b.panning.enabled : b.panning,
          t = b.panKey && a[b.panKey + "Key"],
          q = a.chartX,
          B = a.chartY,
          C = this.selectionMarker;
        if (!C || !C.touch) if (q < m ? q = m : q > m + h && (q = m + h), B < f ? B = f : B > f + r && (B = f + r), this.hasDragged = Math.sqrt(Math.pow(k - q, 2) + Math.pow(p - B, 2)), 10 < this.hasDragged) {
          var J = c.isInsidePlot(k - m, p - f, {
            visiblePlotOnly: !0
          });
          !c.hasCartesianSeries && !c.mapView || !this.zoomX && !this.zoomY || !J || t || C || (this.selectionMarker = C = c.renderer.rect(m, f, e ? 1 : h, d ? 1 : r, 0).attr({
            "class": "highcharts-selection-marker",
            zIndex: 7
          }).add(), c.styledMode || C.attr({
            fill: b.selectionMarkerFill || v("#335cad").setOpacity(.25).get()
          }));
          C && e && (e = q - k, C.attr({
            width: Math.abs(e),
            x: (0 < e ? 0 : e) + k
          }));
          C && d && (e = B - p, C.attr({
            height: Math.abs(e),
            y: (0 < e ? 0 : e) + p
          }));
          J && !C && n && c.pan(a, b.panning);
        }
      };
      a.prototype.dragStart = function (a) {
        var c = this.chart;
        c.mouseIsDown = a.type;
        c.cancelClick = !1;
        c.mouseDownX = this.mouseDownX = a.chartX;
        c.mouseDownY = this.mouseDownY = a.chartY;
      };
      a.prototype.drop = function (a) {
        var c = this,
          b = this.chart,
          g = this.hasPinched;
        if (this.selectionMarker) {
          var d = this.selectionMarker,
            m = d.attr ? d.attr("x") : d.x,
            r = d.attr ? d.attr("y") : d.y,
            p = d.attr ? d.attr("width") : d.width,
            t = d.attr ? d.attr("height") : d.height,
            q = {
              originalEvent: a,
              xAxis: [],
              yAxis: [],
              x: m,
              y: r,
              width: p,
              height: t
            },
            B = !!b.mapView;
          if (this.hasDragged || g) b.axes.forEach(function (b) {
            if (b.zoomEnabled && k(b.min) && (g || c[{
              xAxis: "zoomX",
              yAxis: "zoomY"
            }[b.coll]]) && f(m) && f(r)) {
              var d = b.horiz,
                e = "touchend" === a.type ? b.minPixelPadding : 0,
                l = b.toValue((d ? m : r) + e);
              d = b.toValue((d ? m + p : r + t) - e);
              q[b.coll].push({
                axis: b,
                min: Math.min(l, d),
                max: Math.max(l, d)
              });
              B = !0;
            }
          }), B && h(b, "selection", q, function (a) {
            b.zoom(e(a, g ? {
              animation: !1
            } : null));
          });
          f(b.index) && (this.selectionMarker = this.selectionMarker.destroy());
          g && this.scaleGroups();
        }
        b && f(b.index) && (n(b.container, {
          cursor: b._cursor
        }), b.cancelClick = 10 < this.hasDragged, b.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
      };
      a.prototype.findNearestKDPoint = function (a, c, b) {
        var e = this.chart,
          d = e.hoverPoint;
        e = e.tooltip;
        if (d && e && e.isStickyOnContact()) return d;
        var l;
        a.forEach(function (a) {
          var d = !(a.noSharedTooltip && c) && 0 > a.options.findNearestPointBy.indexOf("y");
          a = a.searchPoint(b, d);
          if ((d = w(a, !0) && a.series) && !(d = !w(l, !0))) {
            d = l.distX - a.distX;
            var e = l.dist - a.dist,
              g = (a.series.group && a.series.group.zIndex) - (l.series.group && l.series.group.zIndex);
            d = 0 < (0 !== d && c ? d : 0 !== e ? e : 0 !== g ? g : l.series.index > a.series.index ? -1 : 1);
          }
          d && (l = a);
        });
        return l;
      };
      a.prototype.getChartCoordinatesFromPoint = function (a, c) {
        var b = a.series,
          e = b.xAxis;
        b = b.yAxis;
        var d = a.shapeArgs;
        if (e && b) {
          var l = t(a.clientX, a.plotX),
            h = a.plotY || 0;
          a.isNode && d && f(d.x) && f(d.y) && (l = d.x, h = d.y);
          return c ? {
            chartX: b.len + b.pos - h,
            chartY: e.len + e.pos - l
          } : {
            chartX: l + e.pos,
            chartY: h + b.pos
          };
        }
        if (d && d.x && d.y) return {
          chartX: d.x,
          chartY: d.y
        };
      };
      a.prototype.getChartPosition = function () {
        if (this.chartPosition) return this.chartPosition;
        var a = this.chart.container,
          c = B(a);
        this.chartPosition = {
          left: c.left,
          top: c.top,
          scaleX: 1,
          scaleY: 1
        };
        var b = a.offsetWidth;
        a = a.offsetHeight;
        2 < b && 2 < a && (this.chartPosition.scaleX = c.width / b, this.chartPosition.scaleY = c.height / a);
        return this.chartPosition;
      };
      a.prototype.getCoordinates = function (a) {
        var c = {
          xAxis: [],
          yAxis: []
        };
        this.chart.axes.forEach(function (b) {
          c[b.isXAxis ? "xAxis" : "yAxis"].push({
            axis: b,
            value: b.toValue(a[b.horiz ? "chartX" : "chartY"])
          });
        });
        return c;
      };
      a.prototype.getHoverData = function (a, e, b, g, d, m) {
        var l = [];
        g = !(!g || !a);
        var f = {
          chartX: m ? m.chartX : void 0,
          chartY: m ? m.chartY : void 0,
          shared: d
        };
        h(this, "beforeGetHoverData", f);
        var r = e && !e.stickyTracking ? [e] : b.filter(function (b) {
          return f.filter ? f.filter(b) : b.visible && !(!d && b.directTouch) && t(b.options.enableMouseTracking, !0) && b.stickyTracking;
        });
        var k = g || !m ? a : this.findNearestKDPoint(r, d, m);
        e = k && k.series;
        k && (d && !e.noSharedTooltip ? (r = b.filter(function (b) {
          return f.filter ? f.filter(b) : b.visible && !(!d && b.directTouch) && t(b.options.enableMouseTracking, !0) && !b.noSharedTooltip;
        }), r.forEach(function (b) {
          var a = c(b.points, function (b) {
            return b.x === k.x && !b.isNull;
          });
          w(a) && (b.chart.isBoosting && (a = b.getPoint(a)), l.push(a));
        })) : l.push(k));
        f = {
          hoverPoint: k
        };
        h(this, "afterGetHoverData", f);
        return {
          hoverPoint: f.hoverPoint,
          hoverSeries: e,
          hoverPoints: l
        };
      };
      a.prototype.getPointFromEvent = function (a) {
        a = a.target;
        for (var c; a && !c;) c = a.point, a = a.parentNode;
        return c;
      };
      a.prototype.onTrackerMouseOut = function (a) {
        a = a.relatedTarget || a.toElement;
        var c = this.chart.hoverSeries;
        this.isDirectTouch = !1;
        if (!(!c || !a || c.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + c.index) && this.inClass(a, "highcharts-tracker"))) c.onMouseOut();
      };
      a.prototype.inClass = function (a, c) {
        for (var b; a;) {
          if (b = q(a, "class")) {
            if (-1 !== b.indexOf(c)) return !0;
            if (-1 !== b.indexOf("highcharts-container")) return !1;
          }
          a = a.parentNode;
        }
      };
      a.prototype.init = function (a, c) {
        this.options = c;
        this.chart = a;
        this.runChartClick = !(!c.chart.events || !c.chart.events.click);
        this.pinchDown = [];
        this.lastValidTouch = {};
        z && (a.tooltip = new z(a, c.tooltip), this.followTouchMove = t(c.tooltip.followTouchMove, !0));
        this.setDOMEvents();
      };
      a.prototype.normalize = function (a, c) {
        var b = a.touches,
          g = b ? b.length ? b.item(0) : t(b.changedTouches, a.changedTouches)[0] : a;
        c || (c = this.getChartPosition());
        b = g.pageX - c.left;
        g = g.pageY - c.top;
        b /= c.scaleX;
        g /= c.scaleY;
        return e(a, {
          chartX: Math.round(b),
          chartY: Math.round(g)
        });
      };
      a.prototype.onContainerClick = function (a) {
        var c = this.chart,
          b = c.hoverPoint;
        a = this.normalize(a);
        var g = c.plotLeft,
          d = c.plotTop;
        c.cancelClick || (b && this.inClass(a.target, "highcharts-tracker") ? (h(b.series, "click", e(a, {
          point: b
        })), c.hoverPoint && b.firePointEvent("click", a)) : (e(a, this.getCoordinates(a)), c.isInsidePlot(a.chartX - g, a.chartY - d, {
          visiblePlotOnly: !0
        }) && h(c, "click", a)));
      };
      a.prototype.onContainerMouseDown = function (a) {
        var c = 1 === ((a.buttons || a.button) & 1);
        a = this.normalize(a);
        if (u.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);
        if ("undefined" === typeof a.button || c) this.zoomOption(a), c && a.preventDefault && a.preventDefault(), this.dragStart(a);
      };
      a.prototype.onContainerMouseLeave = function (c) {
        var e = G[t(a.hoverChartIndex, -1)],
          b = this.chart.tooltip;
        b && b.shouldStickOnContact() && this.inClass(c.relatedTarget, "highcharts-tooltip-container") || (c = this.normalize(c), e && (c.relatedTarget || c.toElement) && (e.pointer.reset(), e.pointer.chartPosition = void 0), b && !b.isHidden && this.reset());
      };
      a.prototype.onContainerMouseEnter = function (a) {
        delete this.chartPosition;
      };
      a.prototype.onContainerMouseMove = function (a) {
        var c = this.chart;
        a = this.normalize(a);
        this.setHoverChartIndex();
        a.preventDefault || (a.returnValue = !1);
        ("mousedown" === c.mouseIsDown || this.touchSelect(a)) && this.drag(a);
        c.openMenu || !this.inClass(a.target, "highcharts-tracker") && !c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
          visiblePlotOnly: !0
        }) || (this.inClass(a.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(a));
      };
      a.prototype.onDocumentTouchEnd = function (c) {
        var e = G[t(a.hoverChartIndex, -1)];
        e && e.pointer.drop(c);
      };
      a.prototype.onContainerTouchMove = function (a) {
        if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);
      };
      a.prototype.onContainerTouchStart = function (a) {
        if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);
      };
      a.prototype.onDocumentMouseMove = function (a) {
        var c = this.chart,
          b = this.chartPosition;
        a = this.normalize(a, b);
        var e = c.tooltip;
        !b || e && e.isStickyOnContact() || c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
          visiblePlotOnly: !0
        }) || this.inClass(a.target, "highcharts-tracker") || this.reset();
      };
      a.prototype.onDocumentMouseUp = function (c) {
        var e = G[t(a.hoverChartIndex, -1)];
        e && e.pointer.drop(c);
      };
      a.prototype.pinch = function (a) {
        var c = this,
          b = c.chart,
          g = c.pinchDown,
          d = a.touches || [],
          m = d.length,
          f = c.lastValidTouch,
          k = c.hasZoom,
          p = {},
          r = 1 === m && (c.inClass(a.target, "highcharts-tracker") && b.runTrackerClick || c.runChartClick),
          n = {},
          q = c.selectionMarker;
        1 < m ? c.initiated = !0 : 1 === m && this.followTouchMove && (c.initiated = !1);
        k && c.initiated && !r && !1 !== a.cancelable && a.preventDefault();
        [].map.call(d, function (b) {
          return c.normalize(b);
        });
        "touchstart" === a.type ? ([].forEach.call(d, function (b, a) {
          g[a] = {
            chartX: b.chartX,
            chartY: b.chartY
          };
        }), f.x = [g[0].chartX, g[1] && g[1].chartX], f.y = [g[0].chartY, g[1] && g[1].chartY], b.axes.forEach(function (a) {
          if (a.zoomEnabled) {
            var d = b.bounds[a.horiz ? "h" : "v"],
              c = a.minPixelPadding,
              e = a.toPixels(Math.min(t(a.options.min, a.dataMin), a.dataMin)),
              g = a.toPixels(Math.max(t(a.options.max, a.dataMax), a.dataMax)),
              m = Math.max(e, g);
            d.min = Math.min(a.pos, Math.min(e, g) - c);
            d.max = Math.max(a.pos + a.len, m + c);
          }
        }), c.res = !0) : c.followTouchMove && 1 === m ? this.runPointActions(c.normalize(a)) : g.length && (h(b, "touchpan", {
          originalEvent: a
        }, function () {
          q || (c.selectionMarker = q = e({
            destroy: H,
            touch: !0
          }, b.plotBox));
          c.pinchTranslate(g, d, p, q, n, f);
          c.hasPinched = k;
          c.scaleGroups(p, n);
        }), c.res && (c.res = !1, this.reset(!1, 0)));
      };
      a.prototype.pinchTranslate = function (a, c, b, e, d, m) {
        this.zoomHor && this.pinchTranslateDirection(!0, a, c, b, e, d, m);
        this.zoomVert && this.pinchTranslateDirection(!1, a, c, b, e, d, m);
      };
      a.prototype.pinchTranslateDirection = function (a, c, b, e, d, m, f, h) {
        var g = this.chart,
          l = a ? "x" : "y",
          k = a ? "X" : "Y",
          p = "chart" + k,
          r = a ? "width" : "height",
          n = g["plot" + (a ? "Left" : "Top")],
          t = g.inverted,
          x = g.bounds[a ? "h" : "v"],
          q = 1 === c.length,
          D = c[0][p],
          B = !q && c[1][p];
        c = function () {
          "number" === typeof v && 20 < Math.abs(D - B) && (C = h || Math.abs(N - v) / Math.abs(D - B));
          E = (n - N) / C + D;
          w = g["plot" + (a ? "Width" : "Height")] / C;
        };
        var w,
          E,
          C = h || 1,
          N = b[0][p],
          v = !q && b[1][p];
        c();
        b = E;
        if (b < x.min) {
          b = x.min;
          var J = !0;
        } else b + w > x.max && (b = x.max - w, J = !0);
        J ? (N -= .8 * (N - f[l][0]), "number" === typeof v && (v -= .8 * (v - f[l][1])), c()) : f[l] = [N, v];
        t || (m[l] = E - n, m[r] = w);
        m = t ? 1 / C : C;
        d[r] = w;
        d[l] = b;
        e[t ? a ? "scaleY" : "scaleX" : "scale" + k] = C;
        e["translate" + k] = m * n + (N - m * D);
      };
      a.prototype.reset = function (a, c) {
        var b = this.chart,
          e = b.hoverSeries,
          d = b.hoverPoint,
          m = b.hoverPoints,
          f = b.tooltip,
          l = f && f.shared ? m : d;
        a && l && J(l).forEach(function (b) {
          b.series.isCartesian && "undefined" === typeof b.plotX && (a = !1);
        });
        if (a) f && l && J(l).length && (f.refresh(l), f.shared && m ? m.forEach(function (b) {
          b.setState(b.state, !0);
          b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));
        }) : d && (d.setState(d.state, !0), b.axes.forEach(function (b) {
          b.crosshair && d.series[b.coll] === b && b.drawCrosshair(null, d);
        })));else {
          if (d) d.onMouseOut();
          m && m.forEach(function (b) {
            b.setState();
          });
          if (e) e.onMouseOut();
          f && f.hide(c);
          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
          b.axes.forEach(function (b) {
            b.hideCrosshair();
          });
          this.hoverX = b.hoverPoints = b.hoverPoint = null;
        }
      };
      a.prototype.runPointActions = function (e, f) {
        var b = this.chart,
          g = b.tooltip && b.tooltip.options.enabled ? b.tooltip : void 0,
          d = g ? g.shared : !1,
          m = f || b.hoverPoint,
          l = m && m.series || b.hoverSeries;
        f = this.getHoverData(m, l, b.series, (!e || "touchmove" !== e.type) && (!!f || l && l.directTouch && this.isDirectTouch), d, e);
        m = f.hoverPoint;
        l = f.hoverSeries;
        var h = f.hoverPoints;
        f = l && l.tooltipOptions.followPointer && !l.tooltipOptions.split;
        d = d && l && !l.noSharedTooltip;
        if (m && (m !== b.hoverPoint || g && g.isHidden)) {
          (b.hoverPoints || []).forEach(function (b) {
            -1 === h.indexOf(b) && b.setState();
          });
          if (b.hoverSeries !== l) l.onMouseOver();
          this.applyInactiveState(h);
          (h || []).forEach(function (b) {
            b.setState("hover");
          });
          b.hoverPoint && b.hoverPoint.firePointEvent("mouseOut");
          if (!m.series) return;
          b.hoverPoints = h;
          b.hoverPoint = m;
          m.firePointEvent("mouseOver");
          g && g.refresh(d ? h : m, e);
        } else f && g && !g.isHidden && (m = g.getAnchor([{}], e), b.isInsidePlot(m[0], m[1], {
          visiblePlotOnly: !0
        }) && g.updatePosition({
          plotX: m[0],
          plotY: m[1]
        }));
        this.unDocMouseMove || (this.unDocMouseMove = A(b.container.ownerDocument, "mousemove", function (b) {
          var d = G[a.hoverChartIndex];
          if (d) d.pointer.onDocumentMouseMove(b);
        }), this.eventsToUnbind.push(this.unDocMouseMove));
        b.axes.forEach(function (a) {
          var d = t((a.crosshair || {}).snap, !0),
            g;
          d && ((g = b.hoverPoint) && g.series[a.coll] === a || (g = c(h, function (b) {
            return b.series[a.coll] === a;
          })));
          g || !d ? a.drawCrosshair(e, g) : a.hideCrosshair();
        });
      };
      a.prototype.scaleGroups = function (a, c) {
        var b = this.chart;
        b.series.forEach(function (e) {
          var d = a || e.getPlotBox();
          e.group && (e.xAxis && e.xAxis.zoomEnabled || b.mapView) && (e.group.attr(d), e.markerGroup && (e.markerGroup.attr(d), e.markerGroup.clip(c ? b.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(d));
        });
        b.clipRect.attr(c || b.clipBox);
      };
      a.prototype.setDOMEvents = function () {
        var c = this,
          e = this.chart.container,
          b = e.ownerDocument;
        e.onmousedown = this.onContainerMouseDown.bind(this);
        e.onmousemove = this.onContainerMouseMove.bind(this);
        e.onclick = this.onContainerClick.bind(this);
        this.eventsToUnbind.push(A(e, "mouseenter", this.onContainerMouseEnter.bind(this)));
        this.eventsToUnbind.push(A(e, "mouseleave", this.onContainerMouseLeave.bind(this)));
        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = A(b, "mouseup", this.onDocumentMouseUp.bind(this)));
        for (var g = this.chart.renderTo.parentElement; g && "BODY" !== g.tagName;) this.eventsToUnbind.push(A(g, "scroll", function () {
          delete c.chartPosition;
        })), g = g.parentElement;
        u.hasTouch && (this.eventsToUnbind.push(A(e, "touchstart", this.onContainerTouchStart.bind(this), {
          passive: !1
        })), this.eventsToUnbind.push(A(e, "touchmove", this.onContainerTouchMove.bind(this), {
          passive: !1
        })), a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = A(b, "touchend", this.onDocumentTouchEnd.bind(this), {
          passive: !1
        })));
      };
      a.prototype.setHoverChartIndex = function () {
        var c = this.chart,
          e = u.charts[t(a.hoverChartIndex, -1)];
        if (e && e !== c) e.pointer.onContainerMouseLeave({
          relatedTarget: !0
        });
        e && e.mouseIsDown || (a.hoverChartIndex = c.index);
      };
      a.prototype.touch = function (a, c) {
        var b = this.chart,
          e;
        this.setHoverChartIndex();
        if (1 === a.touches.length) {
          if (a = this.normalize(a), (e = b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop, {
            visiblePlotOnly: !0
          })) && !b.openMenu) {
            c && this.runPointActions(a);
            if ("touchmove" === a.type) {
              c = this.pinchDown;
              var d = c[0] ? 4 <= Math.sqrt(Math.pow(c[0].chartX - a.chartX, 2) + Math.pow(c[0].chartY - a.chartY, 2)) : !1;
            }
            t(d, !0) && this.pinch(a);
          } else c && this.reset();
        } else 2 === a.touches.length && this.pinch(a);
      };
      a.prototype.touchSelect = function (a) {
        return !(!this.chart.options.chart.zoomBySingleTouch || !a.touches || 1 !== a.touches.length);
      };
      a.prototype.zoomOption = function (a) {
        var c = this.chart,
          b = c.options.chart;
        c = c.inverted;
        var e = b.zoomType || "";
        /touch/.test(a.type) && (e = t(b.pinchType, e));
        this.zoomX = a = /x/.test(e);
        this.zoomY = b = /y/.test(e);
        this.zoomHor = a && !c || b && c;
        this.zoomVert = b && !c || a && c;
        this.hasZoom = a || b;
      };
      return a;
    }();
    "";
    return a;
  });
  M(a, "Core/MSPointer.js", [a["Core/Globals.js"], a["Core/Pointer.js"], a["Core/Utilities.js"]], function (a, u, z) {
    function v() {
      var a = [];
      a.item = function (a) {
        return this[a];
      };
      c(f, function (c) {
        a.push({
          pageX: c.pageX,
          pageY: c.pageY,
          target: c.target
        });
      });
      return a;
    }
    function y(a, c, e, f) {
      var h = H[u.hoverChartIndex || NaN];
      "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !h || (h = h.pointer, f(a), h[c]({
        type: e,
        target: a.currentTarget,
        preventDefault: q,
        touches: v()
      }));
    }
    var G = this && this.__extends || function () {
        var a = function (c, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
          };
          return a(c, e);
        };
        return function (c, e) {
          function f() {
            this.constructor = c;
          }
          a(c, e);
          c.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
        };
      }(),
      H = a.charts,
      A = a.doc,
      q = a.noop,
      n = a.win,
      k = z.addEvent,
      e = z.css,
      c = z.objectEach,
      h = z.removeEvent,
      f = {},
      w = !!n.PointerEvent;
    return function (c) {
      function p() {
        return null !== c && c.apply(this, arguments) || this;
      }
      G(p, c);
      p.isRequired = function () {
        return !(a.hasTouch || !n.PointerEvent && !n.MSPointerEvent);
      };
      p.prototype.batchMSEvents = function (a) {
        a(this.chart.container, w ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
        a(this.chart.container, w ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
        a(A, w ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
      };
      p.prototype.destroy = function () {
        this.batchMSEvents(h);
        c.prototype.destroy.call(this);
      };
      p.prototype.init = function (a, f) {
        c.prototype.init.call(this, a, f);
        this.hasZoom && e(a.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      };
      p.prototype.onContainerPointerDown = function (a) {
        y(a, "onContainerTouchStart", "touchstart", function (a) {
          f[a.pointerId] = {
            pageX: a.pageX,
            pageY: a.pageY,
            target: a.currentTarget
          };
        });
      };
      p.prototype.onContainerPointerMove = function (a) {
        y(a, "onContainerTouchMove", "touchmove", function (a) {
          f[a.pointerId] = {
            pageX: a.pageX,
            pageY: a.pageY
          };
          f[a.pointerId].target || (f[a.pointerId].target = a.currentTarget);
        });
      };
      p.prototype.onDocumentPointerUp = function (a) {
        y(a, "onDocumentTouchEnd", "touchend", function (a) {
          delete f[a.pointerId];
        });
      };
      p.prototype.setDOMEvents = function () {
        c.prototype.setDOMEvents.call(this);
        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(k);
      };
      return p;
    }(u);
  });
  M(a, "Core/Legend/Legend.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Series/Point.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Utilities.js"]], function (a, u, z, F, y, G) {
    var v = a.animObject,
      A = a.setAnimation,
      q = u.format;
    a = z.isFirefox;
    var n = z.marginNames;
    z = z.win;
    var k = y.distribute,
      e = G.addEvent,
      c = G.createElement,
      h = G.css,
      f = G.defined,
      w = G.discardElement,
      p = G.find,
      B = G.fireEvent,
      t = G.isNumber,
      J = G.merge,
      C = G.pick,
      r = G.relativeLength,
      l = G.stableSort,
      b = G.syncTimeout;
    y = G.wrap;
    G = function () {
      function a(b, a) {
        this.allItems = [];
        this.contentGroup = this.box = void 0;
        this.display = !1;
        this.group = void 0;
        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
        this.options = {};
        this.padding = 0;
        this.pages = [];
        this.proximate = !1;
        this.scrollGroup = void 0;
        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
        this.chart = b;
        this.init(b, a);
      }
      a.prototype.init = function (b, a) {
        this.chart = b;
        this.setOptions(a);
        a.enabled && (this.render(), e(this.chart, "endResize", function () {
          this.legend.positionCheckboxes();
        }), this.proximate ? this.unchartrender = e(this.chart, "render", function () {
          this.legend.proximatePositions();
          this.legend.positionItems();
        }) : this.unchartrender && this.unchartrender());
      };
      a.prototype.setOptions = function (b) {
        var a = C(b.padding, 8);
        this.options = b;
        this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = J(this.itemStyle, b.itemHiddenStyle));
        this.itemMarginTop = b.itemMarginTop || 0;
        this.itemMarginBottom = b.itemMarginBottom || 0;
        this.padding = a;
        this.initialItemY = a - 5;
        this.symbolWidth = C(b.symbolWidth, 16);
        this.pages = [];
        this.proximate = "proximate" === b.layout && !this.chart.inverted;
        this.baseline = void 0;
      };
      a.prototype.update = function (b, a) {
        var c = this.chart;
        this.setOptions(J(!0, this.options, b));
        this.destroy();
        c.isDirtyLegend = c.isDirtyBox = !0;
        C(a, !0) && c.redraw();
        B(this, "afterUpdate");
      };
      a.prototype.colorizeItem = function (b, a) {
        b.legendGroup[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
        if (!this.chart.styledMode) {
          var c = this.options,
            d = b.legendItem,
            e = b.legendLine,
            g = b.legendSymbol,
            f = this.itemHiddenStyle.color;
          c = a ? c.itemStyle.color : f;
          var m = a ? b.color || f : f,
            h = b.options && b.options.marker,
            l = {
              fill: m
            };
          d && d.css({
            fill: c,
            color: c
          });
          e && e.attr({
            stroke: m
          });
          g && (h && g.isMarker && (l = b.pointAttribs(), a || (l.stroke = l.fill = f)), g.attr(l));
        }
        B(this, "afterColorizeItem", {
          item: b,
          visible: a
        });
      };
      a.prototype.positionItems = function () {
        this.allItems.forEach(this.positionItem, this);
        this.chart.isResizing || this.positionCheckboxes();
      };
      a.prototype.positionItem = function (b) {
        var a = this,
          c = this.options,
          d = c.symbolPadding,
          e = !c.rtl,
          g = b._legendItemPos;
        c = g[0];
        g = g[1];
        var h = b.checkbox,
          l = b.legendGroup;
        l && l.element && (d = {
          translateX: e ? c : this.legendWidth - c - 2 * d - 4,
          translateY: g
        }, e = function () {
          B(a, "afterPositionItem", {
            item: b
          });
        }, f(l.translateY) ? l.animate(d, void 0, e) : (l.attr(d), e()));
        h && (h.x = c, h.y = g);
      };
      a.prototype.destroyItem = function (b) {
        var a = b.checkbox;
        ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (a) {
          b[a] && (b[a] = b[a].destroy());
        });
        a && w(b.checkbox);
      };
      a.prototype.destroy = function () {
        function b(b) {
          this[b] && (this[b] = this[b].destroy());
        }
        this.getAllItems().forEach(function (a) {
          ["legendItem", "legendGroup"].forEach(b, a);
        });
        "clipRect up down pager nav box title group".split(" ").forEach(b, this);
        this.display = null;
      };
      a.prototype.positionCheckboxes = function () {
        var b = this.group && this.group.alignAttr,
          a = this.clipHeight || this.legendHeight,
          c = this.titleHeight;
        if (b) {
          var e = b.translateY;
          this.allItems.forEach(function (d) {
            var g = d.checkbox;
            if (g) {
              var f = e + c + g.y + (this.scrollOffset || 0) + 3;
              h(g, {
                left: b.translateX + d.checkboxOffset + g.x - 20 + "px",
                top: f + "px",
                display: this.proximate || f > e - 6 && f < e + a - 6 ? "" : "none"
              });
            }
          }, this);
        }
      };
      a.prototype.renderTitle = function () {
        var b = this.options,
          a = this.padding,
          c = b.title,
          e = 0;
        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, a - 3, a - 4, null, null, null, b.useHTML, null, "legend-title").attr({
          zIndex: 1
        }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({
          width: this.maxLegendWidth + "px"
        }), b = this.title.getBBox(), e = b.height, this.offsetWidth = b.width, this.contentGroup.attr({
          translateY: e
        }));
        this.titleHeight = e;
      };
      a.prototype.setText = function (b) {
        var a = this.options;
        b.legendItem.attr({
          text: a.labelFormat ? q(a.labelFormat, b, this.chart) : a.labelFormatter.call(b)
        });
      };
      a.prototype.renderItem = function (b) {
        var a = this.chart,
          c = a.renderer,
          d = this.options,
          e = this.symbolWidth,
          g = d.symbolPadding || 0,
          f = this.itemStyle,
          h = this.itemHiddenStyle,
          l = "horizontal" === d.layout ? C(d.itemDistance, 20) : 0,
          k = !d.rtl,
          p = !b.series,
          n = !p && b.series.drawLegendSymbol ? b.series : b,
          r = n.options,
          t = this.createCheckboxForItem && r && r.showCheckbox,
          q = d.useHTML,
          w = b.options.className,
          E = b.legendItem;
        r = e + g + l + (t ? 20 : 0);
        E || (b.legendGroup = c.g("legend-item").addClass("highcharts-" + n.type + "-series highcharts-color-" + b.colorIndex + (w ? " " + w : "") + (p ? " highcharts-series-" + b.index : "")).attr({
          zIndex: 1
        }).add(this.scrollGroup), b.legendItem = E = c.text("", k ? e + g : -g, this.baseline || 0, q), a.styledMode || E.css(J(b.visible ? f : h)), E.attr({
          align: k ? "left" : "right",
          zIndex: 2
        }).add(b.legendGroup), this.baseline || (this.fontMetrics = c.fontMetrics(a.styledMode ? 12 : f.fontSize, E), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, E.attr("y", this.baseline), this.symbolHeight = d.symbolHeight || this.fontMetrics.f, d.squareSymbol && (this.symbolWidth = C(d.symbolWidth, Math.max(this.symbolHeight, 16)), r = this.symbolWidth + g + l + (t ? 20 : 0), k && E.attr("x", this.symbolWidth + g))), n.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, E, q));
        t && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);
        this.colorizeItem(b, b.visible);
        !a.styledMode && f.width || E.css({
          width: (d.itemWidth || this.widthOption || a.spacingBox.width) - r + "px"
        });
        this.setText(b);
        a = E.getBBox();
        c = this.fontMetrics && this.fontMetrics.h || 0;
        b.itemWidth = b.checkboxOffset = d.itemWidth || b.legendItemWidth || a.width + r;
        this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);
        this.totalItemWidth += b.itemWidth;
        this.itemHeight = b.itemHeight = Math.round(b.legendItemHeight || (a.height > 1.5 * c ? a.height : c));
      };
      a.prototype.layoutItem = function (b) {
        var a = this.options,
          c = this.padding,
          d = "horizontal" === a.layout,
          e = b.itemHeight,
          g = this.itemMarginBottom,
          f = this.itemMarginTop,
          h = d ? C(a.itemDistance, 20) : 0,
          l = this.maxLegendWidth;
        a = a.alignColumns && this.totalItemWidth > l ? this.maxItemWidth : b.itemWidth;
        d && this.itemX - c + a > l && (this.itemX = c, this.lastLineHeight && (this.itemY += f + this.lastLineHeight + g), this.lastLineHeight = 0);
        this.lastItemY = f + this.itemY + g;
        this.lastLineHeight = Math.max(e, this.lastLineHeight);
        b._legendItemPos = [this.itemX, this.itemY];
        d ? this.itemX += a : (this.itemY += f + e + g, this.lastLineHeight = e);
        this.offsetWidth = this.widthOption || Math.max((d ? this.itemX - c - (b.checkbox ? 0 : h) : a) + c, this.offsetWidth);
      };
      a.prototype.getAllItems = function () {
        var b = [];
        this.chart.series.forEach(function (a) {
          var c = a && a.options;
          a && C(c.showInLegend, f(c.linkedTo) ? !1 : void 0, !0) && (b = b.concat(a.legendItems || ("point" === c.legendType ? a.data : a)));
        });
        B(this, "afterGetAllItems", {
          allItems: b
        });
        return b;
      };
      a.prototype.getAlignment = function () {
        var b = this.options;
        return this.proximate ? b.align.charAt(0) + "tv" : b.floating ? "" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);
      };
      a.prototype.adjustMargins = function (b, a) {
        var c = this.chart,
          d = this.options,
          e = this.getAlignment();
        e && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (g, h) {
          g.test(e) && !f(b[h]) && (c[n[h]] = Math.max(c[n[h]], c.legend[(h + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][h] * d[h % 2 ? "x" : "y"] + C(d.margin, 12) + a[h] + (c.titleOffset[h] || 0)));
        });
      };
      a.prototype.proximatePositions = function () {
        var b = this.chart,
          a = [],
          c = "left" === this.options.align;
        this.allItems.forEach(function (d) {
          var e;
          var g = c;
          if (d.yAxis) {
            d.xAxis.options.reversed && (g = !g);
            d.points && (e = p(g ? d.points : d.points.slice(0).reverse(), function (b) {
              return t(b.plotY);
            }));
            g = this.itemMarginTop + d.legendItem.getBBox().height + this.itemMarginBottom;
            var f = d.yAxis.top - b.plotTop;
            d.visible ? (e = e ? e.plotY : d.yAxis.height, e += f - .3 * g) : e = f + d.yAxis.height;
            a.push({
              target: e,
              size: g,
              item: d
            });
          }
        }, this);
        k(a, b.plotHeight).forEach(function (a) {
          a.item._legendItemPos && (a.item._legendItemPos[1] = b.plotTop - b.spacing[0] + a.pos);
        });
      };
      a.prototype.render = function () {
        var b = this.chart,
          a = b.renderer,
          c = this.options,
          e = this.padding,
          g = this.getAllItems(),
          f = this.group,
          h = this.box;
        this.itemX = e;
        this.itemY = this.initialItemY;
        this.lastItemY = this.offsetWidth = 0;
        this.widthOption = r(c.width, b.spacingBox.width - e);
        var k = b.spacingBox.width - 2 * e - c.x;
        -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (k /= 2);
        this.maxLegendWidth = this.widthOption || k;
        f || (this.group = f = a.g("legend").addClass(c.className || "").attr({
          zIndex: 7
        }).add(), this.contentGroup = a.g().attr({
          zIndex: 1
        }).add(f), this.scrollGroup = a.g().add(this.contentGroup));
        this.renderTitle();
        l(g, function (b, a) {
          return (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0);
        });
        c.reversed && g.reverse();
        this.allItems = g;
        this.display = k = !!g.length;
        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
        g.forEach(this.renderItem, this);
        g.forEach(this.layoutItem, this);
        g = (this.widthOption || this.offsetWidth) + e;
        var p = this.lastItemY + this.lastLineHeight + this.titleHeight;
        p = this.handleOverflow(p);
        p += e;
        h || (this.box = h = a.rect().addClass("highcharts-legend-box").attr({
          r: c.borderRadius
        }).add(f), h.isNew = !0);
        b.styledMode || h.attr({
          stroke: c.borderColor,
          "stroke-width": c.borderWidth || 0,
          fill: c.backgroundColor || "none"
        }).shadow(c.shadow);
        0 < g && 0 < p && (h[h.isNew ? "attr" : "animate"](h.crisp.call({}, {
          x: 0,
          y: 0,
          width: g,
          height: p
        }, h.strokeWidth())), h.isNew = !1);
        h[k ? "show" : "hide"]();
        b.styledMode && "none" === f.getStyle("display") && (g = p = 0);
        this.legendWidth = g;
        this.legendHeight = p;
        k && this.align();
        this.proximate || this.positionItems();
        B(this, "afterRender");
      };
      a.prototype.align = function (b) {
        void 0 === b && (b = this.chart.spacingBox);
        var a = this.chart,
          c = this.options,
          d = b.y;
        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? d += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (d -= a.titleOffset[2]);
        d !== b.y && (b = J(b, {
          y: d
        }));
        this.group.align(J(c, {
          width: this.legendWidth,
          height: this.legendHeight,
          verticalAlign: this.proximate ? "top" : c.verticalAlign
        }), !0, b);
      };
      a.prototype.handleOverflow = function (b) {
        var a = this,
          c = this.chart,
          d = c.renderer,
          e = this.options,
          g = e.y,
          f = "top" === e.verticalAlign,
          h = this.padding,
          l = e.maxHeight,
          k = e.navigation,
          p = C(k.animation, !0),
          n = k.arrowSize || 12,
          r = this.pages,
          t = this.allItems,
          q = function (b) {
            "number" === typeof b ? v.attr({
              height: b
            }) : v && (a.clipRect = v.destroy(), a.contentGroup.clip());
            a.contentGroup.div && (a.contentGroup.div.style.clip = b ? "rect(" + h + "px,9999px," + (h + b) + "px,0)" : "auto");
          },
          w = function (b) {
            a[b] = d.circle(0, 0, 1.3 * n).translate(n / 2, n / 2).add(N);
            c.styledMode || a[b].attr("fill", "rgba(0,0,0,0.0001)");
            return a[b];
          },
          E,
          B;
        g = c.spacingBox.height + (f ? -g : g) - h;
        var N = this.nav,
          v = this.clipRect;
        "horizontal" !== e.layout || "middle" === e.verticalAlign || e.floating || (g /= 2);
        l && (g = Math.min(g, l));
        r.length = 0;
        b && 0 < g && b > g && !1 !== k.enabled ? (this.clipHeight = E = Math.max(g - 20 - this.titleHeight - h, 0), this.currentPage = C(this.currentPage, 1), this.fullHeight = b, t.forEach(function (b, a) {
          var c = b._legendItemPos[1],
            d = Math.round(b.legendItem.getBBox().height),
            e = r.length;
          if (!e || c - r[e - 1] > E && (B || c) !== r[e - 1]) r.push(B || c), e++;
          b.pageIx = e - 1;
          B && (t[a - 1].pageIx = e - 1);
          a === t.length - 1 && c + d - r[e - 1] > E && d <= E && (r.push(c), b.pageIx = e);
          c !== B && (B = c);
        }), v || (v = a.clipRect = d.clipRect(0, h, 9999, 0), a.contentGroup.clip(v)), q(E), N || (this.nav = N = d.g().attr({
          zIndex: 1
        }).add(this.group), this.up = d.symbol("triangle", 0, 0, n, n).add(N), w("upTracker").on("click", function () {
          a.scroll(-1, p);
        }), this.pager = d.text("", 15, 10).addClass("highcharts-legend-navigation"), c.styledMode || this.pager.css(k.style), this.pager.add(N), this.down = d.symbol("triangle-down", 0, 0, n, n).add(N), w("downTracker").on("click", function () {
          a.scroll(1, p);
        })), a.scroll(0), b = g) : N && (q(), this.nav = N.destroy(), this.scrollGroup.attr({
          translateY: 1
        }), this.clipHeight = 0);
        return b;
      };
      a.prototype.scroll = function (a, c) {
        var d = this,
          e = this.chart,
          g = this.pages,
          f = g.length,
          h = this.clipHeight,
          l = this.options.navigation,
          m = this.pager,
          k = this.padding,
          p = this.currentPage + a;
        p > f && (p = f);
        0 < p && ("undefined" !== typeof c && A(c, e), this.nav.attr({
          translateX: k,
          translateY: h + this.padding + 7 + this.titleHeight,
          visibility: "visible"
        }), [this.up, this.upTracker].forEach(function (b) {
          b.attr({
            "class": 1 === p ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }), m.attr({
          text: p + "/" + f
        }), [this.down, this.downTracker].forEach(function (b) {
          b.attr({
            x: 18 + this.pager.getBBox().width,
            "class": p === f ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }, this), e.styledMode || (this.up.attr({
          fill: 1 === p ? l.inactiveColor : l.activeColor
        }), this.upTracker.css({
          cursor: 1 === p ? "default" : "pointer"
        }), this.down.attr({
          fill: p === f ? l.inactiveColor : l.activeColor
        }), this.downTracker.css({
          cursor: p === f ? "default" : "pointer"
        })), this.scrollOffset = -g[p - 1] + this.initialItemY, this.scrollGroup.animate({
          translateY: this.scrollOffset
        }), this.currentPage = p, this.positionCheckboxes(), a = v(C(c, e.renderer.globalAnimation, !0)), b(function () {
          B(d, "afterScroll", {
            currentPage: p
          });
        }, a.duration));
      };
      a.prototype.setItemEvents = function (b, a, c) {
        var d = this,
          e = d.chart.renderer.boxWrapper,
          g = b instanceof F,
          f = "highcharts-legend-" + (g ? "point" : "series") + "-active",
          h = d.chart.styledMode,
          l = function (a) {
            d.allItems.forEach(function (c) {
              b !== c && [c].concat(c.linkedSeries || []).forEach(function (b) {
                b.setState(a, !g);
              });
            });
          };
        (c ? [a, b.legendSymbol] : [b.legendGroup]).forEach(function (c) {
          if (c) c.on("mouseover", function () {
            b.visible && l("inactive");
            b.setState("hover");
            b.visible && e.addClass(f);
            h || a.css(d.options.itemHoverStyle);
          }).on("mouseout", function () {
            d.chart.styledMode || a.css(J(b.visible ? d.itemStyle : d.itemHiddenStyle));
            l("");
            e.removeClass(f);
            b.setState();
          }).on("click", function (a) {
            var c = function () {
              b.setVisible && b.setVisible();
              l(b.visible ? "inactive" : "");
            };
            e.removeClass(f);
            a = {
              browserEvent: a
            };
            b.firePointEvent ? b.firePointEvent("legendItemClick", a, c) : B(b, "legendItemClick", a, c);
          });
        });
      };
      a.prototype.createCheckboxForItem = function (b) {
        b.checkbox = c("input", {
          type: "checkbox",
          className: "highcharts-legend-checkbox",
          checked: b.selected,
          defaultChecked: b.selected
        }, this.options.itemCheckboxStyle, this.chart.container);
        e(b.checkbox, "click", function (a) {
          B(b.series || b, "checkboxClick", {
            checked: a.target.checked,
            item: b
          }, function () {
            b.select();
          });
        });
      };
      return a;
    }();
    (/Trident\/7\.0/.test(z.navigator && z.navigator.userAgent) || a) && y(G.prototype, "positionItem", function (b, a) {
      var c = this,
        d = function () {
          a._legendItemPos && b.call(c, a);
        };
      d();
      c.bubbleLegend || setTimeout(d);
    });
    "";
    return G;
  });
  M(a, "Core/Series/SeriesRegistry.js", [a["Core/Globals.js"], a["Core/DefaultOptions.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function (a, u, z, F) {
    var v = u.defaultOptions,
      G = F.error,
      H = F.extendClass,
      A = F.merge,
      q;
    (function (n) {
      function k(a, c) {
        var e = v.plotOptions || {},
          f = c.defaultOptions;
        c.prototype.pointClass || (c.prototype.pointClass = z);
        c.prototype.type = a;
        f && (e[a] = f);
        n.seriesTypes[a] = c;
      }
      n.seriesTypes = a.seriesTypes;
      n.getSeries = function (a, c) {
        void 0 === c && (c = {});
        var e = a.options.chart;
        e = c.type || e.type || e.defaultSeriesType || "";
        var f = n.seriesTypes[e];
        n || G(17, !0, a, {
          missingModuleFor: e
        });
        e = new f();
        "function" === typeof e.init && e.init(a, c);
        return e;
      };
      n.registerSeriesType = k;
      n.seriesType = function (a, c, h, f, q) {
        var e = v.plotOptions || {};
        c = c || "";
        e[a] = A(e[c], h);
        k(a, H(n.seriesTypes[c] || function () {}, f));
        n.seriesTypes[a].prototype.type = a;
        q && (n.seriesTypes[a].prototype.pointClass = H(z, q));
        return n.seriesTypes[a];
      };
    })(q || (q = {}));
    return q;
  });
  M(a, "Core/Chart/Chart.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/FormatUtilities.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Legend/Legend.js"], a["Core/MSPointer.js"], a["Core/DefaultOptions.js"], a["Core/Pointer.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Time.js"], a["Core/Utilities.js"], a["Core/Renderer/HTML/AST.js"]], function (a, u, z, F, y, G, H, A, q, n, k, e, c, h, f) {
    var w = a.animate,
      p = a.animObject,
      B = a.setAnimation,
      t = z.numberFormat,
      v = F.registerEventOptions,
      C = y.charts,
      r = y.doc,
      l = y.marginNames,
      b = y.svg,
      g = y.win,
      d = A.defaultOptions,
      m = A.defaultTime,
      D = k.seriesTypes,
      x = h.addEvent,
      I = h.attr,
      P = h.cleanRecursively,
      S = h.createElement,
      O = h.css,
      U = h.defined,
      Y = h.discardElement,
      L = h.erase,
      K = h.error,
      M = h.extend,
      da = h.find,
      Q = h.fireEvent,
      ea = h.getStyle,
      E = h.isArray,
      T = h.isNumber,
      N = h.isObject,
      V = h.isString,
      W = h.merge,
      X = h.objectEach,
      R = h.pick,
      fa = h.pInt,
      aa = h.relativeLength,
      ia = h.removeEvent,
      ha = h.splat,
      ba = h.syncTimeout,
      ka = h.uniqueKey;
    a = function () {
      function a(b, a, c) {
        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
        this.sharedClips = {};
        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
        this.getArgs(b, a, c);
      }
      a.chart = function (b, c, d) {
        return new a(b, c, d);
      };
      a.prototype.getArgs = function (b, a, c) {
        V(b) || b.nodeName ? (this.renderTo = b, this.init(a, c)) : this.init(b, a);
      };
      a.prototype.init = function (b, a) {
        var e = b.plotOptions || {};
        Q(this, "init", {
          args: arguments
        }, function () {
          var g = W(d, b),
            f = g.chart;
          X(g.plotOptions, function (b, a) {
            N(b) && (b.tooltip = e[a] && W(e[a].tooltip) || void 0);
          });
          g.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
          this.userOptions = b;
          this.margin = [];
          this.spacing = [];
          this.bounds = {
            h: {},
            v: {}
          };
          this.labelCollectors = [];
          this.callback = a;
          this.isResizing = 0;
          this.options = g;
          this.axes = [];
          this.series = [];
          this.time = b.time && Object.keys(b.time).length ? new c(b.time) : y.time;
          this.numberFormatter = f.numberFormatter || t;
          this.styledMode = f.styledMode;
          this.hasCartesianSeries = f.showAxes;
          this.index = C.length;
          C.push(this);
          y.chartCount++;
          v(this, f);
          this.xAxis = [];
          this.yAxis = [];
          this.pointCount = this.colorCounter = this.symbolCounter = 0;
          Q(this, "afterInit");
          this.firstRender();
        });
      };
      a.prototype.initSeries = function (b) {
        var a = this.options.chart;
        a = b.type || a.type || a.defaultSeriesType;
        var c = D[a];
        c || K(17, !0, this, {
          missingModuleFor: a
        });
        a = new c();
        "function" === typeof a.init && a.init(this, b);
        return a;
      };
      a.prototype.setSeriesData = function () {
        this.getSeriesOrderByLinks().forEach(function (b) {
          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
        });
      };
      a.prototype.getSeriesOrderByLinks = function () {
        return this.series.concat().sort(function (b, a) {
          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;
        });
      };
      a.prototype.orderSeries = function (b) {
        var a = this.series;
        b = b || 0;
        for (var c = a.length; b < c; ++b) a[b] && (a[b].index = b, a[b].name = a[b].getName());
      };
      a.prototype.isInsidePlot = function (b, a, c) {
        void 0 === c && (c = {});
        var d = this.inverted,
          e = this.plotBox,
          g = this.plotLeft,
          f = this.plotTop,
          h = this.scrollablePlotBox,
          l = 0;
        var k = 0;
        c.visiblePlotOnly && this.scrollingContainer && (k = this.scrollingContainer, l = k.scrollLeft, k = k.scrollTop);
        var m = c.series;
        e = c.visiblePlotOnly && h || e;
        h = c.inverted ? a : b;
        a = c.inverted ? b : a;
        b = {
          x: h,
          y: a,
          isInsidePlot: !0
        };
        if (!c.ignoreX) {
          var p = m && (d ? m.yAxis : m.xAxis) || {
            pos: g,
            len: Infinity
          };
          h = c.paneCoordinates ? p.pos + h : g + h;
          h >= Math.max(l + g, p.pos) && h <= Math.min(l + g + e.width, p.pos + p.len) || (b.isInsidePlot = !1);
        }
        !c.ignoreY && b.isInsidePlot && (d = m && (d ? m.xAxis : m.yAxis) || {
          pos: f,
          len: Infinity
        }, c = c.paneCoordinates ? d.pos + a : f + a, c >= Math.max(k + f, d.pos) && c <= Math.min(k + f + e.height, d.pos + d.len) || (b.isInsidePlot = !1));
        Q(this, "afterIsInsidePlot", b);
        return b.isInsidePlot;
      };
      a.prototype.redraw = function (b) {
        Q(this, "beforeRedraw");
        var a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
          c = this.series,
          d = this.pointer,
          e = this.legend,
          g = this.userOptions.legend,
          f = this.renderer,
          h = f.isHidden(),
          l = [],
          k = this.isDirtyBox,
          m = this.isDirtyLegend;
        this.setResponsive && this.setResponsive(!1);
        B(this.hasRendered ? b : !1, this);
        h && this.temporaryDisplay();
        this.layOutTitles();
        for (b = c.length; b--;) {
          var p = c[b];
          if (p.options.stacking || p.options.centerInCategory) {
            var n = !0;
            if (p.isDirty) {
              var E = !0;
              break;
            }
          }
        }
        if (E) for (b = c.length; b--;) p = c[b], p.options.stacking && (p.isDirty = !0);
        c.forEach(function (b) {
          b.isDirty && ("point" === b.options.legendType ? ("function" === typeof b.updateTotals && b.updateTotals(), m = !0) : g && (g.labelFormatter || g.labelFormat) && (m = !0));
          b.isDirtyData && Q(b, "updatedData");
        });
        m && e && e.options.enabled && (e.render(), this.isDirtyLegend = !1);
        n && this.getStacks();
        a.forEach(function (b) {
          b.updateNames();
          b.setScale();
        });
        this.getMargins();
        a.forEach(function (b) {
          b.isDirty && (k = !0);
        });
        a.forEach(function (b) {
          var a = b.min + "," + b.max;
          b.extKey !== a && (b.extKey = a, l.push(function () {
            Q(b, "afterSetExtremes", M(b.eventArgs, b.getExtremes()));
            delete b.eventArgs;
          }));
          (k || n) && b.redraw();
        });
        k && this.drawChartBox();
        Q(this, "predraw");
        c.forEach(function (b) {
          (k || b.isDirty) && b.visible && b.redraw();
          b.isDirtyData = !1;
        });
        d && d.reset(!0);
        f.draw();
        Q(this, "redraw");
        Q(this, "render");
        h && this.temporaryDisplay(!0);
        l.forEach(function (b) {
          b.call();
        });
      };
      a.prototype.get = function (b) {
        function a(a) {
          return a.id === b || a.options && a.options.id === b;
        }
        for (var c = this.series, d = da(this.axes, a) || da(this.series, a), e = 0; !d && e < c.length; e++) d = da(c[e].points || [], a);
        return d;
      };
      a.prototype.getAxes = function () {
        var b = this,
          a = this.options,
          c = a.xAxis = ha(a.xAxis || {});
        a = a.yAxis = ha(a.yAxis || {});
        Q(this, "getAxes");
        c.forEach(function (b, a) {
          b.index = a;
          b.isX = !0;
        });
        a.forEach(function (b, a) {
          b.index = a;
        });
        c.concat(a).forEach(function (a) {
          new u(b, a);
        });
        Q(this, "afterGetAxes");
      };
      a.prototype.getSelectedPoints = function () {
        return this.series.reduce(function (b, a) {
          a.getPointsCollection().forEach(function (a) {
            R(a.selectedStaging, a.selected) && b.push(a);
          });
          return b;
        }, []);
      };
      a.prototype.getSelectedSeries = function () {
        return this.series.filter(function (b) {
          return b.selected;
        });
      };
      a.prototype.setTitle = function (b, a, c) {
        this.applyDescription("title", b);
        this.applyDescription("subtitle", a);
        this.applyDescription("caption", void 0);
        this.layOutTitles(c);
      };
      a.prototype.applyDescription = function (b, a) {
        var c = this,
          d = "title" === b ? {
            color: "#333333",
            fontSize: this.options.isStock ? "16px" : "18px"
          } : {
            color: "#666666"
          };
        d = this.options[b] = W(!this.styledMode && {
          style: d
        }, this.options[b], a);
        var e = this[b];
        e && a && (this[b] = e = e.destroy());
        d && !e && (e = this.renderer.text(d.text, 0, 0, d.useHTML).attr({
          align: d.align,
          "class": "highcharts-" + b,
          zIndex: d.zIndex || 4
        }).add(), e.update = function (a) {
          c[{
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }[b]](a);
        }, this.styledMode || e.css(d.style), this[b] = e);
      };
      a.prototype.layOutTitles = function (b) {
        var a = [0, 0, 0],
          c = this.renderer,
          d = this.spacingBox;
        ["title", "subtitle", "caption"].forEach(function (b) {
          var e = this[b],
            g = this.options[b],
            f = g.verticalAlign || "top";
          b = "title" === b ? "top" === f ? -3 : 0 : "top" === f ? a[0] + 2 : 0;
          var h;
          if (e) {
            this.styledMode || (h = g.style && g.style.fontSize);
            h = c.fontMetrics(h, e).b;
            e.css({
              width: (g.width || d.width + (g.widthAdjust || 0)) + "px"
            });
            var l = Math.round(e.getBBox(g.useHTML).height);
            e.align(M({
              y: "bottom" === f ? h : b + h,
              height: l
            }, g), !1, "spacingBox");
            g.floating || ("top" === f ? a[0] = Math.ceil(a[0] + l) : "bottom" === f && (a[2] = Math.ceil(a[2] + l)));
          }
        }, this);
        a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
        a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
        var e = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
        this.titleOffset = a;
        Q(this, "afterLayOutTitles");
        !this.isDirtyBox && e && (this.isDirtyBox = this.isDirtyLegend = e, this.hasRendered && R(b, !0) && this.isDirtyBox && this.redraw());
      };
      a.prototype.getChartSize = function () {
        var b = this.options.chart,
          a = b.width;
        b = b.height;
        var c = this.renderTo;
        U(a) || (this.containerWidth = ea(c, "width"));
        U(b) || (this.containerHeight = ea(c, "height"));
        this.chartWidth = Math.max(0, a || this.containerWidth || 600);
        this.chartHeight = Math.max(0, aa(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
      };
      a.prototype.temporaryDisplay = function (b) {
        var a = this.renderTo;
        if (b) for (; a && a.style;) a.hcOrigStyle && (O(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (r.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {
          r.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, r.body.appendChild(a));
          if ("none" === ea(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
            display: a.style.display,
            height: a.style.height,
            overflow: a.style.overflow
          }, b = {
            display: "block",
            overflow: "hidden"
          }, a !== this.renderTo && (b.height = 0), O(a, b), a.offsetWidth || a.style.setProperty("display", "block", "important");
          a = a.parentNode;
          if (a === r.body) break;
        }
      };
      a.prototype.setClassName = function (b) {
        this.container.className = "highcharts-container " + (b || "");
      };
      a.prototype.getContainer = function () {
        var a = this.options,
          c = a.chart,
          d = ka(),
          g,
          h = this.renderTo;
        h || (this.renderTo = h = c.renderTo);
        V(h) && (this.renderTo = h = r.getElementById(h));
        h || K(13, !0, this);
        var l = fa(I(h, "data-highcharts-chart"));
        T(l) && C[l] && C[l].hasRendered && C[l].destroy();
        I(h, "data-highcharts-chart", this.index);
        h.innerHTML = f.emptyHTML;
        c.skipClone || h.offsetWidth || this.temporaryDisplay();
        this.getChartSize();
        l = this.chartWidth;
        var k = this.chartHeight;
        O(h, {
          overflow: "hidden"
        });
        this.styledMode || (g = M({
          position: "relative",
          overflow: "hidden",
          width: l + "px",
          height: k + "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
          userSelect: "none",
          "touch-action": "manipulation",
          outline: "none"
        }, c.style || {}));
        this.container = d = S("div", {
          id: d
        }, g, h);
        this._cursor = d.style.cursor;
        this.renderer = new (c.renderer || !b ? n.getRendererType(c.renderer) : e)(d, l, k, void 0, c.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);
        B(void 0, this);
        this.setClassName(c.className);
        if (this.styledMode) for (var m in a.defs) this.renderer.definition(a.defs[m]);else this.renderer.setStyle(c.style);
        this.renderer.chartIndex = this.index;
        Q(this, "afterGetContainer");
      };
      a.prototype.getMargins = function (b) {
        var a = this.spacing,
          c = this.margin,
          d = this.titleOffset;
        this.resetMargins();
        d[0] && !U(c[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + a[0]));
        d[2] && !U(c[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + a[2]));
        this.legend && this.legend.display && this.legend.adjustMargins(c, a);
        Q(this, "getMargins");
        b || this.getAxisMargins();
      };
      a.prototype.getAxisMargins = function () {
        var b = this,
          a = b.axisOffset = [0, 0, 0, 0],
          c = b.colorAxis,
          d = b.margin,
          e = function (b) {
            b.forEach(function (b) {
              b.visible && b.getOffset();
            });
          };
        b.hasCartesianSeries ? e(b.axes) : c && c.length && e(c);
        l.forEach(function (c, e) {
          U(d[e]) || (b[c] += a[e]);
        });
        b.setChartSize();
      };
      a.prototype.reflow = function (b) {
        var a = this,
          c = a.options.chart,
          d = a.renderTo,
          e = U(c.width) && U(c.height),
          f = c.width || ea(d, "width");
        c = c.height || ea(d, "height");
        d = b ? b.target : g;
        delete a.pointer.chartPosition;
        if (!e && !a.isPrinting && f && c && (d === g || d === r)) {
          if (f !== a.containerWidth || c !== a.containerHeight) h.clearTimeout(a.reflowTimeout), a.reflowTimeout = ba(function () {
            a.container && a.setSize(void 0, void 0, !1);
          }, b ? 100 : 0);
          a.containerWidth = f;
          a.containerHeight = c;
        }
      };
      a.prototype.setReflow = function (b) {
        var a = this;
        !1 === b || this.unbindReflow ? !1 === b && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = x(g, "resize", function (b) {
          a.options && a.reflow(b);
        }), x(this, "destroy", this.unbindReflow));
      };
      a.prototype.setSize = function (b, a, c) {
        var d = this,
          e = d.renderer;
        d.isResizing += 1;
        B(c, d);
        c = e.globalAnimation;
        d.oldChartHeight = d.chartHeight;
        d.oldChartWidth = d.chartWidth;
        "undefined" !== typeof b && (d.options.chart.width = b);
        "undefined" !== typeof a && (d.options.chart.height = a);
        d.getChartSize();
        d.styledMode || (c ? w : O)(d.container, {
          width: d.chartWidth + "px",
          height: d.chartHeight + "px"
        }, c);
        d.setChartSize(!0);
        e.setSize(d.chartWidth, d.chartHeight, c);
        d.axes.forEach(function (b) {
          b.isDirty = !0;
          b.setScale();
        });
        d.isDirtyLegend = !0;
        d.isDirtyBox = !0;
        d.layOutTitles();
        d.getMargins();
        d.redraw(c);
        d.oldChartHeight = null;
        Q(d, "resize");
        ba(function () {
          d && Q(d, "endResize", null, function () {
            --d.isResizing;
          });
        }, p(c).duration);
      };
      a.prototype.setChartSize = function (b) {
        var a = this.inverted,
          c = this.renderer,
          d = this.chartWidth,
          e = this.chartHeight,
          g = this.options.chart,
          f = this.spacing,
          h = this.clipOffset,
          l,
          k,
          m,
          p;
        this.plotLeft = l = Math.round(this.plotLeft);
        this.plotTop = k = Math.round(this.plotTop);
        this.plotWidth = m = Math.max(0, Math.round(d - l - this.marginRight));
        this.plotHeight = p = Math.max(0, Math.round(e - k - this.marginBottom));
        this.plotSizeX = a ? p : m;
        this.plotSizeY = a ? m : p;
        this.plotBorderWidth = g.plotBorderWidth || 0;
        this.spacingBox = c.spacingBox = {
          x: f[3],
          y: f[0],
          width: d - f[3] - f[1],
          height: e - f[0] - f[2]
        };
        this.plotBox = c.plotBox = {
          x: l,
          y: k,
          width: m,
          height: p
        };
        a = 2 * Math.floor(this.plotBorderWidth / 2);
        d = Math.ceil(Math.max(a, h[3]) / 2);
        e = Math.ceil(Math.max(a, h[0]) / 2);
        this.clipBox = {
          x: d,
          y: e,
          width: Math.floor(this.plotSizeX - Math.max(a, h[1]) / 2 - d),
          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, h[2]) / 2 - e))
        };
        b || (this.axes.forEach(function (b) {
          b.setAxisSize();
          b.setAxisTranslation();
        }), c.alignElements());
        Q(this, "afterSetChartSize", {
          skipAxes: b
        });
      };
      a.prototype.resetMargins = function () {
        Q(this, "resetMargins");
        var b = this,
          a = b.options.chart;
        ["margin", "spacing"].forEach(function (c) {
          var d = a[c],
            e = N(d) ? d : [d, d, d, d];
          ["Top", "Right", "Bottom", "Left"].forEach(function (d, g) {
            b[c][g] = R(a[c + d], e[g]);
          });
        });
        l.forEach(function (a, c) {
          b[a] = R(b.margin[c], b.spacing[c]);
        });
        b.axisOffset = [0, 0, 0, 0];
        b.clipOffset = [0, 0, 0, 0];
      };
      a.prototype.drawChartBox = function () {
        var b = this.options.chart,
          a = this.renderer,
          c = this.chartWidth,
          d = this.chartHeight,
          e = this.styledMode,
          g = this.plotBGImage,
          f = b.backgroundColor,
          h = b.plotBackgroundColor,
          l = b.plotBackgroundImage,
          k = this.plotLeft,
          m = this.plotTop,
          p = this.plotWidth,
          n = this.plotHeight,
          E = this.plotBox,
          r = this.clipRect,
          t = this.clipBox,
          q = this.chartBackground,
          N = this.plotBackground,
          w = this.plotBorder,
          B,
          C = "animate";
        q || (this.chartBackground = q = a.rect().addClass("highcharts-background").add(), C = "attr");
        if (e) var x = B = q.strokeWidth();else {
          x = b.borderWidth || 0;
          B = x + (b.shadow ? 8 : 0);
          f = {
            fill: f || "none"
          };
          if (x || q["stroke-width"]) f.stroke = b.borderColor, f["stroke-width"] = x;
          q.attr(f).shadow(b.shadow);
        }
        q[C]({
          x: B / 2,
          y: B / 2,
          width: c - B - x % 2,
          height: d - B - x % 2,
          r: b.borderRadius
        });
        C = "animate";
        N || (C = "attr", this.plotBackground = N = a.rect().addClass("highcharts-plot-background").add());
        N[C](E);
        e || (N.attr({
          fill: h || "none"
        }).shadow(b.plotShadow), l && (g ? (l !== g.attr("href") && g.attr("href", l), g.animate(E)) : this.plotBGImage = a.image(l, k, m, p, n).add()));
        r ? r.animate({
          width: t.width,
          height: t.height
        }) : this.clipRect = a.clipRect(t);
        C = "animate";
        w || (C = "attr", this.plotBorder = w = a.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
        }).add());
        e || w.attr({
          stroke: b.plotBorderColor,
          "stroke-width": b.plotBorderWidth || 0,
          fill: "none"
        });
        w[C](w.crisp({
          x: k,
          y: m,
          width: p,
          height: n
        }, -w.strokeWidth()));
        this.isDirtyBox = !1;
        Q(this, "afterDrawChartBox");
      };
      a.prototype.propFromSeries = function () {
        var b = this,
          a = b.options.chart,
          c = b.options.series,
          d,
          e,
          g;
        ["inverted", "angular", "polar"].forEach(function (f) {
          e = D[a.type || a.defaultSeriesType];
          g = a[f] || e && e.prototype[f];
          for (d = c && c.length; !g && d--;) (e = D[c[d].type]) && e.prototype[f] && (g = !0);
          b[f] = g;
        });
      };
      a.prototype.linkSeries = function () {
        var b = this,
          a = b.series;
        a.forEach(function (b) {
          b.linkedSeries.length = 0;
        });
        a.forEach(function (a) {
          var c = a.options.linkedTo;
          V(c) && (c = ":previous" === c ? b.series[a.index - 1] : b.get(c)) && c.linkedParent !== a && (c.linkedSeries.push(a), a.linkedParent = c, c.enabledDataSorting && a.setDataSortingOptions(), a.visible = R(a.options.visible, c.options.visible, a.visible));
        });
        Q(this, "afterLinkSeries");
      };
      a.prototype.renderSeries = function () {
        this.series.forEach(function (b) {
          b.translate();
          b.render();
        });
      };
      a.prototype.renderLabels = function () {
        var b = this,
          a = b.options.labels;
        a.items && a.items.forEach(function (c) {
          var d = M(a.style, c.style),
            e = fa(d.left) + b.plotLeft,
            g = fa(d.top) + b.plotTop + 12;
          delete d.left;
          delete d.top;
          b.renderer.text(c.html, e, g).attr({
            zIndex: 2
          }).css(d).add();
        });
      };
      a.prototype.render = function () {
        var b = this.axes,
          a = this.colorAxis,
          c = this.renderer,
          d = this.options,
          e = function (b) {
            b.forEach(function (b) {
              b.visible && b.render();
            });
          },
          g = 0;
        this.setTitle();
        this.legend = new G(this, d.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        d = this.plotWidth;
        b.some(function (b) {
          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return g = 21, !0;
        });
        var f = this.plotHeight = Math.max(this.plotHeight - g, 0);
        b.forEach(function (b) {
          b.setScale();
        });
        this.getAxisMargins();
        var h = 1.1 < d / this.plotWidth,
          l = 1.05 < f / this.plotHeight;
        if (h || l) b.forEach(function (b) {
          (b.horiz && h || !b.horiz && l) && b.setTickInterval(!0);
        }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries ? e(b) : a && a.length && e(a);
        this.seriesGroup || (this.seriesGroup = c.g("series-group").attr({
          zIndex: 3
        }).add());
        this.renderSeries();
        this.renderLabels();
        this.addCredits();
        this.setResponsive && this.setResponsive();
        this.hasRendered = !0;
      };
      a.prototype.addCredits = function (b) {
        var a = this,
          c = W(!0, this.options.credits, b);
        c.enabled && !this.credits && (this.credits = this.renderer.text(c.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
          c.href && (g.location.href = c.href);
        }).attr({
          align: c.position.align,
          zIndex: 8
        }), a.styledMode || this.credits.css(c.style), this.credits.add().align(c.position), this.credits.update = function (b) {
          a.credits = a.credits.destroy();
          a.addCredits(b);
        });
      };
      a.prototype.destroy = function () {
        var b = this,
          a = b.axes,
          c = b.series,
          d = b.container,
          e = d && d.parentNode,
          g;
        Q(b, "destroy");
        b.renderer.forExport ? L(C, b) : C[b.index] = void 0;
        y.chartCount--;
        b.renderTo.removeAttribute("data-highcharts-chart");
        ia(b);
        for (g = a.length; g--;) a[g] = a[g].destroy();
        this.scroller && this.scroller.destroy && this.scroller.destroy();
        for (g = c.length; g--;) c[g] = c[g].destroy();
        "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
          var c = b[a];
          c && c.destroy && (b[a] = c.destroy());
        });
        d && (d.innerHTML = f.emptyHTML, ia(d), e && Y(d));
        X(b, function (a, c) {
          delete b[c];
        });
      };
      a.prototype.firstRender = function () {
        var b = this,
          a = b.options;
        if (!b.isReadyToRender || b.isReadyToRender()) {
          b.getContainer();
          b.resetMargins();
          b.setChartSize();
          b.propFromSeries();
          b.getAxes();
          (E(a.series) ? a.series : []).forEach(function (a) {
            b.initSeries(a);
          });
          b.linkSeries();
          b.setSeriesData();
          Q(b, "beforeRender");
          q && (H.isRequired() ? b.pointer = new H(b, a) : b.pointer = new q(b, a));
          b.render();
          b.pointer.getChartPosition();
          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
          b.temporaryDisplay(!0);
        }
      };
      a.prototype.onload = function () {
        this.callbacks.concat([this.callback]).forEach(function (b) {
          b && "undefined" !== typeof this.index && b.apply(this, [this]);
        }, this);
        Q(this, "load");
        Q(this, "render");
        U(this.index) && this.setReflow(this.options.chart.reflow);
        this.hasLoaded = !0;
      };
      a.prototype.addSeries = function (b, a, c) {
        var d = this,
          e;
        b && (a = R(a, !0), Q(d, "addSeries", {
          options: b
        }, function () {
          e = d.initSeries(b);
          d.isDirtyLegend = !0;
          d.linkSeries();
          e.enabledDataSorting && e.setData(b.data, !1);
          Q(d, "afterAddSeries", {
            series: e
          });
          a && d.redraw(c);
        }));
        return e;
      };
      a.prototype.addAxis = function (b, a, c, d) {
        return this.createAxis(a ? "xAxis" : "yAxis", {
          axis: b,
          redraw: c,
          animation: d
        });
      };
      a.prototype.addColorAxis = function (b, a, c) {
        return this.createAxis("colorAxis", {
          axis: b,
          redraw: a,
          animation: c
        });
      };
      a.prototype.createAxis = function (b, a) {
        b = new u(this, W(a.axis, {
          index: this[b].length,
          isX: "xAxis" === b
        }));
        R(a.redraw, !0) && this.redraw(a.animation);
        return b;
      };
      a.prototype.showLoading = function (b) {
        var a = this,
          c = a.options,
          d = c.loading,
          e = function () {
            g && O(g, {
              left: a.plotLeft + "px",
              top: a.plotTop + "px",
              width: a.plotWidth + "px",
              height: a.plotHeight + "px"
            });
          },
          g = a.loadingDiv,
          h = a.loadingSpan;
        g || (a.loadingDiv = g = S("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, a.container));
        h || (a.loadingSpan = h = S("span", {
          className: "highcharts-loading-inner"
        }, null, g), x(a, "redraw", e));
        g.className = "highcharts-loading";
        f.setElementHTML(h, R(b, c.lang.loading, ""));
        a.styledMode || (O(g, M(d.style, {
          zIndex: 10
        })), O(h, d.labelStyle), a.loadingShown || (O(g, {
          opacity: 0,
          display: ""
        }), w(g, {
          opacity: d.style.opacity || .5
        }, {
          duration: d.showDuration || 0
        })));
        a.loadingShown = !0;
        e();
      };
      a.prototype.hideLoading = function () {
        var b = this.options,
          a = this.loadingDiv;
        a && (a.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || w(a, {
          opacity: 0
        }, {
          duration: b.loading.hideDuration || 100,
          complete: function () {
            O(a, {
              display: "none"
            });
          }
        }));
        this.loadingShown = !1;
      };
      a.prototype.update = function (b, a, d, e) {
        var g = this,
          f = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          },
          h = b.isResponsiveOptions,
          l = [],
          k,
          p;
        Q(g, "update", {
          options: b
        });
        h || g.setResponsive(!1, !0);
        b = P(b, g.options);
        g.userOptions = W(g.userOptions, b);
        var n = b.chart;
        if (n) {
          W(!0, g.options.chart, n);
          "className" in n && g.setClassName(n.className);
          "reflow" in n && g.setReflow(n.reflow);
          if ("inverted" in n || "polar" in n || "type" in n) {
            g.propFromSeries();
            var E = !0;
          }
          "alignTicks" in n && (E = !0);
          "events" in n && v(this, n);
          X(n, function (b, a) {
            -1 !== g.propsRequireUpdateSeries.indexOf("chart." + a) && (k = !0);
            -1 !== g.propsRequireDirtyBox.indexOf(a) && (g.isDirtyBox = !0);
            -1 !== g.propsRequireReflow.indexOf(a) && (h ? g.isDirtyBox = !0 : p = !0);
          });
          !g.styledMode && n.style && g.renderer.setStyle(g.options.chart.style || {});
        }
        !g.styledMode && b.colors && (this.options.colors = b.colors);
        b.time && (this.time === m && (this.time = new c(b.time)), W(!0, g.options.time, b.time));
        X(b, function (a, c) {
          if (g[c] && "function" === typeof g[c].update) g[c].update(a, !1);else if ("function" === typeof g[f[c]]) g[f[c]](a);else "colors" !== c && -1 === g.collectionsWithUpdate.indexOf(c) && W(!0, g.options[c], b[c]);
          "chart" !== c && -1 !== g.propsRequireUpdateSeries.indexOf(c) && (k = !0);
        });
        this.collectionsWithUpdate.forEach(function (a) {
          if (b[a]) {
            var c = [];
            g[a].forEach(function (b, a) {
              b.options.isInternal || c.push(R(b.options.index, a));
            });
            ha(b[a]).forEach(function (b, e) {
              var f = U(b.id),
                h;
              f && (h = g.get(b.id));
              !h && g[a] && (h = g[a][c ? c[e] : e]) && f && U(h.options.id) && (h = void 0);
              h && h.coll === a && (h.update(b, !1), d && (h.touched = !0));
              !h && d && g.collectionsWithInit[a] && (g.collectionsWithInit[a][0].apply(g, [b].concat(g.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);
            });
            d && g[a].forEach(function (b) {
              b.touched || b.options.isInternal ? delete b.touched : l.push(b);
            });
          }
        });
        l.forEach(function (b) {
          b.chart && b.remove && b.remove(!1);
        });
        E && g.axes.forEach(function (b) {
          b.update({}, !1);
        });
        k && g.getSeriesOrderByLinks().forEach(function (b) {
          b.chart && b.update({}, !1);
        }, this);
        E = n && n.width;
        n = n && (V(n.height) ? aa(n.height, E || g.chartWidth) : n.height);
        p || T(E) && E !== g.chartWidth || T(n) && n !== g.chartHeight ? g.setSize(E, n, e) : R(a, !0) && g.redraw(e);
        Q(g, "afterUpdate", {
          options: b,
          redraw: a,
          animation: e
        });
      };
      a.prototype.setSubtitle = function (b, a) {
        this.applyDescription("subtitle", b);
        this.layOutTitles(a);
      };
      a.prototype.setCaption = function (b, a) {
        this.applyDescription("caption", b);
        this.layOutTitles(a);
      };
      a.prototype.showResetZoom = function () {
        function b() {
          a.zoomOut();
        }
        var a = this,
          c = d.lang,
          e = a.options.chart.resetZoomButton,
          g = e.theme,
          f = g.states,
          h = "chart" === e.relativeTo || "spacingBox" === e.relativeTo ? null : "scrollablePlotBox";
        Q(this, "beforeShowResetZoom", null, function () {
          a.resetZoomButton = a.renderer.button(c.resetZoom, null, null, b, g, f && f.hover).attr({
            align: e.position.align,
            title: c.resetZoomTitle
          }).addClass("highcharts-reset-zoom").add().align(e.position, !1, h);
        });
        Q(this, "afterShowResetZoom");
      };
      a.prototype.zoomOut = function () {
        Q(this, "selection", {
          resetSelection: !0
        }, this.zoom);
      };
      a.prototype.zoom = function (b) {
        var a = this,
          c = a.pointer,
          d = a.inverted ? c.mouseDownX : c.mouseDownY,
          e = !1,
          g;
        !b || b.resetSelection ? (a.axes.forEach(function (b) {
          g = b.zoom();
        }), c.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {
          var f = b.axis,
            h = a.inverted ? f.left : f.top,
            l = a.inverted ? h + f.width : h + f.height,
            k = f.isXAxis,
            m = !1;
          if (!k && d >= h && d <= l || k || !U(d)) m = !0;
          c[k ? "zoomX" : "zoomY"] && m && (g = f.zoom(b.min, b.max), f.displayBtn && (e = !0));
        });
        var f = a.resetZoomButton;
        e && !f ? a.showResetZoom() : !e && N(f) && (a.resetZoomButton = f.destroy());
        g && a.redraw(R(a.options.chart.animation, b && b.animation, 100 > a.pointCount));
      };
      a.prototype.pan = function (b, a) {
        var c = this,
          d = c.hoverPoints;
        a = "object" === typeof a ? a : {
          enabled: a,
          type: "x"
        };
        var e = c.options.chart,
          g = c.options.mapNavigation && c.options.mapNavigation.enabled;
        e && e.panning && (e.panning = a);
        var f = a.type,
          h;
        Q(this, "pan", {
          originalEvent: b
        }, function () {
          d && d.forEach(function (b) {
            b.setState();
          });
          var a = c.xAxis;
          "xy" === f ? a = a.concat(c.yAxis) : "y" === f && (a = c.yAxis);
          var e = {};
          a.forEach(function (a) {
            if (a.options.panningEnabled && !a.options.isInternal) {
              var d = a.horiz,
                l = b[d ? "chartX" : "chartY"];
              d = d ? "mouseDownX" : "mouseDownY";
              var k = c[d],
                m = a.minPointOffset || 0,
                p = a.reversed && !c.inverted || !a.reversed && c.inverted ? -1 : 1,
                n = a.getExtremes(),
                E = a.toValue(k - l, !0) + m * p,
                r = a.toValue(k + a.len - l, !0) - (m * p || a.isXAxis && a.pointRangePadding || 0),
                t = r < E;
              p = a.hasVerticalPanning();
              k = t ? r : E;
              E = t ? E : r;
              var q = a.panningState;
              !p || a.isXAxis || q && !q.isDirty || a.series.forEach(function (b) {
                var a = b.getProcessedData(!0);
                a = b.getExtremes(a.yData, !0);
                q || (q = {
                  startMin: Number.MAX_VALUE,
                  startMax: -Number.MAX_VALUE
                });
                T(a.dataMin) && T(a.dataMax) && (q.startMin = Math.min(R(b.options.threshold, Infinity), a.dataMin, q.startMin), q.startMax = Math.max(R(b.options.threshold, -Infinity), a.dataMax, q.startMax));
              });
              p = Math.min(R(q && q.startMin, n.dataMin), m ? n.min : a.toValue(a.toPixels(n.min) - a.minPixelPadding));
              r = Math.max(R(q && q.startMax, n.dataMax), m ? n.max : a.toValue(a.toPixels(n.max) + a.minPixelPadding));
              a.panningState = q;
              a.isOrdinal || (m = p - k, 0 < m && (E += m, k = p), m = E - r, 0 < m && (E = r, k -= m), a.series.length && k !== n.min && E !== n.max && k >= p && E <= r && (a.setExtremes(k, E, !1, !1, {
                trigger: "pan"
              }), c.resetZoomButton || g || k === p || E === r || !f.match("y") || (c.showResetZoom(), a.displayBtn = !1), h = !0), e[d] = l);
            }
          });
          X(e, function (b, a) {
            c[a] = b;
          });
          h && c.redraw(!1);
          O(c.container, {
            cursor: "move"
          });
        });
      };
      return a;
    }();
    M(a.prototype, {
      callbacks: [],
      collectionsWithInit: {
        xAxis: [a.prototype.addAxis, [!0]],
        yAxis: [a.prototype.addAxis, [!1]],
        series: [a.prototype.addSeries]
      },
      collectionsWithUpdate: ["xAxis", "yAxis", "series"],
      propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
      propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
    });
    "";
    return a;
  });
  M(a, "Core/Legend/LegendSymbol.js", [a["Core/Utilities.js"]], function (a) {
    var v = a.merge,
      z = a.pick,
      F;
    (function (a) {
      a.drawLineMarker = function (a) {
        var u = this.options,
          A = a.symbolWidth,
          q = a.symbolHeight,
          n = q / 2,
          k = this.chart.renderer,
          e = this.legendGroup;
        a = a.baseline - Math.round(.3 * a.fontMetrics.b);
        var c = {},
          h = u.marker;
        this.chart.styledMode || (c = {
          "stroke-width": u.lineWidth || 0
        }, u.dashStyle && (c.dashstyle = u.dashStyle));
        this.legendLine = k.path([["M", 0, a], ["L", A, a]]).addClass("highcharts-graph").attr(c).add(e);
        h && !1 !== h.enabled && A && (u = Math.min(z(h.radius, n), n), 0 === this.symbol.indexOf("url") && (h = v(h, {
          width: q,
          height: q
        }), u = 0), this.legendSymbol = A = k.symbol(this.symbol, A / 2 - u, a - u, 2 * u, 2 * u, h).addClass("highcharts-point").add(e), A.isMarker = !0);
      };
      a.drawRectangle = function (a, v) {
        var u = a.symbolHeight,
          q = a.options.squareSymbol;
        v.legendSymbol = this.chart.renderer.rect(q ? (a.symbolWidth - u) / 2 : 0, a.baseline - u + 1, q ? u : a.symbolWidth, u, z(a.options.symbolRadius, u / 2)).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(v.legendGroup);
      };
    })(F || (F = {}));
    return F;
  });
  M(a, "Core/Series/SeriesDefaults.js", [], function () {
    return {
      lineWidth: 2,
      allowPointSelect: !1,
      crisp: !0,
      showCheckbox: !1,
      animation: {
        duration: 1E3
      },
      events: {},
      marker: {
        enabledThreshold: 2,
        lineColor: "#ffffff",
        lineWidth: 0,
        radius: 4,
        states: {
          normal: {
            animation: !0
          },
          hover: {
            animation: {
              duration: 50
            },
            enabled: !0,
            radiusPlus: 2,
            lineWidthPlus: 1
          },
          select: {
            fillColor: "#cccccc",
            lineColor: "#000000",
            lineWidth: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        animation: {},
        align: "center",
        defer: !0,
        formatter: function () {
          var a = this.series.chart.numberFormatter;
          return "number" !== typeof this.y ? "" : a(this.y, -1);
        },
        padding: 5,
        style: {
          fontSize: "11px",
          fontWeight: "bold",
          color: "contrast",
          textOutline: "1px contrast"
        },
        verticalAlign: "bottom",
        x: 0,
        y: 0
      },
      cropThreshold: 300,
      opacity: 1,
      pointRange: 0,
      softThreshold: !0,
      states: {
        normal: {
          animation: !0
        },
        hover: {
          animation: {
            duration: 50
          },
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10,
            opacity: .25
          }
        },
        select: {
          animation: {
            duration: 0
          }
        },
        inactive: {
          animation: {
            duration: 50
          },
          opacity: .2
        }
      },
      stickyTracking: !0,
      turboThreshold: 1E3,
      findNearestPointBy: "x"
    };
  });
  M(a, "Core/Series/Series.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/DefaultOptions.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/Point.js"], a["Core/Series/SeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, u, z, F, y, G, H, A, q, n) {
    var k = a.animObject,
      e = a.setAnimation,
      c = u.defaultOptions,
      h = z.registerEventOptions,
      f = F.hasTouch,
      w = F.svg,
      p = F.win,
      B = A.seriesTypes,
      t = n.addEvent,
      v = n.arrayMax,
      C = n.arrayMin,
      r = n.clamp,
      l = n.cleanRecursively,
      b = n.correctFloat,
      g = n.defined,
      d = n.erase,
      m = n.error,
      D = n.extend,
      x = n.find,
      I = n.fireEvent,
      P = n.getNestedProperty,
      S = n.isArray,
      O = n.isNumber,
      U = n.isString,
      Y = n.merge,
      L = n.objectEach,
      K = n.pick,
      M = n.removeEvent,
      da = n.splat,
      Q = n.syncTimeout;
    a = function () {
      function a() {
        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
      }
      a.prototype.init = function (a, b) {
        I(this, "init", {
          options: b
        });
        var c = this,
          d = a.series;
        this.eventsToUnbind = [];
        c.chart = a;
        c.options = c.setOptions(b);
        b = c.options;
        c.linkedSeries = [];
        c.bindAxes();
        D(c, {
          name: b.name,
          state: "",
          visible: !1 !== b.visible,
          selected: !0 === b.selected
        });
        h(this, b);
        var e = b.events;
        if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;
        c.getColor();
        c.getSymbol();
        c.parallelArrays.forEach(function (a) {
          c[a + "Data"] || (c[a + "Data"] = []);
        });
        c.isCartesian && (a.hasCartesianSeries = !0);
        var g;
        d.length && (g = d[d.length - 1]);
        c._i = K(g && g._i, -1) + 1;
        c.opacity = c.options.opacity;
        a.orderSeries(this.insert(d));
        b.dataSorting && b.dataSorting.enabled ? c.setDataSortingOptions() : c.points || c.data || c.setData(b.data, !1);
        I(this, "afterInit");
      };
      a.prototype.is = function (a) {
        return B[a] && this instanceof B[a];
      };
      a.prototype.insert = function (a) {
        var b = this.options.index,
          c;
        if (O(b)) {
          for (c = a.length; c--;) if (b >= K(a[c].options.index, a[c]._i)) {
            a.splice(c + 1, 0, this);
            break;
          }
          -1 === c && a.unshift(this);
          c += 1;
        } else a.push(this);
        return K(c, a.length - 1);
      };
      a.prototype.bindAxes = function () {
        var a = this,
          b = a.options,
          c = a.chart,
          d;
        I(this, "bindAxes", null, function () {
          (a.axisTypes || []).forEach(function (e) {
            var g = 0;
            c[e].forEach(function (c) {
              d = c.options;
              if (b[e] === g && !d.isInternal || "undefined" !== typeof b[e] && b[e] === d.id || "undefined" === typeof b[e] && 0 === d.index) a.insert(c.series), a[e] = c, c.isDirty = !0;
              d.isInternal || g++;
            });
            a[e] || a.optionalAxis === e || m(18, !0, c);
          });
        });
        I(this, "afterBindAxes");
      };
      a.prototype.updateParallelArrays = function (a, b) {
        var c = a.series,
          d = arguments,
          e = O(b) ? function (d) {
            var e = "y" === d && c.toYData ? c.toYData(a) : a[d];
            c[d + "Data"][b] = e;
          } : function (a) {
            Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2));
          };
        c.parallelArrays.forEach(e);
      };
      a.prototype.hasData = function () {
        return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
      };
      a.prototype.autoIncrement = function (a) {
        var b = this.options,
          c = b.pointIntervalUnit,
          d = b.relativeXValue,
          e = this.chart.time,
          g = this.xIncrement,
          f;
        g = K(g, b.pointStart, 0);
        this.pointInterval = f = K(this.pointInterval, b.pointInterval, 1);
        d && O(a) && (f *= a);
        c && (b = new e.Date(g), "day" === c ? e.set("Date", b, e.get("Date", b) + f) : "month" === c ? e.set("Month", b, e.get("Month", b) + f) : "year" === c && e.set("FullYear", b, e.get("FullYear", b) + f), f = b.getTime() - g);
        if (d && O(a)) return g + f;
        this.xIncrement = g + f;
        return g;
      };
      a.prototype.setDataSortingOptions = function () {
        var a = this.options;
        D(this, {
          requireSorting: !1,
          sorted: !1,
          enabledDataSorting: !0,
          allowDG: !1
        });
        g(a.pointRange) || (a.pointRange = 1);
      };
      a.prototype.setOptions = function (a) {
        var b = this.chart,
          d = b.options,
          e = d.plotOptions,
          f = b.userOptions || {};
        a = Y(a);
        b = b.styledMode;
        var h = {
          plotOptions: e,
          userOptions: a
        };
        I(this, "setOptions", h);
        var l = h.plotOptions[this.type],
          k = f.plotOptions || {};
        this.userOptions = h.userOptions;
        f = Y(l, e.series, f.plotOptions && f.plotOptions[this.type], a);
        this.tooltipOptions = Y(c.tooltip, c.plotOptions.series && c.plotOptions.series.tooltip, c.plotOptions[this.type].tooltip, d.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, a.tooltip);
        this.stickyTracking = K(a.stickyTracking, k[this.type] && k[this.type].stickyTracking, k.series && k.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);
        null === l.marker && delete f.marker;
        this.zoneAxis = f.zoneAxis;
        e = this.zones = (f.zones || []).slice();
        !f.negativeColor && !f.negativeFillColor || f.zones || (d = {
          value: f[this.zoneAxis + "Threshold"] || f.threshold || 0,
          className: "highcharts-negative"
        }, b || (d.color = f.negativeColor, d.fillColor = f.negativeFillColor), e.push(d));
        e.length && g(e[e.length - 1].value) && e.push(b ? {} : {
          color: this.color,
          fillColor: this.fillColor
        });
        I(this, "afterSetOptions", {
          options: f
        });
        return f;
      };
      a.prototype.getName = function () {
        return K(this.options.name, "Series " + (this.index + 1));
      };
      a.prototype.getCyclic = function (a, b, c) {
        var d = this.chart,
          e = this.userOptions,
          f = a + "Index",
          h = a + "Counter",
          l = c ? c.length : K(d.options.chart[a + "Count"], d[a + "Count"]);
        if (!b) {
          var k = K(e[f], e["_" + f]);
          g(k) || (d.series.length || (d[h] = 0), e["_" + f] = k = d[h] % l, d[h] += 1);
          c && (b = c[k]);
        }
        "undefined" !== typeof k && (this[f] = k);
        this[a] = b;
      };
      a.prototype.getColor = function () {
        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || c.plotOptions[this.type].color, this.chart.options.colors);
      };
      a.prototype.getPointsCollection = function () {
        return (this.hasGroupedData ? this.points : this.data) || [];
      };
      a.prototype.getSymbol = function () {
        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
      };
      a.prototype.findPointIndex = function (a, b) {
        var c = a.id,
          d = a.x,
          e = this.points,
          g = this.options.dataSorting,
          f,
          h;
        if (c) g = this.chart.get(c), g instanceof G && (f = g);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (f = function (b) {
          return !b.touched && b.index === a.index;
        }, g && g.matchByName ? f = function (b) {
          return !b.touched && b.name === a.name;
        } : this.options.relativeXValue && (f = function (b) {
          return !b.touched && b.options.x === a.x;
        }), f = x(e, f), !f) return;
        if (f) {
          var l = f && f.index;
          "undefined" !== typeof l && (h = !0);
        }
        "undefined" === typeof l && O(d) && (l = this.xData.indexOf(d, b));
        -1 !== l && "undefined" !== typeof l && this.cropped && (l = l >= this.cropStart ? l - this.cropStart : l);
        !h && O(l) && e[l] && e[l].touched && (l = void 0);
        return l;
      };
      a.prototype.updateData = function (a, b) {
        var c = this.options,
          d = c.dataSorting,
          e = this.points,
          f = [],
          h = this.requireSorting,
          l = a.length === e.length,
          k,
          m,
          p,
          n = !0;
        this.xIncrement = null;
        a.forEach(function (a, b) {
          var m = g(a) && this.pointClass.prototype.optionsToObject.call({
              series: this
            }, a) || {},
            n = m.x;
          if (m.id || O(n)) {
            if (m = this.findPointIndex(m, p), -1 === m || "undefined" === typeof m ? f.push(a) : e[m] && a !== c.data[m] ? (e[m].update(a, !1, null, !1), e[m].touched = !0, h && (p = m + 1)) : e[m] && (e[m].touched = !0), !l || b !== m || d && d.enabled || this.hasDerivedData) k = !0;
          } else f.push(a);
        }, this);
        if (k) for (a = e.length; a--;) (m = e[a]) && !m.touched && m.remove && m.remove(!1, b);else !l || d && d.enabled ? n = !1 : (a.forEach(function (a, b) {
          a !== e[b].y && e[b].update && e[b].update(a, !1, null, !1);
        }), f.length = 0);
        e.forEach(function (a) {
          a && (a.touched = !1);
        });
        if (!n) return !1;
        f.forEach(function (a) {
          this.addPoint(a, !1, null, null, !1);
        }, this);
        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = v(this.xData), this.autoIncrement());
        return !0;
      };
      a.prototype.setData = function (a, b, c, d) {
        var e = this,
          g = e.points,
          f = g && g.length || 0,
          h = e.options,
          l = e.chart,
          k = h.dataSorting,
          p = e.xAxis,
          n = h.turboThreshold,
          r = this.xData,
          E = this.yData,
          t = e.pointArrayMap;
        t = t && t.length;
        var q = h.keys,
          w,
          B = 0,
          C = 1,
          x = null;
        a = a || [];
        var v = a.length;
        b = K(b, !0);
        k && k.enabled && (a = this.sortData(a));
        !1 !== d && v && f && !e.cropped && !e.hasGroupedData && e.visible && !e.isSeriesBoosting && (w = this.updateData(a, c));
        if (!w) {
          e.xIncrement = null;
          e.colorCounter = 0;
          this.parallelArrays.forEach(function (a) {
            e[a + "Data"].length = 0;
          });
          if (n && v > n) {
            if (x = e.getFirstValidPoint(a), O(x)) for (c = 0; c < v; c++) r[c] = this.autoIncrement(), E[c] = a[c];else if (S(x)) {
              if (t) {
                if (x.length === t) for (c = 0; c < v; c++) r[c] = this.autoIncrement(), E[c] = a[c];else for (c = 0; c < v; c++) d = a[c], r[c] = d[0], E[c] = d.slice(1, t + 1);
              } else if (q && (B = q.indexOf("x"), C = q.indexOf("y"), B = 0 <= B ? B : 0, C = 0 <= C ? C : 1), 1 === x.length && (C = 0), B === C) for (c = 0; c < v; c++) r[c] = this.autoIncrement(), E[c] = a[c][C];else for (c = 0; c < v; c++) d = a[c], r[c] = d[B], E[c] = d[C];
            } else m(12, !1, l);
          } else for (c = 0; c < v; c++) "undefined" !== typeof a[c] && (d = {
            series: e
          }, e.pointClass.prototype.applyOptions.apply(d, [a[c]]), e.updateParallelArrays(d, c));
          E && U(E[0]) && m(14, !0, l);
          e.data = [];
          e.options.data = e.userOptions.data = a;
          for (c = f; c--;) g[c] && g[c].destroy && g[c].destroy();
          p && (p.minRange = p.userMinRange);
          e.isDirty = l.isDirtyBox = !0;
          e.isDirtyData = !!g;
          c = !1;
        }
        "point" === h.legendType && (this.processData(), this.generatePoints());
        b && l.redraw(c);
      };
      a.prototype.sortData = function (a) {
        var b = this,
          c = b.options.dataSorting.sortKey || "y",
          d = function (a, b) {
            return g(b) && a.pointClass.prototype.optionsToObject.call({
              series: a
            }, b) || {};
          };
        a.forEach(function (c, e) {
          a[e] = d(b, c);
          a[e].index = e;
        }, this);
        a.concat().sort(function (a, b) {
          a = P(c, a);
          b = P(c, b);
          return b < a ? -1 : b > a ? 1 : 0;
        }).forEach(function (a, b) {
          a.x = b;
        }, this);
        b.linkedSeries && b.linkedSeries.forEach(function (b) {
          var c = b.options,
            e = c.data;
          c.dataSorting && c.dataSorting.enabled || !e || (e.forEach(function (c, g) {
            e[g] = d(b, c);
            a[g] && (e[g].x = a[g].x, e[g].index = g);
          }), b.setData(e, !1));
        });
        return a;
      };
      a.prototype.getProcessedData = function (a) {
        var b = this.xAxis,
          c = this.options,
          d = c.cropThreshold,
          e = a || this.getExtremesFromAll || c.getExtremesFromAll,
          g = this.isCartesian;
        a = b && b.val2lin;
        c = !(!b || !b.logarithmic);
        var f = 0,
          h = this.xData,
          l = this.yData,
          k = this.requireSorting;
        var p = !1;
        var n = h.length;
        if (b) {
          p = b.getExtremes();
          var r = p.min;
          var E = p.max;
          p = b.categories && !b.names.length;
        }
        if (g && this.sorted && !e && (!d || n > d || this.forceCrop)) if (h[n - 1] < r || h[0] > E) h = [], l = [];else if (this.yData && (h[0] < r || h[n - 1] > E)) {
          var t = this.cropData(this.xData, this.yData, r, E);
          h = t.xData;
          l = t.yData;
          f = t.start;
          t = !0;
        }
        for (d = h.length || 1; --d;) if (b = c ? a(h[d]) - a(h[d - 1]) : h[d] - h[d - 1], 0 < b && ("undefined" === typeof q || b < q)) var q = b;else 0 > b && k && !p && (m(15, !1, this.chart), k = !1);
        return {
          xData: h,
          yData: l,
          cropped: t,
          cropStart: f,
          closestPointRange: q
        };
      };
      a.prototype.processData = function (a) {
        var b = this.xAxis;
        if (this.isCartesian && !this.isDirty && !b.isDirty && !this.yAxis.isDirty && !a) return !1;
        a = this.getProcessedData();
        this.cropped = a.cropped;
        this.cropStart = a.cropStart;
        this.processedXData = a.xData;
        this.processedYData = a.yData;
        this.closestPointRange = this.basePointRange = a.closestPointRange;
        I(this, "afterProcessData");
      };
      a.prototype.cropData = function (a, b, c, d, e) {
        var g = a.length,
          f,
          h = 0,
          l = g;
        e = K(e, this.cropShoulder);
        for (f = 0; f < g; f++) if (a[f] >= c) {
          h = Math.max(0, f - e);
          break;
        }
        for (c = f; c < g; c++) if (a[c] > d) {
          l = c + e;
          break;
        }
        return {
          xData: a.slice(h, l),
          yData: b.slice(h, l),
          start: h,
          end: l
        };
      };
      a.prototype.generatePoints = function () {
        var a = this.options,
          b = a.data,
          c = this.processedXData,
          d = this.processedYData,
          e = this.pointClass,
          g = c.length,
          f = this.cropStart || 0,
          h = this.hasGroupedData,
          l = a.keys,
          k = [];
        a = a.dataGrouping && a.dataGrouping.groupAll ? f : 0;
        var m,
          p,
          n = this.data;
        if (!n && !h) {
          var r = [];
          r.length = b.length;
          n = this.data = r;
        }
        l && h && (this.options.keys = !1);
        for (p = 0; p < g; p++) {
          r = f + p;
          if (h) {
            var t = new e().init(this, [c[p]].concat(da(d[p])));
            t.dataGroup = this.groupMap[a + p];
            t.dataGroup.options && (t.options = t.dataGroup.options, D(t, t.dataGroup.options), delete t.dataLabels);
          } else (t = n[r]) || "undefined" === typeof b[r] || (n[r] = t = new e().init(this, b[r], c[p]));
          t && (t.index = h ? a + p : r, k[p] = t);
        }
        this.options.keys = l;
        if (n && (g !== (m = n.length) || h)) for (p = 0; p < m; p++) p !== f || h || (p += g), n[p] && (n[p].destroyElements(), n[p].plotX = void 0);
        this.data = n;
        this.points = k;
        I(this, "afterGeneratePoints");
      };
      a.prototype.getXExtremes = function (a) {
        return {
          min: C(a),
          max: v(a)
        };
      };
      a.prototype.getExtremes = function (a, b) {
        var c = this.xAxis,
          d = this.yAxis,
          e = this.processedXData || this.xData,
          g = [],
          f = this.requireSorting ? this.cropShoulder : 0;
        d = d ? d.positiveValuesOnly : !1;
        var h,
          l = 0,
          k = 0,
          m = 0;
        a = a || this.stackedYData || this.processedYData || [];
        var p = a.length;
        if (c) {
          var n = c.getExtremes();
          l = n.min;
          k = n.max;
        }
        for (h = 0; h < p; h++) {
          var r = e[h];
          n = a[h];
          var t = (O(n) || S(n)) && (n.length || 0 < n || !d);
          r = b || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c || (e[h + f] || r) >= l && (e[h - f] || r) <= k;
          if (t && r) if (t = n.length) for (; t--;) O(n[t]) && (g[m++] = n[t]);else g[m++] = n;
        }
        a = {
          activeYData: g,
          dataMin: C(g),
          dataMax: v(g)
        };
        I(this, "afterGetExtremes", {
          dataExtremes: a
        });
        return a;
      };
      a.prototype.applyExtremes = function () {
        var a = this.getExtremes();
        this.dataMin = a.dataMin;
        this.dataMax = a.dataMax;
        return a;
      };
      a.prototype.getFirstValidPoint = function (a) {
        for (var b = a.length, c = 0, d = null; null === d && c < b;) d = a[c], c++;
        return d;
      };
      a.prototype.translate = function () {
        this.processedXData || this.processData();
        this.generatePoints();
        var a = this.options,
          c = a.stacking,
          d = this.xAxis,
          e = d.categories,
          f = this.enabledDataSorting,
          h = this.yAxis,
          l = this.points,
          k = l.length,
          m = this.pointPlacementToXValue(),
          p = !!m,
          n = a.threshold,
          t = a.startFromThreshold ? n : 0,
          q = this.zoneAxis || "y",
          w,
          B,
          C = Number.MAX_VALUE;
        for (w = 0; w < k; w++) {
          var x = l[w],
            v = x.x,
            u = void 0,
            D = void 0,
            J = x.y,
            A = x.low,
            y = c && h.stacking && h.stacking.stacks[(this.negStacks && J < (t ? 0 : n) ? "-" : "") + this.stackKey];
          if (h.positiveValuesOnly && !h.validatePositiveValue(J) || d.positiveValuesOnly && !d.validatePositiveValue(v)) x.isNull = !0;
          x.plotX = B = b(r(d.translate(v, 0, 0, 0, 1, m, "flags" === this.type), -1E5, 1E5));
          if (c && this.visible && y && y[v]) {
            var z = this.getStackIndicator(z, v, this.index);
            x.isNull || (u = y[v], D = u.points[z.key]);
          }
          S(D) && (A = D[0], J = D[1], A === t && z.key === y[v].base && (A = K(O(n) && n, h.min)), h.positiveValuesOnly && 0 >= A && (A = null), x.total = x.stackTotal = u.total, x.percentage = u.total && x.y / u.total * 100, x.stackY = J, this.irregularWidths || u.setOffset(this.pointXOffset || 0, this.barW || 0));
          x.yBottom = g(A) ? r(h.translate(A, 0, 1, 0, 1), -1E5, 1E5) : null;
          this.dataModify && (J = this.dataModify.modifyValue(J, w));
          x.plotY = void 0;
          O(J) && (u = h.translate(J, !1, !0, !1, !0), "undefined" !== typeof u && (x.plotY = r(u, -1E5, 1E5)));
          x.isInside = this.isPointInside(x);
          x.clientX = p ? b(d.translate(v, 0, 0, 0, 1, m)) : B;
          x.negative = x[q] < (a[q + "Threshold"] || n || 0);
          x.category = e && "undefined" !== typeof e[x.x] ? e[x.x] : x.x;
          if (!x.isNull && !1 !== x.visible) {
            "undefined" !== typeof F && (C = Math.min(C, Math.abs(B - F)));
            var F = B;
          }
          x.zone = this.zones.length ? x.getZone() : void 0;
          !x.graphic && this.group && f && (x.isNew = !0);
        }
        this.closestPointRangePx = C;
        I(this, "afterTranslate");
      };
      a.prototype.getValidPoints = function (a, b, c) {
        var d = this.chart;
        return (a || this.points || []).filter(function (a) {
          return b && !d.isInsidePlot(a.plotX, a.plotY, {
            inverted: d.inverted
          }) ? !1 : !1 !== a.visible && (c || !a.isNull);
        });
      };
      a.prototype.getClipBox = function () {
        var a = this.chart,
          b = this.xAxis,
          c = this.yAxis,
          d = Y(a.clipBox);
        b && b.len !== a.plotSizeX && (d.width = b.len);
        c && c.len !== a.plotSizeY && (d.height = c.len);
        return d;
      };
      a.prototype.getSharedClipKey = function () {
        return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
      };
      a.prototype.setClip = function () {
        var a = this.chart,
          b = this.group,
          c = this.markerGroup,
          d = a.sharedClips;
        a = a.renderer;
        var e = this.getClipBox(),
          g = this.getSharedClipKey(),
          f = d[g];
        f ? f.animate(e) : d[g] = f = a.clipRect(e);
        b && b.clip(!1 === this.options.clip ? void 0 : f);
        c && c.clip();
      };
      a.prototype.animate = function (a) {
        var b = this.chart,
          c = this.group,
          d = this.markerGroup,
          e = b.inverted,
          g = k(this.options.animation),
          f = [this.getSharedClipKey(), g.duration, g.easing, g.defer].join(),
          h = b.sharedClips[f],
          l = b.sharedClips[f + "m"];
        if (a && c) g = this.getClipBox(), h ? h.attr("height", g.height) : (g.width = 0, e && (g.x = b.plotHeight), h = b.renderer.clipRect(g), b.sharedClips[f] = h, l = b.renderer.clipRect({
          x: e ? (b.plotSizeX || 0) + 99 : -99,
          y: e ? -b.plotLeft : -b.plotTop,
          width: 99,
          height: e ? b.chartWidth : b.chartHeight
        }), b.sharedClips[f + "m"] = l), c.clip(h), d && d.clip(l);else if (h && !h.hasClass("highcharts-animating")) {
          b = this.getClipBox();
          var m = g.step;
          d && d.element.childNodes.length && (g.step = function (a, b) {
            m && m.apply(b, arguments);
            l && l.element && l.attr(b.prop, "width" === b.prop ? a + 99 : a);
          });
          h.addClass("highcharts-animating").animate(b, g);
        }
      };
      a.prototype.afterAnimate = function () {
        var a = this;
        this.setClip();
        L(this.chart.sharedClips, function (b, c, d) {
          b && !a.chart.container.querySelector('[clip-path="url(#' + b.id + ')"]') && (b.destroy(), delete d[c]);
        });
        this.finishedAnimating = !0;
        I(this, "afterAnimate");
      };
      a.prototype.drawPoints = function () {
        var a = this.points,
          b = this.chart,
          c = this.options.marker,
          d = this[this.specialGroup] || this.markerGroup,
          e = this.xAxis,
          g = K(c.enabled, !e || e.isRadial ? !0 : null, this.closestPointRangePx >= c.enabledThreshold * c.radius),
          f,
          h;
        if (!1 !== c.enabled || this._hasPointMarkers) for (f = 0; f < a.length; f++) {
          var l = a[f];
          var k = (h = l.graphic) ? "animate" : "attr";
          var m = l.marker || {};
          var p = !!l.marker;
          if ((g && "undefined" === typeof m.enabled || m.enabled) && !l.isNull && !1 !== l.visible) {
            var n = K(m.symbol, this.symbol, "rect");
            var r = this.markerAttribs(l, l.selected && "select");
            this.enabledDataSorting && (l.startXPos = e.reversed ? -(r.width || 0) : e.width);
            var t = !1 !== l.isInside;
            h ? h[t ? "show" : "hide"](t).animate(r) : t && (0 < (r.width || 0) || l.hasImage) && (l.graphic = h = b.renderer.symbol(n, r.x, r.y, r.width, r.height, p ? m : c).add(d), this.enabledDataSorting && b.hasRendered && (h.attr({
              x: l.startXPos
            }), k = "animate"));
            h && "animate" === k && h[t ? "show" : "hide"](t).animate(r);
            if (h && !b.styledMode) h[k](this.pointAttribs(l, l.selected && "select"));
            h && h.addClass(l.getClassName(), !0);
          } else h && (l.graphic = h.destroy());
        }
      };
      a.prototype.markerAttribs = function (a, b) {
        var c = this.options,
          d = c.marker,
          e = a.marker || {},
          g = e.symbol || d.symbol,
          f = K(e.radius, d.radius);
        b && (d = d.states[b], b = e.states && e.states[b], f = K(b && b.radius, d && d.radius, f + (d && d.radiusPlus || 0)));
        a.hasImage = g && 0 === g.indexOf("url");
        a.hasImage && (f = 0);
        a = {
          x: c.crisp ? Math.floor(a.plotX - f) : a.plotX - f,
          y: a.plotY - f
        };
        f && (a.width = a.height = 2 * f);
        return a;
      };
      a.prototype.pointAttribs = function (a, b) {
        var c = this.options.marker,
          d = a && a.options,
          e = d && d.marker || {},
          g = d && d.color,
          f = a && a.color,
          h = a && a.zone && a.zone.color,
          l = this.color;
        a = K(e.lineWidth, c.lineWidth);
        d = 1;
        l = g || h || f || l;
        g = e.fillColor || c.fillColor || l;
        f = e.lineColor || c.lineColor || l;
        b = b || "normal";
        c = c.states[b] || {};
        b = e.states && e.states[b] || {};
        a = K(b.lineWidth, c.lineWidth, a + K(b.lineWidthPlus, c.lineWidthPlus, 0));
        g = b.fillColor || c.fillColor || g;
        f = b.lineColor || c.lineColor || f;
        d = K(b.opacity, c.opacity, d);
        return {
          stroke: f,
          "stroke-width": a,
          fill: g,
          opacity: d
        };
      };
      a.prototype.destroy = function (a) {
        var b = this,
          c = b.chart,
          e = /AppleWebKit\/533/.test(p.navigator.userAgent),
          g = b.data || [],
          f,
          h,
          l,
          k;
        I(b, "destroy");
        this.removeEvents(a);
        (b.axisTypes || []).forEach(function (a) {
          (k = b[a]) && k.series && (d(k.series, b), k.isDirty = k.forceRedraw = !0);
        });
        b.legendItem && b.chart.legend.destroyItem(b);
        for (h = g.length; h--;) (l = g[h]) && l.destroy && l.destroy();
        b.clips && b.clips.forEach(function (a) {
          return a.destroy();
        });
        n.clearTimeout(b.animationTimeout);
        L(b, function (a, b) {
          a instanceof q && !a.survive && (f = e && "group" === b ? "hide" : "destroy", a[f]());
        });
        c.hoverSeries === b && (c.hoverSeries = void 0);
        d(c.series, b);
        c.orderSeries();
        L(b, function (c, d) {
          a && "hcEvents" === d || delete b[d];
        });
      };
      a.prototype.applyZones = function () {
        var a = this,
          b = this.chart,
          c = b.renderer,
          d = this.zones,
          e = this.clips || [],
          g = this.graph,
          f = this.area,
          h = Math.max(b.chartWidth, b.chartHeight),
          l = this[(this.zoneAxis || "y") + "Axis"],
          k = b.inverted,
          m,
          p,
          n,
          t,
          q,
          x,
          w,
          B,
          C = !1;
        if (d.length && (g || f) && l && "undefined" !== typeof l.min) {
          var v = l.reversed;
          var u = l.horiz;
          g && !this.showLine && g.hide();
          f && f.hide();
          var D = l.getExtremes();
          d.forEach(function (d, E) {
            m = v ? u ? b.plotWidth : 0 : u ? 0 : l.toPixels(D.min) || 0;
            m = r(K(p, m), 0, h);
            p = r(Math.round(l.toPixels(K(d.value, D.max), !0) || 0), 0, h);
            C && (m = p = l.toPixels(D.max));
            t = Math.abs(m - p);
            q = Math.min(m, p);
            x = Math.max(m, p);
            l.isXAxis ? (n = {
              x: k ? x : q,
              y: 0,
              width: t,
              height: h
            }, u || (n.x = b.plotHeight - n.x)) : (n = {
              x: 0,
              y: k ? x : q,
              width: h,
              height: t
            }, u && (n.y = b.plotWidth - n.y));
            k && c.isVML && (n = l.isXAxis ? {
              x: 0,
              y: v ? q : x,
              height: n.width,
              width: b.chartWidth
            } : {
              x: n.y - b.plotLeft - b.spacingBox.x,
              y: 0,
              width: n.height,
              height: b.chartHeight
            });
            e[E] ? e[E].animate(n) : e[E] = c.clipRect(n);
            w = a["zone-area-" + E];
            B = a["zone-graph-" + E];
            g && B && B.clip(e[E]);
            f && w && w.clip(e[E]);
            C = d.value > D.max;
            a.resetZones && 0 === p && (p = void 0);
          });
          this.clips = e;
        } else a.visible && (g && g.show(!0), f && f.show(!0));
      };
      a.prototype.invertGroups = function (a) {
        function b() {
          ["group", "markerGroup"].forEach(function (b) {
            c[b] && (d.renderer.isVML && c[b].attr({
              width: c.yAxis.len,
              height: c.xAxis.len
            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(c.isRadialSeries ? !1 : a));
          });
        }
        var c = this,
          d = c.chart;
        c.xAxis && (c.eventsToUnbind.push(t(d, "resize", b)), b(), c.invertGroups = b);
      };
      a.prototype.plotGroup = function (a, b, c, d, e) {
        var f = this[a],
          h = !f;
        c = {
          visibility: c,
          zIndex: d || .1
        };
        "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (c.opacity = this.opacity);
        h && (this[a] = f = this.chart.renderer.g().add(e));
        f.addClass("highcharts-" + b + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (g(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (f.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
        f.attr(c)[h ? "attr" : "animate"](this.getPlotBox());
        return f;
      };
      a.prototype.getPlotBox = function () {
        var a = this.chart,
          b = this.xAxis,
          c = this.yAxis;
        a.inverted && (b = c, c = this.xAxis);
        return {
          translateX: b ? b.left : a.plotLeft,
          translateY: c ? c.top : a.plotTop,
          scaleX: 1,
          scaleY: 1
        };
      };
      a.prototype.removeEvents = function (a) {
        a || M(this);
        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {
          a();
        }), this.eventsToUnbind.length = 0);
      };
      a.prototype.render = function () {
        var a = this,
          b = a.chart,
          c = a.options,
          d = k(c.animation),
          e = a.visible ? "inherit" : "hidden",
          g = c.zIndex,
          f = a.hasRendered,
          h = b.seriesGroup,
          l = b.inverted;
        b = !a.finishedAnimating && b.renderer.isSVG ? d.duration : 0;
        I(this, "render");
        var m = a.plotGroup("group", "series", e, g, h);
        a.markerGroup = a.plotGroup("markerGroup", "markers", e, g, h);
        !1 !== c.clip && a.setClip();
        a.animate && b && a.animate(!0);
        m.inverted = K(a.invertible, a.isCartesian) ? l : !1;
        a.drawGraph && (a.drawGraph(), a.applyZones());
        a.visible && a.drawPoints();
        a.drawDataLabels && a.drawDataLabels();
        a.redrawPoints && a.redrawPoints();
        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
        a.invertGroups(l);
        a.animate && b && a.animate();
        f || (b && d.defer && (b += d.defer), a.animationTimeout = Q(function () {
          a.afterAnimate();
        }, b || 0));
        a.isDirty = !1;
        a.hasRendered = !0;
        I(a, "afterRender");
      };
      a.prototype.redraw = function () {
        var a = this.chart,
          b = this.isDirty || this.isDirtyData,
          c = this.group,
          d = this.xAxis,
          e = this.yAxis;
        c && (a.inverted && c.attr({
          width: a.plotWidth,
          height: a.plotHeight
        }), c.animate({
          translateX: K(d && d.left, a.plotLeft),
          translateY: K(e && e.top, a.plotTop)
        }));
        this.translate();
        this.render();
        b && delete this.kdTree;
      };
      a.prototype.searchPoint = function (a, b) {
        var c = this.xAxis,
          d = this.yAxis,
          e = this.chart.inverted;
        return this.searchKDTree({
          clientX: e ? c.len - a.chartY + c.pos : a.chartX - c.pos,
          plotY: e ? d.len - a.chartX + d.pos : a.chartY - d.pos
        }, b, a);
      };
      a.prototype.buildKDTree = function (a) {
        function b(a, d, e) {
          var g = a && a.length;
          if (g) {
            var f = c.kdAxisArray[d % e];
            a.sort(function (a, b) {
              return a[f] - b[f];
            });
            g = Math.floor(g / 2);
            return {
              point: a[g],
              left: b(a.slice(0, g), d + 1, e),
              right: b(a.slice(g + 1), d + 1, e)
            };
          }
        }
        this.buildingKdTree = !0;
        var c = this,
          d = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        delete c.kdTree;
        Q(function () {
          c.kdTree = b(c.getValidPoints(null, !c.directTouch), d, d);
          c.buildingKdTree = !1;
        }, c.options.kdNow || a && "touchstart" === a.type ? 0 : 1);
      };
      a.prototype.searchKDTree = function (a, b, c) {
        function d(a, b, c, k) {
          var m = b.point,
            p = e.kdAxisArray[c % k],
            n = m,
            r = g(a[f]) && g(m[f]) ? Math.pow(a[f] - m[f], 2) : null;
          var t = g(a[h]) && g(m[h]) ? Math.pow(a[h] - m[h], 2) : null;
          t = (r || 0) + (t || 0);
          m.dist = g(t) ? Math.sqrt(t) : Number.MAX_VALUE;
          m.distX = g(r) ? Math.sqrt(r) : Number.MAX_VALUE;
          p = a[p] - m[p];
          t = 0 > p ? "left" : "right";
          r = 0 > p ? "right" : "left";
          b[t] && (t = d(a, b[t], c + 1, k), n = t[l] < n[l] ? t : m);
          b[r] && Math.sqrt(p * p) < n[l] && (a = d(a, b[r], c + 1, k), n = a[l] < n[l] ? a : n);
          return n;
        }
        var e = this,
          f = this.kdAxisArray[0],
          h = this.kdAxisArray[1],
          l = b ? "distX" : "dist";
        b = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        this.kdTree || this.buildingKdTree || this.buildKDTree(c);
        if (this.kdTree) return d(a, this.kdTree, b, b);
      };
      a.prototype.pointPlacementToXValue = function () {
        var a = this.options,
          b = a.pointRange,
          c = this.xAxis;
        a = a.pointPlacement;
        "between" === a && (a = c.reversed ? -.5 : .5);
        return O(a) ? a * (b || c.pointRange) : 0;
      };
      a.prototype.isPointInside = function (a) {
        var b = this.chart,
          c = this.xAxis,
          d = this.yAxis;
        return "undefined" !== typeof a.plotY && "undefined" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= (d ? d.len : b.plotHeight) && 0 <= a.plotX && a.plotX <= (c ? c.len : b.plotWidth);
      };
      a.prototype.drawTracker = function () {
        var a = this,
          b = a.options,
          c = b.trackByArea,
          d = [].concat(c ? a.areaPath : a.graphPath),
          e = a.chart,
          g = e.pointer,
          h = e.renderer,
          l = e.options.tooltip.snap,
          m = a.tracker,
          k = function (b) {
            if (e.hoverSeries !== a) a.onMouseOver();
          },
          p = "rgba(192,192,192," + (w ? .0001 : .002) + ")";
        m ? m.attr({
          d: d
        }) : a.graph && (a.tracker = h.path(d).attr({
          visibility: a.visible ? "visible" : "hidden",
          zIndex: 2
        }).addClass(c ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group), e.styledMode || a.tracker.attr({
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          stroke: p,
          fill: c ? p : "none",
          "stroke-width": a.graph.strokeWidth() + (c ? 0 : 2 * l)
        }), [a.tracker, a.markerGroup, a.dataLabelsGroup].forEach(function (a) {
          if (a && (a.addClass("highcharts-tracker").on("mouseover", k).on("mouseout", function (a) {
            g.onTrackerMouseOut(a);
          }), b.cursor && !e.styledMode && a.css({
            cursor: b.cursor
          }), f)) a.on("touchstart", k);
        }));
        I(this, "afterDrawTracker");
      };
      a.prototype.addPoint = function (a, b, c, d, e) {
        var g = this.options,
          f = this.data,
          h = this.chart,
          l = this.xAxis;
        l = l && l.hasNames && l.names;
        var m = g.data,
          k = this.xData,
          p;
        b = K(b, !0);
        var n = {
          series: this
        };
        this.pointClass.prototype.applyOptions.apply(n, [a]);
        var r = n.x;
        var t = k.length;
        if (this.requireSorting && r < k[t - 1]) for (p = !0; t && k[t - 1] > r;) t--;
        this.updateParallelArrays(n, "splice", t, 0, 0);
        this.updateParallelArrays(n, t);
        l && n.name && (l[r] = n.name);
        m.splice(t, 0, a);
        p && (this.data.splice(t, 0, null), this.processData());
        "point" === g.legendType && this.generatePoints();
        c && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(n, "shift"), m.shift()));
        !1 !== e && I(this, "addPoint", {
          point: n
        });
        this.isDirtyData = this.isDirty = !0;
        b && h.redraw(d);
      };
      a.prototype.removePoint = function (a, b, c) {
        var d = this,
          g = d.data,
          f = g[a],
          h = d.points,
          l = d.chart,
          k = function () {
            h && h.length === g.length && h.splice(a, 1);
            g.splice(a, 1);
            d.options.data.splice(a, 1);
            d.updateParallelArrays(f || {
              series: d
            }, "splice", a, 1);
            f && f.destroy();
            d.isDirty = !0;
            d.isDirtyData = !0;
            b && l.redraw();
          };
        e(c, l);
        b = K(b, !0);
        f ? f.firePointEvent("remove", null, k) : k();
      };
      a.prototype.remove = function (a, b, c, d) {
        function e() {
          g.destroy(d);
          f.isDirtyLegend = f.isDirtyBox = !0;
          f.linkSeries();
          K(a, !0) && f.redraw(b);
        }
        var g = this,
          f = g.chart;
        !1 !== c ? I(g, "remove", null, e) : e();
      };
      a.prototype.update = function (a, b) {
        a = l(a, this.userOptions);
        I(this, "update", {
          options: a
        });
        var c = this,
          d = c.chart,
          e = c.userOptions,
          g = c.initialType || c.type,
          f = d.options.plotOptions,
          h = B[g].prototype,
          k = c.finishedAnimating && {
            animation: !1
          },
          p = {},
          n,
          r = ["eventOptions", "navigatorSeries", "baseSeries"],
          t = a.type || e.type || d.options.chart.type,
          q = !(this.hasDerivedData || t && t !== this.type || "undefined" !== typeof a.pointStart || "undefined" !== typeof a.pointInterval || "undefined" !== typeof a.relativeXValue || c.hasOptionChanged("dataGrouping") || c.hasOptionChanged("pointStart") || c.hasOptionChanged("pointInterval") || c.hasOptionChanged("pointIntervalUnit") || c.hasOptionChanged("keys"));
        t = t || g;
        q && (r.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== a.visible && r.push("area", "graph"), c.parallelArrays.forEach(function (a) {
          r.push(a + "Data");
        }), a.data && (a.dataSorting && D(c.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));
        a = Y(e, k, {
          index: "undefined" === typeof e.index ? c.index : e.index,
          pointStart: K(f && f.series && f.series.pointStart, e.pointStart, c.xData[0])
        }, !q && {
          data: c.options.data
        }, a);
        q && a.data && (a.data = c.options.data);
        r = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(r);
        r.forEach(function (a) {
          r[a] = c[a];
          delete c[a];
        });
        f = !1;
        if (B[t]) {
          if (f = t !== c.type, c.remove(!1, !1, !1, !0), f) if (Object.setPrototypeOf) Object.setPrototypeOf(c, B[t].prototype);else {
            k = Object.hasOwnProperty.call(c, "hcEvents") && c.hcEvents;
            for (n in h) c[n] = void 0;
            D(c, B[t].prototype);
            k ? c.hcEvents = k : delete c.hcEvents;
          }
        } else m(17, !0, d, {
          missingModuleFor: t
        });
        r.forEach(function (a) {
          c[a] = r[a];
        });
        c.init(d, a);
        if (q && this.points) {
          var x = c.options;
          !1 === x.visible ? (p.graphic = 1, p.dataLabel = 1) : c._hasPointLabels || (a = x.marker, h = x.dataLabels, !a || !1 !== a.enabled && (e.marker && e.marker.symbol) === a.symbol || (p.graphic = 1), h && !1 === h.enabled && (p.dataLabel = 1));
          this.points.forEach(function (a) {
            a && a.series && (a.resolveColor(), Object.keys(p).length && a.destroyElements(p), !1 === x.showInLegend && a.legendItem && d.legend.destroyItem(a));
          }, this);
        }
        c.initialType = g;
        d.linkSeries();
        f && c.linkedSeries.length && (c.isDirtyData = !0);
        I(this, "afterUpdate");
        K(b, !0) && d.redraw(q ? void 0 : !1);
      };
      a.prototype.setName = function (a) {
        this.name = this.options.name = this.userOptions.name = a;
        this.chart.isDirtyLegend = !0;
      };
      a.prototype.hasOptionChanged = function (a) {
        var b = this.options[a],
          c = this.chart.options.plotOptions,
          d = this.userOptions[a];
        return d ? b !== d : b !== K(c && c[this.type] && c[this.type][a], c && c.series && c.series[a], b);
      };
      a.prototype.onMouseOver = function () {
        var a = this.chart,
          b = a.hoverSeries;
        a.pointer.setHoverChartIndex();
        if (b && b !== this) b.onMouseOut();
        this.options.events.mouseOver && I(this, "mouseOver");
        this.setState("hover");
        a.hoverSeries = this;
      };
      a.prototype.onMouseOut = function () {
        var a = this.options,
          b = this.chart,
          c = b.tooltip,
          d = b.hoverPoint;
        b.hoverSeries = null;
        if (d) d.onMouseOut();
        this && a.events.mouseOut && I(this, "mouseOut");
        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();
        b.series.forEach(function (a) {
          a.setState("", !0);
        });
      };
      a.prototype.setState = function (a, b) {
        var c = this,
          d = c.options,
          e = c.graph,
          g = d.inactiveOtherPoints,
          f = d.states,
          h = K(f[a || "normal"] && f[a || "normal"].animation, c.chart.options.chart.animation),
          l = d.lineWidth,
          k = 0,
          m = d.opacity;
        a = a || "";
        if (c.state !== a && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (b) {
          b && (c.state && b.removeClass("highcharts-series-" + c.state), a && b.addClass("highcharts-series-" + a));
        }), c.state = a, !c.chart.styledMode)) {
          if (f[a] && !1 === f[a].enabled) return;
          a && (l = f[a].lineWidth || l + (f[a].lineWidthPlus || 0), m = K(f[a].opacity, m));
          if (e && !e.dashstyle) for (d = {
            "stroke-width": l
          }, e.animate(d, h); c["zone-graph-" + k];) c["zone-graph-" + k].animate(d, h), k += 1;
          g || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (a) {
            a && a.animate({
              opacity: m
            }, h);
          });
        }
        b && g && c.points && c.setAllPointsToState(a || void 0);
      };
      a.prototype.setAllPointsToState = function (a) {
        this.points.forEach(function (b) {
          b.setState && b.setState(a);
        });
      };
      a.prototype.setVisible = function (a, b) {
        var c = this,
          d = c.chart,
          e = c.legendItem,
          g = d.options.chart.ignoreHiddenSeries,
          f = c.visible,
          h = (c.visible = a = c.options.visible = c.userOptions.visible = "undefined" === typeof a ? !f : a) ? "show" : "hide";
        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (a) {
          if (c[a]) c[a][h]();
        });
        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();
        e && d.legend.colorizeItem(c, a);
        c.isDirty = !0;
        c.options.stacking && d.series.forEach(function (a) {
          a.options.stacking && a.visible && (a.isDirty = !0);
        });
        c.linkedSeries.forEach(function (b) {
          b.setVisible(a, !1);
        });
        g && (d.isDirtyBox = !0);
        I(c, h);
        !1 !== b && d.redraw();
      };
      a.prototype.show = function () {
        this.setVisible(!0);
      };
      a.prototype.hide = function () {
        this.setVisible(!1);
      };
      a.prototype.select = function (a) {
        this.selected = a = this.options.selected = "undefined" === typeof a ? !this.selected : a;
        this.checkbox && (this.checkbox.checked = a);
        I(this, a ? "select" : "unselect");
      };
      a.prototype.shouldShowTooltip = function (a, b, c) {
        void 0 === c && (c = {});
        c.series = this;
        c.visiblePlotOnly = !0;
        return this.chart.isInsidePlot(a, b, c);
      };
      a.defaultOptions = H;
      return a;
    }();
    D(a.prototype, {
      axisTypes: ["xAxis", "yAxis"],
      coll: "series",
      colorCounter: 0,
      cropShoulder: 1,
      directTouch: !1,
      drawLegendSymbol: y.drawLineMarker,
      isCartesian: !0,
      kdAxisArray: ["clientX", "plotY"],
      parallelArrays: ["x", "y"],
      pointClass: G,
      requireSorting: !0,
      sorted: !0
    });
    A.series = a;
    "";
    "";
    return a;
  });
  M(a, "Extensions/ScrollablePlotArea.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function (a, u, z, F, y, G) {
    var v = a.stop,
      A = G.addEvent,
      q = G.createElement,
      n = G.merge,
      k = G.pick;
    A(z, "afterSetChartSize", function (a) {
      var c = this.options.chart.scrollablePlotArea,
        e = c && c.minWidth;
      c = c && c.minHeight;
      if (!this.renderer.forExport) {
        if (e) {
          if (this.scrollablePixelsX = e = Math.max(0, e - this.chartWidth)) {
            this.scrollablePlotBox = this.renderer.scrollablePlotBox = n(this.plotBox);
            this.plotBox.width = this.plotWidth += e;
            this.inverted ? this.clipBox.height += e : this.clipBox.width += e;
            var f = {
              1: {
                name: "right",
                value: e
              }
            };
          }
        } else c && (this.scrollablePixelsY = e = Math.max(0, c - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = n(this.plotBox), this.plotBox.height = this.plotHeight += e, this.inverted ? this.clipBox.width += e : this.clipBox.height += e, f = {
          2: {
            name: "bottom",
            value: e
          }
        });
        f && !a.skipAxes && this.axes.forEach(function (a) {
          f[a.side] ? a.getPlotLinePath = function () {
            var c = f[a.side].name,
              e = this[c];
            this[c] = e - f[a.side].value;
            var h = u.prototype.getPlotLinePath.apply(this, arguments);
            this[c] = e;
            return h;
          } : (a.setAxisSize(), a.setAxisTranslation());
        });
      }
    });
    A(z, "render", function () {
      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
    });
    z.prototype.setUpScrolling = function () {
      var a = this,
        c = {
          WebkitOverflowScrolling: "touch",
          overflowX: "hidden",
          overflowY: "hidden"
        };
      this.scrollablePixelsX && (c.overflowX = "auto");
      this.scrollablePixelsY && (c.overflowY = "auto");
      this.scrollingParent = q("div", {
        className: "highcharts-scrolling-parent"
      }, {
        position: "relative"
      }, this.renderTo);
      this.scrollingContainer = q("div", {
        className: "highcharts-scrolling"
      }, c, this.scrollingParent);
      A(this.scrollingContainer, "scroll", function () {
        a.pointer && delete a.pointer.chartPosition;
      });
      this.innerContainer = q("div", {
        className: "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null;
    };
    z.prototype.moveFixedElements = function () {
      var a = this.container,
        c = this.fixedRenderer,
        h = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
        f;
      this.scrollablePixelsX && !this.inverted ? f = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? f = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? f = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (f = ".highcharts-yaxis");
      f && h.push(f + ":not(.highcharts-radial-axis)", f + "-labels:not(.highcharts-radial-axis-labels)");
      h.forEach(function (e) {
        [].forEach.call(a.querySelectorAll(e), function (a) {
          (a.namespaceURI === c.SVG_NS ? c.box : c.box.parentNode).appendChild(a);
          a.style.pointerEvents = "auto";
        });
      });
    };
    z.prototype.applyFixed = function () {
      var a = !this.fixedDiv,
        c = this.options.chart,
        h = c.scrollablePlotArea,
        f = y.getRendererType();
      a ? (this.fixedDiv = q("div", {
        className: "highcharts-fixed"
      }, {
        position: "absolute",
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: (c.style && c.style.zIndex || 0) + 2,
        top: 0
      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = c = new f(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = c.path().attr({
        fill: this.options.chart.backgroundColor || "#fff",
        "fill-opacity": k(h.opacity, .85),
        zIndex: -1
      }).addClass("highcharts-scrollable-mask").add(), A(this, "afterShowResetZoom", this.moveFixedElements), A(this, "afterDrilldown", this.moveFixedElements), A(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();
      c = this.chartWidth + (this.scrollablePixelsX || 0);
      f = this.chartHeight + (this.scrollablePixelsY || 0);
      v(this.container);
      this.container.style.width = c + "px";
      this.container.style.height = f + "px";
      this.renderer.boxWrapper.attr({
        width: c,
        height: f,
        viewBox: [0, 0, c, f].join(" ")
      });
      this.chartBackground.attr({
        width: c,
        height: f
      });
      this.scrollingContainer.style.height = this.chartHeight + "px";
      a && (h.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * h.scrollPositionX), h.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * h.scrollPositionY));
      f = this.axisOffset;
      a = this.plotTop - f[0] - 1;
      h = this.plotLeft - f[3] - 1;
      c = this.plotTop + this.plotHeight + f[2] + 1;
      f = this.plotLeft + this.plotWidth + f[1] + 1;
      var n = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
        p = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
      a = this.scrollablePixelsX ? [["M", 0, a], ["L", this.plotLeft - 1, a], ["L", this.plotLeft - 1, c], ["L", 0, c], ["Z"], ["M", n, a], ["L", this.chartWidth, a], ["L", this.chartWidth, c], ["L", n, c], ["Z"]] : this.scrollablePixelsY ? [["M", h, 0], ["L", h, this.plotTop - 1], ["L", f, this.plotTop - 1], ["L", f, 0], ["Z"], ["M", h, p], ["L", h, this.chartHeight], ["L", f, this.chartHeight], ["L", f, p], ["Z"]] : [["M", 0, 0]];
      "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
        d: a
      });
    };
    A(u, "afterInit", function () {
      this.chart.scrollableDirty = !0;
    });
    A(F, "show", function () {
      this.chart.scrollableDirty = !0;
    });
    "";
  });
  M(a, "Core/Axis/StackingAxis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = a.getDeferredAnimation,
      y = z.addEvent,
      G = z.destroyObjectProperties,
      H = z.fireEvent,
      A = z.isNumber,
      q = z.objectEach,
      n;
    (function (a) {
      function e() {
        var a = this.stacking;
        if (a) {
          var c = a.stacks;
          q(c, function (a, e) {
            G(a);
            c[e] = null;
          });
          a && a.stackTotalGroup && a.stackTotalGroup.destroy();
        }
      }
      function c() {
        this.stacking || (this.stacking = new f(this));
      }
      var h = [];
      a.compose = function (a) {
        -1 === h.indexOf(a) && (h.push(a), y(a, "init", c), y(a, "destroy", e));
        return a;
      };
      var f = function () {
        function a(a) {
          this.oldStacks = {};
          this.stacks = {};
          this.stacksTouched = 0;
          this.axis = a;
        }
        a.prototype.buildStacks = function () {
          var a = this.axis,
            c = a.series,
            e = a.options.reversedStacks,
            f = c.length,
            h;
          if (!a.isXAxis) {
            this.usePercentage = !1;
            for (h = f; h--;) {
              var k = c[e ? h : f - h - 1];
              k.setStackedPoints();
              k.setGroupedPoints();
            }
            for (h = 0; h < f; h++) c[h].modifyStacks();
            H(a, "afterBuildStacks");
          }
        };
        a.prototype.cleanStacks = function () {
          if (!this.axis.isXAxis) {
            if (this.oldStacks) var a = this.stacks = this.oldStacks;
            q(a, function (a) {
              q(a, function (a) {
                a.cumulative = a.total;
              });
            });
          }
        };
        a.prototype.resetStacks = function () {
          var a = this,
            c = a.stacks;
          a.axis.isXAxis || q(c, function (c) {
            q(c, function (e, f) {
              A(e.touched) && e.touched < a.stacksTouched ? (e.destroy(), delete c[f]) : (e.total = null, e.cumulative = null);
            });
          });
        };
        a.prototype.renderStackTotals = function () {
          var a = this.axis,
            c = a.chart,
            e = c.renderer,
            f = this.stacks;
          a = v(c, a.options.stackLabels && a.options.stackLabels.animation || !1);
          var h = this.stackTotalGroup = this.stackTotalGroup || e.g("stack-labels").attr({
            visibility: "visible",
            zIndex: 6,
            opacity: 0
          }).add();
          h.translate(c.plotLeft, c.plotTop);
          q(f, function (a) {
            q(a, function (a) {
              a.render(h);
            });
          });
          h.animate({
            opacity: 1
          }, a);
        };
        return a;
      }();
      a.Additions = f;
    })(n || (n = {}));
    return n;
  });
  M(a, "Extensions/Stacking.js", [a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Axis/StackingAxis.js"], a["Core/Utilities.js"]], function (a, u, z, F, y, G, H) {
    var v = z.format,
      q = H.correctFloat,
      n = H.defined,
      k = H.destroyObjectProperties,
      e = H.isArray,
      c = H.isNumber,
      h = H.objectEach,
      f = H.pick,
      w = function () {
        function a(a, c, e, f, h) {
          var l = a.chart.inverted;
          this.axis = a;
          this.isNegative = e;
          this.options = c = c || {};
          this.x = f;
          this.total = null;
          this.points = {};
          this.hasValidPoints = !1;
          this.stack = h;
          this.rightCliff = this.leftCliff = 0;
          this.alignOptions = {
            align: c.align || (l ? e ? "left" : "right" : "center"),
            verticalAlign: c.verticalAlign || (l ? "middle" : e ? "bottom" : "top"),
            y: c.y,
            x: c.x
          };
          this.textAlign = c.textAlign || (l ? e ? "right" : "left" : "center");
        }
        a.prototype.destroy = function () {
          k(this, this.axis);
        };
        a.prototype.render = function (a) {
          var c = this.axis.chart,
            e = this.options,
            h = e.format;
          h = h ? v(h, this, c) : e.formatter.call(this);
          this.label ? this.label.attr({
            text: h,
            visibility: "hidden"
          }) : (this.label = c.renderer.label(h, null, null, e.shape, null, null, e.useHTML, !1, "stack-labels"), h = {
            r: e.borderRadius || 0,
            text: h,
            rotation: e.rotation,
            padding: f(e.padding, 5),
            visibility: "hidden"
          }, c.styledMode || (h.fill = e.backgroundColor, h.stroke = e.borderColor, h["stroke-width"] = e.borderWidth, this.label.css(e.style)), this.label.attr(h), this.label.added || this.label.add(a));
          this.label.labelrank = c.plotSizeY;
        };
        a.prototype.setOffset = function (a, e, h, k, p) {
          var l = this.axis,
            b = l.chart;
          k = l.translate(l.stacking.usePercentage ? 100 : k ? k : this.total, 0, 0, 0, 1);
          h = l.translate(h ? h : 0);
          h = n(k) && Math.abs(k - h);
          a = f(p, b.xAxis[0].translate(this.x)) + a;
          l = n(k) && this.getStackBox(b, this, a, k, e, h, l);
          e = this.label;
          h = this.isNegative;
          a = "justify" === f(this.options.overflow, "justify");
          var g = this.textAlign;
          e && l && (p = e.getBBox(), k = e.padding, g = "left" === g ? b.inverted ? -k : k : "right" === g ? p.width : b.inverted && "center" === g ? p.width / 2 : b.inverted ? h ? p.width + k : -k : p.width / 2, h = b.inverted ? p.height / 2 : h ? -k : p.height, this.alignOptions.x = f(this.options.x, 0), this.alignOptions.y = f(this.options.y, 0), l.x -= g, l.y -= h, e.align(this.alignOptions, null, l), b.isInsidePlot(e.alignAttr.x + g - this.alignOptions.x, e.alignAttr.y + h - this.alignOptions.y) ? e.show() : (e.alignAttr.y = -9999, a = !1), a && y.prototype.justifyDataLabel.call(this.axis, e, this.alignOptions, e.alignAttr, p, l), e.attr({
            x: e.alignAttr.x,
            y: e.alignAttr.y
          }), f(!a && this.options.crop, !0) && ((b = c(e.x) && c(e.y) && b.isInsidePlot(e.x - k + e.width, e.y) && b.isInsidePlot(e.x + k, e.y)) || e.hide()));
        };
        a.prototype.getStackBox = function (a, c, e, f, h, l, b) {
          var g = c.axis.reversed,
            d = a.inverted,
            k = b.height + b.pos - (d ? a.plotLeft : a.plotTop);
          c = c.isNegative && !g || !c.isNegative && g;
          return {
            x: d ? c ? f - b.right : f - l + b.pos - a.plotLeft : e + a.xAxis[0].transB - a.plotLeft,
            y: d ? b.height - e - h : c ? k - f - l : k - f,
            width: d ? l : h,
            height: d ? h : l
          };
        };
        return a;
      }();
    u.prototype.getStacks = function () {
      var a = this,
        c = a.inverted;
      a.yAxis.forEach(function (a) {
        a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);
      });
      a.series.forEach(function (e) {
        var h = e.xAxis && e.xAxis.options || {};
        !e.options.stacking || !0 !== e.visible && !1 !== a.options.chart.ignoreHiddenSeries || (e.stackKey = [e.type, f(e.options.stack, ""), c ? h.top : h.left, c ? h.height : h.width].join());
      });
    };
    G.compose(a);
    y.prototype.setGroupedPoints = function () {
      var a = this.yAxis.stacking;
      this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? y.prototype.setStackedPoints.call(this, "group") : a && h(a.stacks, function (c, e) {
        "group" === e.slice(-5) && (h(c, function (a) {
          return a.destroy();
        }), delete a.stacks[e]);
      });
    };
    y.prototype.setStackedPoints = function (a) {
      var c = a || this.options.stacking;
      if (c && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
        var h = this.processedXData,
          k = this.processedYData,
          p = [],
          r = k.length,
          l = this.options,
          b = l.threshold,
          g = f(l.startFromThreshold && b, 0);
        l = l.stack;
        a = a ? this.type + "," + c : this.stackKey;
        var d = "-" + a,
          m = this.negStacks,
          v = this.yAxis,
          x = v.stacking.stacks,
          u = v.stacking.oldStacks,
          A,
          y;
        v.stacking.stacksTouched += 1;
        for (y = 0; y < r; y++) {
          var z = h[y];
          var F = k[y];
          var H = this.getStackIndicator(H, z, this.index);
          var G = H.key;
          var K = (A = m && F < (g ? 0 : b)) ? d : a;
          x[K] || (x[K] = {});
          x[K][z] || (u[K] && u[K][z] ? (x[K][z] = u[K][z], x[K][z].total = null) : x[K][z] = new w(v, v.options.stackLabels, A, z, l));
          K = x[K][z];
          null !== F ? (K.points[G] = K.points[this.index] = [f(K.cumulative, g)], n(K.cumulative) || (K.base = G), K.touched = v.stacking.stacksTouched, 0 < H.index && !1 === this.singleStacks && (K.points[G][0] = K.points[this.index + "," + z + ",0"][0])) : K.points[G] = K.points[this.index] = null;
          "percent" === c ? (A = A ? a : d, m && x[A] && x[A][z] ? (A = x[A][z], K.total = A.total = Math.max(A.total, K.total) + Math.abs(F) || 0) : K.total = q(K.total + (Math.abs(F) || 0))) : "group" === c ? (e(F) && (F = F[0]), null !== F && (K.total = (K.total || 0) + 1)) : K.total = q(K.total + (F || 0));
          K.cumulative = "group" === c ? (K.total || 1) - 1 : f(K.cumulative, g) + (F || 0);
          null !== F && (K.points[G].push(K.cumulative), p[y] = K.cumulative, K.hasValidPoints = !0);
        }
        "percent" === c && (v.stacking.usePercentage = !0);
        "group" !== c && (this.stackedYData = p);
        v.stacking.oldStacks = {};
      }
    };
    y.prototype.modifyStacks = function () {
      var a = this,
        c = a.stackKey,
        e = a.yAxis.stacking.stacks,
        f = a.processedXData,
        h,
        k = a.options.stacking;
      a[k + "Stacker"] && [c, "-" + c].forEach(function (c) {
        for (var b = f.length, g, d; b--;) if (g = f[b], h = a.getStackIndicator(h, g, a.index, c), d = (g = e[c] && e[c][g]) && g.points[h.key]) a[k + "Stacker"](d, g, b);
      });
    };
    y.prototype.percentStacker = function (a, c, e) {
      c = c.total ? 100 / c.total : 0;
      a[0] = q(a[0] * c);
      a[1] = q(a[1] * c);
      this.stackedYData[e] = a[1];
    };
    y.prototype.getStackIndicator = function (a, c, e, f) {
      !n(a) || a.x !== c || f && a.key !== f ? a = {
        x: c,
        index: 0,
        key: f
      } : a.index++;
      a.key = [e, c, a.index].join();
      return a;
    };
    F.StackItem = w;
    "";
    return F.StackItem;
  });
  M(a, "Series/Line/LineSeries.js", [a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = this && this.__extends || function () {
        var a = function (v, q) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, k) {
            a.__proto__ = k;
          } || function (a, k) {
            for (var e in k) k.hasOwnProperty(e) && (a[e] = k[e]);
          };
          return a(v, q);
        };
        return function (v, q) {
          function n() {
            this.constructor = v;
          }
          a(v, q);
          v.prototype = null === q ? Object.create(q) : (n.prototype = q.prototype, new n());
        };
      }(),
      y = z.defined,
      G = z.merge;
    z = function (u) {
      function A() {
        var a = null !== u && u.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      v(A, u);
      A.prototype.drawGraph = function () {
        var a = this,
          n = this.options,
          k = (this.gappedPath || this.getGraphPath).call(this),
          e = this.chart.styledMode,
          c = [["graph", "highcharts-graph"]];
        e || c[0].push(n.lineColor || this.color || "#cccccc", n.dashStyle);
        c = a.getZonesGraphs(c);
        c.forEach(function (c, f) {
          var h = c[0],
            p = a[h],
            q = p ? "animate" : "attr";
          p ? (p.endX = a.preventGraphAnimation ? null : k.xMap, p.animate({
            d: k
          })) : k.length && (a[h] = p = a.chart.renderer.path(k).addClass(c[1]).attr({
            zIndex: 1
          }).add(a.group));
          p && !e && (h = {
            stroke: c[2],
            "stroke-width": n.lineWidth,
            fill: a.fillGraph && a.color || "none"
          }, c[3] ? h.dashstyle = c[3] : "square" !== n.linecap && (h["stroke-linecap"] = h["stroke-linejoin"] = "round"), p[q](h).shadow(2 > f && n.shadow));
          p && (p.startX = k.xMap, p.isArea = k.isArea);
        });
      };
      A.prototype.getGraphPath = function (a, n, k) {
        var e = this,
          c = e.options,
          h = [],
          f = [],
          q,
          p = c.step;
        a = a || e.points;
        var v = a.reversed;
        v && a.reverse();
        (p = {
          right: 1,
          center: 2
        }[p] || p && 3) && v && (p = 4 - p);
        a = this.getValidPoints(a, !1, !(c.connectNulls && !n && !k));
        a.forEach(function (t, v) {
          var w = t.plotX,
            r = t.plotY,
            l = a[v - 1];
          (t.leftCliff || l && l.rightCliff) && !k && (q = !0);
          t.isNull && !y(n) && 0 < v ? q = !c.connectNulls : t.isNull && !n ? q = !0 : (0 === v || q ? v = [["M", t.plotX, t.plotY]] : e.getPointSpline ? v = [e.getPointSpline(a, t, v)] : p ? (v = 1 === p ? [["L", l.plotX, r]] : 2 === p ? [["L", (l.plotX + w) / 2, l.plotY], ["L", (l.plotX + w) / 2, r]] : [["L", w, l.plotY]], v.push(["L", w, r])) : v = [["L", w, r]], f.push(t.x), p && (f.push(t.x), 2 === p && f.push(t.x)), h.push.apply(h, v), q = !1);
        });
        h.xMap = f;
        return e.graphPath = h;
      };
      A.prototype.getZonesGraphs = function (a) {
        this.zones.forEach(function (n, k) {
          k = ["zone-graph-" + k, "highcharts-graph highcharts-zone-graph-" + k + " " + (n.className || "")];
          this.chart.styledMode || k.push(n.color || this.color, n.dashStyle || this.options.dashStyle);
          a.push(k);
        }, this);
        return a;
      };
      A.defaultOptions = G(a.defaultOptions, {});
      return A;
    }(a);
    u.registerSeriesType("line", z);
    "";
    return z;
  });
  M(a, "Series/Area/AreaSeries.js", [a["Core/Color/Color.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, u, z, F) {
    var v = this && this.__extends || function () {
        var a = function (e, c) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
          };
          return a(e, c);
        };
        return function (e, c) {
          function h() {
            this.constructor = e;
          }
          a(e, c);
          e.prototype = null === c ? Object.create(c) : (h.prototype = c.prototype, new h());
        };
      }(),
      G = a.parse,
      H = z.seriesTypes.line;
    a = F.extend;
    var A = F.merge,
      q = F.objectEach,
      n = F.pick;
    F = function (a) {
      function e() {
        var c = null !== a && a.apply(this, arguments) || this;
        c.data = void 0;
        c.options = void 0;
        c.points = void 0;
        return c;
      }
      v(e, a);
      e.prototype.drawGraph = function () {
        this.areaPath = [];
        a.prototype.drawGraph.apply(this);
        var c = this,
          e = this.areaPath,
          f = this.options,
          k = [["area", "highcharts-area", this.color, f.fillColor]];
        this.zones.forEach(function (a, e) {
          k.push(["zone-area-" + e, "highcharts-area highcharts-zone-area-" + e + " " + a.className, a.color || c.color, a.fillColor || f.fillColor]);
        });
        k.forEach(function (a) {
          var h = a[0],
            k = c[h],
            p = k ? "animate" : "attr",
            q = {};
          k ? (k.endX = c.preventGraphAnimation ? null : e.xMap, k.animate({
            d: e
          })) : (q.zIndex = 0, k = c[h] = c.chart.renderer.path(e).addClass(a[1]).add(c.group), k.isArea = !0);
          c.chart.styledMode || (q.fill = n(a[3], G(a[2]).setOpacity(n(f.fillOpacity, .75)).get()));
          k[p](q);
          k.startX = e.xMap;
          k.shiftUnit = f.step ? 2 : 1;
        });
      };
      e.prototype.getGraphPath = function (a) {
        var c = H.prototype.getGraphPath,
          e = this.options,
          k = e.stacking,
          p = this.yAxis,
          q,
          t = [],
          v = [],
          u = this.index,
          r = p.stacking.stacks[this.stackKey],
          l = e.threshold,
          b = Math.round(p.getThreshold(e.threshold));
        e = n(e.connectNulls, "percent" === k);
        var g = function (c, d, e) {
          var g = a[c];
          c = k && r[g.x].points[u];
          var f = g[e + "Null"] || 0;
          e = g[e + "Cliff"] || 0;
          g = !0;
          if (e || f) {
            var h = (f ? c[0] : c[1]) + e;
            var n = c[0] + e;
            g = !!f;
          } else !k && a[d] && a[d].isNull && (h = n = l);
          "undefined" !== typeof h && (v.push({
            plotX: m,
            plotY: null === h ? b : p.getThreshold(h),
            isNull: g,
            isCliff: !0
          }), t.push({
            plotX: m,
            plotY: null === n ? b : p.getThreshold(n),
            doCurve: !1
          }));
        };
        a = a || this.points;
        k && (a = this.getStackPoints(a));
        for (q = 0; q < a.length; q++) {
          k || (a[q].leftCliff = a[q].rightCliff = a[q].leftNull = a[q].rightNull = void 0);
          var d = a[q].isNull;
          var m = n(a[q].rectPlotX, a[q].plotX);
          var D = k ? n(a[q].yBottom, b) : b;
          if (!d || e) e || g(q, q - 1, "left"), d && !k && e || (v.push(a[q]), t.push({
            x: q,
            plotX: m,
            plotY: D
          })), e || g(q, q + 1, "right");
        }
        q = c.call(this, v, !0, !0);
        t.reversed = !0;
        d = c.call(this, t, !0, !0);
        (D = d[0]) && "M" === D[0] && (d[0] = ["L", D[1], D[2]]);
        d = q.concat(d);
        d.length && d.push(["Z"]);
        c = c.call(this, v, !1, e);
        d.xMap = q.xMap;
        this.areaPath = d;
        return c;
      };
      e.prototype.getStackPoints = function (a) {
        var c = this,
          e = [],
          k = [],
          p = this.xAxis,
          v = this.yAxis,
          t = v.stacking.stacks[this.stackKey],
          u = {},
          C = v.series,
          r = C.length,
          l = v.options.reversedStacks ? 1 : -1,
          b = C.indexOf(c);
        a = a || this.points;
        if (this.options.stacking) {
          for (var g = 0; g < a.length; g++) a[g].leftNull = a[g].rightNull = void 0, u[a[g].x] = a[g];
          q(t, function (a, b) {
            null !== a.total && k.push(b);
          });
          k.sort(function (a, b) {
            return a - b;
          });
          var d = C.map(function (a) {
            return a.visible;
          });
          k.forEach(function (a, g) {
            var f = 0,
              h,
              m;
            if (u[a] && !u[a].isNull) e.push(u[a]), [-1, 1].forEach(function (e) {
              var f = 1 === e ? "rightNull" : "leftNull",
                n = 0,
                p = t[k[g + e]];
              if (p) for (var q = b; 0 <= q && q < r;) {
                var v = C[q].index;
                h = p.points[v];
                h || (v === c.index ? u[a][f] = !0 : d[q] && (m = t[a].points[v]) && (n -= m[1] - m[0]));
                q += l;
              }
              u[a][1 === e ? "rightCliff" : "leftCliff"] = n;
            });else {
              for (var q = b; 0 <= q && q < r;) {
                if (h = t[a].points[C[q].index]) {
                  f = h[1];
                  break;
                }
                q += l;
              }
              f = n(f, 0);
              f = v.translate(f, 0, 1, 0, 1);
              e.push({
                isNull: !0,
                plotX: p.translate(a, 0, 0, 0, 1),
                x: a,
                plotY: f,
                yBottom: f
              });
            }
          });
        }
        return e;
      };
      e.defaultOptions = A(H.defaultOptions, {
        threshold: 0
      });
      return e;
    }(H);
    a(F.prototype, {
      singleStacks: !1,
      drawLegendSymbol: u.drawRectangle
    });
    z.registerSeriesType("area", F);
    "";
    return F;
  });
  M(a, "Series/Spline/SplineSeries.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, u) {
    var v = this && this.__extends || function () {
        var a = function (v, q) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, k) {
            a.__proto__ = k;
          } || function (a, k) {
            for (var e in k) k.hasOwnProperty(e) && (a[e] = k[e]);
          };
          return a(v, q);
        };
        return function (v, q) {
          function n() {
            this.constructor = v;
          }
          a(v, q);
          v.prototype = null === q ? Object.create(q) : (n.prototype = q.prototype, new n());
        };
      }(),
      F = a.seriesTypes.line,
      y = u.merge,
      G = u.pick;
    u = function (a) {
      function u() {
        var q = null !== a && a.apply(this, arguments) || this;
        q.data = void 0;
        q.options = void 0;
        q.points = void 0;
        return q;
      }
      v(u, a);
      u.prototype.getPointSpline = function (a, n, k) {
        var e = n.plotX || 0,
          c = n.plotY || 0,
          h = a[k - 1];
        k = a[k + 1];
        if (h && !h.isNull && !1 !== h.doCurve && !n.isCliff && k && !k.isNull && !1 !== k.doCurve && !n.isCliff) {
          a = h.plotY || 0;
          var f = k.plotX || 0;
          k = k.plotY || 0;
          var q = 0;
          var p = (1.5 * e + (h.plotX || 0)) / 2.5;
          var v = (1.5 * c + a) / 2.5;
          f = (1.5 * e + f) / 2.5;
          var t = (1.5 * c + k) / 2.5;
          f !== p && (q = (t - v) * (f - e) / (f - p) + c - t);
          v += q;
          t += q;
          v > a && v > c ? (v = Math.max(a, c), t = 2 * c - v) : v < a && v < c && (v = Math.min(a, c), t = 2 * c - v);
          t > k && t > c ? (t = Math.max(k, c), v = 2 * c - t) : t < k && t < c && (t = Math.min(k, c), v = 2 * c - t);
          n.rightContX = f;
          n.rightContY = t;
        }
        n = ["C", G(h.rightContX, h.plotX, 0), G(h.rightContY, h.plotY, 0), G(p, e, 0), G(v, c, 0), e, c];
        h.rightContX = h.rightContY = void 0;
        return n;
      };
      u.defaultOptions = y(F.defaultOptions);
      return u;
    }(F);
    a.registerSeriesType("spline", u);
    "";
    return u;
  });
  M(a, "Series/AreaSpline/AreaSplineSeries.js", [a["Series/Area/AreaSeries.js"], a["Series/Spline/SplineSeries.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, u, z, F, y) {
    var v = this && this.__extends || function () {
        var a = function (k, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, e) {
            a.__proto__ = e;
          } || function (a, e) {
            for (var c in e) e.hasOwnProperty(c) && (a[c] = e[c]);
          };
          return a(k, e);
        };
        return function (k, e) {
          function c() {
            this.constructor = k;
          }
          a(k, e);
          k.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());
        };
      }(),
      H = a.prototype,
      A = y.extend,
      q = y.merge;
    y = function (n) {
      function k() {
        var a = null !== n && n.apply(this, arguments) || this;
        a.data = void 0;
        a.points = void 0;
        a.options = void 0;
        return a;
      }
      v(k, n);
      k.defaultOptions = q(u.defaultOptions, a.defaultOptions);
      return k;
    }(u);
    A(y.prototype, {
      getGraphPath: H.getGraphPath,
      getStackPoints: H.getStackPoints,
      drawGraph: H.drawGraph,
      drawLegendSymbol: z.drawRectangle
    });
    F.registerSeriesType("areaspline", y);
    "";
    return y;
  });
  M(a, "Series/Column/ColumnSeries.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, u, z, F, y, G, H) {
    var v = this && this.__extends || function () {
        var a = function (c, b) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, b) {
            a.__proto__ = b;
          } || function (a, b) {
            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
          };
          return a(c, b);
        };
        return function (c, b) {
          function e() {
            this.constructor = c;
          }
          a(c, b);
          c.prototype = null === b ? Object.create(b) : (e.prototype = b.prototype, new e());
        };
      }(),
      q = a.animObject,
      n = u.parse,
      k = z.hasTouch;
    a = z.noop;
    var e = H.clamp,
      c = H.css,
      h = H.defined,
      f = H.extend,
      w = H.fireEvent,
      p = H.isArray,
      B = H.isNumber,
      t = H.merge,
      J = H.pick,
      C = H.objectEach;
    H = function (a) {
      function l() {
        var b = null !== a && a.apply(this, arguments) || this;
        b.borderWidth = void 0;
        b.data = void 0;
        b.group = void 0;
        b.options = void 0;
        b.points = void 0;
        return b;
      }
      v(l, a);
      l.prototype.animate = function (a) {
        var b = this,
          c = this.yAxis,
          h = b.options,
          l = this.chart.inverted,
          k = {},
          n = l ? "translateX" : "translateY";
        if (a) k.scaleY = .001, a = e(c.toPixels(h.threshold), c.pos, c.pos + c.len), l ? k.translateX = a - c.len : k.translateY = a, b.clipBox && b.setClip(), b.group.attr(k);else {
          var p = Number(b.group.attr(n));
          b.group.animate({
            scaleY: 1
          }, f(q(b.options.animation), {
            step: function (a, d) {
              b.group && (k[n] = p + d.pos * (c.pos - p), b.group.attr(k));
            }
          }));
        }
      };
      l.prototype.init = function (b, c) {
        a.prototype.init.apply(this, arguments);
        var d = this;
        b = d.chart;
        b.hasRendered && b.series.forEach(function (a) {
          a.type === d.type && (a.isDirty = !0);
        });
      };
      l.prototype.getColumnMetrics = function () {
        var a = this,
          c = a.options,
          d = a.xAxis,
          e = a.yAxis,
          f = d.options.reversedStacks;
        f = d.reversed && !f || !d.reversed && f;
        var h = {},
          l,
          k = 0;
        !1 === c.grouping ? k = 1 : a.chart.series.forEach(function (b) {
          var c = b.yAxis,
            d = b.options;
          if (b.type === a.type && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && e.len === c.len && e.pos === c.pos) {
            if (d.stacking && "group" !== d.stacking) {
              l = b.stackKey;
              "undefined" === typeof h[l] && (h[l] = k++);
              var g = h[l];
            } else !1 !== d.grouping && (g = k++);
            b.columnIndex = g;
          }
        });
        var n = Math.min(Math.abs(d.transA) * (d.ordinal && d.ordinal.slope || c.pointRange || d.closestPointRange || d.tickInterval || 1), d.len),
          p = n * c.groupPadding,
          r = (n - 2 * p) / (k || 1);
        c = Math.min(c.maxPointWidth || d.len, J(c.pointWidth, r * (1 - 2 * c.pointPadding)));
        a.columnMetrics = {
          width: c,
          offset: (r - c) / 2 + (p + ((a.columnIndex || 0) + (f ? 1 : 0)) * r - n / 2) * (f ? -1 : 1),
          paddedWidth: r,
          columnCount: k
        };
        return a.columnMetrics;
      };
      l.prototype.crispCol = function (a, c, d, e) {
        var b = this.chart,
          g = this.borderWidth,
          f = -(g % 2 ? .5 : 0);
        g = g % 2 ? .5 : 1;
        b.inverted && b.renderer.isVML && (g += 1);
        this.options.crisp && (d = Math.round(a + d) + f, a = Math.round(a) + f, d -= a);
        e = Math.round(c + e) + g;
        f = .5 >= Math.abs(c) && .5 < e;
        c = Math.round(c) + g;
        e -= c;
        f && e && (--c, e += 1);
        return {
          x: a,
          y: c,
          width: d,
          height: e
        };
      };
      l.prototype.adjustForMissingColumns = function (a, c, d, e) {
        var b = this,
          g = this.options.stacking;
        if (!d.isNull && 1 < e.columnCount) {
          var f = 0,
            h = 0;
          C(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {
            if ("number" === typeof d.x && (a = a[d.x.toString()])) {
              var c = a.points[b.index],
                e = a.total;
              g ? (c && (f = h), a.hasValidPoints && h++) : p(c) && (f = c[1], h = e || 0);
            }
          });
          a = (d.plotX || 0) + ((h - 1) * e.paddedWidth + c) / 2 - c - f * e.paddedWidth;
        }
        return a;
      };
      l.prototype.translate = function () {
        var a = this,
          c = a.chart,
          d = a.options,
          f = a.dense = 2 > a.closestPointRange * a.xAxis.transA;
        f = a.borderWidth = J(d.borderWidth, f ? 0 : 1);
        var l = a.xAxis,
          k = a.yAxis,
          n = d.threshold,
          p = a.translatedThreshold = k.getThreshold(n),
          r = J(d.minPointLength, 5),
          q = a.getColumnMetrics(),
          t = q.width,
          v = a.pointXOffset = q.offset,
          u = a.dataMin,
          w = a.dataMax,
          C = a.barW = Math.max(t, 1 + 2 * f);
        c.inverted && (p -= .5);
        d.pointPadding && (C = Math.ceil(C));
        y.prototype.translate.apply(a);
        a.points.forEach(function (b) {
          var g = J(b.yBottom, p),
            f = 999 + Math.abs(g),
            m = b.plotX || 0;
          f = e(b.plotY, -f, k.len + f);
          var x = Math.min(f, g),
            D = Math.max(f, g) - x,
            y = t,
            A = m + v,
            z = C;
          r && Math.abs(D) < r && (D = r, m = !k.reversed && !b.negative || k.reversed && b.negative, B(n) && B(w) && b.y === n && w <= n && (k.min || 0) < n && (u !== w || (k.max || 0) <= n) && (m = !m), x = Math.abs(x - p) > r ? g - r : p - (m ? r : 0));
          h(b.options.pointWidth) && (y = z = Math.ceil(b.options.pointWidth), A -= Math.round((y - t) / 2));
          d.centerInCategory && (A = a.adjustForMissingColumns(A, y, b, q));
          b.barX = A;
          b.pointWidth = y;
          b.tooltipPos = c.inverted ? [e(k.len + k.pos - c.plotLeft - f, k.pos - c.plotLeft, k.len + k.pos - c.plotLeft), l.len + l.pos - c.plotTop - A - z / 2, D] : [l.left - c.plotLeft + A + z / 2, e(f + k.pos - c.plotTop, k.pos - c.plotTop, k.len + k.pos - c.plotTop), D];
          b.shapeType = a.pointClass.prototype.shapeType || "rect";
          b.shapeArgs = a.crispCol.apply(a, b.isNull ? [A, p, z, 0] : [A, x, z, D]);
        });
      };
      l.prototype.drawGraph = function () {
        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
      };
      l.prototype.pointAttribs = function (a, c) {
        var b = this.options,
          e = this.pointAttrToOptions || {},
          g = e.stroke || "borderColor",
          f = e["stroke-width"] || "borderWidth",
          h = a && a.color || this.color,
          l = a && a[g] || b[g] || h;
        e = a && a.options.dashStyle || b.dashStyle;
        var k = a && a[f] || b[f] || this[f] || 0,
          p = J(a && a.opacity, b.opacity, 1);
        if (a && this.zones.length) {
          var r = a.getZone();
          h = a.options.color || r && (r.color || a.nonZonedColor) || this.color;
          r && (l = r.borderColor || l, e = r.dashStyle || e, k = r.borderWidth || k);
        }
        c && a && (a = t(b.states[c], a.options.states && a.options.states[c] || {}), c = a.brightness, h = a.color || "undefined" !== typeof c && n(h).brighten(a.brightness).get() || h, l = a[g] || l, k = a[f] || k, e = a.dashStyle || e, p = J(a.opacity, p));
        g = {
          fill: h,
          stroke: l,
          "stroke-width": k,
          opacity: p
        };
        e && (g.dashstyle = e);
        return g;
      };
      l.prototype.drawPoints = function () {
        var a = this,
          c = this.chart,
          d = a.options,
          e = c.renderer,
          f = d.animationLimit || 250,
          h;
        a.points.forEach(function (b) {
          var g = b.graphic,
            l = !!g,
            k = g && c.pointCount < f ? "animate" : "attr";
          if (B(b.plotY) && null !== b.y) {
            h = b.shapeArgs;
            g && b.hasNewShapeType() && (g = g.destroy());
            a.enabledDataSorting && (b.startXPos = a.xAxis.reversed ? -(h ? h.width || 0 : 0) : a.xAxis.width);
            g || (b.graphic = g = e[b.shapeType](h).add(b.group || a.group)) && a.enabledDataSorting && c.hasRendered && c.pointCount < f && (g.attr({
              x: b.startXPos
            }), l = !0, k = "animate");
            if (g && l) g[k](t(h));
            if (d.borderRadius) g[k]({
              r: d.borderRadius
            });
            c.styledMode || g[k](a.pointAttribs(b, b.selected && "select")).shadow(!1 !== b.allowShadow && d.shadow, null, d.stacking && !d.borderRadius);
            g && (g.addClass(b.getClassName(), !0), g.attr({
              visibility: b.visible ? "inherit" : "hidden"
            }));
          } else g && (b.graphic = g.destroy());
        });
      };
      l.prototype.drawTracker = function () {
        var a = this,
          e = a.chart,
          d = e.pointer,
          f = function (a) {
            var b = d.getPointFromEvent(a);
            "undefined" !== typeof b && (d.isDirectTouch = !0, b.onMouseOver(a));
          },
          h;
        a.points.forEach(function (a) {
          h = p(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];
          a.graphic && (a.graphic.element.point = a);
          h.forEach(function (b) {
            b.div ? b.div.point = a : b.element.point = a;
          });
        });
        a._hasTracking || (a.trackerGroups.forEach(function (b) {
          if (a[b]) {
            a[b].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function (a) {
              d.onTrackerMouseOut(a);
            });
            if (k) a[b].on("touchstart", f);
            !e.styledMode && a.options.cursor && a[b].css(c).css({
              cursor: a.options.cursor
            });
          }
        }), a._hasTracking = !0);
        w(this, "afterDrawTracker");
      };
      l.prototype.remove = function () {
        var a = this,
          c = a.chart;
        c.hasRendered && c.series.forEach(function (b) {
          b.type === a.type && (b.isDirty = !0);
        });
        y.prototype.remove.apply(a, arguments);
      };
      l.defaultOptions = t(y.defaultOptions, {
        borderRadius: 0,
        centerInCategory: !1,
        groupPadding: .2,
        marker: null,
        pointPadding: .1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
          hover: {
            halo: !1,
            brightness: .1
          },
          select: {
            color: "#cccccc",
            borderColor: "#000000"
          }
        },
        dataLabels: {
          align: void 0,
          verticalAlign: void 0,
          y: void 0
        },
        startFromThreshold: !0,
        stickyTracking: !1,
        tooltip: {
          distance: 6
        },
        threshold: 0,
        borderColor: "#ffffff"
      });
      return l;
    }(y);
    f(H.prototype, {
      cropShoulder: 0,
      directTouch: !0,
      drawLegendSymbol: F.drawRectangle,
      getSymbol: a,
      negStacks: !0,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    G.registerSeriesType("column", H);
    "";
    "";
    return H;
  });
  M(a, "Core/Series/DataLabel.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = a.getDeferredAnimation,
      y = u.format,
      G = z.defined,
      H = z.extend,
      A = z.fireEvent,
      q = z.isArray,
      n = z.merge,
      k = z.objectEach,
      e = z.pick,
      c = z.splat,
      h;
    (function (a) {
      function f(a, b, c, d, f) {
        var g = this,
          h = this.chart,
          l = this.isCartesian && h.inverted,
          k = this.enabledDataSorting,
          m = e(a.dlBox && a.dlBox.centerX, a.plotX, -9999),
          n = e(a.plotY, -9999),
          p = b.getBBox(),
          r = c.rotation,
          q = c.align,
          t = h.isInsidePlot(m, Math.round(n), {
            inverted: l,
            paneCoordinates: !0,
            series: g
          }),
          v = function (c) {
            k && g.xAxis && !u && g.setDataLabelStartPos(a, b, f, t, c);
          },
          u = "justify" === e(c.overflow, k ? "none" : "justify"),
          w = this.visible && !1 !== a.visible && (a.series.forceDL || k && !u || t || e(c.inside, !!this.options.stacking) && d && h.isInsidePlot(m, l ? d.x + 1 : d.y + d.height - 1, {
            inverted: l,
            paneCoordinates: !0,
            series: g
          }));
        if (w) {
          var C = h.renderer.fontMetrics(h.styledMode ? void 0 : c.style.fontSize, b).b;
          d = H({
            x: l ? this.yAxis.len - n : m,
            y: Math.round(l ? this.xAxis.len - m : n),
            width: 0,
            height: 0
          }, d);
          H(c, {
            width: p.width,
            height: p.height
          });
          r ? (u = !1, m = h.renderer.rotCorr(C, r), m = {
            x: d.x + (c.x || 0) + d.width / 2 + m.x,
            y: d.y + (c.y || 0) + {
              top: 0,
              middle: .5,
              bottom: 1
            }[c.verticalAlign] * d.height
          }, v(m), b[f ? "attr" : "animate"](m).attr({
            align: q
          }), v = (r + 720) % 360, v = 180 < v && 360 > v, "left" === q ? m.y -= v ? p.height : 0 : "center" === q ? (m.x -= p.width / 2, m.y -= p.height / 2) : "right" === q && (m.x -= p.width, m.y -= v ? 0 : p.height), b.placed = !0, b.alignAttr = m) : (v(d), b.align(c, void 0, d), m = b.alignAttr);
          u && 0 <= d.height ? this.justifyDataLabel(b, c, m, p, d, f) : e(c.crop, !0) && (w = h.isInsidePlot(m.x, m.y, {
            paneCoordinates: !0,
            series: g
          }) && h.isInsidePlot(m.x + p.width, m.y + p.height, {
            paneCoordinates: !0,
            series: g
          }));
          if (c.shape && !r) b[f ? "attr" : "animate"]({
            anchorX: l ? h.plotWidth - a.plotY : a.plotX,
            anchorY: l ? h.plotHeight - a.plotX : a.plotY
          });
        }
        f && k && (b.placed = !1);
        w || k && !u || (b.hide(!0), b.placed = !1);
      }
      function h(a, b) {
        var c = b.filter;
        return c ? (b = c.operator, a = a[c.property], c = c.value, ">" === b && a > c || "<" === b && a < c || ">=" === b && a >= c || "<=" === b && a <= c || "==" === b && a == c || "===" === b && a === c ? !0 : !1) : !0;
      }
      function u() {
        var a = this,
          b = a.chart,
          g = a.options,
          d = a.points,
          f = a.hasRendered || 0,
          n = b.renderer,
          p = g.dataLabels,
          r,
          t = p.animation;
        t = p.defer ? v(b, t, a) : {
          defer: 0,
          duration: 0
        };
        p = z(z(b.options.plotOptions && b.options.plotOptions.series && b.options.plotOptions.series.dataLabels, b.options.plotOptions && b.options.plotOptions[a.type] && b.options.plotOptions[a.type].dataLabels), p);
        A(this, "drawDataLabels");
        if (q(p) || p.enabled || a._hasPointLabels) {
          var u = a.plotGroup("dataLabelsGroup", "data-labels", f ? "inherit" : "hidden", p.zIndex || 6);
          u.attr({
            opacity: +f
          });
          !f && (f = a.dataLabelsGroup) && (a.visible && u.show(!0), f[g.animation ? "animate" : "attr"]({
            opacity: 1
          }, t));
          d.forEach(function (d) {
            r = c(z(p, d.dlOptions || d.options && d.options.dataLabels));
            r.forEach(function (c, f) {
              var l = c.enabled && (!d.isNull || d.dataLabelOnNull) && h(d, c),
                m = d.connectors ? d.connectors[f] : d.connector,
                p = d.dataLabels ? d.dataLabels[f] : d.dataLabel,
                r = e(c.distance, d.labelDistance),
                q = !p;
              if (l) {
                var t = d.getLabelConfig();
                var v = e(c[d.formatPrefix + "Format"], c.format);
                t = G(v) ? y(v, t, b) : (c[d.formatPrefix + "Formatter"] || c.formatter).call(t, c);
                v = c.style;
                var w = c.rotation;
                b.styledMode || (v.color = e(c.color, v.color, a.color, "#000000"), "contrast" === v.color ? (d.contrastColor = n.getContrast(d.color || a.color), v.color = !G(r) && c.inside || 0 > r || g.stacking ? d.contrastColor : "#000000") : delete d.contrastColor, g.cursor && (v.cursor = g.cursor));
                var C = {
                  r: c.borderRadius || 0,
                  rotation: w,
                  padding: c.padding,
                  zIndex: 1
                };
                b.styledMode || (C.fill = c.backgroundColor, C.stroke = c.borderColor, C["stroke-width"] = c.borderWidth);
                k(C, function (a, b) {
                  "undefined" === typeof a && delete C[b];
                });
              }
              !p || l && G(t) && !!p.div === !!c.useHTML || (d.dataLabel = p = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[f]), f || delete d.dataLabel, m && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[f])));
              l && G(t) && (p ? C.text = t : (d.dataLabels = d.dataLabels || [], p = d.dataLabels[f] = w ? n.text(t, 0, -9999, c.useHTML).addClass("highcharts-data-label") : n.label(t, 0, -9999, c.shape, null, null, c.useHTML, null, "data-label"), f || (d.dataLabel = p), p.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (c.className || "") + (c.useHTML ? " highcharts-tracker" : ""))), p.options = c, p.attr(C), b.styledMode || p.css(v).shadow(c.shadow), p.added || p.add(u), c.textPath && !c.useHTML && (p.setTextPath(d.getDataLabelPath && d.getDataLabelPath(p) || d.graphic, c.textPath), d.dataLabelPath && !c.textPath.enabled && (d.dataLabelPath = d.dataLabelPath.destroy())), a.alignDataLabel(d, p, c, null, q));
            });
          });
        }
        A(this, "afterDrawDataLabels");
      }
      function t(a, b, c, d, e, f) {
        var g = this.chart,
          h = b.align,
          k = b.verticalAlign,
          l = a.box ? 0 : a.padding || 0,
          m = b.x;
        m = void 0 === m ? 0 : m;
        var n = b.y;
        n = void 0 === n ? 0 : n;
        var p = (c.x || 0) + l;
        if (0 > p) {
          "right" === h && 0 <= m ? (b.align = "left", b.inside = !0) : m -= p;
          var r = !0;
        }
        p = (c.x || 0) + d.width - l;
        p > g.plotWidth && ("left" === h && 0 >= m ? (b.align = "right", b.inside = !0) : m += g.plotWidth - p, r = !0);
        p = c.y + l;
        0 > p && ("bottom" === k && 0 <= n ? (b.verticalAlign = "top", b.inside = !0) : n -= p, r = !0);
        p = (c.y || 0) + d.height - l;
        p > g.plotHeight && ("top" === k && 0 >= n ? (b.verticalAlign = "bottom", b.inside = !0) : n += g.plotHeight - p, r = !0);
        r && (b.x = m, b.y = n, a.placed = !f, a.align(b, void 0, e));
        return r;
      }
      function z(a, b) {
        var c = [],
          d;
        if (q(a) && !q(b)) c = a.map(function (a) {
          return n(a, b);
        });else if (q(b) && !q(a)) c = b.map(function (b) {
          return n(a, b);
        });else if (q(a) || q(b)) for (d = Math.max(a.length, b.length); d--;) c[d] = n(a[d], b[d]);else c = n(a, b);
        return c;
      }
      function C(a, b, c, d, e) {
        var g = this.chart,
          f = g.inverted,
          h = this.xAxis,
          k = h.reversed,
          l = f ? b.height / 2 : b.width / 2;
        a = (a = a.pointWidth) ? a / 2 : 0;
        b.startXPos = f ? e.x : k ? -l - a : h.width - l + a;
        b.startYPos = f ? k ? this.yAxis.height - l + a : -l - a : e.y;
        d ? "hidden" === b.visibility && (b.show(), b.attr({
          opacity: 0
        }).animate({
          opacity: 1
        })) : b.attr({
          opacity: 1
        }).animate({
          opacity: 0
        }, void 0, b.hide);
        g.hasRendered && (c && b.attr({
          x: b.startXPos,
          y: b.startYPos
        }), b.placed = !0);
      }
      var r = [];
      a.compose = function (a) {
        if (-1 === r.indexOf(a)) {
          var b = a.prototype;
          r.push(a);
          b.alignDataLabel = f;
          b.drawDataLabels = u;
          b.justifyDataLabel = t;
          b.setDataLabelStartPos = C;
        }
      };
    })(h || (h = {}));
    "";
    return h;
  });
  M(a, "Series/Column/ColumnDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = u.series,
      y = z.merge,
      G = z.pick,
      H;
    (function (u) {
      function q(a, e, c, h, f) {
        var k = this.chart.inverted,
          n = a.series,
          q = (n.xAxis ? n.xAxis.len : this.chart.plotSizeX) || 0;
        n = (n.yAxis ? n.yAxis.len : this.chart.plotSizeY) || 0;
        var t = a.dlBox || a.shapeArgs,
          u = G(a.below, a.plotY > G(this.translatedThreshold, n)),
          C = G(c.inside, !!this.options.stacking);
        t && (h = y(t), 0 > h.y && (h.height += h.y, h.y = 0), t = h.y + h.height - n, 0 < t && t < h.height && (h.height -= t), k && (h = {
          x: n - h.y - h.height,
          y: q - h.x - h.width,
          width: h.height,
          height: h.width
        }), C || (k ? (h.x += u ? 0 : h.width, h.width = 0) : (h.y += u ? h.height : 0, h.height = 0)));
        c.align = G(c.align, !k || C ? "center" : u ? "right" : "left");
        c.verticalAlign = G(c.verticalAlign, k || C ? "middle" : u ? "top" : "bottom");
        v.prototype.alignDataLabel.call(this, a, e, c, h, f);
        c.inside && a.contrastColor && e.css({
          color: a.contrastColor
        });
      }
      var n = [];
      u.compose = function (k) {
        a.compose(v);
        -1 === n.indexOf(k) && (n.push(k), k.prototype.alignDataLabel = q);
      };
    })(H || (H = {}));
    return H;
  });
  M(a, "Series/Bar/BarSeries.js", [a["Series/Column/ColumnSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = this && this.__extends || function () {
        var a = function (v, q) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, k) {
            a.__proto__ = k;
          } || function (a, k) {
            for (var e in k) k.hasOwnProperty(e) && (a[e] = k[e]);
          };
          return a(v, q);
        };
        return function (v, q) {
          function n() {
            this.constructor = v;
          }
          a(v, q);
          v.prototype = null === q ? Object.create(q) : (n.prototype = q.prototype, new n());
        };
      }(),
      y = z.extend,
      G = z.merge;
    z = function (u) {
      function y() {
        var a = null !== u && u.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      v(y, u);
      y.defaultOptions = G(a.defaultOptions, {});
      return y;
    }(a);
    y(z.prototype, {
      inverted: !0
    });
    u.registerSeriesType("bar", z);
    "";
    return z;
  });
  M(a, "Series/Scatter/ScatterSeries.js", [a["Series/Column/ColumnSeries.js"], a["Series/Line/LineSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, u, z, F) {
    var v = this && this.__extends || function () {
        var a = function (n, k) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
          };
          return a(n, k);
        };
        return function (n, k) {
          function e() {
            this.constructor = n;
          }
          a(n, k);
          n.prototype = null === k ? Object.create(k) : (e.prototype = k.prototype, new e());
        };
      }(),
      G = F.addEvent,
      H = F.extend,
      A = F.merge;
    F = function (a) {
      function n() {
        var k = null !== a && a.apply(this, arguments) || this;
        k.data = void 0;
        k.options = void 0;
        k.points = void 0;
        return k;
      }
      v(n, a);
      n.prototype.applyJitter = function () {
        var a = this,
          e = this.options.jitter,
          c = this.points.length;
        e && this.points.forEach(function (h, f) {
          ["x", "y"].forEach(function (k, n) {
            var p = "plot" + k.toUpperCase();
            if (e[k] && !h.isNull) {
              var q = a[k + "Axis"];
              var v = e[k] * q.transA;
              if (q && !q.isLog) {
                var u = Math.max(0, h[p] - v);
                q = Math.min(q.len, h[p] + v);
                n = 1E4 * Math.sin(f + n * c);
                h[p] = u + (q - u) * (n - Math.floor(n));
                "x" === k && (h.clientX = h.plotX);
              }
            }
          });
        });
      };
      n.prototype.drawGraph = function () {
        this.options.lineWidth ? a.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
      };
      n.defaultOptions = A(u.defaultOptions, {
        lineWidth: 0,
        findNearestPointBy: "xy",
        jitter: {
          x: 0,
          y: 0
        },
        marker: {
          enabled: !0
        },
        tooltip: {
          headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
          pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
        }
      });
      return n;
    }(u);
    H(F.prototype, {
      drawTracker: a.prototype.drawTracker,
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1
    });
    G(F, "afterTranslate", function () {
      this.applyJitter();
    });
    z.registerSeriesType("scatter", F);
    "";
    return F;
  });
  M(a, "Series/CenteredUtilities.js", [a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = a.deg2rad,
      y = z.isNumber,
      G = z.pick,
      H = z.relativeLength,
      A;
    (function (a) {
      a.getCenter = function () {
        var a = this.options,
          k = this.chart,
          e = 2 * (a.slicedOffset || 0),
          c = k.plotWidth - 2 * e,
          h = k.plotHeight - 2 * e,
          f = a.center,
          q = Math.min(c, h),
          p = a.size,
          v = a.innerSize || 0;
        "string" === typeof p && (p = parseFloat(p));
        "string" === typeof v && (v = parseFloat(v));
        a = [G(f[0], "50%"), G(f[1], "50%"), G(p && 0 > p ? void 0 : a.size, "100%"), G(v && 0 > v ? void 0 : a.innerSize || 0, "0%")];
        !k.angular || this instanceof u || (a[3] = 0);
        for (f = 0; 4 > f; ++f) p = a[f], k = 2 > f || 2 === f && /%$/.test(p), a[f] = H(p, [c, h, q, a[2]][f]) + (k ? e : 0);
        a[3] > a[2] && (a[3] = a[2]);
        return a;
      };
      a.getStartAndEndRadians = function (a, k) {
        a = y(a) ? a : 0;
        k = y(k) && k > a && 360 > k - a ? k : a + 360;
        return {
          start: v * (a + -90),
          end: v * (k + -90)
        };
      };
    })(A || (A = {}));
    "";
    return A;
  });
  M(a, "Series/Pie/PiePoint.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function (a, u, z) {
    var v = this && this.__extends || function () {
        var a = function (e, c) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
          };
          return a(e, c);
        };
        return function (e, c) {
          function h() {
            this.constructor = e;
          }
          a(e, c);
          e.prototype = null === c ? Object.create(c) : (h.prototype = c.prototype, new h());
        };
      }(),
      y = a.setAnimation,
      G = z.addEvent,
      H = z.defined;
    a = z.extend;
    var A = z.isNumber,
      q = z.pick,
      n = z.relativeLength;
    u = function (a) {
      function e() {
        var c = null !== a && a.apply(this, arguments) || this;
        c.labelDistance = void 0;
        c.options = void 0;
        c.series = void 0;
        return c;
      }
      v(e, a);
      e.prototype.getConnectorPath = function () {
        var a = this.labelPosition,
          e = this.series.options.dataLabels,
          f = this.connectorShapes,
          k = e.connectorShape;
        f[k] && (k = f[k]);
        return k.call(this, {
          x: a.final.x,
          y: a.final.y,
          alignment: a.alignment
        }, a.connectorPosition, e);
      };
      e.prototype.getTranslate = function () {
        return this.sliced ? this.slicedTranslation : {
          translateX: 0,
          translateY: 0
        };
      };
      e.prototype.haloPath = function (a) {
        var c = this.shapeArgs;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {
          innerR: c.r - 1,
          start: c.start,
          end: c.end
        });
      };
      e.prototype.init = function () {
        var c = this;
        a.prototype.init.apply(this, arguments);
        this.name = q(this.name, "Slice");
        var e = function (a) {
          c.slice("select" === a.type);
        };
        G(this, "select", e);
        G(this, "unselect", e);
        return this;
      };
      e.prototype.isValid = function () {
        return A(this.y) && 0 <= this.y;
      };
      e.prototype.setVisible = function (a, e) {
        var c = this,
          h = this.series,
          k = h.chart,
          n = h.options.ignoreHiddenPoint;
        e = q(e, n);
        a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a, h.options.data[h.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (e) {
          if (c[e]) c[e][a ? "show" : "hide"](a);
        }), this.legendItem && k.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""), n && (h.isDirty = !0), e && k.redraw());
      };
      e.prototype.slice = function (a, e, f) {
        var c = this.series;
        y(f, c.chart);
        q(e, !0);
        this.sliced = this.options.sliced = H(a) ? a : !this.sliced;
        c.options.data[c.data.indexOf(this)] = this.options;
        this.graphic && this.graphic.animate(this.getTranslate());
        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
      };
      return e;
    }(u);
    a(u.prototype, {
      connectorShapes: {
        fixedOffset: function (a, e, c) {
          var h = e.breakAt;
          e = e.touchingSliceAt;
          return [["M", a.x, a.y], c.softConnector ? ["C", a.x + ("left" === a.alignment ? -5 : 5), a.y, 2 * h.x - e.x, 2 * h.y - e.y, h.x, h.y] : ["L", h.x, h.y], ["L", e.x, e.y]];
        },
        straight: function (a, e) {
          e = e.touchingSliceAt;
          return [["M", a.x, a.y], ["L", e.x, e.y]];
        },
        crookedLine: function (a, e, c) {
          e = e.touchingSliceAt;
          var h = this.series,
            f = h.center[0],
            k = h.chart.plotWidth,
            p = h.chart.plotLeft;
          h = a.alignment;
          var q = this.shapeArgs.r;
          c = n(c.crookDistance, 1);
          k = "left" === h ? f + q + (k + p - f - q) * (1 - c) : p + (f - q) * c;
          c = ["L", k, a.y];
          f = !0;
          if ("left" === h ? k > a.x || k < e.x : k < a.x || k > e.x) f = !1;
          a = [["M", a.x, a.y]];
          f && a.push(c);
          a.push(["L", e.x, e.y]);
          return a;
        }
      }
    });
    return u;
  });
  M(a, "Series/Pie/PieSeries.js", [a["Series/CenteredUtilities.js"], a["Series/Column/ColumnSeries.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Series/Pie/PiePoint.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Utilities.js"]], function (a, u, z, F, y, G, H, A, q) {
    var n = this && this.__extends || function () {
        var a = function (c, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
          };
          return a(c, e);
        };
        return function (c, e) {
          function f() {
            this.constructor = c;
          }
          a(c, e);
          c.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
        };
      }(),
      k = a.getStartAndEndRadians;
    z = z.noop;
    var e = q.clamp,
      c = q.extend,
      h = q.fireEvent,
      f = q.merge,
      v = q.pick,
      p = q.relativeLength;
    q = function (a) {
      function c() {
        var c = null !== a && a.apply(this, arguments) || this;
        c.center = void 0;
        c.data = void 0;
        c.maxLabelDistance = void 0;
        c.options = void 0;
        c.points = void 0;
        return c;
      }
      n(c, a);
      c.prototype.animate = function (a) {
        var c = this,
          e = c.points,
          f = c.startAngleRad;
        a || e.forEach(function (a) {
          var b = a.graphic,
            d = a.shapeArgs;
          b && d && (b.attr({
            r: v(a.startR, c.center && c.center[3] / 2),
            start: f,
            end: f
          }), b.animate({
            r: d.r,
            start: d.start,
            end: d.end
          }, c.options.animation));
        });
      };
      c.prototype.drawEmpty = function () {
        var a = this.startAngleRad,
          c = this.endAngleRad,
          e = this.options;
        if (0 === this.total && this.center) {
          var f = this.center[0];
          var b = this.center[1];
          this.graph || (this.graph = this.chart.renderer.arc(f, b, this.center[1] / 2, 0, a, c).addClass("highcharts-empty-series").add(this.group));
          this.graph.attr({
            d: A.arc(f, b, this.center[2] / 2, 0, {
              start: a,
              end: c,
              innerR: this.center[3] / 2
            })
          });
          this.chart.styledMode || this.graph.attr({
            "stroke-width": e.borderWidth,
            fill: e.fillColor || "none",
            stroke: e.color || "#cccccc"
          });
        } else this.graph && (this.graph = this.graph.destroy());
      };
      c.prototype.drawPoints = function () {
        var a = this.chart.renderer;
        this.points.forEach(function (c) {
          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
          c.graphic || (c.graphic = a[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
        });
      };
      c.prototype.generatePoints = function () {
        a.prototype.generatePoints.call(this);
        this.updateTotals();
      };
      c.prototype.getX = function (a, c, f) {
        var h = this.center,
          b = this.radii ? this.radii[f.index] || 0 : h[2] / 2;
        a = Math.asin(e((a - h[1]) / (b + f.labelDistance), -1, 1));
        return h[0] + (c ? -1 : 1) * Math.cos(a) * (b + f.labelDistance) + (0 < f.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
      };
      c.prototype.hasData = function () {
        return !!this.processedXData.length;
      };
      c.prototype.redrawPoints = function () {
        var a = this,
          c = a.chart,
          e = c.renderer,
          h = a.options.shadow,
          b,
          g,
          d,
          k;
        this.drawEmpty();
        !h || a.shadowGroup || c.styledMode || (a.shadowGroup = e.g("shadow").attr({
          zIndex: -1
        }).add(a.group));
        a.points.forEach(function (l) {
          var m = {};
          g = l.graphic;
          if (!l.isNull && g) {
            var n = void 0;
            k = l.shapeArgs;
            b = l.getTranslate();
            c.styledMode || (n = l.shadowGroup, h && !n && (n = l.shadowGroup = e.g("shadow").add(a.shadowGroup)), n && n.attr(b), d = a.pointAttribs(l, l.selected && "select"));
            l.delayedRendering ? (g.setRadialReference(a.center).attr(k).attr(b), c.styledMode || g.attr(d).attr({
              "stroke-linejoin": "round"
            }).shadow(h, n), l.delayedRendering = !1) : (g.setRadialReference(a.center), c.styledMode || f(!0, m, d), f(!0, m, k, b), g.animate(m));
            g.attr({
              visibility: l.visible ? "inherit" : "hidden"
            });
            g.addClass(l.getClassName(), !0);
          } else g && (l.graphic = g.destroy());
        });
      };
      c.prototype.sortByAngle = function (a, c) {
        a.sort(function (a, e) {
          return "undefined" !== typeof a.angle && (e.angle - a.angle) * c;
        });
      };
      c.prototype.translate = function (a) {
        this.generatePoints();
        var c = this.options,
          e = c.slicedOffset,
          f = e + (c.borderWidth || 0),
          b = k(c.startAngle, c.endAngle),
          g = this.startAngleRad = b.start;
        b = (this.endAngleRad = b.end) - g;
        var d = this.points,
          m = c.dataLabels.distance;
        c = c.ignoreHiddenPoint;
        var n = d.length,
          q,
          t = 0;
        a || (this.center = a = this.getCenter());
        for (q = 0; q < n; q++) {
          var u = d[q];
          var w = g + t * b;
          !u.isValid() || c && !u.visible || (t += u.percentage / 100);
          var y = g + t * b;
          var B = {
            x: a[0],
            y: a[1],
            r: a[2] / 2,
            innerR: a[3] / 2,
            start: Math.round(1E3 * w) / 1E3,
            end: Math.round(1E3 * y) / 1E3
          };
          u.shapeType = "arc";
          u.shapeArgs = B;
          u.labelDistance = v(u.options.dataLabels && u.options.dataLabels.distance, m);
          u.labelDistance = p(u.labelDistance, B.r);
          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, u.labelDistance);
          y = (y + w) / 2;
          y > 1.5 * Math.PI ? y -= 2 * Math.PI : y < -Math.PI / 2 && (y += 2 * Math.PI);
          u.slicedTranslation = {
            translateX: Math.round(Math.cos(y) * e),
            translateY: Math.round(Math.sin(y) * e)
          };
          B = Math.cos(y) * a[2] / 2;
          var A = Math.sin(y) * a[2] / 2;
          u.tooltipPos = [a[0] + .7 * B, a[1] + .7 * A];
          u.half = y < -Math.PI / 2 || y > Math.PI / 2 ? 1 : 0;
          u.angle = y;
          w = Math.min(f, u.labelDistance / 5);
          u.labelPosition = {
            natural: {
              x: a[0] + B + Math.cos(y) * u.labelDistance,
              y: a[1] + A + Math.sin(y) * u.labelDistance
            },
            "final": {},
            alignment: 0 > u.labelDistance ? "center" : u.half ? "right" : "left",
            connectorPosition: {
              breakAt: {
                x: a[0] + B + Math.cos(y) * w,
                y: a[1] + A + Math.sin(y) * w
              },
              touchingSliceAt: {
                x: a[0] + B,
                y: a[1] + A
              }
            }
          };
        }
        h(this, "afterTranslate");
      };
      c.prototype.updateTotals = function () {
        var a = this.points,
          c = a.length,
          e = this.options.ignoreHiddenPoint,
          f,
          b = 0;
        for (f = 0; f < c; f++) {
          var g = a[f];
          !g.isValid() || e && !g.visible || (b += g.y);
        }
        this.total = b;
        for (f = 0; f < c; f++) g = a[f], g.percentage = 0 < b && (g.visible || !e) ? g.y / b * 100 : 0, g.total = b;
      };
      c.defaultOptions = f(G.defaultOptions, {
        center: [null, null],
        clip: !1,
        colorByPoint: !0,
        dataLabels: {
          allowOverlap: !0,
          connectorPadding: 5,
          connectorShape: "fixedOffset",
          crookDistance: "70%",
          distance: 30,
          enabled: !0,
          formatter: function () {
            return this.point.isNull ? void 0 : this.point.name;
          },
          softConnector: !0,
          x: 0
        },
        fillColor: void 0,
        ignoreHiddenPoint: !0,
        inactiveOtherPoints: !0,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: !1,
        slicedOffset: 10,
        stickyTracking: !1,
        tooltip: {
          followPointer: !0
        },
        borderColor: "#ffffff",
        borderWidth: 1,
        lineWidth: void 0,
        states: {
          hover: {
            brightness: .1
          }
        }
      });
      return c;
    }(G);
    c(q.prototype, {
      axisTypes: [],
      directTouch: !0,
      drawGraph: void 0,
      drawLegendSymbol: F.drawRectangle,
      drawTracker: u.prototype.drawTracker,
      getCenter: a.getCenter,
      getSymbol: z,
      isCartesian: !1,
      noSharedTooltip: !0,
      pointAttribs: u.prototype.pointAttribs,
      pointClass: y,
      requireSorting: !1,
      searchPoint: z,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    H.registerSeriesType("pie", q);
    "";
    return q;
  });
  M(a, "Series/Pie/PieDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Globals.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, u, z, F, y) {
    var v = u.noop,
      H = z.distribute,
      A = F.series,
      q = y.arrayMax,
      n = y.clamp,
      k = y.defined,
      e = y.merge,
      c = y.pick,
      h = y.relativeLength,
      f;
    (function (f) {
      function p() {
        var a = this,
          f = a.data,
          b = a.chart,
          g = a.options.dataLabels || {},
          d = g.connectorPadding,
          h = b.plotWidth,
          n = b.plotHeight,
          p = b.plotLeft,
          v = Math.round(b.chartWidth / 3),
          t = a.center,
          u = t[2] / 2,
          w = t[1],
          C = [[], []],
          y = [0, 0, 0, 0],
          B = a.dataLabelPositioners,
          z,
          F,
          G,
          J,
          M,
          E,
          T,
          N,
          V,
          W,
          X,
          R;
        a.visible && (g.enabled || a._hasPointLabels) && (f.forEach(function (a) {
          a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
            width: "auto"
          }).css({
            width: "auto",
            textOverflow: "clip"
          }), a.dataLabel.shortened = !1);
        }), A.prototype.drawDataLabels.apply(a), f.forEach(function (a) {
          a.dataLabel && (a.visible ? (C[a.half].push(a), a.dataLabel._pos = null, !k(g.style.width) && !k(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > v && (a.dataLabel.css({
            width: Math.round(.7 * v) + "px"
          }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
        }), C.forEach(function (e, f) {
          var l = e.length,
            m = [],
            r;
          if (l) {
            a.sortByAngle(e, f - .5);
            if (0 < a.maxLabelDistance) {
              var q = Math.max(0, w - u - a.maxLabelDistance);
              var v = Math.min(w + u + a.maxLabelDistance, b.plotHeight);
              e.forEach(function (a) {
                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, w - u - a.labelDistance), a.bottom = Math.min(w + u + a.labelDistance, b.plotHeight), r = a.dataLabel.getBBox().height || 21, a.distributeBox = {
                  target: a.labelPosition.natural.y - a.top + r / 2,
                  size: r,
                  rank: a.y
                }, m.push(a.distributeBox));
              });
              q = v + r - q;
              H(m, q, q / 5);
            }
            for (X = 0; X < l; X++) {
              z = e[X];
              E = z.labelPosition;
              J = z.dataLabel;
              W = !1 === z.visible ? "hidden" : "inherit";
              V = q = E.natural.y;
              m && k(z.distributeBox) && ("undefined" === typeof z.distributeBox.pos ? W = "hidden" : (T = z.distributeBox.size, V = B.radialDistributionY(z)));
              delete z.positionIndex;
              if (g.justify) N = B.justify(z, u, t);else switch (g.alignTo) {
                case "connectors":
                  N = B.alignToConnectors(e, f, h, p);
                  break;
                case "plotEdges":
                  N = B.alignToPlotEdges(J, f, h, p);
                  break;
                default:
                  N = B.radialDistributionX(a, z, V, q);
              }
              J._attr = {
                visibility: W,
                align: E.alignment
              };
              R = z.options.dataLabels || {};
              J._pos = {
                x: N + c(R.x, g.x) + ({
                  left: d,
                  right: -d
                }[E.alignment] || 0),
                y: V + c(R.y, g.y) - 10
              };
              E.final.x = N;
              E.final.y = V;
              c(g.crop, !0) && (M = J.getBBox().width, q = null, N - M < d && 1 === f ? (q = Math.round(M - N + d), y[3] = Math.max(q, y[3])) : N + M > h - d && 0 === f && (q = Math.round(N + M - h + d), y[1] = Math.max(q, y[1])), 0 > V - T / 2 ? y[0] = Math.max(Math.round(-V + T / 2), y[0]) : V + T / 2 > n && (y[2] = Math.max(Math.round(V + T / 2 - n), y[2])), J.sideOverflow = q);
            }
          }
        }), 0 === q(y) || this.verifyDataLabelOverflow(y)) && (this.placeDataLabels(), this.points.forEach(function (d) {
          R = e(g, d.options.dataLabels);
          if (F = c(R.connectorWidth, 1)) {
            var f;
            G = d.connector;
            if ((J = d.dataLabel) && J._pos && d.visible && 0 < d.labelDistance) {
              W = J._attr.visibility;
              if (f = !G) d.connector = G = b.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + d.colorIndex + (d.className ? " " + d.className : "")).add(a.dataLabelsGroup), b.styledMode || G.attr({
                "stroke-width": F,
                stroke: R.connectorColor || d.color || "#666666"
              });
              G[f ? "attr" : "animate"]({
                d: d.getConnectorPath()
              });
              G.attr("visibility", W);
            } else G && (d.connector = G.destroy());
          }
        }));
      }
      function u() {
        this.points.forEach(function (a) {
          var c = a.dataLabel,
            b;
          c && a.visible && ((b = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
            width: c._attr.width + "px",
            textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
          }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](b), c.moved = !0) : c && c.attr({
            y: -9999
          }));
          delete a.distributeBox;
        }, this);
      }
      function t(a) {
        var c = this.center,
          b = this.options,
          e = b.center,
          d = b.minSize || 80,
          f = null !== b.size;
        if (!f) {
          if (null !== e[0]) var k = Math.max(c[2] - Math.max(a[1], a[3]), d);else k = Math.max(c[2] - a[1] - a[3], d), c[0] += (a[3] - a[1]) / 2;
          null !== e[1] ? k = n(k, d, c[2] - Math.max(a[0], a[2])) : (k = n(k, d, c[2] - a[0] - a[2]), c[1] += (a[0] - a[2]) / 2);
          k < c[2] ? (c[2] = k, c[3] = Math.min(h(b.innerSize || 0, k), k), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : f = !0;
        }
        return f;
      }
      var w = [],
        C = {
          radialDistributionY: function (a) {
            return a.top + a.distributeBox.pos;
          },
          radialDistributionX: function (a, c, b, e) {
            return a.getX(b < c.top + 2 || b > c.bottom - 2 ? e : b, c.half, c);
          },
          justify: function (a, c, b) {
            return b[0] + (a.half ? -1 : 1) * (c + a.labelDistance);
          },
          alignToPlotEdges: function (a, c, b, e) {
            a = a.getBBox().width;
            return c ? a + e : b - a - e;
          },
          alignToConnectors: function (a, c, b, e) {
            var d = 0,
              g;
            a.forEach(function (a) {
              g = a.dataLabel.getBBox().width;
              g > d && (d = g);
            });
            return c ? d + e : b - d - e;
          }
        };
      f.compose = function (c) {
        a.compose(A);
        -1 === w.indexOf(c) && (w.push(c), c = c.prototype, c.dataLabelPositioners = C, c.alignDataLabel = v, c.drawDataLabels = p, c.placeDataLabels = u, c.verifyDataLabelOverflow = t);
      };
    })(f || (f = {}));
    return f;
  });
  M(a, "Extensions/OverlappingDataLabels.js", [a["Core/Chart/Chart.js"], a["Core/Utilities.js"]], function (a, u) {
    function v(a, k) {
      var e = !1;
      if (a) {
        var c = a.newOpacity;
        a.oldOpacity !== c && (a.alignAttr && a.placed ? (a[c ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), e = !0, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, function () {
          k.styledMode || a.css({
            pointerEvents: c ? "auto" : "none"
          });
        }), y(k, "afterHideOverlappingLabel")) : a.attr({
          opacity: c
        }));
        a.isOld = !0;
      }
      return e;
    }
    var F = u.addEvent,
      y = u.fireEvent,
      G = u.isArray,
      H = u.isNumber,
      A = u.objectEach,
      q = u.pick;
    F(a, "render", function () {
      var a = this,
        k = [];
      (this.labelCollectors || []).forEach(function (a) {
        k = k.concat(a());
      });
      (this.yAxis || []).forEach(function (a) {
        a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && A(a.stacking.stacks, function (a) {
          A(a, function (a) {
            a.label && "hidden" !== a.label.visibility && k.push(a.label);
          });
        });
      });
      (this.series || []).forEach(function (e) {
        var c = e.options.dataLabels;
        e.visible && (!1 !== c.enabled || e._hasPointLabels) && (c = function (c) {
          return c.forEach(function (c) {
            c.visible && (G(c.dataLabels) ? c.dataLabels : c.dataLabel ? [c.dataLabel] : []).forEach(function (e) {
              var f = e.options;
              e.labelrank = q(f.labelrank, c.labelrank, c.shapeArgs && c.shapeArgs.height);
              f.allowOverlap ? (e.oldOpacity = e.opacity, e.newOpacity = 1, v(e, a)) : k.push(e);
            });
          });
        }, c(e.nodes || []), c(e.points));
      });
      this.hideOverlappingLabels(k);
    });
    a.prototype.hideOverlappingLabels = function (a) {
      var k = this,
        e = a.length,
        c = k.renderer,
        h,
        f,
        n,
        p = !1;
      var q = function (a) {
        var e,
          f = a.box ? 0 : a.padding || 0,
          b = e = 0,
          g;
        if (a && (!a.alignAttr || a.placed)) {
          var d = a.alignAttr || {
            x: a.attr("x"),
            y: a.attr("y")
          };
          var h = a.parentGroup;
          a.width || (e = a.getBBox(), a.width = e.width, a.height = e.height, e = c.fontMetrics(null, a.element).h);
          var k = a.width - 2 * f;
          (g = {
            left: "0",
            center: "0.5",
            right: "1"
          }[a.alignValue]) ? b = +g * k : H(a.x) && Math.round(a.x) !== a.translateX && (b = a.x - a.translateX);
          return {
            x: d.x + (h.translateX || 0) + f - (b || 0),
            y: d.y + (h.translateY || 0) + f - e,
            width: a.width - 2 * f,
            height: a.height - 2 * f
          };
        }
      };
      for (f = 0; f < e; f++) if (h = a[f]) h.oldOpacity = h.opacity, h.newOpacity = 1, h.absoluteBox = q(h);
      a.sort(function (a, c) {
        return (c.labelrank || 0) - (a.labelrank || 0);
      });
      for (f = 0; f < e; f++) {
        var t = (q = a[f]) && q.absoluteBox;
        for (h = f + 1; h < e; ++h) {
          var u = (n = a[h]) && n.absoluteBox;
          !t || !u || q === n || 0 === q.newOpacity || 0 === n.newOpacity || u.x >= t.x + t.width || u.x + u.width <= t.x || u.y >= t.y + t.height || u.y + u.height <= t.y || ((q.labelrank < n.labelrank ? q : n).newOpacity = 0);
        }
      }
      a.forEach(function (a) {
        v(a, k) && (p = !0);
      });
      p && y(k, "afterHideAllOverlappingLabels");
    };
  });
  M(a, "Core/Responsive.js", [a["Core/Utilities.js"]], function (a) {
    var v = a.extend,
      z = a.find,
      F = a.isArray,
      y = a.isObject,
      G = a.merge,
      H = a.objectEach,
      A = a.pick,
      q = a.splat,
      n = a.uniqueKey,
      k;
    (function (a) {
      var c = [];
      a.compose = function (a) {
        -1 === c.indexOf(a) && (c.push(a), v(a.prototype, e.prototype));
        return a;
      };
      var e = function () {
        function a() {}
        a.prototype.currentOptions = function (a) {
          function c(a, f, h, k) {
            var b;
            H(a, function (a, d) {
              if (!k && -1 < e.collectionsWithUpdate.indexOf(d) && f[d]) for (a = q(a), h[d] = [], b = 0; b < Math.max(a.length, f[d].length); b++) f[d][b] && (void 0 === a[b] ? h[d][b] = f[d][b] : (h[d][b] = {}, c(a[b], f[d][b], h[d][b], k + 1)));else y(a) ? (h[d] = F(a) ? [] : {}, c(a, f[d] || {}, h[d], k + 1)) : h[d] = "undefined" === typeof f[d] ? null : f[d];
            });
          }
          var e = this,
            f = {};
          c(a, this.options, f, 0);
          return f;
        };
        a.prototype.matchResponsiveRule = function (a, c) {
          var e = a.condition;
          (e.callback || function () {
            return this.chartWidth <= A(e.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(e.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(e.minWidth, 0) && this.chartHeight >= A(e.minHeight, 0);
          }).call(this) && c.push(a._id);
        };
        a.prototype.setResponsive = function (a, c) {
          var e = this,
            f = this.options.responsive,
            h = this.currentResponsive,
            k = [];
          !c && f && f.rules && f.rules.forEach(function (a) {
            "undefined" === typeof a._id && (a._id = n());
            e.matchResponsiveRule(a, k);
          }, this);
          c = G.apply(void 0, k.map(function (a) {
            return z((f || {}).rules || [], function (c) {
              return c._id === a;
            });
          }).map(function (a) {
            return a && a.chartOptions;
          }));
          c.isResponsiveOptions = !0;
          k = k.toString() || void 0;
          k !== (h && h.ruleIds) && (h && this.update(h.undoOptions, a, !0), k ? (h = this.currentOptions(c), h.isResponsiveOptions = !0, this.currentResponsive = {
            ruleIds: k,
            mergedOptions: c,
            undoOptions: h
          }, this.update(c, a, !0)) : this.currentResponsive = void 0);
        };
        return a;
      }();
    })(k || (k = {}));
    "";
    "";
    return k;
  });
  M(a, "masters/highcharts.src.js", [a["Core/Globals.js"], a["Core/Utilities.js"], a["Core/DefaultOptions.js"], a["Core/Animation/Fx.js"], a["Core/Animation/AnimationUtilities.js"], a["Core/Renderer/HTML/AST.js"], a["Core/FormatUtilities.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Renderer/HTML/HTMLElement.js"], a["Core/Renderer/HTML/HTMLRenderer.js"], a["Core/Axis/Axis.js"], a["Core/Axis/DateTimeAxis.js"], a["Core/Axis/LogarithmicAxis.js"], a["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], a["Core/Axis/Tick.js"], a["Core/Tooltip.js"], a["Core/Series/Point.js"], a["Core/Pointer.js"], a["Core/MSPointer.js"], a["Core/Legend/Legend.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Series/Column/ColumnSeries.js"], a["Series/Column/ColumnDataLabel.js"], a["Series/Pie/PieSeries.js"], a["Series/Pie/PieDataLabel.js"], a["Core/Series/DataLabel.js"], a["Core/Responsive.js"], a["Core/Color/Color.js"], a["Core/Time.js"]], function (a, u, z, F, y, G, H, A, q, n, k, e, c, h, f, w, p, B, t, J, C, r, l, b, g, d, m, D, x, I, M, S, O) {
    a.animate = y.animate;
    a.animObject = y.animObject;
    a.getDeferredAnimation = y.getDeferredAnimation;
    a.setAnimation = y.setAnimation;
    a.stop = y.stop;
    a.timers = F.timers;
    a.AST = G;
    a.Axis = c;
    a.Chart = l;
    a.chart = l.chart;
    a.Fx = F;
    a.Legend = r;
    a.PlotLineOrBand = w;
    a.Point = t;
    a.Pointer = C.isRequired() ? C : J;
    a.Series = b;
    a.SVGElement = q;
    a.SVGRenderer = n;
    a.Tick = p;
    a.Time = O;
    a.Tooltip = B;
    a.Color = S;
    a.color = S.parse;
    e.compose(n);
    k.compose(q);
    a.defaultOptions = z.defaultOptions;
    a.getOptions = z.getOptions;
    a.time = z.defaultTime;
    a.setOptions = z.setOptions;
    a.dateFormat = H.dateFormat;
    a.format = H.format;
    a.numberFormat = H.numberFormat;
    a.addEvent = u.addEvent;
    a.arrayMax = u.arrayMax;
    a.arrayMin = u.arrayMin;
    a.attr = u.attr;
    a.clearTimeout = u.clearTimeout;
    a.correctFloat = u.correctFloat;
    a.createElement = u.createElement;
    a.css = u.css;
    a.defined = u.defined;
    a.destroyObjectProperties = u.destroyObjectProperties;
    a.discardElement = u.discardElement;
    a.distribute = A.distribute;
    a.erase = u.erase;
    a.error = u.error;
    a.extend = u.extend;
    a.extendClass = u.extendClass;
    a.find = u.find;
    a.fireEvent = u.fireEvent;
    a.getMagnitude = u.getMagnitude;
    a.getStyle = u.getStyle;
    a.inArray = u.inArray;
    a.isArray = u.isArray;
    a.isClass = u.isClass;
    a.isDOMElement = u.isDOMElement;
    a.isFunction = u.isFunction;
    a.isNumber = u.isNumber;
    a.isObject = u.isObject;
    a.isString = u.isString;
    a.keys = u.keys;
    a.merge = u.merge;
    a.normalizeTickInterval = u.normalizeTickInterval;
    a.objectEach = u.objectEach;
    a.offset = u.offset;
    a.pad = u.pad;
    a.pick = u.pick;
    a.pInt = u.pInt;
    a.relativeLength = u.relativeLength;
    a.removeEvent = u.removeEvent;
    a.seriesType = g.seriesType;
    a.splat = u.splat;
    a.stableSort = u.stableSort;
    a.syncTimeout = u.syncTimeout;
    a.timeUnits = u.timeUnits;
    a.uniqueKey = u.uniqueKey;
    a.useSerialIds = u.useSerialIds;
    a.wrap = u.wrap;
    m.compose(d);
    I.compose(b);
    h.compose(c);
    f.compose(c);
    x.compose(D);
    w.compose(c);
    M.compose(l);
    return a;
  });
  a["masters/highcharts.src.js"]._modules = a;
  return a["masters/highcharts.src.js"];
});
//# sourceMappingURL=highcharts.js.map

/***/ }),

/***/ 81220:
/*!*********************************************!*\
  !*** ./node_modules/highcharts/highmaps.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highmaps JS v9.3.3 (2022-02-01)

 (c) 2011-2021 Torstein Honsi

 License: www.highcharts.com/license
*/


(function (Y, G) {
   true && module.exports ? (G["default"] = G, module.exports = Y.document ? G(Y) : G) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return G(Y);
  }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);
})("undefined" !== typeof window ? window : this, function (Y) {
  function G(v, b, A, E) {
    v.hasOwnProperty(b) || (v[b] = E.apply(null, A));
  }
  var b = {};
  G(b, "Core/Globals.js", [], function () {
    var v = "undefined" !== typeof Y ? Y : "undefined" !== typeof window ? window : {},
      b;
    (function (b) {
      b.SVG_NS = "http://www.w3.org/2000/svg";
      b.product = "Highcharts";
      b.version = "9.3.3";
      b.win = v;
      b.doc = b.win.document;
      b.svg = b.doc && b.doc.createElementNS && !!b.doc.createElementNS(b.SVG_NS, "svg").createSVGRect;
      b.userAgent = b.win.navigator && b.win.navigator.userAgent || "";
      b.isChrome = -1 !== b.userAgent.indexOf("Chrome");
      b.isFirefox = -1 !== b.userAgent.indexOf("Firefox");
      b.isMS = /(edge|msie|trident)/i.test(b.userAgent) && !b.win.opera;
      b.isSafari = !b.isChrome && -1 !== b.userAgent.indexOf("Safari");
      b.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(b.userAgent);
      b.isWebKit = -1 !== b.userAgent.indexOf("AppleWebKit");
      b.deg2rad = 2 * Math.PI / 360;
      b.hasBidiBug = b.isFirefox && 4 > parseInt(b.userAgent.split("Firefox/")[1], 10);
      b.hasTouch = !!b.win.TouchEvent;
      b.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
      b.noop = function () {};
      b.supportsPassiveEvents = function () {
        var v = !1;
        if (!b.isMS) {
          var p = Object.defineProperty({}, "passive", {
            get: function () {
              v = !0;
            }
          });
          b.win.addEventListener && b.win.removeEventListener && (b.win.addEventListener("testPassive", b.noop, p), b.win.removeEventListener("testPassive", b.noop, p));
        }
        return v;
      }();
      b.charts = [];
      b.dateFormats = {};
      b.seriesTypes = {};
      b.symbolSizes = {};
      b.chartCount = 0;
    })(b || (b = {}));
    "";
    return b;
  });
  G(b, "Core/Utilities.js", [b["Core/Globals.js"]], function (b) {
    function v(c, l, a, f) {
      var F = l ? "Highcharts error" : "Highcharts warning";
      32 === c && (c = F + ": Deprecated member");
      var d = n(c),
        m = d ? F + " #" + c + ": www.highcharts.com/errors/" + c + "/" : c.toString();
      if ("undefined" !== typeof f) {
        var e = "";
        d && (m += "?");
        r(f, function (c, F) {
          e += "\n - " + F + ": " + c;
          d && (m += encodeURI(F) + "=" + encodeURI(c));
        });
        m += e;
      }
      z(b, "displayError", {
        chart: a,
        code: c,
        message: m,
        params: f
      }, function () {
        if (l) throw Error(m);
        y.console && -1 === v.messages.indexOf(m) && console.warn(m);
      });
      v.messages.push(m);
    }
    function A(c, l) {
      var F = {};
      r(c, function (a, f) {
        if (B(c[f], !0) && !c.nodeType && l[f]) a = A(c[f], l[f]), Object.keys(a).length && (F[f] = a);else if (B(c[f]) || c[f] !== l[f]) F[f] = c[f];
      });
      return F;
    }
    function E(c, f) {
      return parseInt(c, f || 10);
    }
    function w(c) {
      return "string" === typeof c;
    }
    function D(c) {
      c = Object.prototype.toString.call(c);
      return "[object Array]" === c || "[object Array Iterator]" === c;
    }
    function B(c, f) {
      return !!c && "object" === typeof c && (!f || !D(c));
    }
    function k(c) {
      return B(c) && "number" === typeof c.nodeType;
    }
    function t(c) {
      var f = c && c.constructor;
      return !(!B(c, !0) || k(c) || !f || !f.name || "Object" === f.name);
    }
    function n(c) {
      return "number" === typeof c && !isNaN(c) && Infinity > c && -Infinity < c;
    }
    function h(c) {
      return "undefined" !== typeof c && null !== c;
    }
    function d(c, f, l) {
      var a;
      w(f) ? h(l) ? c.setAttribute(f, l) : c && c.getAttribute && ((a = c.getAttribute(f)) || "class" !== f || (a = c.getAttribute(f + "Name"))) : r(f, function (f, l) {
        h(f) ? c.setAttribute(l, f) : c.removeAttribute(l);
      });
      return a;
    }
    function a(c, f) {
      var l;
      c || (c = {});
      for (l in f) c[l] = f[l];
      return c;
    }
    function e() {
      for (var c = arguments, f = c.length, l = 0; l < f; l++) {
        var a = c[l];
        if ("undefined" !== typeof a && null !== a) return a;
      }
    }
    function g(c, f) {
      b.isMS && !b.svg && f && "undefined" !== typeof f.opacity && (f.filter = "alpha(opacity=" + 100 * f.opacity + ")");
      a(c.style, f);
    }
    function x(c, f) {
      return 1E14 < c ? c : parseFloat(c.toPrecision(f || 14));
    }
    function C(c, f, l) {
      var a = b.getStyle || C;
      if ("width" === f) return f = Math.min(c.offsetWidth, c.scrollWidth), l = c.getBoundingClientRect && c.getBoundingClientRect().width, l < f && l >= f - 1 && (f = Math.floor(l)), Math.max(0, f - (a(c, "padding-left", !0) || 0) - (a(c, "padding-right", !0) || 0));
      if ("height" === f) return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - (a(c, "padding-top", !0) || 0) - (a(c, "padding-bottom", !0) || 0));
      y.getComputedStyle || v(27, !0);
      if (c = y.getComputedStyle(c, void 0)) {
        var d = c.getPropertyValue(f);
        e(l, "opacity" !== f) && (d = E(d));
      }
      return d;
    }
    function r(c, f, l) {
      for (var a in c) Object.hasOwnProperty.call(c, a) && f.call(l || c[a], c[a], a, c);
    }
    function q(c, f, l) {
      function a(f, l) {
        var a = c.removeEventListener || b.removeEventListenerPolyfill;
        a && a.call(c, f, l, !1);
      }
      function d(l) {
        var d;
        if (c.nodeName) {
          if (f) {
            var m = {};
            m[f] = !0;
          } else m = l;
          r(m, function (c, f) {
            if (l[f]) for (d = l[f].length; d--;) a(f, l[f][d].fn);
          });
        }
      }
      var m = "function" === typeof c && c.prototype || c;
      if (Object.hasOwnProperty.call(m, "hcEvents")) {
        var F = m.hcEvents;
        f ? (m = F[f] || [], l ? (F[f] = m.filter(function (c) {
          return l !== c.fn;
        }), a(f, l)) : (d(F), F[f] = [])) : (d(F), delete m.hcEvents);
      }
    }
    function z(c, l, d, m) {
      d = d || {};
      if (f.createEvent && (c.dispatchEvent || c.fireEvent && c !== b)) {
        var F = f.createEvent("Events");
        F.initEvent(l, !0, !0);
        d = a(F, d);
        c.dispatchEvent ? c.dispatchEvent(d) : c.fireEvent(l, d);
      } else if (c.hcEvents) {
        d.target || a(d, {
          preventDefault: function () {
            d.defaultPrevented = !0;
          },
          target: c,
          type: l
        });
        F = [];
        for (var e = c, q = !1; e.hcEvents;) Object.hasOwnProperty.call(e, "hcEvents") && e.hcEvents[l] && (F.length && (q = !0), F.unshift.apply(F, e.hcEvents[l])), e = Object.getPrototypeOf(e);
        q && F.sort(function (c, f) {
          return c.order - f.order;
        });
        F.forEach(function (f) {
          !1 === f.fn.call(c, d) && d.preventDefault();
        });
      }
      m && !d.defaultPrevented && m.call(c, d);
    }
    var m = b.charts,
      f = b.doc,
      y = b.win;
    (v || (v = {})).messages = [];
    Math.easeInOutSine = function (c) {
      return -.5 * (Math.cos(Math.PI * c) - 1);
    };
    var c = Array.prototype.find ? function (c, f) {
      return c.find(f);
    } : function (c, f) {
      var l,
        a = c.length;
      for (l = 0; l < a; l++) if (f(c[l], l)) return c[l];
    };
    r({
      map: "map",
      each: "forEach",
      grep: "filter",
      reduce: "reduce",
      some: "some"
    }, function (c, f) {
      b[f] = function (l) {
        var a;
        v(32, !1, void 0, (a = {}, a["Highcharts." + f] = "use Array." + c, a));
        return Array.prototype[c].apply(l, [].slice.call(arguments, 1));
      };
    });
    var u,
      l = function () {
        var c = Math.random().toString(36).substring(2, 9) + "-",
          f = 0;
        return function () {
          return "highcharts-" + (u ? "" : c) + f++;
        };
      }();
    y.jQuery && (y.jQuery.fn.highcharts = function () {
      var c = [].slice.call(arguments);
      if (this[0]) return c[0] ? (new b[w(c[0]) ? c.shift() : "Chart"](this[0], c[0], c[1]), this) : m[d(this[0], "data-highcharts-chart")];
    });
    c = {
      addEvent: function (c, f, l, a) {
        void 0 === a && (a = {});
        var d = "function" === typeof c && c.prototype || c;
        Object.hasOwnProperty.call(d, "hcEvents") || (d.hcEvents = {});
        d = d.hcEvents;
        b.Point && c instanceof b.Point && c.series && c.series.chart && (c.series.chart.runTrackerClick = !0);
        var m = c.addEventListener || b.addEventListenerPolyfill;
        m && m.call(c, f, l, b.supportsPassiveEvents ? {
          passive: void 0 === a.passive ? -1 !== f.indexOf("touch") : a.passive,
          capture: !1
        } : !1);
        d[f] || (d[f] = []);
        d[f].push({
          fn: l,
          order: "number" === typeof a.order ? a.order : Infinity
        });
        d[f].sort(function (c, f) {
          return c.order - f.order;
        });
        return function () {
          q(c, f, l);
        };
      },
      arrayMax: function (c) {
        for (var f = c.length, l = c[0]; f--;) c[f] > l && (l = c[f]);
        return l;
      },
      arrayMin: function (c) {
        for (var f = c.length, l = c[0]; f--;) c[f] < l && (l = c[f]);
        return l;
      },
      attr: d,
      clamp: function (c, f, l) {
        return c > f ? c < l ? c : l : f;
      },
      cleanRecursively: A,
      clearTimeout: function (c) {
        h(c) && clearTimeout(c);
      },
      correctFloat: x,
      createElement: function (c, l, d, m, e) {
        c = f.createElement(c);
        l && a(c, l);
        e && g(c, {
          padding: "0",
          border: "none",
          margin: "0"
        });
        d && g(c, d);
        m && m.appendChild(c);
        return c;
      },
      css: g,
      defined: h,
      destroyObjectProperties: function (c, f) {
        r(c, function (l, a) {
          l && l !== f && l.destroy && l.destroy();
          delete c[a];
        });
      },
      discardElement: function (c) {
        c && c.parentElement && c.parentElement.removeChild(c);
      },
      erase: function (c, f) {
        for (var l = c.length; l--;) if (c[l] === f) {
          c.splice(l, 1);
          break;
        }
      },
      error: v,
      extend: a,
      extendClass: function (c, f) {
        var l = function () {};
        l.prototype = new c();
        a(l.prototype, f);
        return l;
      },
      find: c,
      fireEvent: z,
      getMagnitude: function (c) {
        return Math.pow(10, Math.floor(Math.log(c) / Math.LN10));
      },
      getNestedProperty: function (c, f) {
        for (c = c.split("."); c.length && h(f);) {
          var l = c.shift();
          if ("undefined" === typeof l || "__proto__" === l) return;
          f = f[l];
          if (!h(f) || "function" === typeof f || "number" === typeof f.nodeType || f === y) return;
        }
        return f;
      },
      getStyle: C,
      inArray: function (c, f, l) {
        v(32, !1, void 0, {
          "Highcharts.inArray": "use Array.indexOf"
        });
        return f.indexOf(c, l);
      },
      isArray: D,
      isClass: t,
      isDOMElement: k,
      isFunction: function (c) {
        return "function" === typeof c;
      },
      isNumber: n,
      isObject: B,
      isString: w,
      keys: function (c) {
        v(32, !1, void 0, {
          "Highcharts.keys": "use Object.keys"
        });
        return Object.keys(c);
      },
      merge: function () {
        var c,
          f = arguments,
          l = {},
          a = function (c, f) {
            "object" !== typeof c && (c = {});
            r(f, function (l, d) {
              "__proto__" !== d && "constructor" !== d && (!B(l, !0) || t(l) || k(l) ? c[d] = f[d] : c[d] = a(c[d] || {}, l));
            });
            return c;
          };
        !0 === f[0] && (l = f[1], f = Array.prototype.slice.call(f, 2));
        var d = f.length;
        for (c = 0; c < d; c++) l = a(l, f[c]);
        return l;
      },
      normalizeTickInterval: function (c, f, l, a, d) {
        var m = c;
        l = e(l, 1);
        var q = c / l;
        f || (f = d ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === a && (1 === l ? f = f.filter(function (c) {
          return 0 === c % 1;
        }) : .1 >= l && (f = [1 / l])));
        for (a = 0; a < f.length && !(m = f[a], d && m * l >= c || !d && q <= (f[a] + (f[a + 1] || f[a])) / 2); a++);
        return m = x(m * l, -Math.round(Math.log(.001) / Math.LN10));
      },
      objectEach: r,
      offset: function (c) {
        var l = f.documentElement;
        c = c.parentElement || c.parentNode ? c.getBoundingClientRect() : {
          top: 0,
          left: 0,
          width: 0,
          height: 0
        };
        return {
          top: c.top + (y.pageYOffset || l.scrollTop) - (l.clientTop || 0),
          left: c.left + (y.pageXOffset || l.scrollLeft) - (l.clientLeft || 0),
          width: c.width,
          height: c.height
        };
      },
      pad: function (c, f, l) {
        return Array((f || 2) + 1 - String(c).replace("-", "").length).join(l || "0") + c;
      },
      pick: e,
      pInt: E,
      relativeLength: function (c, f, l) {
        return /%$/.test(c) ? f * parseFloat(c) / 100 + (l || 0) : parseFloat(c);
      },
      removeEvent: q,
      splat: function (c) {
        return D(c) ? c : [c];
      },
      stableSort: function (c, f) {
        var l = c.length,
          a,
          d;
        for (d = 0; d < l; d++) c[d].safeI = d;
        c.sort(function (c, l) {
          a = f(c, l);
          return 0 === a ? c.safeI - l.safeI : a;
        });
        for (d = 0; d < l; d++) delete c[d].safeI;
      },
      syncTimeout: function (c, f, l) {
        if (0 < f) return setTimeout(c, f, l);
        c.call(0, l);
        return -1;
      },
      timeUnits: {
        millisecond: 1,
        second: 1E3,
        minute: 6E4,
        hour: 36E5,
        day: 864E5,
        week: 6048E5,
        month: 24192E5,
        year: 314496E5
      },
      uniqueKey: l,
      useSerialIds: function (c) {
        return u = e(c, u);
      },
      wrap: function (c, f, l) {
        var a = c[f];
        c[f] = function () {
          var c = Array.prototype.slice.call(arguments),
            f = arguments,
            d = this;
          d.proceed = function () {
            a.apply(d, arguments.length ? arguments : f);
          };
          c.unshift(a);
          c = l.apply(this, c);
          d.proceed = null;
          return c;
        };
      }
    };
    "";
    return c;
  });
  G(b, "Core/Chart/ChartDefaults.js", [], function () {
    return {
      panning: {
        enabled: !1,
        type: "x"
      },
      styledMode: !1,
      borderRadius: 0,
      colorCount: 10,
      defaultSeriesType: "line",
      ignoreHiddenSeries: !0,
      spacing: [10, 10, 15, 10],
      resetZoomButton: {
        theme: {
          zIndex: 6
        },
        position: {
          align: "right",
          x: -10,
          y: 10
        }
      },
      zoomBySingleTouch: !1,
      width: null,
      height: null,
      borderColor: "#335cad",
      backgroundColor: "#ffffff",
      plotBorderColor: "#cccccc"
    };
  });
  G(b, "Core/Color/Color.js", [b["Core/Globals.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = p.isNumber,
      E = p.merge,
      w = p.pInt;
    p = function () {
      function p(v) {
        this.rgba = [NaN, NaN, NaN, NaN];
        this.input = v;
        var k = b.Color;
        if (k && k !== p) return new k(v);
        if (!(this instanceof p)) return new p(v);
        this.init(v);
      }
      p.parse = function (b) {
        return b ? new p(b) : p.None;
      };
      p.prototype.init = function (b) {
        var k;
        if ("object" === typeof b && "undefined" !== typeof b.stops) this.stops = b.stops.map(function (d) {
          return new p(d[1]);
        });else if ("string" === typeof b) {
          this.input = b = p.names[b.toLowerCase()] || b;
          if ("#" === b.charAt(0)) {
            var t = b.length;
            var n = parseInt(b.substr(1), 16);
            7 === t ? k = [(n & 16711680) >> 16, (n & 65280) >> 8, n & 255, 1] : 4 === t && (k = [(n & 3840) >> 4 | (n & 3840) >> 8, (n & 240) >> 4 | n & 240, (n & 15) << 4 | n & 15, 1]);
          }
          if (!k) for (n = p.parsers.length; n-- && !k;) {
            var h = p.parsers[n];
            (t = h.regex.exec(b)) && (k = h.parse(t));
          }
        }
        k && (this.rgba = k);
      };
      p.prototype.get = function (b) {
        var k = this.input,
          t = this.rgba;
        if ("object" === typeof k && "undefined" !== typeof this.stops) {
          var n = E(k);
          n.stops = [].slice.call(n.stops);
          this.stops.forEach(function (h, d) {
            n.stops[d] = [n.stops[d][0], h.get(b)];
          });
          return n;
        }
        return t && v(t[0]) ? "rgb" === b || !b && 1 === t[3] ? "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")" : "a" === b ? "" + t[3] : "rgba(" + t.join(",") + ")" : k;
      };
      p.prototype.brighten = function (b) {
        var k = this.rgba;
        if (this.stops) this.stops.forEach(function (n) {
          n.brighten(b);
        });else if (v(b) && 0 !== b) for (var t = 0; 3 > t; t++) k[t] += w(255 * b), 0 > k[t] && (k[t] = 0), 255 < k[t] && (k[t] = 255);
        return this;
      };
      p.prototype.setOpacity = function (b) {
        this.rgba[3] = b;
        return this;
      };
      p.prototype.tweenTo = function (b, k) {
        var t = this.rgba,
          n = b.rgba;
        if (!v(t[0]) || !v(n[0])) return b.input || "none";
        b = 1 !== n[3] || 1 !== t[3];
        return (b ? "rgba(" : "rgb(") + Math.round(n[0] + (t[0] - n[0]) * (1 - k)) + "," + Math.round(n[1] + (t[1] - n[1]) * (1 - k)) + "," + Math.round(n[2] + (t[2] - n[2]) * (1 - k)) + (b ? "," + (n[3] + (t[3] - n[3]) * (1 - k)) : "") + ")";
      };
      p.names = {
        white: "#ffffff",
        black: "#000000"
      };
      p.parsers = [{
        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        parse: function (b) {
          return [w(b[1]), w(b[2]), w(b[3]), parseFloat(b[4], 10)];
        }
      }, {
        regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
        parse: function (b) {
          return [w(b[1]), w(b[2]), w(b[3]), 1];
        }
      }];
      p.None = new p("");
      return p;
    }();
    "";
    return p;
  });
  G(b, "Core/Color/Palettes.js", [], function () {
    return {
      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ")
    };
  });
  G(b, "Core/Time.js", [b["Core/Globals.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = b.win,
      E = p.defined,
      w = p.error,
      D = p.extend,
      B = p.isObject,
      k = p.merge,
      t = p.objectEach,
      n = p.pad,
      h = p.pick,
      d = p.splat,
      a = p.timeUnits,
      e = b.isSafari && v.Intl && v.Intl.DateTimeFormat.prototype.formatRange,
      g = b.isSafari && v.Intl && !v.Intl.DateTimeFormat.prototype.formatRange;
    p = function () {
      function x(a) {
        this.options = {};
        this.variableTimezone = this.useUTC = !1;
        this.Date = v.Date;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.update(a);
      }
      x.prototype.get = function (a, d) {
        if (this.variableTimezone || this.timezoneOffset) {
          var e = d.getTime(),
            g = e - this.getTimezoneOffset(d);
          d.setTime(g);
          a = d["getUTC" + a]();
          d.setTime(e);
          return a;
        }
        return this.useUTC ? d["getUTC" + a]() : d["get" + a]();
      };
      x.prototype.set = function (a, d, q) {
        if (this.variableTimezone || this.timezoneOffset) {
          if ("Milliseconds" === a || "Seconds" === a || "Minutes" === a && 0 === this.getTimezoneOffset(d) % 36E5) return d["setUTC" + a](q);
          var g = this.getTimezoneOffset(d);
          g = d.getTime() - g;
          d.setTime(g);
          d["setUTC" + a](q);
          a = this.getTimezoneOffset(d);
          g = d.getTime() + a;
          return d.setTime(g);
        }
        return this.useUTC || e && "FullYear" === a ? d["setUTC" + a](q) : d["set" + a](q);
      };
      x.prototype.update = function (a) {
        var d = h(a && a.useUTC, !0);
        this.options = a = k(!0, this.options || {}, a);
        this.Date = a.Date || v.Date || Date;
        this.timezoneOffset = (this.useUTC = d) && a.timezoneOffset;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.variableTimezone = d && !(!a.getTimezoneOffset && !a.timezone);
      };
      x.prototype.makeTime = function (a, d, e, z, m, f) {
        if (this.useUTC) {
          var q = this.Date.UTC.apply(0, arguments);
          var c = this.getTimezoneOffset(q);
          q += c;
          var u = this.getTimezoneOffset(q);
          c !== u ? q += u - c : c - 36E5 !== this.getTimezoneOffset(q - 36E5) || g || (q -= 36E5);
        } else q = new this.Date(a, d, h(e, 1), h(z, 0), h(m, 0), h(f, 0)).getTime();
        return q;
      };
      x.prototype.timezoneOffsetFunction = function () {
        var a = this,
          d = this.options,
          e = d.getTimezoneOffset,
          g = d.moment || v.moment;
        if (!this.useUTC) return function (a) {
          return 6E4 * new Date(a.toString()).getTimezoneOffset();
        };
        if (d.timezone) {
          if (g) return function (a) {
            return 6E4 * -g.tz(a, d.timezone).utcOffset();
          };
          w(25);
        }
        return this.useUTC && e ? function (a) {
          return 6E4 * e(a.valueOf());
        } : function () {
          return 6E4 * (a.timezoneOffset || 0);
        };
      };
      x.prototype.dateFormat = function (a, d, e) {
        if (!E(d) || isNaN(d)) return b.defaultOptions.lang && b.defaultOptions.lang.invalidDate || "";
        a = h(a, "%Y-%m-%d %H:%M:%S");
        var q = this,
          m = new this.Date(d),
          f = this.get("Hours", m),
          g = this.get("Day", m),
          c = this.get("Date", m),
          u = this.get("Month", m),
          l = this.get("FullYear", m),
          r = b.defaultOptions.lang,
          C = r && r.weekdays,
          x = r && r.shortWeekdays;
        m = D({
          a: x ? x[g] : C[g].substr(0, 3),
          A: C[g],
          d: n(c),
          e: n(c, 2, " "),
          w: g,
          b: r.shortMonths[u],
          B: r.months[u],
          m: n(u + 1),
          o: u + 1,
          y: l.toString().substr(2, 2),
          Y: l,
          H: n(f),
          k: f,
          I: n(f % 12 || 12),
          l: f % 12 || 12,
          M: n(this.get("Minutes", m)),
          p: 12 > f ? "AM" : "PM",
          P: 12 > f ? "am" : "pm",
          S: n(m.getSeconds()),
          L: n(Math.floor(d % 1E3), 3)
        }, b.dateFormats);
        t(m, function (c, f) {
          for (; -1 !== a.indexOf("%" + f);) a = a.replace("%" + f, "function" === typeof c ? c.call(q, d) : c);
        });
        return e ? a.substr(0, 1).toUpperCase() + a.substr(1) : a;
      };
      x.prototype.resolveDTLFormat = function (a) {
        return B(a, !0) ? a : (a = d(a), {
          main: a[0],
          from: a[1],
          to: a[2]
        });
      };
      x.prototype.getTimeTicks = function (d, e, q, g) {
        var m = this,
          f = [],
          y = {},
          c = new m.Date(e),
          u = d.unitRange,
          l = d.count || 1,
          z;
        g = h(g, 1);
        if (E(e)) {
          m.set("Milliseconds", c, u >= a.second ? 0 : l * Math.floor(m.get("Milliseconds", c) / l));
          u >= a.second && m.set("Seconds", c, u >= a.minute ? 0 : l * Math.floor(m.get("Seconds", c) / l));
          u >= a.minute && m.set("Minutes", c, u >= a.hour ? 0 : l * Math.floor(m.get("Minutes", c) / l));
          u >= a.hour && m.set("Hours", c, u >= a.day ? 0 : l * Math.floor(m.get("Hours", c) / l));
          u >= a.day && m.set("Date", c, u >= a.month ? 1 : Math.max(1, l * Math.floor(m.get("Date", c) / l)));
          if (u >= a.month) {
            m.set("Month", c, u >= a.year ? 0 : l * Math.floor(m.get("Month", c) / l));
            var r = m.get("FullYear", c);
          }
          u >= a.year && m.set("FullYear", c, r - r % l);
          u === a.week && (r = m.get("Day", c), m.set("Date", c, m.get("Date", c) - r + g + (r < g ? -7 : 0)));
          r = m.get("FullYear", c);
          g = m.get("Month", c);
          var C = m.get("Date", c),
            x = m.get("Hours", c);
          e = c.getTime();
          !m.variableTimezone && m.useUTC || !E(q) || (z = q - e > 4 * a.month || m.getTimezoneOffset(e) !== m.getTimezoneOffset(q));
          e = c.getTime();
          for (c = 1; e < q;) f.push(e), e = u === a.year ? m.makeTime(r + c * l, 0) : u === a.month ? m.makeTime(r, g + c * l) : !z || u !== a.day && u !== a.week ? z && u === a.hour && 1 < l ? m.makeTime(r, g, C, x + c * l) : e + u * l : m.makeTime(r, g, C + c * l * (u === a.day ? 1 : 7)), c++;
          f.push(e);
          u <= a.hour && 1E4 > f.length && f.forEach(function (c) {
            0 === c % 18E5 && "000000000" === m.dateFormat("%H%M%S%L", c) && (y[c] = "day");
          });
        }
        f.info = D(d, {
          higherRanks: y,
          totalRange: u * l
        });
        return f;
      };
      x.prototype.getDateFormat = function (d, e, q, g) {
        var m = this.dateFormat("%m-%d %H:%M:%S.%L", e),
          f = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          },
          y = "millisecond";
        for (c in a) {
          if (d === a.week && +this.dateFormat("%w", e) === q && "00:00:00.000" === m.substr(6)) {
            var c = "week";
            break;
          }
          if (a[c] > d) {
            c = y;
            break;
          }
          if (f[c] && m.substr(f[c]) !== "01-01 00:00:00.000".substr(f[c])) break;
          "week" !== c && (y = c);
        }
        if (c) var u = this.resolveDTLFormat(g[c]).main;
        return u;
      };
      return x;
    }();
    "";
    return p;
  });
  G(b, "Core/DefaultOptions.js", [b["Core/Chart/ChartDefaults.js"], b["Core/Color/Color.js"], b["Core/Globals.js"], b["Core/Color/Palettes.js"], b["Core/Time.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D) {
    p = p.parse;
    var v = D.merge,
      k = {
        colors: E.colors,
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
          loading: "Loading...",
          months: "January February March April May June July August September October November December".split(" "),
          shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
          weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
          decimalPoint: ".",
          numericSymbols: "kMGTPE".split(""),
          resetZoom: "Reset zoom",
          resetZoomTitle: "Reset zoom level 1:1",
          thousandsSep: " "
        },
        global: {},
        time: {
          Date: void 0,
          getTimezoneOffset: void 0,
          timezone: void 0,
          timezoneOffset: 0,
          useUTC: !0
        },
        chart: b,
        title: {
          text: "Chart title",
          align: "center",
          margin: 15,
          widthAdjust: -44
        },
        subtitle: {
          text: "",
          align: "center",
          widthAdjust: -44
        },
        caption: {
          margin: 15,
          text: "",
          align: "left",
          verticalAlign: "bottom"
        },
        plotOptions: {},
        labels: {
          style: {
            position: "absolute",
            color: "#333333"
          }
        },
        legend: {
          enabled: !0,
          align: "center",
          alignColumns: !0,
          className: "highcharts-no-tooltip",
          layout: "horizontal",
          labelFormatter: function () {
            return this.name;
          },
          borderColor: "#999999",
          borderRadius: 0,
          navigation: {
            activeColor: "#003399",
            inactiveColor: "#cccccc"
          },
          itemStyle: {
            color: "#333333",
            cursor: "pointer",
            fontSize: "12px",
            fontWeight: "bold",
            textOverflow: "ellipsis"
          },
          itemHoverStyle: {
            color: "#000000"
          },
          itemHiddenStyle: {
            color: "#cccccc"
          },
          shadow: !1,
          itemCheckboxStyle: {
            position: "absolute",
            width: "13px",
            height: "13px"
          },
          squareSymbol: !0,
          symbolPadding: 5,
          verticalAlign: "bottom",
          x: 0,
          y: 0,
          title: {
            style: {
              fontWeight: "bold"
            }
          }
        },
        loading: {
          labelStyle: {
            fontWeight: "bold",
            position: "relative",
            top: "45%"
          },
          style: {
            position: "absolute",
            backgroundColor: "#ffffff",
            opacity: .5,
            textAlign: "center"
          }
        },
        tooltip: {
          enabled: !0,
          animation: A.svg,
          borderRadius: 3,
          dateTimeLabelFormats: {
            millisecond: "%A, %b %e, %H:%M:%S.%L",
            second: "%A, %b %e, %H:%M:%S",
            minute: "%A, %b %e, %H:%M",
            hour: "%A, %b %e, %H:%M",
            day: "%A, %b %e, %Y",
            week: "Week from %A, %b %e, %Y",
            month: "%B %Y",
            year: "%Y"
          },
          footerFormat: "",
          headerShape: "callout",
          hideDelay: 500,
          padding: 8,
          shape: "callout",
          shared: !1,
          snap: A.isTouchDevice ? 25 : 10,
          headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
          pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
          backgroundColor: p("#f7f7f7").setOpacity(.85).get(),
          borderWidth: 1,
          shadow: !0,
          stickOnContact: !1,
          style: {
            color: "#333333",
            cursor: "default",
            fontSize: "12px",
            whiteSpace: "nowrap"
          },
          useHTML: !1
        },
        credits: {
          enabled: !0,
          href: "https://www.highcharts.com?credits",
          position: {
            align: "right",
            x: -10,
            verticalAlign: "bottom",
            y: -5
          },
          style: {
            cursor: "pointer",
            color: "#999999",
            fontSize: "9px"
          },
          text: "Highcharts.com"
        }
      };
    k.chart.styledMode = !1;
    "";
    var t = new w(v(k.global, k.time));
    b = {
      defaultOptions: k,
      defaultTime: t,
      getOptions: function () {
        return k;
      },
      setOptions: function (n) {
        v(!0, k, n);
        if (n.time || n.global) A.time ? A.time.update(v(k.global, k.time, n.global, n.time)) : A.time = t;
        return k;
      }
    };
    "";
    return b;
  });
  G(b, "Core/Animation/Fx.js", [b["Core/Color/Color.js"], b["Core/Globals.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = b.parse,
      w = p.win,
      D = A.isNumber,
      B = A.objectEach;
    return function () {
      function k(k, n, h) {
        this.pos = NaN;
        this.options = n;
        this.elem = k;
        this.prop = h;
      }
      k.prototype.dSetter = function () {
        var k = this.paths,
          n = k && k[0];
        k = k && k[1];
        var h = this.now || 0,
          d = [];
        if (1 !== h && n && k) {
          if (n.length === k.length && 1 > h) for (var a = 0; a < k.length; a++) {
            for (var e = n[a], g = k[a], x = [], C = 0; C < g.length; C++) {
              var r = e[C],
                q = g[C];
              D(r) && D(q) && ("A" !== g[0] || 4 !== C && 5 !== C) ? x[C] = r + h * (q - r) : x[C] = q;
            }
            d.push(x);
          } else d = k;
        } else d = this.toD || [];
        this.elem.attr("d", d, void 0, !0);
      };
      k.prototype.update = function () {
        var k = this.elem,
          n = this.prop,
          h = this.now,
          d = this.options.step;
        if (this[n + "Setter"]) this[n + "Setter"]();else k.attr ? k.element && k.attr(n, h, null, !0) : k.style[n] = h + this.unit;
        d && d.call(k, h, this);
      };
      k.prototype.run = function (b, n, h) {
        var d = this,
          a = d.options,
          e = function (a) {
            return e.stopped ? !1 : d.step(a);
          },
          g = w.requestAnimationFrame || function (a) {
            setTimeout(a, 13);
          },
          x = function () {
            for (var a = 0; a < k.timers.length; a++) k.timers[a]() || k.timers.splice(a--, 1);
            k.timers.length && g(x);
          };
        b !== n || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = b, this.end = n, this.unit = h, this.now = this.start, this.pos = 0, e.elem = this.elem, e.prop = this.prop, e() && 1 === k.timers.push(e) && g(x)) : (delete a.curAnim[this.prop], a.complete && 0 === Object.keys(a.curAnim).length && a.complete.call(this.elem));
      };
      k.prototype.step = function (k) {
        var n = +new Date(),
          h = this.options,
          d = this.elem,
          a = h.complete,
          e = h.duration,
          g = h.curAnim;
        if (d.attr && !d.element) k = !1;else if (k || n >= e + this.startTime) {
          this.now = this.end;
          this.pos = 1;
          this.update();
          var x = g[this.prop] = !0;
          B(g, function (a) {
            !0 !== a && (x = !1);
          });
          x && a && a.call(d);
          k = !1;
        } else this.pos = h.easing((n - this.startTime) / e), this.now = this.start + (this.end - this.start) * this.pos, this.update(), k = !0;
        return k;
      };
      k.prototype.initPath = function (k, n, h) {
        function d(a, f) {
          for (; a.length < z;) {
            var d = a[0],
              c = f[z - a.length];
            c && "M" === d[0] && (a[0] = "C" === c[0] ? ["C", d[1], d[2], d[1], d[2], d[1], d[2]] : ["L", d[1], d[2]]);
            a.unshift(d);
            x && (d = a.pop(), a.push(a[a.length - 1], d));
          }
        }
        function a(a, f) {
          for (; a.length < z;) if (f = a[Math.floor(a.length / C) - 1].slice(), "C" === f[0] && (f[1] = f[5], f[2] = f[6]), x) {
            var d = a[Math.floor(a.length / C)].slice();
            a.splice(a.length / 2, 0, f, d);
          } else a.push(f);
        }
        var e = k.startX,
          g = k.endX;
        h = h.slice();
        var x = k.isArea,
          C = x ? 2 : 1;
        n = n && n.slice();
        if (!n) return [h, h];
        if (e && g && g.length) {
          for (k = 0; k < e.length; k++) if (e[k] === g[0]) {
            var r = k;
            break;
          } else if (e[0] === g[g.length - e.length + k]) {
            r = k;
            var q = !0;
            break;
          } else if (e[e.length - 1] === g[g.length - e.length + k]) {
            r = e.length - k;
            break;
          }
          "undefined" === typeof r && (n = []);
        }
        if (n.length && D(r)) {
          var z = h.length + r * C;
          q ? (d(n, h), a(h, n)) : (d(h, n), a(n, h));
        }
        return [n, h];
      };
      k.prototype.fillSetter = function () {
        k.prototype.strokeSetter.apply(this, arguments);
      };
      k.prototype.strokeSetter = function () {
        this.elem.attr(this.prop, v(this.start).tweenTo(v(this.end), this.pos), void 0, !0);
      };
      k.timers = [];
      return k;
    }();
  });
  G(b, "Core/Animation/AnimationUtilities.js", [b["Core/Animation/Fx.js"], b["Core/Utilities.js"]], function (b, p) {
    function v(a) {
      return t(a) ? n({
        duration: 500,
        defer: 0
      }, a) : {
        duration: a ? 500 : 0,
        defer: 0
      };
    }
    function E(a, d) {
      for (var e = b.timers.length; e--;) b.timers[e].elem !== a || d && d !== b.timers[e].prop || (b.timers[e].stopped = !0);
    }
    var w = p.defined,
      D = p.getStyle,
      B = p.isArray,
      k = p.isNumber,
      t = p.isObject,
      n = p.merge,
      h = p.objectEach,
      d = p.pick;
    return {
      animate: function (a, d, g) {
        var e,
          C = "",
          r,
          q;
        if (!t(g)) {
          var z = arguments;
          g = {
            duration: z[2],
            easing: z[3],
            complete: z[4]
          };
        }
        k(g.duration) || (g.duration = 400);
        g.easing = "function" === typeof g.easing ? g.easing : Math[g.easing] || Math.easeInOutSine;
        g.curAnim = n(d);
        h(d, function (m, f) {
          E(a, f);
          q = new b(a, g, f);
          r = void 0;
          "d" === f && B(d.d) ? (q.paths = q.initPath(a, a.pathArray, d.d), q.toD = d.d, e = 0, r = 1) : a.attr ? e = a.attr(f) : (e = parseFloat(D(a, f)) || 0, "opacity" !== f && (C = "px"));
          r || (r = m);
          "string" === typeof r && r.match("px") && (r = r.replace(/px/g, ""));
          q.run(e, r, C);
        });
      },
      animObject: v,
      getDeferredAnimation: function (a, d, g) {
        var e = v(d),
          h = 0,
          r = 0;
        (g ? [g] : a.series).forEach(function (a) {
          a = v(a.options.animation);
          h = d && w(d.defer) ? e.defer : Math.max(h, a.duration + a.defer);
          r = Math.min(e.duration, a.duration);
        });
        a.renderer.forExport && (h = 0);
        return {
          defer: Math.max(0, h - r),
          duration: Math.min(h, r)
        };
      },
      setAnimation: function (a, e) {
        e.renderer.globalAnimation = d(a, e.options.chart.animation, !0);
      },
      stop: E
    };
  });
  G(b, "Core/Renderer/HTML/AST.js", [b["Core/Globals.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = b.SVG_NS,
      E = p.attr,
      w = p.createElement,
      D = p.error,
      B = p.isFunction,
      k = p.isString,
      t = p.objectEach,
      n = p.splat,
      h = (p = b.win.trustedTypes) && B(p.createPolicy) && p.createPolicy("highcharts", {
        createHTML: function (a) {
          return a;
        }
      }),
      d = h ? h.createHTML("") : "";
    try {
      var a = !!new DOMParser().parseFromString(d, "text/html");
    } catch (e) {
      a = !1;
    }
    B = function () {
      function e(a) {
        this.nodes = "string" === typeof a ? this.parseMarkup(a) : a;
      }
      e.filterUserAttributes = function (a) {
        t(a, function (d, g) {
          var r = !0;
          -1 === e.allowedAttributes.indexOf(g) && (r = !1);
          -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(g) && (r = k(d) && e.allowedReferences.some(function (a) {
            return 0 === d.indexOf(a);
          }));
          r || (D("Highcharts warning: Invalid attribute '" + g + "' in config"), delete a[g]);
        });
        return a;
      };
      e.setElementHTML = function (a, d) {
        a.innerHTML = e.emptyHTML;
        d && new e(d).addToDOM(a);
      };
      e.prototype.addToDOM = function (a) {
        function d(a, g) {
          var q;
          n(a).forEach(function (a) {
            var m = a.tagName,
              f = a.textContent ? b.doc.createTextNode(a.textContent) : void 0;
            if (m) if ("#text" === m) var y = f;else if (-1 !== e.allowedTags.indexOf(m)) {
              m = b.doc.createElementNS("svg" === m ? v : g.namespaceURI || v, m);
              var c = a.attributes || {};
              t(a, function (a, f) {
                "tagName" !== f && "attributes" !== f && "children" !== f && "textContent" !== f && (c[f] = a);
              });
              E(m, e.filterUserAttributes(c));
              f && m.appendChild(f);
              d(a.children || [], m);
              y = m;
            } else D("Highcharts warning: Invalid tagName " + m + " in config");
            y && g.appendChild(y);
            q = y;
          });
          return q;
        }
        return d(this.nodes, a);
      };
      e.prototype.parseMarkup = function (d) {
        var e = [];
        d = d.trim();
        if (a) d = new DOMParser().parseFromString(h ? h.createHTML(d) : d, "text/html");else {
          var g = w("div");
          g.innerHTML = d;
          d = {
            body: g
          };
        }
        var r = function (a, d) {
          var m = a.nodeName.toLowerCase(),
            f = {
              tagName: m
            };
          "#text" === m && (f.textContent = a.textContent || "");
          if (m = a.attributes) {
            var e = {};
            [].forEach.call(m, function (c) {
              e[c.name] = c.value;
            });
            f.attributes = e;
          }
          if (a.childNodes.length) {
            var c = [];
            [].forEach.call(a.childNodes, function (a) {
              r(a, c);
            });
            c.length && (f.children = c);
          }
          d.push(f);
        };
        [].forEach.call(d.body.childNodes, function (a) {
          return r(a, e);
        });
        return e;
      };
      e.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex".split(" ");
      e.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
      e.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
      e.emptyHTML = d;
      return e;
    }();
    "";
    return B;
  });
  G(b, "Core/FormatUtilities.js", [b["Core/DefaultOptions.js"], b["Core/Utilities.js"]], function (b, p) {
    function v(n, h, d, a) {
      n = +n || 0;
      h = +h;
      var e = E.lang,
        g = (n.toString().split(".")[1] || "").split("e")[0].length,
        x = n.toString().split("e"),
        C = h;
      if (-1 === h) h = Math.min(g, 20);else if (!B(h)) h = 2;else if (h && x[1] && 0 > x[1]) {
        var r = h + +x[1];
        0 <= r ? (x[0] = (+x[0]).toExponential(r).split("e")[0], h = r) : (x[0] = x[0].split(".")[0] || 0, n = 20 > h ? (x[0] * Math.pow(10, x[1])).toFixed(h) : 0, x[1] = 0);
      }
      r = (Math.abs(x[1] ? x[0] : n) + Math.pow(10, -Math.max(h, g) - 1)).toFixed(h);
      g = String(t(r));
      var q = 3 < g.length ? g.length % 3 : 0;
      d = k(d, e.decimalPoint);
      a = k(a, e.thousandsSep);
      n = (0 > n ? "-" : "") + (q ? g.substr(0, q) + a : "");
      n = 0 > +x[1] && !C ? "0" : n + g.substr(q).replace(/(\d{3})(?=\d)/g, "$1" + a);
      h && (n += d + r.slice(-h));
      x[1] && 0 !== +n && (n += "e" + x[1]);
      return n;
    }
    var E = b.defaultOptions,
      w = b.defaultTime,
      D = p.getNestedProperty,
      B = p.isNumber,
      k = p.pick,
      t = p.pInt;
    return {
      dateFormat: function (k, h, d) {
        return w.dateFormat(k, h, d);
      },
      format: function (k, h, d) {
        var a = "{",
          e = !1,
          g = /f$/,
          x = /\.([0-9])/,
          C = E.lang,
          r = d && d.time || w;
        d = d && d.numberFormatter || v;
        for (var q = []; k;) {
          var z = k.indexOf(a);
          if (-1 === z) break;
          var m = k.slice(0, z);
          if (e) {
            m = m.split(":");
            a = D(m.shift() || "", h);
            if (m.length && "number" === typeof a) if (m = m.join(":"), g.test(m)) {
              var f = parseInt((m.match(x) || ["", "-1"])[1], 10);
              null !== a && (a = d(a, f, C.decimalPoint, -1 < m.indexOf(",") ? C.thousandsSep : ""));
            } else a = r.dateFormat(m, a);
            q.push(a);
          } else q.push(m);
          k = k.slice(z + 1);
          a = (e = !e) ? "}" : "{";
        }
        q.push(k);
        return q.join("");
      },
      numberFormat: v
    };
  });
  G(b, "Core/Renderer/RendererUtilities.js", [b["Core/Utilities.js"]], function (b) {
    var v = b.clamp,
      A = b.pick,
      E = b.stableSort,
      w;
    (function (b) {
      function p(k, b, n) {
        var h = k,
          d = h.reducedLen || b,
          a = function (a, d) {
            return (d.rank || 0) - (a.rank || 0);
          },
          e = function (a, d) {
            return a.target - d.target;
          },
          g,
          x = !0,
          C = [],
          r = 0;
        for (g = k.length; g--;) r += k[g].size;
        if (r > d) {
          E(k, a);
          for (r = g = 0; r <= d;) r += k[g].size, g++;
          C = k.splice(g - 1, k.length);
        }
        E(k, e);
        for (k = k.map(function (a) {
          return {
            size: a.size,
            targets: [a.target],
            align: A(a.align, .5)
          };
        }); x;) {
          for (g = k.length; g--;) d = k[g], a = (Math.min.apply(0, d.targets) + Math.max.apply(0, d.targets)) / 2, d.pos = v(a - d.size * d.align, 0, b - d.size);
          g = k.length;
          for (x = !1; g--;) 0 < g && k[g - 1].pos + k[g - 1].size > k[g].pos && (k[g - 1].size += k[g].size, k[g - 1].targets = k[g - 1].targets.concat(k[g].targets), k[g - 1].align = .5, k[g - 1].pos + k[g - 1].size > b && (k[g - 1].pos = b - k[g - 1].size), k.splice(g, 1), x = !0);
        }
        h.push.apply(h, C);
        g = 0;
        k.some(function (a) {
          var d = 0;
          return (a.targets || []).some(function () {
            h[g].pos = a.pos + d;
            if ("undefined" !== typeof n && Math.abs(h[g].pos - h[g].target) > n) return h.slice(0, g + 1).forEach(function (a) {
              return delete a.pos;
            }), h.reducedLen = (h.reducedLen || b) - .1 * b, h.reducedLen > .1 * b && p(h, b, n), !0;
            d += h[g].size;
            g++;
            return !1;
          });
        });
        E(h, e);
        return h;
      }
      b.distribute = p;
    })(w || (w = {}));
    return w;
  });
  G(b, "Core/Renderer/SVG/SVGElement.js", [b["Core/Animation/AnimationUtilities.js"], b["Core/Renderer/HTML/AST.js"], b["Core/Color/Color.js"], b["Core/Globals.js"], b["Core/Utilities.js"]], function (b, p, A, E, w) {
    var v = b.animate,
      B = b.animObject,
      k = b.stop,
      t = E.deg2rad,
      n = E.doc,
      h = E.noop,
      d = E.svg,
      a = E.SVG_NS,
      e = E.win,
      g = w.addEvent,
      x = w.attr,
      C = w.createElement,
      r = w.css,
      q = w.defined,
      z = w.erase,
      m = w.extend,
      f = w.fireEvent,
      y = w.isArray,
      c = w.isFunction,
      u = w.isNumber,
      l = w.isString,
      F = w.merge,
      K = w.objectEach,
      H = w.pick,
      I = w.pInt,
      Z = w.syncTimeout,
      Q = w.uniqueKey;
    b = function () {
      function b() {
        this.element = void 0;
        this.onEvents = {};
        this.opacity = 1;
        this.renderer = void 0;
        this.SVG_NS = a;
        this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
      }
      b.prototype._defaultGetter = function (c) {
        c = H(this[c + "Value"], this[c], this.element ? this.element.getAttribute(c) : null, 0);
        /^[\-0-9\.]+$/.test(c) && (c = parseFloat(c));
        return c;
      };
      b.prototype._defaultSetter = function (c, a, f) {
        f.setAttribute(a, c);
      };
      b.prototype.add = function (c) {
        var a = this.renderer,
          f = this.element;
        c && (this.parentGroup = c);
        this.parentInverted = c && c.inverted;
        "undefined" !== typeof this.textStr && "text" === this.element.nodeName && a.buildText(this);
        this.added = !0;
        if (!c || c.handleZ || this.zIndex) var d = this.zIndexSetter();
        d || (c ? c.element : a.box).appendChild(f);
        if (this.onAdd) this.onAdd();
        return this;
      };
      b.prototype.addClass = function (c, a) {
        var f = a ? "" : this.attr("class") || "";
        c = (c || "").split(/ /g).reduce(function (c, a) {
          -1 === f.indexOf(a) && c.push(a);
          return c;
        }, f ? [f] : []).join(" ");
        c !== f && this.attr("class", c);
        return this;
      };
      b.prototype.afterSetters = function () {
        this.doTransform && (this.updateTransform(), this.doTransform = !1);
      };
      b.prototype.align = function (c, a, f) {
        var d = {},
          e = this.renderer,
          m = e.alignedObjects,
          g,
          q,
          u;
        if (c) {
          if (this.alignOptions = c, this.alignByTranslate = a, !f || l(f)) this.alignTo = g = f || "renderer", z(m, this), m.push(this), f = void 0;
        } else c = this.alignOptions, a = this.alignByTranslate, g = this.alignTo;
        f = H(f, e[g], "scrollablePlotBox" === g ? e.plotBox : void 0, e);
        g = c.align;
        var y = c.verticalAlign;
        e = (f.x || 0) + (c.x || 0);
        m = (f.y || 0) + (c.y || 0);
        "right" === g ? q = 1 : "center" === g && (q = 2);
        q && (e += (f.width - (c.width || 0)) / q);
        d[a ? "translateX" : "x"] = Math.round(e);
        "bottom" === y ? u = 1 : "middle" === y && (u = 2);
        u && (m += (f.height - (c.height || 0)) / u);
        d[a ? "translateY" : "y"] = Math.round(m);
        this[this.placed ? "animate" : "attr"](d);
        this.placed = !0;
        this.alignAttr = d;
        return this;
      };
      b.prototype.alignSetter = function (c) {
        var a = {
          left: "start",
          center: "middle",
          right: "end"
        };
        a[c] && (this.alignValue = c, this.element.setAttribute("text-anchor", a[c]));
      };
      b.prototype.animate = function (c, a, f) {
        var d = this,
          l = B(H(a, this.renderer.globalAnimation, !0));
        a = l.defer;
        H(n.hidden, n.msHidden, n.webkitHidden, !1) && (l.duration = 0);
        0 !== l.duration ? (f && (l.complete = f), Z(function () {
          d.element && v(d, c, l);
        }, a)) : (this.attr(c, void 0, f), K(c, function (c, a) {
          l.step && l.step.call(this, c, {
            prop: a,
            pos: 1,
            elem: this
          });
        }, this));
        return this;
      };
      b.prototype.applyTextOutline = function (c) {
        var f = this.element;
        -1 !== c.indexOf("contrast") && (c = c.replace(/contrast/g, this.renderer.getContrast(f.style.fill)));
        var d = c.split(" ");
        c = d[d.length - 1];
        if ((d = d[0]) && "none" !== d && E.svg) {
          this.fakeTS = !0;
          this.ySetter = this.xSetter;
          d = d.replace(/(^[\d\.]+)(.*?)$/g, function (c, a, f) {
            return 2 * Number(a) + f;
          });
          this.removeTextOutline();
          var l = n.createElementNS(a, "tspan");
          x(l, {
            "class": "highcharts-text-outline",
            fill: c,
            stroke: c,
            "stroke-width": d,
            "stroke-linejoin": "round"
          });
          [].forEach.call(f.childNodes, function (c) {
            var a = c.cloneNode(!0);
            a.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (c) {
              return a.removeAttribute(c);
            });
            l.appendChild(a);
          });
          var e = n.createElementNS(a, "tspan");
          e.textContent = "\u200b";
          ["x", "y"].forEach(function (c) {
            var a = f.getAttribute(c);
            a && e.setAttribute(c, a);
          });
          l.appendChild(e);
          f.insertBefore(l, f.firstChild);
        }
      };
      b.prototype.attr = function (c, a, f, d) {
        var l = this.element,
          e = this.symbolCustomAttribs,
          m,
          g = this,
          q,
          u;
        if ("string" === typeof c && "undefined" !== typeof a) {
          var y = c;
          c = {};
          c[y] = a;
        }
        "string" === typeof c ? g = (this[c + "Getter"] || this._defaultGetter).call(this, c, l) : (K(c, function (a, f) {
          q = !1;
          d || k(this, f);
          this.symbolName && -1 !== e.indexOf(f) && (m || (this.symbolAttr(c), m = !0), q = !0);
          !this.rotation || "x" !== f && "y" !== f || (this.doTransform = !0);
          q || (u = this[f + "Setter"] || this._defaultSetter, u.call(this, a, f, l), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(f) && this.updateShadows(f, a, u));
        }, this), this.afterSetters());
        f && f.call(this);
        return g;
      };
      b.prototype.clip = function (c) {
        return this.attr("clip-path", c ? "url(" + this.renderer.url + "#" + c.id + ")" : "none");
      };
      b.prototype.crisp = function (c, a) {
        a = a || c.strokeWidth || 0;
        var f = Math.round(a) % 2 / 2;
        c.x = Math.floor(c.x || this.x || 0) + f;
        c.y = Math.floor(c.y || this.y || 0) + f;
        c.width = Math.floor((c.width || this.width || 0) - 2 * f);
        c.height = Math.floor((c.height || this.height || 0) - 2 * f);
        q(c.strokeWidth) && (c.strokeWidth = a);
        return c;
      };
      b.prototype.complexColor = function (c, a, d) {
        var l = this.renderer,
          e,
          m,
          g,
          u,
          r,
          h,
          b,
          da,
          z,
          k,
          x = [],
          C;
        f(this.renderer, "complexColor", {
          args: arguments
        }, function () {
          c.radialGradient ? m = "radialGradient" : c.linearGradient && (m = "linearGradient");
          if (m) {
            g = c[m];
            r = l.gradients;
            h = c.stops;
            z = d.radialReference;
            y(g) && (c[m] = g = {
              x1: g[0],
              y1: g[1],
              x2: g[2],
              y2: g[3],
              gradientUnits: "userSpaceOnUse"
            });
            "radialGradient" === m && z && !q(g.gradientUnits) && (u = g, g = F(g, l.getRadialAttr(z, u), {
              gradientUnits: "userSpaceOnUse"
            }));
            K(g, function (c, a) {
              "id" !== a && x.push(a, c);
            });
            K(h, function (c) {
              x.push(c);
            });
            x = x.join(",");
            if (r[x]) k = r[x].attr("id");else {
              g.id = k = Q();
              var f = r[x] = l.createElement(m).attr(g).add(l.defs);
              f.radAttr = u;
              f.stops = [];
              h.forEach(function (c) {
                0 === c[1].indexOf("rgba") ? (e = A.parse(c[1]), b = e.get("rgb"), da = e.get("a")) : (b = c[1], da = 1);
                c = l.createElement("stop").attr({
                  offset: c[0],
                  "stop-color": b,
                  "stop-opacity": da
                }).add(f);
                f.stops.push(c);
              });
            }
            C = "url(" + l.url + "#" + k + ")";
            d.setAttribute(a, C);
            d.gradient = x;
            c.toString = function () {
              return C;
            };
          }
        });
      };
      b.prototype.css = function (c) {
        var a = this.styles,
          f = {},
          l = this.element,
          e = ["textOutline", "textOverflow", "width"],
          g = "",
          q = !a;
        c && c.color && (c.fill = c.color);
        a && K(c, function (c, d) {
          a && a[d] !== c && (f[d] = c, q = !0);
        });
        if (q) {
          a && (c = m(a, f));
          if (c) if (null === c.width || "auto" === c.width) delete this.textWidth;else if ("text" === l.nodeName.toLowerCase() && c.width) var u = this.textWidth = I(c.width);
          this.styles = c;
          u && !d && this.renderer.forExport && delete c.width;
          if (l.namespaceURI === this.SVG_NS) {
            var y = function (c, a) {
              return "-" + a.toLowerCase();
            };
            K(c, function (c, a) {
              -1 === e.indexOf(a) && (g += a.replace(/([A-Z])/g, y) + ":" + c + ";");
            });
            g && x(l, "style", g);
          } else r(l, c);
          this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), c && c.textOutline && this.applyTextOutline(c.textOutline));
        }
        return this;
      };
      b.prototype.dashstyleSetter = function (c) {
        var a = this["stroke-width"];
        "inherit" === a && (a = 1);
        if (c = c && c.toLowerCase()) {
          var f = c.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
          for (c = f.length; c--;) f[c] = "" + I(f[c]) * H(a, NaN);
          c = f.join(",").replace(/NaN/g, "none");
          this.element.setAttribute("stroke-dasharray", c);
        }
      };
      b.prototype.destroy = function () {
        var c = this,
          a = c.element || {},
          f = c.renderer,
          d = a.ownerSVGElement,
          l = f.isSVG && "SPAN" === a.nodeName && c.parentGroup || void 0;
        a.onclick = a.onmouseout = a.onmouseover = a.onmousemove = a.point = null;
        k(c);
        if (c.clipPath && d) {
          var e = c.clipPath;
          [].forEach.call(d.querySelectorAll("[clip-path],[CLIP-PATH]"), function (c) {
            -1 < c.getAttribute("clip-path").indexOf(e.element.id) && c.removeAttribute("clip-path");
          });
          c.clipPath = e.destroy();
        }
        if (c.stops) {
          for (d = 0; d < c.stops.length; d++) c.stops[d].destroy();
          c.stops.length = 0;
          c.stops = void 0;
        }
        c.safeRemoveChild(a);
        for (f.styledMode || c.destroyShadows(); l && l.div && 0 === l.div.childNodes.length;) a = l.parentGroup, c.safeRemoveChild(l.div), delete l.div, l = a;
        c.alignTo && z(f.alignedObjects, c);
        K(c, function (a, f) {
          c[f] && c[f].parentGroup === c && c[f].destroy && c[f].destroy();
          delete c[f];
        });
      };
      b.prototype.destroyShadows = function () {
        (this.shadows || []).forEach(function (c) {
          this.safeRemoveChild(c);
        }, this);
        this.shadows = void 0;
      };
      b.prototype.destroyTextPath = function (c, a) {
        var f = c.getElementsByTagName("text")[0];
        if (f) {
          if (f.removeAttribute("dx"), f.removeAttribute("dy"), a.element.setAttribute("id", ""), this.textPathWrapper && f.getElementsByTagName("textPath").length) {
            for (c = this.textPathWrapper.element.childNodes; c.length;) f.appendChild(c[0]);
            f.removeChild(this.textPathWrapper.element);
          }
        } else if (c.getAttribute("dx") || c.getAttribute("dy")) c.removeAttribute("dx"), c.removeAttribute("dy");
        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
      };
      b.prototype.dSetter = function (c, a, f) {
        y(c) && ("string" === typeof c[0] && (c = this.renderer.pathToSegments(c)), this.pathArray = c, c = c.reduce(function (c, a, f) {
          return a && a.join ? (f ? c + " " : "") + a.join(" ") : (a || "").toString();
        }, ""));
        /(NaN| {2}|^$)/.test(c) && (c = "M 0 0");
        this[a] !== c && (f.setAttribute(a, c), this[a] = c);
      };
      b.prototype.fadeOut = function (c) {
        var a = this;
        a.animate({
          opacity: 0
        }, {
          duration: H(c, 150),
          complete: function () {
            a.attr({
              y: -9999
            }).hide();
          }
        });
      };
      b.prototype.fillSetter = function (c, a, f) {
        "string" === typeof c ? f.setAttribute(a, c) : c && this.complexColor(c, a, f);
      };
      b.prototype.getBBox = function (a, f) {
        var d = this.renderer,
          l = this.element,
          e = this.styles,
          g = this.textStr,
          u = d.cache,
          y = d.cacheKeys,
          h = l.namespaceURI === this.SVG_NS;
        f = H(f, this.rotation, 0);
        var z = d.styledMode ? l && b.prototype.getStyle.call(l, "font-size") : e && e.fontSize,
          k;
        if (q(g)) {
          var F = g.toString();
          -1 === F.indexOf("<") && (F = F.replace(/[0-9]/g, "0"));
          F += ["", f, z, this.textWidth, e && e.textOverflow, e && e.fontWeight].join();
        }
        F && !a && (k = u[F]);
        if (!k) {
          if (h || d.forExport) {
            try {
              var x = this.fakeTS && function (c) {
                var a = l.querySelector(".highcharts-text-outline");
                a && r(a, {
                  display: c
                });
              };
              c(x) && x("none");
              k = l.getBBox ? m({}, l.getBBox()) : {
                width: l.offsetWidth,
                height: l.offsetHeight
              };
              c(x) && x("");
            } catch (V) {
              "";
            }
            if (!k || 0 > k.width) k = {
              width: 0,
              height: 0
            };
          } else k = this.htmlGetBBox();
          d.isSVG && (a = k.width, d = k.height, h && (k.height = d = {
            "11px,17": 14,
            "13px,20": 16
          }[(z || "") + "," + Math.round(d)] || d), f && (h = f * t, k.width = Math.abs(d * Math.sin(h)) + Math.abs(a * Math.cos(h)), k.height = Math.abs(d * Math.cos(h)) + Math.abs(a * Math.sin(h))));
          if (F && ("" === g || 0 < k.height)) {
            for (; 250 < y.length;) delete u[y.shift()];
            u[F] || y.push(F);
            u[F] = k;
          }
        }
        return k;
      };
      b.prototype.getStyle = function (c) {
        return e.getComputedStyle(this.element || this, "").getPropertyValue(c);
      };
      b.prototype.hasClass = function (c) {
        return -1 !== ("" + this.attr("class")).split(" ").indexOf(c);
      };
      b.prototype.hide = function (c) {
        c ? this.attr({
          y: -9999
        }) : this.attr({
          visibility: "hidden"
        });
        return this;
      };
      b.prototype.htmlGetBBox = function () {
        return {
          height: 0,
          width: 0,
          x: 0,
          y: 0
        };
      };
      b.prototype.init = function (c, a) {
        this.element = "span" === a ? C(a) : n.createElementNS(this.SVG_NS, a);
        this.renderer = c;
        f(this, "afterInit");
      };
      b.prototype.invert = function (c) {
        this.inverted = c;
        this.updateTransform();
        return this;
      };
      b.prototype.on = function (c, a) {
        var f = this.onEvents;
        if (f[c]) f[c]();
        f[c] = g(this.element, c, a);
        return this;
      };
      b.prototype.opacitySetter = function (c, a, f) {
        this.opacity = c = Number(Number(c).toFixed(3));
        f.setAttribute(a, c);
      };
      b.prototype.removeClass = function (c) {
        return this.attr("class", ("" + this.attr("class")).replace(l(c) ? new RegExp("(^| )" + c + "( |$)") : c, " ").replace(/ +/g, " ").trim());
      };
      b.prototype.removeTextOutline = function () {
        var c = this.element.querySelector("tspan.highcharts-text-outline");
        c && this.safeRemoveChild(c);
      };
      b.prototype.safeRemoveChild = function (c) {
        var a = c.parentNode;
        a && a.removeChild(c);
      };
      b.prototype.setRadialReference = function (c) {
        var a = this.element.gradient && this.renderer.gradients[this.element.gradient];
        this.element.radialReference = c;
        a && a.radAttr && a.animate(this.renderer.getRadialAttr(c, a.radAttr));
        return this;
      };
      b.prototype.setTextPath = function (c, a) {
        var f = this.element,
          d = this.text ? this.text.element : f,
          l = {
            textAnchor: "text-anchor"
          },
          m = !1,
          g = this.textPathWrapper,
          y = !g;
        a = F(!0, {
          enabled: !0,
          attributes: {
            dy: -5,
            startOffset: "50%",
            textAnchor: "middle"
          }
        }, a);
        var r = p.filterUserAttributes(a.attributes);
        if (c && a && a.enabled) {
          g && null === g.element.parentNode ? (y = !0, g = g.destroy()) : g && this.removeTextOutline.call(g.parentGroup);
          this.options && this.options.padding && (r.dx = -this.options.padding);
          g || (this.textPathWrapper = g = this.renderer.createElement("textPath"), m = !0);
          var z = g.element;
          (a = c.element.getAttribute("id")) || c.element.setAttribute("id", a = Q());
          if (y) for (d.setAttribute("y", 0), u(r.dx) && d.setAttribute("x", -r.dx), c = [].slice.call(d.childNodes), y = 0; y < c.length; y++) {
            var b = c[y];
            b.nodeType !== e.Node.TEXT_NODE && "tspan" !== b.nodeName || z.appendChild(b);
          }
          m && g && g.add({
            element: d
          });
          z.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + a);
          q(r.dy) && (z.parentNode.setAttribute("dy", r.dy), delete r.dy);
          q(r.dx) && (z.parentNode.setAttribute("dx", r.dx), delete r.dx);
          K(r, function (c, a) {
            z.setAttribute(l[a] || a, c);
          });
          f.removeAttribute("transform");
          this.removeTextOutline.call(g);
          this.text && !this.renderer.styledMode && this.attr({
            fill: "none",
            "stroke-width": 0
          });
          this.applyTextOutline = this.updateTransform = h;
        } else g && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(f, c), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));
        return this;
      };
      b.prototype.shadow = function (c, a, f) {
        var d = [],
          l = this.element,
          e = this.oldShadowOptions,
          g = {
            color: "#000000",
            offsetX: this.parentInverted ? -1 : 1,
            offsetY: this.parentInverted ? -1 : 1,
            opacity: .15,
            width: 3
          },
          q = !1,
          u;
        !0 === c ? u = g : "object" === typeof c && (u = m(g, c));
        u && (u && e && K(u, function (c, a) {
          c !== e[a] && (q = !0);
        }), q && this.destroyShadows(), this.oldShadowOptions = u);
        if (!u) this.destroyShadows();else if (!this.shadows) {
          var y = u.opacity / u.width;
          var r = this.parentInverted ? "translate(" + u.offsetY + ", " + u.offsetX + ")" : "translate(" + u.offsetX + ", " + u.offsetY + ")";
          for (g = 1; g <= u.width; g++) {
            var h = l.cloneNode(!1);
            var z = 2 * u.width + 1 - 2 * g;
            x(h, {
              stroke: c.color || "#000000",
              "stroke-opacity": y * g,
              "stroke-width": z,
              transform: r,
              fill: "none"
            });
            h.setAttribute("class", (h.getAttribute("class") || "") + " highcharts-shadow");
            f && (x(h, "height", Math.max(x(h, "height") - z, 0)), h.cutHeight = z);
            a ? a.element.appendChild(h) : l.parentNode && l.parentNode.insertBefore(h, l);
            d.push(h);
          }
          this.shadows = d;
        }
        return this;
      };
      b.prototype.show = function (c) {
        return this.attr({
          visibility: c ? "inherit" : "visible"
        });
      };
      b.prototype.strokeSetter = function (c, a, f) {
        this[a] = c;
        this.stroke && this["stroke-width"] ? (b.prototype.fillSetter.call(this, this.stroke, "stroke", f), f.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === a && 0 === c && this.hasStroke ? (f.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (f.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
      };
      b.prototype.strokeWidth = function () {
        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
        var c = this.getStyle("stroke-width"),
          f = 0;
        if (c.indexOf("px") === c.length - 2) f = I(c);else if ("" !== c) {
          var d = n.createElementNS(a, "rect");
          x(d, {
            width: c,
            "stroke-width": 0
          });
          this.element.parentNode.appendChild(d);
          f = d.getBBox().width;
          d.parentNode.removeChild(d);
        }
        return f;
      };
      b.prototype.symbolAttr = function (c) {
        var a = this;
        "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (f) {
          a[f] = H(c[f], a[f]);
        });
        a.attr({
          d: a.renderer.symbols[a.symbolName](a.x, a.y, a.width, a.height, a)
        });
      };
      b.prototype.textSetter = function (c) {
        c !== this.textStr && (delete this.textPxLength, this.textStr = c, this.added && this.renderer.buildText(this));
      };
      b.prototype.titleSetter = function (c) {
        var a = this.element,
          f = a.getElementsByTagName("title")[0] || n.createElementNS(this.SVG_NS, "title");
        a.insertBefore ? a.insertBefore(f, a.firstChild) : a.appendChild(f);
        f.textContent = String(H(c, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
      };
      b.prototype.toFront = function () {
        var c = this.element;
        c.parentNode.appendChild(c);
        return this;
      };
      b.prototype.translate = function (c, a) {
        return this.attr({
          translateX: c,
          translateY: a
        });
      };
      b.prototype.updateShadows = function (c, a, f) {
        var d = this.shadows;
        if (d) for (var l = d.length; l--;) f.call(d[l], "height" === c ? Math.max(a - (d[l].cutHeight || 0), 0) : "d" === c ? this.d : a, c, d[l]);
      };
      b.prototype.updateTransform = function () {
        var c = this.scaleX,
          a = this.scaleY,
          f = this.inverted,
          d = this.rotation,
          l = this.matrix,
          e = this.element,
          m = this.translateX || 0,
          g = this.translateY || 0;
        f && (m += this.width, g += this.height);
        m = ["translate(" + m + "," + g + ")"];
        q(l) && m.push("matrix(" + l.join(",") + ")");
        f ? m.push("rotate(90) scale(-1,1)") : d && m.push("rotate(" + d + " " + H(this.rotationOriginX, e.getAttribute("x"), 0) + " " + H(this.rotationOriginY, e.getAttribute("y") || 0) + ")");
        (q(c) || q(a)) && m.push("scale(" + H(c, 1) + " " + H(a, 1) + ")");
        m.length && e.setAttribute("transform", m.join(" "));
      };
      b.prototype.visibilitySetter = function (c, a, f) {
        "inherit" === c ? f.removeAttribute(a) : this[a] !== c && f.setAttribute(a, c);
        this[a] = c;
      };
      b.prototype.xGetter = function (c) {
        "circle" === this.element.nodeName && ("x" === c ? c = "cx" : "y" === c && (c = "cy"));
        return this._defaultGetter(c);
      };
      b.prototype.zIndexSetter = function (c, a) {
        var f = this.renderer,
          d = this.parentGroup,
          l = (d || f).element || f.box,
          e = this.element;
        f = l === f.box;
        var m = !1;
        var g = this.added;
        var u;
        q(c) ? (e.setAttribute("data-z-index", c), c = +c, this[a] === c && (g = !1)) : q(this[a]) && e.removeAttribute("data-z-index");
        this[a] = c;
        if (g) {
          (c = this.zIndex) && d && (d.handleZ = !0);
          a = l.childNodes;
          for (u = a.length - 1; 0 <= u && !m; u--) {
            d = a[u];
            g = d.getAttribute("data-z-index");
            var y = !q(g);
            if (d !== e) if (0 > c && y && !f && !u) l.insertBefore(e, a[u]), m = !0;else if (I(g) <= c || y && (!q(c) || 0 <= c)) l.insertBefore(e, a[u + 1] || null), m = !0;
          }
          m || (l.insertBefore(e, a[f ? 3 : 0] || null), m = !0);
        }
        return m;
      };
      return b;
    }();
    b.prototype["stroke-widthSetter"] = b.prototype.strokeSetter;
    b.prototype.yGetter = b.prototype.xGetter;
    b.prototype.matrixSetter = b.prototype.rotationOriginXSetter = b.prototype.rotationOriginYSetter = b.prototype.rotationSetter = b.prototype.scaleXSetter = b.prototype.scaleYSetter = b.prototype.translateXSetter = b.prototype.translateYSetter = b.prototype.verticalAlignSetter = function (c, a) {
      this[a] = c;
      this.doTransform = !0;
    };
    "";
    return b;
  });
  G(b, "Core/Renderer/RendererRegistry.js", [b["Core/Globals.js"]], function (b) {
    var v;
    (function (v) {
      v.rendererTypes = {};
      var p;
      v.getRendererType = function (b) {
        void 0 === b && (b = p);
        return v.rendererTypes[b] || v.rendererTypes[p];
      };
      v.registerRendererType = function (w, D, B) {
        v.rendererTypes[w] = D;
        if (!p || B) p = w, b.Renderer = D;
      };
    })(v || (v = {}));
    return v;
  });
  G(b, "Core/Renderer/SVG/SVGLabel.js", [b["Core/Renderer/SVG/SVGElement.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = this && this.__extends || function () {
        var b = function (h, d) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var e in d) d.hasOwnProperty(e) && (a[e] = d[e]);
          };
          return b(h, d);
        };
        return function (h, d) {
          function a() {
            this.constructor = h;
          }
          b(h, d);
          h.prototype = null === d ? Object.create(d) : (a.prototype = d.prototype, new a());
        };
      }(),
      E = p.defined,
      w = p.extend,
      D = p.isNumber,
      B = p.merge,
      k = p.pick,
      t = p.removeEvent;
    return function (n) {
      function h(d, a, e, g, b, k, r, q, z, m) {
        var f = n.call(this) || this;
        f.paddingLeftSetter = f.paddingSetter;
        f.paddingRightSetter = f.paddingSetter;
        f.init(d, "g");
        f.textStr = a;
        f.x = e;
        f.y = g;
        f.anchorX = k;
        f.anchorY = r;
        f.baseline = z;
        f.className = m;
        f.addClass("button" === m ? "highcharts-no-tooltip" : "highcharts-label");
        m && f.addClass("highcharts-" + m);
        f.text = d.text(void 0, 0, 0, q).attr({
          zIndex: 1
        });
        var y;
        "string" === typeof b && ((y = /^url\((.*?)\)$/.test(b)) || f.renderer.symbols[b]) && (f.symbolKey = b);
        f.bBox = h.emptyBBox;
        f.padding = 3;
        f.baselineOffset = 0;
        f.needsBox = d.styledMode || y;
        f.deferredAttr = {};
        f.alignFactor = 0;
        return f;
      }
      v(h, n);
      h.prototype.alignSetter = function (d) {
        d = {
          left: 0,
          center: .5,
          right: 1
        }[d];
        d !== this.alignFactor && (this.alignFactor = d, this.bBox && D(this.xSetting) && this.attr({
          x: this.xSetting
        }));
      };
      h.prototype.anchorXSetter = function (d, a) {
        this.anchorX = d;
        this.boxAttr(a, Math.round(d) - this.getCrispAdjust() - this.xSetting);
      };
      h.prototype.anchorYSetter = function (d, a) {
        this.anchorY = d;
        this.boxAttr(a, d - this.ySetting);
      };
      h.prototype.boxAttr = function (d, a) {
        this.box ? this.box.attr(d, a) : this.deferredAttr[d] = a;
      };
      h.prototype.css = function (d) {
        if (d) {
          var a = {};
          d = B(d);
          h.textProps.forEach(function (e) {
            "undefined" !== typeof d[e] && (a[e] = d[e], delete d[e]);
          });
          this.text.css(a);
          var e = ("width" in a);
          "fontSize" in a || "fontWeight" in a ? this.updateTextPadding() : e && this.updateBoxSize();
        }
        return b.prototype.css.call(this, d);
      };
      h.prototype.destroy = function () {
        t(this.element, "mouseenter");
        t(this.element, "mouseleave");
        this.text && this.text.destroy();
        this.box && (this.box = this.box.destroy());
        b.prototype.destroy.call(this);
      };
      h.prototype.fillSetter = function (d, a) {
        d && (this.needsBox = !0);
        this.fill = d;
        this.boxAttr(a, d);
      };
      h.prototype.getBBox = function () {
        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
        var d = this.padding,
          a = k(this.paddingLeft, d);
        return {
          width: this.width,
          height: this.height,
          x: this.bBox.x - a,
          y: this.bBox.y - d
        };
      };
      h.prototype.getCrispAdjust = function () {
        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
      };
      h.prototype.heightSetter = function (d) {
        this.heightSetting = d;
      };
      h.prototype.onAdd = function () {
        var d = this.textStr;
        this.text.add(this);
        this.attr({
          text: E(d) ? d : "",
          x: this.x,
          y: this.y
        });
        this.box && E(this.anchorX) && this.attr({
          anchorX: this.anchorX,
          anchorY: this.anchorY
        });
      };
      h.prototype.paddingSetter = function (d, a) {
        D(d) ? d !== this[a] && (this[a] = d, this.updateTextPadding()) : this[a] = void 0;
      };
      h.prototype.rSetter = function (d, a) {
        this.boxAttr(a, d);
      };
      h.prototype.shadow = function (d) {
        d && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(d));
        return this;
      };
      h.prototype.strokeSetter = function (d, a) {
        this.stroke = d;
        this.boxAttr(a, d);
      };
      h.prototype["stroke-widthSetter"] = function (d, a) {
        d && (this.needsBox = !0);
        this["stroke-width"] = d;
        this.boxAttr(a, d);
      };
      h.prototype["text-alignSetter"] = function (d) {
        this.textAlign = d;
      };
      h.prototype.textSetter = function (d) {
        "undefined" !== typeof d && this.text.attr({
          text: d
        });
        this.updateTextPadding();
      };
      h.prototype.updateBoxSize = function () {
        var d = this.text.element.style,
          a = {},
          e = this.padding,
          g = this.bBox = D(this.widthSetting) && D(this.heightSetting) && !this.textAlign || !E(this.text.textStr) ? h.emptyBBox : this.text.getBBox();
        this.width = this.getPaddedWidth();
        this.height = (this.heightSetting || g.height || 0) + 2 * e;
        d = this.renderer.fontMetrics(d && d.fontSize, this.text);
        this.baselineOffset = e + Math.min((this.text.firstLineMetrics || d).b, g.height || Infinity);
        this.heightSetting && (this.baselineOffset += (this.heightSetting - d.h) / 2);
        this.needsBox && (this.box || (e = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), e.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), e.add(this)), e = this.getCrispAdjust(), a.x = e, a.y = (this.baseline ? -this.baselineOffset : 0) + e, a.width = Math.round(this.width), a.height = Math.round(this.height), this.box.attr(w(a, this.deferredAttr)), this.deferredAttr = {});
      };
      h.prototype.updateTextPadding = function () {
        var d = this.text;
        this.updateBoxSize();
        var a = this.baseline ? 0 : this.baselineOffset,
          e = k(this.paddingLeft, this.padding);
        E(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (e += {
          center: .5,
          right: 1
        }[this.textAlign] * (this.widthSetting - this.bBox.width));
        if (e !== d.x || a !== d.y) d.attr("x", e), d.hasBoxWidthChanged && (this.bBox = d.getBBox(!0)), "undefined" !== typeof a && d.attr("y", a);
        d.x = e;
        d.y = a;
      };
      h.prototype.widthSetter = function (d) {
        this.widthSetting = D(d) ? d : void 0;
      };
      h.prototype.getPaddedWidth = function () {
        var d = this.padding,
          a = k(this.paddingLeft, d);
        d = k(this.paddingRight, d);
        return (this.widthSetting || this.bBox.width || 0) + a + d;
      };
      h.prototype.xSetter = function (d) {
        this.x = d;
        this.alignFactor && (d -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
        this.xSetting = Math.round(d);
        this.attr("translateX", this.xSetting);
      };
      h.prototype.ySetter = function (d) {
        this.ySetting = this.y = Math.round(d);
        this.attr("translateY", this.ySetting);
      };
      h.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      };
      h.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
      return h;
    }(b);
  });
  G(b, "Core/Renderer/SVG/Symbols.js", [b["Core/Utilities.js"]], function (b) {
    function v(b, t, n, h, d) {
      var a = [];
      if (d) {
        var e = d.start || 0,
          g = B(d.r, n);
        n = B(d.r, h || n);
        var k = (d.end || 0) - .001;
        h = d.innerR;
        var C = B(d.open, .001 > Math.abs((d.end || 0) - e - 2 * Math.PI)),
          r = Math.cos(e),
          q = Math.sin(e),
          z = Math.cos(k),
          m = Math.sin(k);
        e = B(d.longArc, .001 > k - e - Math.PI ? 0 : 1);
        a.push(["M", b + g * r, t + n * q], ["A", g, n, 0, e, B(d.clockwise, 1), b + g * z, t + n * m]);
        w(h) && a.push(C ? ["M", b + h * z, t + h * m] : ["L", b + h * z, t + h * m], ["A", h, h, 0, e, w(d.clockwise) ? 1 - d.clockwise : 0, b + h * r, t + h * q]);
        C || a.push(["Z"]);
      }
      return a;
    }
    function A(b, t, n, h, d) {
      return d && d.r ? E(b, t, n, h, d) : [["M", b, t], ["L", b + n, t], ["L", b + n, t + h], ["L", b, t + h], ["Z"]];
    }
    function E(b, t, n, h, d) {
      d = d && d.r || 0;
      return [["M", b + d, t], ["L", b + n - d, t], ["C", b + n, t, b + n, t, b + n, t + d], ["L", b + n, t + h - d], ["C", b + n, t + h, b + n, t + h, b + n - d, t + h], ["L", b + d, t + h], ["C", b, t + h, b, t + h, b, t + h - d], ["L", b, t + d], ["C", b, t, b, t, b + d, t]];
    }
    var w = b.defined,
      D = b.isNumber,
      B = b.pick;
    return {
      arc: v,
      callout: function (b, t, n, h, d) {
        var a = Math.min(d && d.r || 0, n, h),
          e = a + 6,
          g = d && d.anchorX;
        d = d && d.anchorY || 0;
        var x = E(b, t, n, h, {
          r: a
        });
        if (!D(g)) return x;
        b + g >= n ? d > t + e && d < t + h - e ? x.splice(3, 1, ["L", b + n, d - 6], ["L", b + n + 6, d], ["L", b + n, d + 6], ["L", b + n, t + h - a]) : x.splice(3, 1, ["L", b + n, h / 2], ["L", g, d], ["L", b + n, h / 2], ["L", b + n, t + h - a]) : 0 >= b + g ? d > t + e && d < t + h - e ? x.splice(7, 1, ["L", b, d + 6], ["L", b - 6, d], ["L", b, d - 6], ["L", b, t + a]) : x.splice(7, 1, ["L", b, h / 2], ["L", g, d], ["L", b, h / 2], ["L", b, t + a]) : d && d > h && g > b + e && g < b + n - e ? x.splice(5, 1, ["L", g + 6, t + h], ["L", g, t + h + 6], ["L", g - 6, t + h], ["L", b + a, t + h]) : d && 0 > d && g > b + e && g < b + n - e && x.splice(1, 1, ["L", g - 6, t], ["L", g, t - 6], ["L", g + 6, t], ["L", n - a, t]);
        return x;
      },
      circle: function (b, t, n, h) {
        return v(b + n / 2, t + h / 2, n / 2, h / 2, {
          start: .5 * Math.PI,
          end: 2.5 * Math.PI,
          open: !1
        });
      },
      diamond: function (b, t, n, h) {
        return [["M", b + n / 2, t], ["L", b + n, t + h / 2], ["L", b + n / 2, t + h], ["L", b, t + h / 2], ["Z"]];
      },
      rect: A,
      roundedRect: E,
      square: A,
      triangle: function (b, t, n, h) {
        return [["M", b + n / 2, t], ["L", b + n, t + h], ["L", b, t + h], ["Z"]];
      },
      "triangle-down": function (b, t, n, h) {
        return [["M", b, t], ["L", b + n, t], ["L", b + n / 2, t + h], ["Z"]];
      }
    };
  });
  G(b, "Core/Renderer/SVG/TextBuilder.js", [b["Core/Renderer/HTML/AST.js"], b["Core/Globals.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = p.doc,
      w = p.SVG_NS,
      D = p.win,
      B = A.attr,
      k = A.isString,
      t = A.objectEach,
      n = A.pick;
    return function () {
      function h(d) {
        var a = d.styles;
        this.renderer = d.renderer;
        this.svgElement = d;
        this.width = d.textWidth;
        this.textLineHeight = a && a.lineHeight;
        this.textOutline = a && a.textOutline;
        this.ellipsis = !(!a || "ellipsis" !== a.textOverflow);
        this.noWrap = !(!a || "nowrap" !== a.whiteSpace);
        this.fontSize = a && a.fontSize;
      }
      h.prototype.buildSVG = function () {
        var d = this.svgElement,
          a = d.element,
          e = d.renderer,
          g = n(d.textStr, "").toString(),
          h = -1 !== g.indexOf("<"),
          C = a.childNodes;
        e = this.width && !d.added && e.box;
        var r = /<br.*?>/g,
          q = [g, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();
        if (q !== d.textCache) {
          d.textCache = q;
          delete d.actualWidth;
          for (q = C.length; q--;) a.removeChild(C[q]);
          h || this.ellipsis || this.width || -1 !== g.indexOf(" ") && (!this.noWrap || r.test(g)) ? "" !== g && (e && e.appendChild(a), g = new b(g), this.modifyTree(g.nodes), g.addToDOM(d.element), this.modifyDOM(), this.ellipsis && -1 !== (a.textContent || "").indexOf("\u2026") && d.attr("title", this.unescapeEntities(d.textStr || "", ["&lt;", "&gt;"])), e && e.removeChild(a)) : a.appendChild(v.createTextNode(this.unescapeEntities(g)));
          k(this.textOutline) && d.applyTextOutline && d.applyTextOutline(this.textOutline);
        }
      };
      h.prototype.modifyDOM = function () {
        var d = this,
          a = this.svgElement,
          e = B(a.element, "x");
        a.firstLineMetrics = void 0;
        for (var g; g = a.element.firstChild;) if (/^[\s\u200B]*$/.test(g.textContent || " ")) a.element.removeChild(g);else break;
        [].forEach.call(a.element.querySelectorAll("tspan.highcharts-br"), function (g, b) {
          g.nextSibling && g.previousSibling && (0 === b && 1 === g.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(void 0, g.previousSibling)), B(g, {
            dy: d.getLineHeight(g.nextSibling),
            x: e
          }));
        });
        var b = this.width || 0;
        if (b) {
          var h = function (g, h) {
              var m = g.textContent || "",
                f = m.replace(/([^\^])-/g, "$1- ").split(" "),
                q = !d.noWrap && (1 < f.length || 1 < a.element.childNodes.length),
                c = d.getLineHeight(h),
                u = 0,
                l = a.actualWidth;
              if (d.ellipsis) m && d.truncate(g, m, void 0, 0, Math.max(0, b - parseInt(d.fontSize || 12, 10)), function (c, a) {
                return c.substring(0, a) + "\u2026";
              });else if (q) {
                m = [];
                for (q = []; h.firstChild && h.firstChild !== g;) q.push(h.firstChild), h.removeChild(h.firstChild);
                for (; f.length;) f.length && !d.noWrap && 0 < u && (m.push(g.textContent || ""), g.textContent = f.join(" ").replace(/- /g, "-")), d.truncate(g, void 0, f, 0 === u ? l || 0 : 0, b, function (c, a) {
                  return f.slice(0, a).join(" ").replace(/- /g, "-");
                }), l = a.actualWidth, u++;
                q.forEach(function (c) {
                  h.insertBefore(c, g);
                });
                m.forEach(function (a) {
                  h.insertBefore(v.createTextNode(a), g);
                  a = v.createElementNS(w, "tspan");
                  a.textContent = "\u200b";
                  B(a, {
                    dy: c,
                    x: e
                  });
                  h.insertBefore(a, g);
                });
              }
            },
            r = function (d) {
              [].slice.call(d.childNodes).forEach(function (e) {
                e.nodeType === D.Node.TEXT_NODE ? h(e, d) : (-1 !== e.className.baseVal.indexOf("highcharts-br") && (a.actualWidth = 0), r(e));
              });
            };
          r(a.element);
        }
      };
      h.prototype.getLineHeight = function (d) {
        var a;
        d = d.nodeType === D.Node.TEXT_NODE ? d.parentElement : d;
        this.renderer.styledMode || (a = d && /(px|em)$/.test(d.style.fontSize) ? d.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a, d || this.svgElement.element).h;
      };
      h.prototype.modifyTree = function (d) {
        var a = this,
          e = function (g, b) {
            var h = g.attributes;
            h = void 0 === h ? {} : h;
            var r = g.children,
              q = g.tagName,
              z = a.renderer.styledMode;
            if ("b" === q || "strong" === q) z ? h["class"] = "highcharts-strong" : h.style = "font-weight:bold;" + (h.style || "");else if ("i" === q || "em" === q) z ? h["class"] = "highcharts-emphasized" : h.style = "font-style:italic;" + (h.style || "");
            k(h.style) && (h.style = h.style.replace(/(;| |^)color([ :])/, "$1fill$2"));
            "br" === q ? (h["class"] = "highcharts-br", g.textContent = "\u200b", (b = d[b + 1]) && b.textContent && (b.textContent = b.textContent.replace(/^ +/gm, ""))) : "a" === q && r && r.some(function (a) {
              return "#text" === a.tagName;
            }) && (g.children = [{
              children: r,
              tagName: "tspan"
            }]);
            "#text" !== q && "a" !== q && (g.tagName = "tspan");
            g.attributes = h;
            r && r.filter(function (a) {
              return "#text" !== a.tagName;
            }).forEach(e);
          };
        d.forEach(e);
      };
      h.prototype.truncate = function (d, a, e, g, b, h) {
        var r = this.svgElement,
          q = r.renderer,
          z = r.rotation,
          m = [],
          f = e ? 1 : 0,
          y = (a || e || "").length,
          c = y,
          u,
          l = function (c, f) {
            f = f || c;
            var l = d.parentNode;
            if (l && "undefined" === typeof m[f]) if (l.getSubStringLength) try {
              m[f] = g + l.getSubStringLength(0, e ? f + 1 : f);
            } catch (Z) {
              "";
            } else q.getSpanWidth && (d.textContent = h(a || e, c), m[f] = g + q.getSpanWidth(r, d));
            return m[f];
          };
        r.rotation = 0;
        var F = l(d.textContent.length);
        if (g + F > b) {
          for (; f <= y;) c = Math.ceil((f + y) / 2), e && (u = h(e, c)), F = l(c, u && u.length - 1), f === y ? f = y + 1 : F > b ? y = c - 1 : f = c;
          0 === y ? d.textContent = "" : a && y === a.length - 1 || (d.textContent = u || h(a || e, c));
        }
        e && e.splice(0, c);
        r.actualWidth = F;
        r.rotation = z;
      };
      h.prototype.unescapeEntities = function (d, a) {
        t(this.renderer.escapes, function (e, g) {
          a && -1 !== a.indexOf(e) || (d = d.toString().replace(new RegExp(e, "g"), g));
        });
        return d;
      };
      return h;
    }();
  });
  G(b, "Core/Renderer/SVG/SVGRenderer.js", [b["Core/Renderer/HTML/AST.js"], b["Core/Color/Color.js"], b["Core/Globals.js"], b["Core/Renderer/RendererRegistry.js"], b["Core/Renderer/SVG/SVGElement.js"], b["Core/Renderer/SVG/SVGLabel.js"], b["Core/Renderer/SVG/Symbols.js"], b["Core/Renderer/SVG/TextBuilder.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D, B, k, t) {
    var n = A.charts,
      h = A.deg2rad,
      d = A.doc,
      a = A.isFirefox,
      e = A.isMS,
      g = A.isWebKit,
      x = A.noop,
      C = A.SVG_NS,
      r = A.symbolSizes,
      q = A.win,
      z = t.addEvent,
      m = t.attr,
      f = t.createElement,
      y = t.css,
      c = t.defined,
      u = t.destroyObjectProperties,
      l = t.extend,
      F = t.isArray,
      K = t.isNumber,
      H = t.isObject,
      I = t.isString,
      v = t.merge,
      Q = t.pick,
      O = t.pInt,
      R = t.uniqueKey,
      T;
    A = function () {
      function x(c, a, f, d, l, e, m) {
        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
        this.init(c, a, f, d, l, e, m);
      }
      x.prototype.init = function (c, f, l, e, g, b, u) {
        var h = this.createElement("svg").attr({
            version: "1.1",
            "class": "highcharts-root"
          }),
          r = h.element;
        u || h.css(this.getStyle(e));
        c.appendChild(r);
        m(c, "dir", "ltr");
        -1 === c.innerHTML.indexOf("xmlns") && m(r, "xmlns", this.SVG_NS);
        this.isSVG = !0;
        this.box = r;
        this.boxWrapper = h;
        this.alignedObjects = [];
        this.url = this.getReferenceURL();
        this.createElement("desc").add().element.appendChild(d.createTextNode("Created with Highcharts 9.3.3"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = b;
        this.forExport = g;
        this.styledMode = u;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(f, l, !1);
        var x;
        a && c.getBoundingClientRect && (f = function () {
          y(c, {
            left: 0,
            top: 0
          });
          x = c.getBoundingClientRect();
          y(c, {
            left: Math.ceil(x.left) - x.left + "px",
            top: Math.ceil(x.top) - x.top + "px"
          });
        }, f(), this.unSubPixelFix = z(q, "resize", f));
      };
      x.prototype.definition = function (c) {
        return new b([c]).addToDOM(this.defs.element);
      };
      x.prototype.getReferenceURL = function () {
        if ((a || g) && d.getElementsByTagName("base").length) {
          if (!c(T)) {
            var f = R();
            f = new b([{
              tagName: "svg",
              attributes: {
                width: 8,
                height: 8
              },
              children: [{
                tagName: "defs",
                children: [{
                  tagName: "clipPath",
                  attributes: {
                    id: f
                  },
                  children: [{
                    tagName: "rect",
                    attributes: {
                      width: 4,
                      height: 4
                    }
                  }]
                }]
              }, {
                tagName: "rect",
                attributes: {
                  id: "hitme",
                  width: 8,
                  height: 8,
                  "clip-path": "url(#" + f + ")",
                  fill: "rgba(0,0,0,0.001)"
                }
              }]
            }]).addToDOM(d.body);
            y(f, {
              position: "fixed",
              top: 0,
              left: 0,
              zIndex: 9E5
            });
            var l = d.elementFromPoint(6, 6);
            T = "hitme" === (l && l.id);
            d.body.removeChild(f);
          }
          if (T) return q.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
        }
        return "";
      };
      x.prototype.getStyle = function (c) {
        return this.style = l({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: "12px"
        }, c);
      };
      x.prototype.setStyle = function (c) {
        this.boxWrapper.css(this.getStyle(c));
      };
      x.prototype.isHidden = function () {
        return !this.boxWrapper.getBBox().width;
      };
      x.prototype.destroy = function () {
        var c = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        u(this.gradients || {});
        this.gradients = null;
        c && (this.defs = c.destroy());
        this.unSubPixelFix && this.unSubPixelFix();
        return this.alignedObjects = null;
      };
      x.prototype.createElement = function (c) {
        var a = new this.Element();
        a.init(this, c);
        return a;
      };
      x.prototype.getRadialAttr = function (c, a) {
        return {
          cx: c[0] - c[2] / 2 + (a.cx || 0) * c[2],
          cy: c[1] - c[2] / 2 + (a.cy || 0) * c[2],
          r: (a.r || 0) * c[2]
        };
      };
      x.prototype.buildText = function (c) {
        new k(c).buildSVG();
      };
      x.prototype.getContrast = function (c) {
        c = p.parse(c).rgba;
        c[0] *= 1;
        c[1] *= 1.2;
        c[2] *= .5;
        return 459 < c[0] + c[1] + c[2] ? "#000000" : "#FFFFFF";
      };
      x.prototype.button = function (c, a, f, d, m, g, u, q, h, y) {
        var r = this.label(c, a, f, h, void 0, void 0, y, void 0, "button"),
          x = this.styledMode,
          F = 0,
          C = m ? v(m) : {};
        c = C && C.style || {};
        C = b.filterUserAttributes(C);
        r.attr(v({
          padding: 8,
          r: 2
        }, C));
        if (!x) {
          C = v({
            fill: "#f7f7f7",
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontWeight: "normal"
            }
          }, {
            style: c
          }, C);
          var n = C.style;
          delete C.style;
          g = v(C, {
            fill: "#e6e6e6"
          }, b.filterUserAttributes(g || {}));
          var H = g.style;
          delete g.style;
          u = v(C, {
            fill: "#e6ebf5",
            style: {
              color: "#000000",
              fontWeight: "bold"
            }
          }, b.filterUserAttributes(u || {}));
          var k = u.style;
          delete u.style;
          q = v(C, {
            style: {
              color: "#cccccc"
            }
          }, b.filterUserAttributes(q || {}));
          var M = q.style;
          delete q.style;
        }
        z(r.element, e ? "mouseover" : "mouseenter", function () {
          3 !== F && r.setState(1);
        });
        z(r.element, e ? "mouseout" : "mouseleave", function () {
          3 !== F && r.setState(F);
        });
        r.setState = function (c) {
          1 !== c && (r.state = F = c);
          r.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][c || 0]);
          x || r.attr([C, g, u, q][c || 0]).css([n, H, k, M][c || 0]);
        };
        x || r.attr(C).css(l({
          cursor: "default"
        }, n));
        return r.on("touchstart", function (c) {
          return c.stopPropagation();
        }).on("click", function (c) {
          3 !== F && d.call(r, c);
        });
      };
      x.prototype.crispLine = function (a, f, d) {
        void 0 === d && (d = "round");
        var l = a[0],
          e = a[1];
        c(l[1]) && l[1] === e[1] && (l[1] = e[1] = Math[d](l[1]) - f % 2 / 2);
        c(l[2]) && l[2] === e[2] && (l[2] = e[2] = Math[d](l[2]) + f % 2 / 2);
        return a;
      };
      x.prototype.path = function (c) {
        var a = this.styledMode ? {} : {
          fill: "none"
        };
        F(c) ? a.d = c : H(c) && l(a, c);
        return this.createElement("path").attr(a);
      };
      x.prototype.circle = function (c, a, f) {
        c = H(c) ? c : "undefined" === typeof c ? {} : {
          x: c,
          y: a,
          r: f
        };
        a = this.createElement("circle");
        a.xSetter = a.ySetter = function (c, a, f) {
          f.setAttribute("c" + a, c);
        };
        return a.attr(c);
      };
      x.prototype.arc = function (c, a, f, d, l, e) {
        H(c) ? (d = c, a = d.y, f = d.r, c = d.x) : d = {
          innerR: d,
          start: l,
          end: e
        };
        c = this.symbol("arc", c, a, f, f, d);
        c.r = f;
        return c;
      };
      x.prototype.rect = function (c, a, f, d, l, e) {
        l = H(c) ? c.r : l;
        var g = this.createElement("rect");
        c = H(c) ? c : "undefined" === typeof c ? {} : {
          x: c,
          y: a,
          width: Math.max(f, 0),
          height: Math.max(d, 0)
        };
        this.styledMode || ("undefined" !== typeof e && (c["stroke-width"] = e, c = g.crisp(c)), c.fill = "none");
        l && (c.r = l);
        g.rSetter = function (c, a, f) {
          g.r = c;
          m(f, {
            rx: c,
            ry: c
          });
        };
        g.rGetter = function () {
          return g.r || 0;
        };
        return g.attr(c);
      };
      x.prototype.setSize = function (c, a, f) {
        this.width = c;
        this.height = a;
        this.boxWrapper.animate({
          width: c,
          height: a
        }, {
          step: function () {
            this.attr({
              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
            });
          },
          duration: Q(f, !0) ? void 0 : 0
        });
        this.alignElements();
      };
      x.prototype.g = function (c) {
        var a = this.createElement("g");
        return c ? a.attr({
          "class": "highcharts-" + c
        }) : a;
      };
      x.prototype.image = function (c, a, f, d, l, e) {
        var m = {
            preserveAspectRatio: "none"
          },
          g = function (c, a) {
            c.setAttributeNS ? c.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : c.setAttribute("hc-svg-href", a);
          };
        K(a) && (m.x = a);
        K(f) && (m.y = f);
        K(d) && (m.width = d);
        K(l) && (m.height = l);
        var b = this.createElement("image").attr(m);
        a = function (a) {
          g(b.element, c);
          e.call(b, a);
        };
        e ? (g(b.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), f = new q.Image(), z(f, "load", a), f.src = c, f.complete && a({})) : g(b.element, c);
        return b;
      };
      x.prototype.symbol = function (a, e, m, g, b, u) {
        var q = this,
          h = /^url\((.*?)\)$/,
          z = h.test(a),
          x = !z && (this.symbols[a] ? a : "circle"),
          F = x && this.symbols[x],
          C;
        if (F) {
          "number" === typeof e && (C = F.call(this.symbols, Math.round(e || 0), Math.round(m || 0), g || 0, b || 0, u));
          var H = this.path(C);
          q.styledMode || H.attr("fill", "none");
          l(H, {
            symbolName: x || void 0,
            x: e,
            y: m,
            width: g,
            height: b
          });
          u && l(H, u);
        } else if (z) {
          var k = a.match(h)[1];
          var M = H = this.image(k);
          M.imgwidth = Q(r[k] && r[k].width, u && u.width);
          M.imgheight = Q(r[k] && r[k].height, u && u.height);
          var da = function (c) {
            return c.attr({
              width: c.width,
              height: c.height
            });
          };
          ["width", "height"].forEach(function (a) {
            M[a + "Setter"] = function (a, f) {
              var d = this["img" + f];
              this[f] = a;
              c(d) && (u && "within" === u.backgroundSize && this.width && this.height && (d = Math.round(d * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(f, d), this.alignByTranslate || (a = ((this[f] || 0) - d) / 2, this.attr("width" === f ? {
                translateX: a
              } : {
                translateY: a
              })));
            };
          });
          c(e) && M.attr({
            x: e,
            y: m
          });
          M.isImg = !0;
          c(M.imgwidth) && c(M.imgheight) ? da(M) : (M.attr({
            width: 0,
            height: 0
          }), f("img", {
            onload: function () {
              var c = n[q.chartIndex];
              0 === this.width && (y(this, {
                position: "absolute",
                top: "-999em"
              }), d.body.appendChild(this));
              r[k] = {
                width: this.width,
                height: this.height
              };
              M.imgwidth = this.width;
              M.imgheight = this.height;
              M.element && da(M);
              this.parentNode && this.parentNode.removeChild(this);
              q.imgCount--;
              if (!q.imgCount && c && !c.hasLoaded) c.onload();
            },
            src: k
          }), this.imgCount++);
        }
        return H;
      };
      x.prototype.clipRect = function (c, a, f, d) {
        var l = R() + "-",
          e = this.createElement("clipPath").attr({
            id: l
          }).add(this.defs);
        c = this.rect(c, a, f, d, 0).add(e);
        c.id = l;
        c.clipPath = e;
        c.count = 0;
        return c;
      };
      x.prototype.text = function (a, f, d, l) {
        var e = {};
        if (l && (this.allowHTML || !this.forExport)) return this.html(a, f, d);
        e.x = Math.round(f || 0);
        d && (e.y = Math.round(d));
        c(a) && (e.text = a);
        a = this.createElement("text").attr(e);
        if (!l || this.forExport && !this.allowHTML) a.xSetter = function (c, a, f) {
          for (var d = f.getElementsByTagName("tspan"), l = f.getAttribute(a), e = 0, m; e < d.length; e++) m = d[e], m.getAttribute(a) === l && m.setAttribute(a, c);
          f.setAttribute(a, c);
        };
        return a;
      };
      x.prototype.fontMetrics = function (c, a) {
        c = !this.styledMode && /px/.test(c) || !q.getComputedStyle ? c || a && a.style && a.style.fontSize || this.style && this.style.fontSize : a && w.prototype.getStyle.call(a, "font-size");
        c = /px/.test(c) ? O(c) : 12;
        a = 24 > c ? c + 3 : Math.round(1.2 * c);
        return {
          h: a,
          b: Math.round(.8 * a),
          f: c
        };
      };
      x.prototype.rotCorr = function (c, a, f) {
        var d = c;
        a && f && (d = Math.max(d * Math.cos(a * h), 4));
        return {
          x: -c / 3 * Math.sin(a * h),
          y: d
        };
      };
      x.prototype.pathToSegments = function (c) {
        for (var a = [], f = [], d = {
            A: 8,
            C: 7,
            H: 2,
            L: 3,
            M: 3,
            Q: 5,
            S: 5,
            T: 3,
            V: 2
          }, l = 0; l < c.length; l++) I(f[0]) && K(c[l]) && f.length === d[f[0].toUpperCase()] && c.splice(l, 0, f[0].replace("M", "L").replace("m", "l")), "string" === typeof c[l] && (f.length && a.push(f.slice(0)), f.length = 0), f.push(c[l]);
        a.push(f.slice(0));
        return a;
      };
      x.prototype.label = function (c, a, f, d, l, e, m, g, b) {
        return new D(this, c, a, f, d, l, e, m, g, b);
      };
      x.prototype.alignElements = function () {
        this.alignedObjects.forEach(function (c) {
          return c.align();
        });
      };
      return x;
    }();
    l(A.prototype, {
      Element: w,
      SVG_NS: C,
      escapes: {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      },
      symbols: B,
      draw: x
    });
    E.registerRendererType("svg", A, !0);
    "";
    return A;
  });
  G(b, "Core/Renderer/HTML/HTMLElement.js", [b["Core/Globals.js"], b["Core/Renderer/SVG/SVGElement.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = this && this.__extends || function () {
        var a = function (d, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var e in d) d.hasOwnProperty(e) && (a[e] = d[e]);
          };
          return a(d, e);
        };
        return function (d, e) {
          function g() {
            this.constructor = d;
          }
          a(d, e);
          d.prototype = null === e ? Object.create(e) : (g.prototype = e.prototype, new g());
        };
      }(),
      w = b.isFirefox,
      D = b.isMS,
      B = b.isWebKit,
      k = b.win,
      t = A.css,
      n = A.defined,
      h = A.extend,
      d = A.pick,
      a = A.pInt;
    return function (e) {
      function g() {
        return null !== e && e.apply(this, arguments) || this;
      }
      v(g, e);
      g.compose = function (a) {
        if (-1 === g.composedClasses.indexOf(a)) {
          g.composedClasses.push(a);
          var d = g.prototype,
            e = a.prototype;
          e.getSpanCorrection = d.getSpanCorrection;
          e.htmlCss = d.htmlCss;
          e.htmlGetBBox = d.htmlGetBBox;
          e.htmlUpdateTransform = d.htmlUpdateTransform;
          e.setSpanRotation = d.setSpanRotation;
        }
        return a;
      };
      g.prototype.getSpanCorrection = function (a, d, e) {
        this.xCorr = -a * e;
        this.yCorr = -d;
      };
      g.prototype.htmlCss = function (a) {
        var e = "SPAN" === this.element.tagName && a && "width" in a,
          g = d(e && a.width, void 0);
        if (e) {
          delete a.width;
          this.textWidth = g;
          var b = !0;
        }
        a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
        this.styles = h(this.styles, a);
        t(this.element, a);
        b && this.htmlUpdateTransform();
        return this;
      };
      g.prototype.htmlGetBBox = function () {
        var a = this.element;
        return {
          x: a.offsetLeft,
          y: a.offsetTop,
          width: a.offsetWidth,
          height: a.offsetHeight
        };
      };
      g.prototype.htmlUpdateTransform = function () {
        if (this.added) {
          var d = this.renderer,
            e = this.element,
            g = this.translateX || 0,
            b = this.translateY || 0,
            h = this.x || 0,
            m = this.y || 0,
            f = this.textAlign || "left",
            y = {
              left: 0,
              center: .5,
              right: 1
            }[f],
            c = this.styles;
          c = c && c.whiteSpace;
          t(e, {
            marginLeft: g,
            marginTop: b
          });
          !d.styledMode && this.shadows && this.shadows.forEach(function (c) {
            t(c, {
              marginLeft: g + 1,
              marginTop: b + 1
            });
          });
          this.inverted && [].forEach.call(e.childNodes, function (c) {
            d.invertChild(c, e);
          });
          if ("SPAN" === e.tagName) {
            var u = this.rotation,
              l = this.textWidth && a(this.textWidth),
              F = [u, f, e.innerHTML, this.textWidth, this.textAlign].join(),
              k = void 0;
            k = !1;
            if (l !== this.oldTextWidth) {
              if (this.textPxLength) var H = this.textPxLength;else t(e, {
                width: "",
                whiteSpace: c || "nowrap"
              }), H = e.offsetWidth;
              (l > this.oldTextWidth || H > l) && (/[ \-]/.test(e.textContent || e.innerText) || "ellipsis" === e.style.textOverflow) && (t(e, {
                width: H > l || u ? l + "px" : "auto",
                display: "block",
                whiteSpace: c || "normal"
              }), this.oldTextWidth = l, k = !0);
            }
            this.hasBoxWidthChanged = k;
            F !== this.cTT && (k = d.fontMetrics(e.style.fontSize, e).b, !n(u) || u === (this.oldRotation || 0) && f === this.oldAlign || this.setSpanRotation(u, y, k), this.getSpanCorrection(!n(u) && this.textPxLength || e.offsetWidth, k, y, u, f));
            t(e, {
              left: h + (this.xCorr || 0) + "px",
              top: m + (this.yCorr || 0) + "px"
            });
            this.cTT = F;
            this.oldRotation = u;
            this.oldAlign = f;
          }
        } else this.alignOnAdd = !0;
      };
      g.prototype.setSpanRotation = function (a, d, e) {
        var g = {},
          b = D && !/Edge/.test(k.navigator.userAgent) ? "-ms-transform" : B ? "-webkit-transform" : w ? "MozTransform" : k.opera ? "-o-transform" : void 0;
        b && (g[b] = g.transform = "rotate(" + a + "deg)", g[b + (w ? "Origin" : "-origin")] = g.transformOrigin = 100 * d + "% " + e + "px", t(this.element, g));
      };
      g.composedClasses = [];
      return g;
    }(p);
  });
  G(b, "Core/Renderer/HTML/HTMLRenderer.js", [b["Core/Renderer/HTML/AST.js"], b["Core/Renderer/SVG/SVGElement.js"], b["Core/Renderer/SVG/SVGRenderer.js"], b["Core/Utilities.js"]], function (b, p, A, E) {
    var v = this && this.__extends || function () {
        var b = function (h, d) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var e in d) d.hasOwnProperty(e) && (a[e] = d[e]);
          };
          return b(h, d);
        };
        return function (h, d) {
          function a() {
            this.constructor = h;
          }
          b(h, d);
          h.prototype = null === d ? Object.create(d) : (a.prototype = d.prototype, new a());
        };
      }(),
      D = E.attr,
      B = E.createElement,
      k = E.extend,
      t = E.pick;
    return function (n) {
      function h() {
        return null !== n && n.apply(this, arguments) || this;
      }
      v(h, n);
      h.compose = function (d) {
        -1 === h.composedClasses.indexOf(d) && (h.composedClasses.push(d), d.prototype.html = h.prototype.html);
        return d;
      };
      h.prototype.html = function (d, a, e) {
        var g = this.createElement("span"),
          h = g.element,
          n = g.renderer,
          r = n.isSVG,
          q = function (a, d) {
            ["opacity", "visibility"].forEach(function (f) {
              a[f + "Setter"] = function (e, c, m) {
                var l = a.div ? a.div.style : d;
                p.prototype[f + "Setter"].call(this, e, c, m);
                l && (l[c] = e);
              };
            });
            a.addedSetters = !0;
          };
        g.textSetter = function (a) {
          a !== this.textStr && (delete this.bBox, delete this.oldTextWidth, b.setElementHTML(this.element, t(a, "")), this.textStr = a, g.doTransform = !0);
        };
        r && q(g, g.element.style);
        g.xSetter = g.ySetter = g.alignSetter = g.rotationSetter = function (a, d) {
          "align" === d ? g.alignValue = g.textAlign = a : g[d] = a;
          g.doTransform = !0;
        };
        g.afterSetters = function () {
          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
        };
        g.attr({
          text: d,
          x: Math.round(a),
          y: Math.round(e)
        }).css({
          position: "absolute"
        });
        n.styledMode || g.css({
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize
        });
        h.style.whiteSpace = "nowrap";
        g.css = g.htmlCss;
        r && (g.add = function (a) {
          var d = n.box.parentNode,
            f = [];
          if (this.parentGroup = a) {
            var e = a.div;
            if (!e) {
              for (; a;) f.push(a), a = a.parentGroup;
              f.reverse().forEach(function (c) {
                function a(a, f) {
                  c[f] = a;
                  "translateX" === f ? b.left = a + "px" : b.top = a + "px";
                  c.doTransform = !0;
                }
                var l = D(c.element, "class"),
                  m = c.styles || {};
                e = c.div = c.div || B("div", l ? {
                  className: l
                } : void 0, {
                  position: "absolute",
                  left: (c.translateX || 0) + "px",
                  top: (c.translateY || 0) + "px",
                  display: c.display,
                  opacity: c.opacity,
                  cursor: m.cursor,
                  pointerEvents: m.pointerEvents,
                  visibility: c.visibility
                }, e || d);
                var b = e.style;
                k(c, {
                  classSetter: function (c) {
                    return function (a) {
                      this.element.setAttribute("class", a);
                      c.className = a;
                    };
                  }(e),
                  on: function () {
                    f[0].div && g.on.apply({
                      element: f[0].div,
                      onEvents: c.onEvents
                    }, arguments);
                    return c;
                  },
                  translateXSetter: a,
                  translateYSetter: a
                });
                c.addedSetters || q(c);
              });
            }
          } else e = d;
          e.appendChild(h);
          g.added = !0;
          g.alignOnAdd && g.htmlUpdateTransform();
          return g;
        });
        return g;
      };
      h.composedClasses = [];
      return h;
    }(A);
  });
  G(b, "Core/Axis/AxisDefaults.js", [], function () {
    var b;
    (function (b) {
      b.defaultXAxisOptions = {
        alignTicks: !0,
        allowDecimals: void 0,
        panningEnabled: !0,
        zIndex: 2,
        zoomEnabled: !0,
        dateTimeLabelFormats: {
          millisecond: {
            main: "%H:%M:%S.%L",
            range: !1
          },
          second: {
            main: "%H:%M:%S",
            range: !1
          },
          minute: {
            main: "%H:%M",
            range: !1
          },
          hour: {
            main: "%H:%M",
            range: !1
          },
          day: {
            main: "%e. %b"
          },
          week: {
            main: "%e. %b"
          },
          month: {
            main: "%b '%y"
          },
          year: {
            main: "%Y"
          }
        },
        endOnTick: !1,
        gridLineDashStyle: "Solid",
        gridZIndex: 1,
        labels: {
          autoRotation: void 0,
          autoRotationLimit: 80,
          distance: void 0,
          enabled: !0,
          indentation: 10,
          overflow: "justify",
          padding: 5,
          reserveSpace: void 0,
          rotation: void 0,
          staggerLines: 0,
          step: 0,
          useHTML: !1,
          x: 0,
          zIndex: 7,
          style: {
            color: "#666666",
            cursor: "default",
            fontSize: "11px"
          }
        },
        maxPadding: .01,
        minorGridLineDashStyle: "Solid",
        minorTickLength: 2,
        minorTickPosition: "outside",
        minPadding: .01,
        offset: void 0,
        opposite: !1,
        reversed: void 0,
        reversedStacks: !1,
        showEmpty: !0,
        showFirstLabel: !0,
        showLastLabel: !0,
        startOfWeek: 1,
        startOnTick: !1,
        tickLength: 10,
        tickPixelInterval: 100,
        tickmarkPlacement: "between",
        tickPosition: "outside",
        title: {
          align: "middle",
          rotation: 0,
          useHTML: !1,
          x: 0,
          y: 0,
          style: {
            color: "#666666"
          }
        },
        type: "linear",
        uniqueNames: !0,
        visible: !0,
        minorGridLineColor: "#f2f2f2",
        minorGridLineWidth: 1,
        minorTickColor: "#999999",
        lineColor: "#ccd6eb",
        lineWidth: 1,
        gridLineColor: "#e6e6e6",
        gridLineWidth: void 0,
        tickColor: "#ccd6eb"
      };
      b.defaultYAxisOptions = {
        reversedStacks: !0,
        endOnTick: !0,
        maxPadding: .05,
        minPadding: .05,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {
          x: -8
        },
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          animation: {},
          allowOverlap: !1,
          enabled: !1,
          crop: !0,
          overflow: "justify",
          formatter: function () {
            var b = this.axis.chart.numberFormatter;
            return b(this.total, -1);
          },
          style: {
            color: "#000000",
            fontSize: "11px",
            fontWeight: "bold",
            textOutline: "1px contrast"
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
      };
      b.defaultLeftAxisOptions = {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      };
      b.defaultRightAxisOptions = {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      };
      b.defaultBottomAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
      b.defaultTopAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
    })(b || (b = {}));
    return b;
  });
  G(b, "Core/Foundation.js", [b["Core/Utilities.js"]], function (b) {
    var v = b.addEvent,
      A = b.isFunction,
      E = b.objectEach,
      w = b.removeEvent,
      D;
    (function (b) {
      b.registerEventOptions = function (b, t) {
        b.eventOptions = b.eventOptions || {};
        E(t.events, function (k, h) {
          b.eventOptions[h] !== k && (b.eventOptions[h] && (w(b, h, b.eventOptions[h]), delete b.eventOptions[h]), A(k) && (b.eventOptions[h] = k, v(b, h, k)));
        });
      };
    })(D || (D = {}));
    return D;
  });
  G(b, "Core/Axis/Tick.js", [b["Core/FormatUtilities.js"], b["Core/Globals.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = p.deg2rad,
      w = A.clamp,
      D = A.correctFloat,
      B = A.defined,
      k = A.destroyObjectProperties,
      t = A.extend,
      n = A.fireEvent,
      h = A.isNumber,
      d = A.merge,
      a = A.objectEach,
      e = A.pick;
    p = function () {
      function g(a, d, e, b, g) {
        this.isNewLabel = this.isNew = !0;
        this.axis = a;
        this.pos = d;
        this.type = e || "";
        this.parameters = g || {};
        this.tickmarkOffset = this.parameters.tickmarkOffset;
        this.options = this.parameters.options;
        n(this, "init");
        e || b || this.addLabel();
      }
      g.prototype.addLabel = function () {
        var a = this,
          d = a.axis,
          g = d.options,
          q = d.chart,
          z = d.categories,
          m = d.logarithmic,
          f = d.names,
          y = a.pos,
          c = e(a.options && a.options.labels, g.labels),
          u = d.tickPositions,
          l = y === u[0],
          F = y === u[u.length - 1],
          k = (!c.step || 1 === c.step) && 1 === d.tickInterval;
        u = u.info;
        var H = a.label,
          I;
        z = this.parameters.category || (z ? e(z[y], f[y], y) : y);
        m && h(z) && (z = D(m.lin2log(z)));
        if (d.dateTime) if (u) {
          var v = q.time.resolveDTLFormat(g.dateTimeLabelFormats[!g.grid && u.higherRanks[y] || u.unitName]);
          var p = v.main;
        } else h(z) && (p = d.dateTime.getXDateFormat(z, g.dateTimeLabelFormats || {}));
        a.isFirst = l;
        a.isLast = F;
        var w = {
          axis: d,
          chart: q,
          dateTimeLabelFormat: p,
          isFirst: l,
          isLast: F,
          pos: y,
          tick: a,
          tickPositionInfo: u,
          value: z
        };
        n(this, "labelFormat", w);
        var A = function (a) {
          return c.formatter ? c.formatter.call(a, a) : c.format ? (a.text = d.defaultLabelFormatter.call(a), b.format(c.format, a, q)) : d.defaultLabelFormatter.call(a, a);
        };
        g = A.call(w, w);
        var E = v && v.list;
        a.shortenLabel = E ? function () {
          for (I = 0; I < E.length; I++) if (t(w, {
            dateTimeLabelFormat: E[I]
          }), H.attr({
            text: A.call(w, w)
          }), H.getBBox().width < d.getSlotWidth(a) - 2 * c.padding) return;
          H.attr({
            text: ""
          });
        } : void 0;
        k && d._addedPlotLB && a.moveLabel(g, c);
        B(H) || a.movedLabel ? H && H.textStr !== g && !k && (!H.textWidth || c.style.width || H.styles.width || H.css({
          width: null
        }), H.attr({
          text: g
        }), H.textPxLength = H.getBBox().width) : (a.label = H = a.createLabel({
          x: 0,
          y: 0
        }, g, c), a.rotation = 0);
      };
      g.prototype.createLabel = function (a, e, b) {
        var g = this.axis,
          h = g.chart;
        if (a = B(e) && b.enabled ? h.renderer.text(e, a.x, a.y, b.useHTML).add(g.labelGroup) : null) h.styledMode || a.css(d(b.style)), a.textPxLength = a.getBBox().width;
        return a;
      };
      g.prototype.destroy = function () {
        k(this, this.axis);
      };
      g.prototype.getPosition = function (a, d, e, b) {
        var g = this.axis,
          m = g.chart,
          f = b && m.oldChartHeight || m.chartHeight;
        a = {
          x: a ? D(g.translate(d + e, null, null, b) + g.transB) : g.left + g.offset + (g.opposite ? (b && m.oldChartWidth || m.chartWidth) - g.right - g.left : 0),
          y: a ? f - g.bottom + g.offset - (g.opposite ? g.height : 0) : D(f - g.translate(d + e, null, null, b) - g.transB)
        };
        a.y = w(a.y, -1E5, 1E5);
        n(this, "afterGetPosition", {
          pos: a
        });
        return a;
      };
      g.prototype.getLabelPosition = function (a, d, e, g, b, m, f, h) {
        var c = this.axis,
          u = c.transA,
          l = c.isLinked && c.linkedParent ? c.linkedParent.reversed : c.reversed,
          q = c.staggerLines,
          y = c.tickRotCorr || {
            x: 0,
            y: 0
          },
          r = g || c.reserveSpaceDefault ? 0 : -c.labelOffset * ("center" === c.labelAlign ? .5 : 1),
          k = {},
          z = b.y;
        B(z) || (z = 0 === c.side ? e.rotation ? -8 : -e.getBBox().height : 2 === c.side ? y.y + 8 : Math.cos(e.rotation * v) * (y.y - e.getBBox(!1, 0).height / 2));
        a = a + b.x + r + y.x - (m && g ? m * u * (l ? -1 : 1) : 0);
        d = d + z - (m && !g ? m * u * (l ? 1 : -1) : 0);
        q && (e = f / (h || 1) % q, c.opposite && (e = q - e - 1), d += c.labelOffset / q * e);
        k.x = a;
        k.y = Math.round(d);
        n(this, "afterGetLabelPosition", {
          pos: k,
          tickmarkOffset: m,
          index: f
        });
        return k;
      };
      g.prototype.getLabelSize = function () {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
      };
      g.prototype.getMarkPath = function (a, d, e, g, b, m) {
        return m.crispLine([["M", a, d], ["L", a + (b ? 0 : -e), d + (b ? e : 0)]], g);
      };
      g.prototype.handleOverflow = function (a) {
        var d = this.axis,
          g = d.options.labels,
          b = a.x,
          h = d.chart.chartWidth,
          m = d.chart.spacing,
          f = e(d.labelLeft, Math.min(d.pos, m[3]));
        m = e(d.labelRight, Math.max(d.isRadial ? 0 : d.pos + d.len, h - m[1]));
        var y = this.label,
          c = this.rotation,
          u = {
            left: 0,
            center: .5,
            right: 1
          }[d.labelAlign || y.attr("align")],
          l = y.getBBox().width,
          F = d.getSlotWidth(this),
          k = {},
          H = F,
          n = 1,
          x;
        if (c || "justify" !== g.overflow) 0 > c && b - u * l < f ? x = Math.round(b / Math.cos(c * v) - f) : 0 < c && b + u * l > m && (x = Math.round((h - b) / Math.cos(c * v)));else if (h = b + (1 - u) * l, b - u * l < f ? H = a.x + H * (1 - u) - f : h > m && (H = m - a.x + H * u, n = -1), H = Math.min(F, H), H < F && "center" === d.labelAlign && (a.x += n * (F - H - u * (F - Math.min(l, H)))), l > H || d.autoRotation && (y.styles || {}).width) x = H;
        x && (this.shortenLabel ? this.shortenLabel() : (k.width = Math.floor(x) + "px", (g.style || {}).textOverflow || (k.textOverflow = "ellipsis"), y.css(k)));
      };
      g.prototype.moveLabel = function (d, e) {
        var g = this,
          b = g.label,
          h = g.axis,
          m = h.reversed,
          f = !1;
        b && b.textStr === d ? (g.movedLabel = b, f = !0, delete g.label) : a(h.ticks, function (c) {
          f || c.isNew || c === g || !c.label || c.label.textStr !== d || (g.movedLabel = c.label, f = !0, c.labelPos = g.movedLabel.xy, delete c.label);
        });
        if (!f && (g.labelPos || b)) {
          var y = g.labelPos || b.xy;
          b = h.horiz ? m ? 0 : h.width + h.left : y.x;
          h = h.horiz ? y.y : m ? h.width + h.left : 0;
          g.movedLabel = g.createLabel({
            x: b,
            y: h
          }, d, e);
          g.movedLabel && g.movedLabel.attr({
            opacity: 0
          });
        }
      };
      g.prototype.render = function (a, d, g) {
        var b = this.axis,
          h = b.horiz,
          m = this.pos,
          f = e(this.tickmarkOffset, b.tickmarkOffset);
        m = this.getPosition(h, m, f, d);
        f = m.x;
        var y = m.y;
        b = h && f === b.pos + b.len || !h && y === b.pos ? -1 : 1;
        h = e(g, this.label && this.label.newOpacity, 1);
        g = e(g, 1);
        this.isActive = !0;
        this.renderGridLine(d, g, b);
        this.renderMark(m, g, b);
        this.renderLabel(m, d, h, a);
        this.isNew = !1;
        n(this, "afterRender");
      };
      g.prototype.renderGridLine = function (a, d, g) {
        var b = this.axis,
          h = b.options,
          m = {},
          f = this.pos,
          y = this.type,
          c = e(this.tickmarkOffset, b.tickmarkOffset),
          u = b.chart.renderer,
          l = this.gridLine,
          F = h.gridLineWidth,
          r = h.gridLineColor,
          k = h.gridLineDashStyle;
        "minor" === this.type && (F = h.minorGridLineWidth, r = h.minorGridLineColor, k = h.minorGridLineDashStyle);
        l || (b.chart.styledMode || (m.stroke = r, m["stroke-width"] = F || 0, m.dashstyle = k), y || (m.zIndex = 1), a && (d = 0), this.gridLine = l = u.path().attr(m).addClass("highcharts-" + (y ? y + "-" : "") + "grid-line").add(b.gridGroup));
        if (l && (g = b.getPlotLinePath({
          value: f + c,
          lineWidth: l.strokeWidth() * g,
          force: "pass",
          old: a
        }))) l[a || this.isNew ? "attr" : "animate"]({
          d: g,
          opacity: d
        });
      };
      g.prototype.renderMark = function (a, d, g) {
        var b = this.axis,
          h = b.options,
          m = b.chart.renderer,
          f = this.type,
          y = b.tickSize(f ? f + "Tick" : "tick"),
          c = a.x;
        a = a.y;
        var u = e(h["minor" !== f ? "tickWidth" : "minorTickWidth"], !f && b.isXAxis ? 1 : 0);
        h = h["minor" !== f ? "tickColor" : "minorTickColor"];
        var l = this.mark,
          F = !l;
        y && (b.opposite && (y[0] = -y[0]), l || (this.mark = l = m.path().addClass("highcharts-" + (f ? f + "-" : "") + "tick").add(b.axisGroup), b.chart.styledMode || l.attr({
          stroke: h,
          "stroke-width": u
        })), l[F ? "attr" : "animate"]({
          d: this.getMarkPath(c, a, y[0], l.strokeWidth() * g, b.horiz, m),
          opacity: d
        }));
      };
      g.prototype.renderLabel = function (a, d, b, g) {
        var q = this.axis,
          m = q.horiz,
          f = q.options,
          y = this.label,
          c = f.labels,
          u = c.step;
        q = e(this.tickmarkOffset, q.tickmarkOffset);
        var l = a.x;
        a = a.y;
        var F = !0;
        y && h(l) && (y.xy = a = this.getLabelPosition(l, a, y, m, c, q, g, u), this.isFirst && !this.isLast && !f.showFirstLabel || this.isLast && !this.isFirst && !f.showLastLabel ? F = !1 : !m || c.step || c.rotation || d || 0 === b || this.handleOverflow(a), u && g % u && (F = !1), F && h(a.y) ? (a.opacity = b, y[this.isNewLabel ? "attr" : "animate"](a), this.isNewLabel = !1) : (y.attr("y", -9999), this.isNewLabel = !0));
      };
      g.prototype.replaceMovedLabel = function () {
        var a = this.label,
          d = this.axis,
          e = d.reversed;
        if (a && !this.isNew) {
          var b = d.horiz ? e ? d.left : d.width + d.left : a.xy.x;
          e = d.horiz ? a.xy.y : e ? d.width + d.top : d.top;
          a.animate({
            x: b,
            y: e,
            opacity: 0
          }, void 0, a.destroy);
          delete this.label;
        }
        d.isDirty = !0;
        this.label = this.movedLabel;
        delete this.movedLabel;
      };
      return g;
    }();
    "";
    return p;
  });
  G(b, "Core/Axis/Axis.js", [b["Core/Animation/AnimationUtilities.js"], b["Core/Axis/AxisDefaults.js"], b["Core/Color/Color.js"], b["Core/DefaultOptions.js"], b["Core/Foundation.js"], b["Core/Globals.js"], b["Core/Axis/Tick.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D, B, k) {
    var t = b.animObject,
      n = E.defaultOptions,
      h = w.registerEventOptions,
      d = D.deg2rad,
      a = k.arrayMax,
      e = k.arrayMin,
      g = k.clamp,
      x = k.correctFloat,
      C = k.defined,
      r = k.destroyObjectProperties,
      q = k.erase,
      z = k.error,
      m = k.extend,
      f = k.fireEvent,
      y = k.getMagnitude,
      c = k.isArray,
      u = k.isNumber,
      l = k.isString,
      F = k.merge,
      K = k.normalizeTickInterval,
      H = k.objectEach,
      I = k.pick,
      v = k.relativeLength,
      Q = k.removeEvent,
      O = k.splat,
      R = k.syncTimeout;
    b = function () {
      function b(c, a) {
        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;
        this.init(c, a);
      }
      b.prototype.init = function (c, a) {
        var d = a.isX;
        this.chart = c;
        this.horiz = c.inverted && !this.isZAxis ? !d : d;
        this.isXAxis = d;
        this.coll = this.coll || (d ? "xAxis" : "yAxis");
        f(this, "init", {
          userOptions: a
        });
        this.opposite = I(a.opposite, this.opposite);
        this.side = I(a.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
        this.setOptions(a);
        var l = this.options,
          b = l.labels,
          e = l.type;
        this.userOptions = a;
        this.minPixelPadding = 0;
        this.reversed = I(l.reversed, this.reversed);
        this.visible = l.visible;
        this.zoomEnabled = l.zoomEnabled;
        this.hasNames = "category" === e || !0 === l.categories;
        this.categories = l.categories || this.hasNames;
        this.names || (this.names = [], this.names.keys = {});
        this.plotLinesAndBandsGroups = {};
        this.positiveValuesOnly = !!this.logarithmic;
        this.isLinked = C(l.linkedTo);
        this.ticks = {};
        this.labelEdge = [];
        this.minorTicks = {};
        this.plotLinesAndBands = [];
        this.alternateBands = {};
        this.len = 0;
        this.minRange = this.userMinRange = l.minRange || l.maxZoom;
        this.range = l.range;
        this.offset = l.offset || 0;
        this.min = this.max = null;
        a = I(l.crosshair, O(c.options.tooltip.crosshairs)[d ? 0 : 1]);
        this.crosshair = !0 === a ? {} : a;
        -1 === c.axes.indexOf(this) && (d ? c.axes.splice(c.xAxis.length, 0, this) : c.axes.push(this), c[this.coll].push(this));
        this.series = this.series || [];
        c.inverted && !this.isZAxis && d && "undefined" === typeof this.reversed && (this.reversed = !0);
        this.labelRotation = u(b.rotation) ? b.rotation : void 0;
        h(this, l);
        f(this, "afterInit");
      };
      b.prototype.setOptions = function (c) {
        this.options = F(p.defaultXAxisOptions, "yAxis" === this.coll && p.defaultYAxisOptions, [p.defaultTopAxisOptions, p.defaultRightAxisOptions, p.defaultBottomAxisOptions, p.defaultLeftAxisOptions][this.side], F(n[this.coll], c));
        f(this, "afterSetOptions", {
          userOptions: c
        });
      };
      b.prototype.defaultLabelFormatter = function (c) {
        var a = this.axis;
        c = this.chart.numberFormatter;
        var d = u(this.value) ? this.value : NaN,
          f = a.chart.time,
          l = this.dateTimeLabelFormat,
          b = n.lang,
          e = b.numericSymbols;
        b = b.numericSymbolMagnitude || 1E3;
        var g = a.logarithmic ? Math.abs(d) : a.tickInterval,
          m = e && e.length;
        if (a.categories) var h = "" + this.value;else if (l) h = f.dateFormat(l, d);else if (m && 1E3 <= g) for (; m-- && "undefined" === typeof h;) a = Math.pow(b, m + 1), g >= a && 0 === 10 * d % a && null !== e[m] && 0 !== d && (h = c(d / a, -1) + e[m]);
        "undefined" === typeof h && (h = 1E4 <= Math.abs(d) ? c(d, -1) : c(d, -1, void 0, ""));
        return h;
      };
      b.prototype.getSeriesExtremes = function () {
        var c = this,
          a = c.chart,
          d;
        f(this, "getSeriesExtremes", null, function () {
          c.hasVisibleSeries = !1;
          c.dataMin = c.dataMax = c.threshold = null;
          c.softThreshold = !c.isXAxis;
          c.stacking && c.stacking.buildStacks();
          c.series.forEach(function (f) {
            if (f.visible || !a.options.chart.ignoreHiddenSeries) {
              var l = f.options,
                b = l.threshold;
              c.hasVisibleSeries = !0;
              c.positiveValuesOnly && 0 >= b && (b = null);
              if (c.isXAxis) {
                if (l = f.xData, l.length) {
                  l = c.logarithmic ? l.filter(c.validatePositiveValue) : l;
                  d = f.getXExtremes(l);
                  var e = d.min;
                  var g = d.max;
                  u(e) || e instanceof Date || (l = l.filter(u), d = f.getXExtremes(l), e = d.min, g = d.max);
                  l.length && (c.dataMin = Math.min(I(c.dataMin, e), e), c.dataMax = Math.max(I(c.dataMax, g), g));
                }
              } else if (f = f.applyExtremes(), u(f.dataMin) && (e = f.dataMin, c.dataMin = Math.min(I(c.dataMin, e), e)), u(f.dataMax) && (g = f.dataMax, c.dataMax = Math.max(I(c.dataMax, g), g)), C(b) && (c.threshold = b), !l.softThreshold || c.positiveValuesOnly) c.softThreshold = !1;
            }
          });
        });
        f(this, "afterGetSeriesExtremes");
      };
      b.prototype.translate = function (c, a, d, f, l, b) {
        var e = this.linkedParent || this,
          g = f && e.old ? e.old.min : e.min,
          m = e.minPixelPadding;
        l = (e.isOrdinal || e.brokenAxis && e.brokenAxis.hasBreaks || e.logarithmic && l) && e.lin2val;
        var h = 1,
          y = 0;
        f = f && e.old ? e.old.transA : e.transA;
        f || (f = e.transA);
        d && (h *= -1, y = e.len);
        e.reversed && (h *= -1, y -= h * (e.sector || e.len));
        a ? (c = (c * h + y - m) / f + g, l && (c = e.lin2val(c))) : (l && (c = e.val2lin(c)), c = u(g) ? h * (c - g) * f + y + h * m + (u(b) ? f * b : 0) : void 0);
        return c;
      };
      b.prototype.toPixels = function (c, a) {
        return this.translate(c, !1, !this.horiz, null, !0) + (a ? 0 : this.pos);
      };
      b.prototype.toValue = function (c, a) {
        return this.translate(c - (a ? 0 : this.pos), !0, !this.horiz, null, !0);
      };
      b.prototype.getPlotLinePath = function (c) {
        function a(c, a, d) {
          if ("pass" !== n && c < a || c > d) n ? c = g(c, a, d) : C = !0;
          return c;
        }
        var d = this,
          l = d.chart,
          e = d.left,
          b = d.top,
          m = c.old,
          h = c.value,
          y = c.lineWidth,
          q = m && l.oldChartHeight || l.chartHeight,
          F = m && l.oldChartWidth || l.chartWidth,
          k = d.transB,
          r = c.translatedValue,
          n = c.force,
          H,
          z,
          x,
          K,
          C;
        c = {
          value: h,
          lineWidth: y,
          old: m,
          force: n,
          acrossPanes: c.acrossPanes,
          translatedValue: r
        };
        f(this, "getPlotLinePath", c, function (c) {
          r = I(r, d.translate(h, null, null, m));
          r = g(r, -1E5, 1E5);
          H = x = Math.round(r + k);
          z = K = Math.round(q - r - k);
          u(r) ? d.horiz ? (z = b, K = q - d.bottom, H = x = a(H, e, e + d.width)) : (H = e, x = F - d.right, z = K = a(z, b, b + d.height)) : (C = !0, n = !1);
          c.path = C && !n ? null : l.renderer.crispLine([["M", H, z], ["L", x, K]], y || 1);
        });
        return c.path;
      };
      b.prototype.getLinearTickPositions = function (c, a, d) {
        var f = x(Math.floor(a / c) * c);
        d = x(Math.ceil(d / c) * c);
        var l = [],
          e;
        x(f + c) === f && (e = 20);
        if (this.single) return [a];
        for (a = f; a <= d;) {
          l.push(a);
          a = x(a + c, e);
          if (a === b) break;
          var b = a;
        }
        return l;
      };
      b.prototype.getMinorTickInterval = function () {
        var c = this.options;
        return !0 === c.minorTicks ? I(c.minorTickInterval, "auto") : !1 === c.minorTicks ? null : c.minorTickInterval;
      };
      b.prototype.getMinorTickPositions = function () {
        var c = this.options,
          a = this.tickPositions,
          d = this.minorTickInterval,
          f = this.pointRangePadding || 0,
          l = this.min - f;
        f = this.max + f;
        var e = f - l,
          b = [];
        if (e && e / d < this.len / 3) {
          var g = this.logarithmic;
          if (g) this.paddedTicks.forEach(function (c, a, f) {
            a && b.push.apply(b, g.getLogTickPositions(d, f[a - 1], f[a], !0));
          });else if (this.dateTime && "auto" === this.getMinorTickInterval()) b = b.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(d), l, f, c.startOfWeek));else for (c = l + (a[0] - l) % d; c <= f && c !== b[0]; c += d) b.push(c);
        }
        0 !== b.length && this.trimTicks(b);
        return b;
      };
      b.prototype.adjustForMinRange = function () {
        var c = this.options,
          d = this.logarithmic,
          f = this.min,
          l = this.max,
          b = 0,
          g,
          m,
          h,
          u;
        this.isXAxis && "undefined" === typeof this.minRange && !d && (C(c.min) || C(c.max) || C(c.floor) || C(c.ceiling) ? this.minRange = null : (this.series.forEach(function (c) {
          h = c.xData;
          u = c.xIncrement ? 1 : h.length - 1;
          if (1 < h.length) for (g = u; 0 < g; g--) if (m = h[g] - h[g - 1], !b || m < b) b = m;
        }), this.minRange = Math.min(5 * b, this.dataMax - this.dataMin)));
        if (l - f < this.minRange) {
          var y = this.dataMax - this.dataMin >= this.minRange;
          var q = this.minRange;
          var F = (q - l + f) / 2;
          F = [f - F, I(c.min, f - F)];
          y && (F[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
          f = a(F);
          l = [f + q, I(c.max, f + q)];
          y && (l[2] = d ? d.log2lin(this.dataMax) : this.dataMax);
          l = e(l);
          l - f < q && (F[0] = l - q, F[1] = I(c.min, l - q), f = a(F));
        }
        this.min = f;
        this.max = l;
      };
      b.prototype.getClosest = function () {
        var c;
        this.categories ? c = 1 : this.series.forEach(function (a) {
          var d = a.closestPointRange,
            f = a.visible || !a.chart.options.chart.ignoreHiddenSeries;
          !a.noSharedTooltip && C(d) && f && (c = C(c) ? Math.min(c, d) : d);
        });
        return c;
      };
      b.prototype.nameToX = function (a) {
        var d = c(this.categories),
          f = d ? this.categories : this.names,
          l = a.options.x;
        a.series.requireSorting = !1;
        C(l) || (l = this.options.uniqueNames ? d ? f.indexOf(a.name) : I(f.keys[a.name], -1) : a.series.autoIncrement());
        if (-1 === l) {
          if (!d) var e = f.length;
        } else e = l;
        "undefined" !== typeof e && (this.names[e] = a.name, this.names.keys[a.name] = e);
        return e;
      };
      b.prototype.updateNames = function () {
        var c = this,
          a = this.names;
        0 < a.length && (Object.keys(a.keys).forEach(function (c) {
          delete a.keys[c];
        }), a.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (a) {
          a.xIncrement = null;
          if (!a.points || a.isDirtyData) c.max = Math.max(c.max, a.xData.length - 1), a.processData(), a.generatePoints();
          a.data.forEach(function (d, f) {
            if (d && d.options && "undefined" !== typeof d.name) {
              var l = c.nameToX(d);
              "undefined" !== typeof l && l !== d.x && (d.x = l, a.xData[f] = l);
            }
          });
        }));
      };
      b.prototype.setAxisTranslation = function () {
        var c = this,
          a = c.max - c.min,
          d = c.linkedParent,
          e = !!c.categories,
          b = c.isXAxis,
          g = c.axisPointRange || 0,
          m = 0,
          h = 0,
          u = c.transA;
        if (b || e || g) {
          var y = c.getClosest();
          d ? (m = d.minPointOffset, h = d.pointRangePadding) : c.series.forEach(function (a) {
            var d = e ? 1 : b ? I(a.options.pointRange, y, 0) : c.axisPointRange || 0,
              f = a.options.pointPlacement;
            g = Math.max(g, d);
            if (!c.single || e) a = a.is("xrange") ? !b : b, m = Math.max(m, a && l(f) ? 0 : d / 2), h = Math.max(h, a && "on" === f ? 0 : d);
          });
          d = c.ordinal && c.ordinal.slope && y ? c.ordinal.slope / y : 1;
          c.minPointOffset = m *= d;
          c.pointRangePadding = h *= d;
          c.pointRange = Math.min(g, c.single && e ? 1 : a);
          b && (c.closestPointRange = y);
        }
        c.translationSlope = c.transA = u = c.staticScale || c.len / (a + h || 1);
        c.transB = c.horiz ? c.left : c.bottom;
        c.minPixelPadding = u * m;
        f(this, "afterSetAxisTranslation");
      };
      b.prototype.minFromRange = function () {
        return this.max - this.range;
      };
      b.prototype.setTickInterval = function (c) {
        var a = this.chart,
          d = this.logarithmic,
          l = this.options,
          e = this.isXAxis,
          b = this.isLinked,
          g = l.tickPixelInterval,
          m = this.categories,
          h = this.softThreshold,
          q = l.maxPadding,
          F = l.minPadding,
          r = u(l.tickInterval) && 0 <= l.tickInterval ? l.tickInterval : void 0,
          k = u(this.threshold) ? this.threshold : null;
        this.dateTime || m || b || this.getTickAmount();
        var n = I(this.userMin, l.min);
        var H = I(this.userMax, l.max);
        if (b) {
          this.linkedParent = a[this.coll][l.linkedTo];
          var t = this.linkedParent.getExtremes();
          this.min = I(t.min, t.dataMin);
          this.max = I(t.max, t.dataMax);
          l.type !== this.linkedParent.options.type && z(11, 1, a);
        } else {
          if (h && C(k)) if (this.dataMin >= k) t = k, F = 0;else if (this.dataMax <= k) {
            var v = k;
            q = 0;
          }
          this.min = I(n, t, this.dataMin);
          this.max = I(H, v, this.dataMax);
        }
        d && (this.positiveValuesOnly && !c && 0 >= Math.min(this.min, I(this.dataMin, this.min)) && z(10, 1, a), this.min = x(d.log2lin(this.min), 16), this.max = x(d.log2lin(this.max), 16));
        this.range && C(this.max) && (this.userMin = this.min = n = Math.max(this.dataMin, this.minFromRange()), this.userMax = H = this.max, this.range = null);
        f(this, "foundExtremes");
        this.beforePadding && this.beforePadding();
        this.adjustForMinRange();
        !(m || this.axisPointRange || this.stacking && this.stacking.usePercentage || b) && C(this.min) && C(this.max) && (a = this.max - this.min) && (!C(n) && F && (this.min -= a * F), !C(H) && q && (this.max += a * q));
        u(this.userMin) || (u(l.softMin) && l.softMin < this.min && (this.min = n = l.softMin), u(l.floor) && (this.min = Math.max(this.min, l.floor)));
        u(this.userMax) || (u(l.softMax) && l.softMax > this.max && (this.max = H = l.softMax), u(l.ceiling) && (this.max = Math.min(this.max, l.ceiling)));
        h && C(this.dataMin) && (k = k || 0, !C(n) && this.min < k && this.dataMin >= k ? this.min = this.options.minRange ? Math.min(k, this.max - this.minRange) : k : !C(H) && this.max > k && this.dataMax <= k && (this.max = this.options.minRange ? Math.max(k, this.min + this.minRange) : k));
        u(this.min) && u(this.max) && !this.chart.polar && this.min > this.max && (C(this.options.min) ? this.max = this.min : C(this.options.max) && (this.min = this.max));
        this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : b && this.linkedParent && !r && g === this.linkedParent.options.tickPixelInterval ? r = this.linkedParent.tickInterval : I(r, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, m ? 1 : (this.max - this.min) * g / Math.max(this.len, g));
        if (e && !c) {
          var p = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
          this.series.forEach(function (c) {
            c.forceCrop = c.forceCropping && c.forceCropping();
            c.processData(p);
          });
          f(this, "postProcessData", {
            hasExtemesChanged: p
          });
        }
        this.setAxisTranslation();
        f(this, "initialAxisTranslation");
        this.pointRange && !r && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
        c = I(l.minTickInterval, this.dateTime && !this.series.some(function (c) {
          return c.noSharedTooltip;
        }) ? this.closestPointRange : 0);
        !r && this.tickInterval < c && (this.tickInterval = c);
        this.dateTime || this.logarithmic || r || (this.tickInterval = K(this.tickInterval, void 0, y(this.tickInterval), I(l.allowDecimals, .5 > this.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));
        this.tickAmount || (this.tickInterval = this.unsquish());
        this.setTickPositions();
      };
      b.prototype.setTickPositions = function () {
        var c = this.options,
          a = c.tickPositions,
          d = this.getMinorTickInterval(),
          l = this.hasVerticalPanning(),
          e = "colorAxis" === this.coll,
          b = (e || !l) && c.startOnTick;
        l = (e || !l) && c.endOnTick;
        e = c.tickPositioner;
        this.tickmarkOffset = this.categories && "between" === c.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
        this.minorTickInterval = "auto" === d && this.tickInterval ? this.tickInterval / 5 : d;
        this.single = this.min === this.max && C(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== c.allowDecimals);
        this.tickPositions = d = a && a.slice();
        !d && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? d = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, c.units), this.min, this.max, c.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (d = [this.min, this.max], z(19, !1, this.chart)), d.length > this.len && (d = [d[0], d.pop()], d[0] === d[1] && (d.length = 1)), this.tickPositions = d, e && (e = e.apply(this, [this.min, this.max]))) && (this.tickPositions = d = e);
        this.paddedTicks = d.slice(0);
        this.trimTicks(d, b, l);
        this.isLinked || (this.single && 2 > d.length && !this.categories && !this.series.some(function (c) {
          return c.is("heatmap") && "between" === c.options.pointPlacement;
        }) && (this.min -= .5, this.max += .5), a || e || this.adjustTickAmount());
        f(this, "afterSetTickPositions");
      };
      b.prototype.trimTicks = function (c, a, d) {
        var l = c[0],
          e = c[c.length - 1],
          b = !this.isOrdinal && this.minPointOffset || 0;
        f(this, "trimTicks");
        if (!this.isLinked) {
          if (a && -Infinity !== l) this.min = l;else for (; this.min - b > c[0];) c.shift();
          if (d) this.max = e;else for (; this.max + b < c[c.length - 1];) c.pop();
          0 === c.length && C(l) && !this.options.tickPositions && c.push((e + l) / 2);
        }
      };
      b.prototype.alignToOthers = function () {
        var c = {},
          a = this.options,
          d;
        !1 !== this.chart.options.chart.alignTicks && a.alignTicks && !1 !== a.startOnTick && !1 !== a.endOnTick && !this.logarithmic && this.chart[this.coll].forEach(function (a) {
          var f = a.options;
          f = [a.horiz ? f.left : f.top, f.width, f.height, f.pane].join();
          a.series.length && (c[f] ? d = !0 : c[f] = 1);
        });
        return d;
      };
      b.prototype.getTickAmount = function () {
        var c = this.options,
          a = c.tickPixelInterval,
          d = c.tickAmount;
        !C(c.tickInterval) && !d && this.len < a && !this.isRadial && !this.logarithmic && c.startOnTick && c.endOnTick && (d = 2);
        !d && this.alignToOthers() && (d = Math.ceil(this.len / a) + 1);
        4 > d && (this.finalTickAmt = d, d = 5);
        this.tickAmount = d;
      };
      b.prototype.adjustTickAmount = function () {
        var c = this.options,
          a = this.tickInterval,
          d = this.tickPositions,
          f = this.tickAmount,
          l = this.finalTickAmt,
          e = d && d.length,
          b = I(this.threshold, this.softThreshold ? 0 : null);
        if (this.hasData() && u(this.min) && u(this.max)) {
          if (e < f) {
            for (; d.length < f;) d.length % 2 || this.min === b ? d.push(x(d[d.length - 1] + a)) : d.unshift(x(d[0] - a));
            this.transA *= (e - 1) / (f - 1);
            this.min = c.startOnTick ? d[0] : Math.min(this.min, d[0]);
            this.max = c.endOnTick ? d[d.length - 1] : Math.max(this.max, d[d.length - 1]);
          } else e > f && (this.tickInterval *= 2, this.setTickPositions());
          if (C(l)) {
            for (a = c = d.length; a--;) (3 === l && 1 === a % 2 || 2 >= l && 0 < a && a < c - 1) && d.splice(a, 1);
            this.finalTickAmt = void 0;
          }
        }
      };
      b.prototype.setScale = function () {
        var c = !1,
          a = !1;
        this.series.forEach(function (d) {
          c = c || d.isDirtyData || d.isDirty;
          a = a || d.xAxis && d.xAxis.isDirty || !1;
        });
        this.setAxisSize();
        var d = this.len !== (this.old && this.old.len);
        d || c || a || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = d || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
        c && this.panningState && (this.panningState.isDirty = !0);
        f(this, "afterSetScale");
      };
      b.prototype.setExtremes = function (c, a, d, l, e) {
        var b = this,
          g = b.chart;
        d = I(d, !0);
        b.series.forEach(function (c) {
          delete c.kdTree;
        });
        e = m(e, {
          min: c,
          max: a
        });
        f(b, "setExtremes", e, function () {
          b.userMin = c;
          b.userMax = a;
          b.eventArgs = e;
          d && g.redraw(l);
        });
      };
      b.prototype.zoom = function (c, a) {
        var d = this,
          l = this.dataMin,
          e = this.dataMax,
          b = this.options,
          g = Math.min(l, I(b.min, l)),
          m = Math.max(e, I(b.max, e));
        c = {
          newMin: c,
          newMax: a
        };
        f(this, "zoom", c, function (c) {
          var a = c.newMin,
            f = c.newMax;
          if (a !== d.min || f !== d.max) d.allowZoomOutside || (C(l) && (a < g && (a = g), a > m && (a = m)), C(e) && (f < g && (f = g), f > m && (f = m))), d.displayBtn = "undefined" !== typeof a || "undefined" !== typeof f, d.setExtremes(a, f, !1, void 0, {
            trigger: "zoom"
          });
          c.zoomed = !0;
        });
        return c.zoomed;
      };
      b.prototype.setAxisSize = function () {
        var c = this.chart,
          a = this.options,
          d = a.offsets || [0, 0, 0, 0],
          f = this.horiz,
          l = this.width = Math.round(v(I(a.width, c.plotWidth - d[3] + d[1]), c.plotWidth)),
          e = this.height = Math.round(v(I(a.height, c.plotHeight - d[0] + d[2]), c.plotHeight)),
          b = this.top = Math.round(v(I(a.top, c.plotTop + d[0]), c.plotHeight, c.plotTop));
        a = this.left = Math.round(v(I(a.left, c.plotLeft + d[3]), c.plotWidth, c.plotLeft));
        this.bottom = c.chartHeight - e - b;
        this.right = c.chartWidth - l - a;
        this.len = Math.max(f ? l : e, 0);
        this.pos = f ? a : b;
      };
      b.prototype.getExtremes = function () {
        var c = this.logarithmic;
        return {
          min: c ? x(c.lin2log(this.min)) : this.min,
          max: c ? x(c.lin2log(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        };
      };
      b.prototype.getThreshold = function (c) {
        var a = this.logarithmic,
          d = a ? a.lin2log(this.min) : this.min;
        a = a ? a.lin2log(this.max) : this.max;
        null === c || -Infinity === c ? c = d : Infinity === c ? c = a : d > c ? c = d : a < c && (c = a);
        return this.translate(c, 0, 1, 0, 1);
      };
      b.prototype.autoLabelAlign = function (c) {
        var a = (I(c, 0) - 90 * this.side + 720) % 360;
        c = {
          align: "center"
        };
        f(this, "autoLabelAlign", c, function (c) {
          15 < a && 165 > a ? c.align = "right" : 195 < a && 345 > a && (c.align = "left");
        });
        return c.align;
      };
      b.prototype.tickSize = function (c) {
        var a = this.options,
          d = I(a["tick" === c ? "tickWidth" : "minorTickWidth"], "tick" === c && this.isXAxis && !this.categories ? 1 : 0),
          l = a["tick" === c ? "tickLength" : "minorTickLength"];
        if (d && l) {
          "inside" === a[c + "Position"] && (l = -l);
          var e = [l, d];
        }
        c = {
          tickSize: e
        };
        f(this, "afterTickSize", c);
        return c.tickSize;
      };
      b.prototype.labelMetrics = function () {
        var c = this.tickPositions && this.tickPositions[0] || 0;
        return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[c] && this.ticks[c].label);
      };
      b.prototype.unsquish = function () {
        var c = this.options.labels,
          a = this.horiz,
          f = this.tickInterval,
          l = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / f),
          e = c.rotation,
          b = this.labelMetrics(),
          g = Math.max(this.max - this.min, 0),
          m = function (c) {
            var a = c / (l || 1);
            a = 1 < a ? Math.ceil(a) : 1;
            a * f > g && Infinity !== c && Infinity !== l && g && (a = Math.ceil(g / f));
            return x(a * f);
          },
          h = f,
          y,
          q,
          F = Number.MAX_VALUE;
        if (a) {
          if (!c.staggerLines && !c.step) if (u(e)) var k = [e];else l < c.autoRotationLimit && (k = c.autoRotation);
          k && k.forEach(function (c) {
            if (c === e || c && -90 <= c && 90 >= c) {
              q = m(Math.abs(b.h / Math.sin(d * c)));
              var a = q + Math.abs(c / 360);
              a < F && (F = a, y = c, h = q);
            }
          });
        } else c.step || (h = m(b.h));
        this.autoRotation = k;
        this.labelRotation = I(y, u(e) ? e : 0);
        return h;
      };
      b.prototype.getSlotWidth = function (c) {
        var a = this.chart,
          d = this.horiz,
          f = this.options.labels,
          l = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
          e = a.margin[3];
        if (c && u(c.slotWidth)) return c.slotWidth;
        if (d && 2 > f.step) return f.rotation ? 0 : (this.staggerLines || 1) * this.len / l;
        if (!d) {
          c = f.style.width;
          if (void 0 !== c) return parseInt(String(c), 10);
          if (e) return e - a.spacing[3];
        }
        return .33 * a.chartWidth;
      };
      b.prototype.renderUnsquish = function () {
        var c = this.chart,
          a = c.renderer,
          d = this.tickPositions,
          f = this.ticks,
          e = this.options.labels,
          b = e.style,
          g = this.horiz,
          m = this.getSlotWidth(),
          h = Math.max(1, Math.round(m - 2 * e.padding)),
          u = {},
          y = this.labelMetrics(),
          q = b.textOverflow,
          F = 0;
        l(e.rotation) || (u.rotation = e.rotation || 0);
        d.forEach(function (c) {
          c = f[c];
          c.movedLabel && c.replaceMovedLabel();
          c && c.label && c.label.textPxLength > F && (F = c.label.textPxLength);
        });
        this.maxLabelLength = F;
        if (this.autoRotation) F > h && F > y.h ? u.rotation = this.labelRotation : this.labelRotation = 0;else if (m) {
          var k = h;
          if (!q) {
            var r = "clip";
            for (h = d.length; !g && h--;) {
              var n = d[h];
              if (n = f[n].label) n.styles && "ellipsis" === n.styles.textOverflow ? n.css({
                textOverflow: "clip"
              }) : n.textPxLength > m && n.css({
                width: m + "px"
              }), n.getBBox().height > this.len / d.length - (y.h - y.f) && (n.specificTextOverflow = "ellipsis");
            }
          }
        }
        u.rotation && (k = F > .5 * c.chartHeight ? .33 * c.chartHeight : F, q || (r = "ellipsis"));
        if (this.labelAlign = e.align || this.autoLabelAlign(this.labelRotation)) u.align = this.labelAlign;
        d.forEach(function (c) {
          var a = (c = f[c]) && c.label,
            d = b.width,
            l = {};
          a && (a.attr(u), c.shortenLabel ? c.shortenLabel() : k && !d && "nowrap" !== b.whiteSpace && (k < a.textPxLength || "SPAN" === a.element.tagName) ? (l.width = k + "px", q || (l.textOverflow = a.specificTextOverflow || r), a.css(l)) : a.styles && a.styles.width && !l.width && !d && a.css({
            width: null
          }), delete a.specificTextOverflow, c.rotation = u.rotation);
        }, this);
        this.tickRotCorr = a.rotCorr(y.b, this.labelRotation || 0, 0 !== this.side);
      };
      b.prototype.hasData = function () {
        return this.series.some(function (c) {
          return c.hasData();
        }) || this.options.showEmpty && C(this.min) && C(this.max);
      };
      b.prototype.addTitle = function (c) {
        var a = this.chart.renderer,
          d = this.horiz,
          f = this.opposite,
          l = this.options.title,
          e = this.chart.styledMode,
          b;
        this.axisTitle || ((b = l.textAlign) || (b = (d ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: f ? "right" : "left",
          middle: "center",
          high: f ? "left" : "right"
        })[l.align]), this.axisTitle = a.text(l.text || "", 0, 0, l.useHTML).attr({
          zIndex: 7,
          rotation: l.rotation,
          align: b
        }).addClass("highcharts-axis-title"), e || this.axisTitle.css(F(l.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
        e || l.style.width || this.isRadial || this.axisTitle.css({
          width: this.len + "px"
        });
        this.axisTitle[c ? "show" : "hide"](c);
      };
      b.prototype.generateTick = function (c) {
        var a = this.ticks;
        a[c] ? a[c].addLabel() : a[c] = new B(this, c);
      };
      b.prototype.getOffset = function () {
        var c = this,
          a = this,
          d = a.chart,
          l = a.horiz,
          e = a.options,
          b = a.side,
          g = a.ticks,
          m = a.tickPositions,
          h = a.coll,
          u = a.axisParent,
          y = d.renderer,
          q = d.inverted && !a.isZAxis ? [1, 0, 3, 2][b] : b,
          F = a.hasData(),
          k = e.title,
          r = e.labels,
          n = d.axisOffset;
        d = d.clipOffset;
        var z = [-1, 1, 1, -1][b],
          x = e.className,
          K,
          t = 0,
          v = 0,
          p = 0;
        a.showAxis = K = F || e.showEmpty;
        a.staggerLines = a.horiz && r.staggerLines || void 0;
        if (!a.axisGroup) {
          var B = function (a, d, f) {
            return y.g(a).attr({
              zIndex: f
            }).addClass("highcharts-" + h.toLowerCase() + d + " " + (c.isRadial ? "highcharts-radial-axis" + d + " " : "") + (x || "")).add(u);
          };
          a.gridGroup = B("grid", "-grid", e.gridZIndex);
          a.axisGroup = B("axis", "", e.zIndex);
          a.labelGroup = B("axis-labels", "-labels", r.zIndex);
        }
        F || a.isLinked ? (m.forEach(function (c) {
          a.generateTick(c);
        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === b || 2 === b || {
          1: "left",
          3: "right"
        }[b] === a.labelAlign, I(r.reserveSpace, "center" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && m.forEach(function (c) {
          p = Math.max(g[c].getLabelSize(), p);
        }), a.staggerLines && (p *= a.staggerLines), a.labelOffset = p * (a.opposite ? -1 : 1)) : H(g, function (c, a) {
          c.destroy();
          delete g[a];
        });
        if (k && k.text && !1 !== k.enabled && (a.addTitle(K), K && !1 !== k.reserveSpace)) {
          a.titleOffset = t = a.axisTitle.getBBox()[l ? "height" : "width"];
          var Z = k.offset;
          v = C(Z) ? 0 : I(k.margin, l ? 5 : 10);
        }
        a.renderLine();
        a.offset = z * I(e.offset, n[b] ? n[b] + (e.margin || 0) : 0);
        a.tickRotCorr = a.tickRotCorr || {
          x: 0,
          y: 0
        };
        k = 0 === b ? -a.labelMetrics().h : 2 === b ? a.tickRotCorr.y : 0;
        F = Math.abs(p) + v;
        p && (F = F - k + z * (l ? I(r.y, a.tickRotCorr.y + 8 * z) : r.x));
        a.axisTitleMargin = I(Z, F);
        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(g, m));
        "colorAxis" !== h && (l = this.tickSize("tick"), n[b] = Math.max(n[b], (a.axisTitleMargin || 0) + t + z * a.offset, F, m && m.length && l ? l[0] + z * a.offset : 0), e = !a.axisLine || e.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2), d[q] = Math.max(d[q], e));
        f(this, "afterGetOffset");
      };
      b.prototype.getLinePath = function (c) {
        var a = this.chart,
          d = this.opposite,
          f = this.offset,
          l = this.horiz,
          e = this.left + (d ? this.width : 0) + f;
        f = a.chartHeight - this.bottom - (d ? this.height : 0) + f;
        d && (c *= -1);
        return a.renderer.crispLine([["M", l ? this.left : e, l ? f : this.top], ["L", l ? a.chartWidth - this.right : e, l ? f : a.chartHeight - this.bottom]], c);
      };
      b.prototype.renderLine = function () {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        }));
      };
      b.prototype.getTitlePosition = function () {
        var c = this.horiz,
          a = this.left,
          d = this.top,
          l = this.len,
          e = this.options.title,
          b = c ? a : d,
          g = this.opposite,
          m = this.offset,
          h = e.x,
          u = e.y,
          y = this.axisTitle,
          q = this.chart.renderer.fontMetrics(e.style.fontSize, y);
        y = Math.max(y.getBBox(null, 0).height - q.h - 1, 0);
        l = {
          low: b + (c ? 0 : l),
          middle: b + l / 2,
          high: b + (c ? l : 0)
        }[e.align];
        a = (c ? d + this.height : a) + (c ? 1 : -1) * (g ? -1 : 1) * this.axisTitleMargin + [-y, y, q.f, -y][this.side];
        c = {
          x: c ? l + h : a + (g ? this.width : 0) + m + h,
          y: c ? a + u - (g ? this.height : 0) + m : l + u
        };
        f(this, "afterGetTitlePosition", {
          titlePosition: c
        });
        return c;
      };
      b.prototype.renderMinorTick = function (c, a) {
        var d = this.minorTicks;
        d[c] || (d[c] = new B(this, c, "minor"));
        a && d[c].isNew && d[c].render(null, !0);
        d[c].render(null, !1, 1);
      };
      b.prototype.renderTick = function (c, a, d) {
        var f = this.ticks;
        if (!this.isLinked || c >= this.min && c <= this.max || this.grid && this.grid.isColumn) f[c] || (f[c] = new B(this, c)), d && f[c].isNew && f[c].render(a, !0, -1), f[c].render(a);
      };
      b.prototype.render = function () {
        var c = this,
          a = c.chart,
          d = c.logarithmic,
          l = c.options,
          e = c.isLinked,
          b = c.tickPositions,
          g = c.axisTitle,
          m = c.ticks,
          h = c.minorTicks,
          y = c.alternateBands,
          q = l.stackLabels,
          F = l.alternateGridColor,
          k = c.tickmarkOffset,
          r = c.axisLine,
          n = c.showAxis,
          z = t(a.renderer.globalAnimation),
          x,
          K;
        c.labelEdge.length = 0;
        c.overlap = !1;
        [m, h, y].forEach(function (c) {
          H(c, function (c) {
            c.isActive = !1;
          });
        });
        if (c.hasData() || e) {
          var C = c.chart.hasRendered && c.old && u(c.old.min);
          c.minorTickInterval && !c.categories && c.getMinorTickPositions().forEach(function (a) {
            c.renderMinorTick(a, C);
          });
          b.length && (b.forEach(function (a, d) {
            c.renderTick(a, d, C);
          }), k && (0 === c.min || c.single) && (m[-1] || (m[-1] = new B(c, -1, null, !0)), m[-1].render(-1)));
          F && b.forEach(function (f, l) {
            K = "undefined" !== typeof b[l + 1] ? b[l + 1] + k : c.max - k;
            0 === l % 2 && f < c.max && K <= c.max + (a.polar ? -k : k) && (y[f] || (y[f] = new D.PlotLineOrBand(c)), x = f + k, y[f].options = {
              from: d ? d.lin2log(x) : x,
              to: d ? d.lin2log(K) : K,
              color: F,
              className: "highcharts-alternate-grid"
            }, y[f].render(), y[f].isActive = !0);
          });
          c._addedPlotLB || (c._addedPlotLB = !0, (l.plotLines || []).concat(l.plotBands || []).forEach(function (a) {
            c.addPlotBandOrLine(a);
          }));
        }
        [m, h, y].forEach(function (c) {
          var d = [],
            f = z.duration;
          H(c, function (c, a) {
            c.isActive || (c.render(a, !1, 0), c.isActive = !1, d.push(a));
          });
          R(function () {
            for (var a = d.length; a--;) c[d[a]] && !c[d[a]].isActive && (c[d[a]].destroy(), delete c[d[a]]);
          }, c !== y && a.hasRendered && f ? f : 0);
        });
        r && (r[r.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(r.strokeWidth())
        }), r.isPlaced = !0, r[n ? "show" : "hide"](n));
        g && n && (l = c.getTitlePosition(), u(l.y) ? (g[g.isNew ? "attr" : "animate"](l), g.isNew = !1) : (g.attr("y", -9999), g.isNew = !0));
        q && q.enabled && c.stacking && c.stacking.renderStackTotals();
        c.old = {
          len: c.len,
          max: c.max,
          min: c.min,
          transA: c.transA,
          userMax: c.userMax,
          userMin: c.userMin
        };
        c.isDirty = !1;
        f(this, "afterRender");
      };
      b.prototype.redraw = function () {
        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (c) {
          c.render();
        }));
        this.series.forEach(function (c) {
          c.isDirty = !0;
        });
      };
      b.prototype.getKeepProps = function () {
        return this.keepProps || b.keepProps;
      };
      b.prototype.destroy = function (c) {
        var a = this,
          d = a.plotLinesAndBands,
          l = this.eventOptions;
        f(this, "destroy", {
          keepEvents: c
        });
        c || Q(a);
        [a.ticks, a.minorTicks, a.alternateBands].forEach(function (c) {
          r(c);
        });
        if (d) for (c = d.length; c--;) d[c].destroy();
        "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (c) {
          a[c] && (a[c] = a[c].destroy());
        });
        for (var e in a.plotLinesAndBandsGroups) a.plotLinesAndBandsGroups[e] = a.plotLinesAndBandsGroups[e].destroy();
        H(a, function (c, d) {
          -1 === a.getKeepProps().indexOf(d) && delete a[d];
        });
        this.eventOptions = l;
      };
      b.prototype.drawCrosshair = function (c, a) {
        var d = this.crosshair,
          l = I(d && d.snap, !0),
          e = this.chart,
          b,
          g = this.cross;
        f(this, "drawCrosshair", {
          e: c,
          point: a
        });
        c || (c = this.cross && this.cross.e);
        if (d && !1 !== (C(a) || !l)) {
          l ? C(a) && (b = I("colorAxis" !== this.coll ? a.crosshairPos : null, this.isXAxis ? a.plotX : this.len - a.plotY)) : b = c && (this.horiz ? c.chartX - this.pos : this.len - c.chartY + this.pos);
          if (C(b)) {
            var h = {
              value: a && (this.isXAxis ? a.x : I(a.stackY, a.y)),
              translatedValue: b
            };
            e.polar && m(h, {
              isCrosshair: !0,
              chartX: c && c.chartX,
              chartY: c && c.chartY,
              point: a
            });
            h = this.getPlotLinePath(h) || null;
          }
          if (!C(h)) {
            this.hideCrosshair();
            return;
          }
          l = this.categories && !this.isRadial;
          g || (this.cross = g = e.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (l ? "category " : "thin ") + (d.className || "")).attr({
            zIndex: I(d.zIndex, 2)
          }).add(), e.styledMode || (g.attr({
            stroke: d.color || (l ? A.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
            "stroke-width": I(d.width, 1)
          }).css({
            "pointer-events": "none"
          }), d.dashStyle && g.attr({
            dashstyle: d.dashStyle
          })));
          g.show().attr({
            d: h
          });
          l && !d.width && g.attr({
            "stroke-width": this.transA
          });
          this.cross.e = c;
        } else this.hideCrosshair();
        f(this, "afterDrawCrosshair", {
          e: c,
          point: a
        });
      };
      b.prototype.hideCrosshair = function () {
        this.cross && this.cross.hide();
        f(this, "afterHideCrosshair");
      };
      b.prototype.hasVerticalPanning = function () {
        var c = this.chart.options.chart.panning;
        return !!(c && c.enabled && /y/.test(c.type));
      };
      b.prototype.validatePositiveValue = function (c) {
        return u(c) && 0 < c;
      };
      b.prototype.update = function (c, a) {
        var d = this.chart;
        c = F(this.userOptions, c);
        this.destroy(!0);
        this.init(d, c);
        d.isDirtyBox = !0;
        I(a, !0) && d.redraw();
      };
      b.prototype.remove = function (c) {
        for (var a = this.chart, d = this.coll, f = this.series, l = f.length; l--;) f[l] && f[l].remove(!1);
        q(a.axes, this);
        q(a[d], this);
        a[d].forEach(function (c, a) {
          c.options.index = c.userOptions.index = a;
        });
        this.destroy();
        a.isDirtyBox = !0;
        I(c, !0) && a.redraw();
      };
      b.prototype.setTitle = function (c, a) {
        this.update({
          title: c
        }, a);
      };
      b.prototype.setCategories = function (c, a) {
        this.update({
          categories: c
        }, a);
      };
      b.defaultOptions = p.defaultXAxisOptions;
      b.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
      return b;
    }();
    "";
    return b;
  });
  G(b, "Core/Axis/DateTimeAxis.js", [b["Core/Utilities.js"]], function (b) {
    var v = b.addEvent,
      A = b.getMagnitude,
      E = b.normalizeTickInterval,
      w = b.timeUnits,
      D;
    (function (b) {
      function k() {
        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
      }
      function t(d) {
        "datetime" !== d.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new h(this));
      }
      var n = [];
      b.compose = function (d) {
        -1 === n.indexOf(d) && (n.push(d), d.keepProps.push("dateTime"), d.prototype.getTimeTicks = k, v(d, "init", t));
        return d;
      };
      var h = function () {
        function d(a) {
          this.axis = a;
        }
        d.prototype.normalizeTimeTickInterval = function (a, d) {
          var e = d || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
          d = e[e.length - 1];
          var b = w[d[0]],
            h = d[1],
            k;
          for (k = 0; k < e.length && !(d = e[k], b = w[d[0]], h = d[1], e[k + 1] && a <= (b * h[h.length - 1] + w[e[k + 1][0]]) / 2); k++);
          b === w.year && a < 5 * b && (h = [1, 2, 5]);
          a = E(a / b, h, "year" === d[0] ? Math.max(A(a / b), 1) : 1);
          return {
            unitRange: b,
            count: a,
            unitName: d[0]
          };
        };
        d.prototype.getXDateFormat = function (a, d) {
          var b = this.axis;
          return b.closestPointRange ? b.chart.time.getDateFormat(b.closestPointRange, a, b.options.startOfWeek, d) || d.year : d.day;
        };
        return d;
      }();
      b.Additions = h;
    })(D || (D = {}));
    return D;
  });
  G(b, "Core/Axis/LogarithmicAxis.js", [b["Core/Utilities.js"]], function (b) {
    var v = b.addEvent,
      A = b.getMagnitude,
      E = b.normalizeTickInterval,
      w = b.pick,
      D;
    (function (b) {
      function k(d) {
        var a = this.logarithmic;
        "logarithmic" !== d.userOptions.type ? this.logarithmic = void 0 : a || (this.logarithmic = new h(this));
      }
      function t() {
        var d = this.logarithmic;
        d && (this.lin2val = function (a) {
          return d.lin2log(a);
        }, this.val2lin = function (a) {
          return d.log2lin(a);
        });
      }
      var n = [];
      b.compose = function (d) {
        -1 === n.indexOf(d) && (n.push(d), d.keepProps.push("logarithmic"), v(d, "init", k), v(d, "afterInit", t));
        return d;
      };
      var h = function () {
        function d(a) {
          this.axis = a;
        }
        d.prototype.getLogTickPositions = function (a, d, b, h) {
          var e = this.axis,
            g = e.len,
            q = e.options,
            k = [];
          h || (this.minorAutoInterval = void 0);
          if (.5 <= a) a = Math.round(a), k = e.getLinearTickPositions(a, d, b);else if (.08 <= a) {
            var m = Math.floor(d),
              f,
              y = q = void 0;
            for (g = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; m < b + 1 && !y; m++) {
              var c = g.length;
              for (f = 0; f < c && !y; f++) {
                var u = this.log2lin(this.lin2log(m) * g[f]);
                u > d && (!h || q <= b) && "undefined" !== typeof q && k.push(q);
                q > b && (y = !0);
                q = u;
              }
            }
          } else d = this.lin2log(d), b = this.lin2log(b), a = h ? e.getMinorTickInterval() : q.tickInterval, a = w("auto" === a ? null : a, this.minorAutoInterval, q.tickPixelInterval / (h ? 5 : 1) * (b - d) / ((h ? g / e.tickPositions.length : g) || 1)), a = E(a, void 0, A(a)), k = e.getLinearTickPositions(a, d, b).map(this.log2lin), h || (this.minorAutoInterval = a / 5);
          h || (e.tickInterval = a);
          return k;
        };
        d.prototype.lin2log = function (a) {
          return Math.pow(10, a);
        };
        d.prototype.log2lin = function (a) {
          return Math.log(a) / Math.LN10;
        };
        return d;
      }();
      b.Additions = h;
    })(D || (D = {}));
    return D;
  });
  G(b, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [b["Core/Utilities.js"]], function (b) {
    var v = b.erase,
      A = b.extend,
      E = b.isNumber,
      w;
    (function (b) {
      var p = [],
        k;
      b.compose = function (b, h) {
        k || (k = b);
        -1 === p.indexOf(h) && (p.push(h), A(h.prototype, t.prototype));
        return h;
      };
      var t = function () {
        function b() {}
        b.prototype.getPlotBandPath = function (b, d, a) {
          void 0 === a && (a = this.options);
          var e = this.getPlotLinePath({
              value: d,
              force: !0,
              acrossPanes: a.acrossPanes
            }),
            g = [],
            h = this.horiz;
          d = !E(this.min) || !E(this.max) || b < this.min && d < this.min || b > this.max && d > this.max;
          b = this.getPlotLinePath({
            value: b,
            force: !0,
            acrossPanes: a.acrossPanes
          });
          a = 1;
          if (b && e) {
            if (d) {
              var k = b.toString() === e.toString();
              a = 0;
            }
            for (d = 0; d < b.length; d += 2) {
              var r = b[d],
                q = b[d + 1],
                n = e[d],
                m = e[d + 1];
              "M" !== r[0] && "L" !== r[0] || "M" !== q[0] && "L" !== q[0] || "M" !== n[0] && "L" !== n[0] || "M" !== m[0] && "L" !== m[0] || (h && n[1] === r[1] ? (n[1] += a, m[1] += a) : h || n[2] !== r[2] || (n[2] += a, m[2] += a), g.push(["M", r[1], r[2]], ["L", q[1], q[2]], ["L", m[1], m[2]], ["L", n[1], n[2]], ["Z"]));
              g.isFlat = k;
            }
          }
          return g;
        };
        b.prototype.addPlotBand = function (b) {
          return this.addPlotBandOrLine(b, "plotBands");
        };
        b.prototype.addPlotLine = function (b) {
          return this.addPlotBandOrLine(b, "plotLines");
        };
        b.prototype.addPlotBandOrLine = function (b, d) {
          var a = this,
            e = this.userOptions,
            g = new k(this, b);
          this.visible && (g = g.render());
          if (g) {
            this._addedPlotLB || (this._addedPlotLB = !0, (e.plotLines || []).concat(e.plotBands || []).forEach(function (d) {
              a.addPlotBandOrLine(d);
            }));
            if (d) {
              var h = e[d] || [];
              h.push(b);
              e[d] = h;
            }
            this.plotLinesAndBands.push(g);
          }
          return g;
        };
        b.prototype.removePlotBandOrLine = function (b) {
          var d = this.plotLinesAndBands,
            a = this.options,
            e = this.userOptions;
          if (d) {
            for (var g = d.length; g--;) d[g].id === b && d[g].destroy();
            [a.plotLines || [], e.plotLines || [], a.plotBands || [], e.plotBands || []].forEach(function (a) {
              for (g = a.length; g--;) (a[g] || {}).id === b && v(a, a[g]);
            });
          }
        };
        b.prototype.removePlotBand = function (b) {
          this.removePlotBandOrLine(b);
        };
        b.prototype.removePlotLine = function (b) {
          this.removePlotBandOrLine(b);
        };
        return b;
      }();
    })(w || (w = {}));
    return w;
  });
  G(b, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [b["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = p.arrayMax,
      E = p.arrayMin,
      w = p.defined,
      D = p.destroyObjectProperties,
      B = p.erase,
      k = p.fireEvent,
      t = p.merge,
      n = p.objectEach,
      h = p.pick;
    p = function () {
      function d(a, d) {
        this.axis = a;
        d && (this.options = d, this.id = d.id);
      }
      d.compose = function (a) {
        return b.compose(d, a);
      };
      d.prototype.render = function () {
        k(this, "render");
        var a = this,
          d = a.axis,
          b = d.horiz,
          x = d.logarithmic,
          C = a.options,
          r = C.color,
          q = h(C.zIndex, 0),
          z = C.events,
          m = {},
          f = d.chart.renderer,
          y = C.label,
          c = a.label,
          u = C.to,
          l = C.from,
          F = C.value,
          K = a.svgElem,
          H = [],
          I = w(l) && w(u);
        H = w(F);
        var v = !K,
          p = {
            "class": "highcharts-plot-" + (I ? "band " : "line ") + (C.className || "")
          },
          B = I ? "bands" : "lines";
        x && (l = x.log2lin(l), u = x.log2lin(u), F = x.log2lin(F));
        d.chart.styledMode || (H ? (p.stroke = r || "#999999", p["stroke-width"] = h(C.width, 1), C.dashStyle && (p.dashstyle = C.dashStyle)) : I && (p.fill = r || "#e6ebf5", C.borderWidth && (p.stroke = C.borderColor, p["stroke-width"] = C.borderWidth)));
        m.zIndex = q;
        B += "-" + q;
        (x = d.plotLinesAndBandsGroups[B]) || (d.plotLinesAndBandsGroups[B] = x = f.g("plot-" + B).attr(m).add());
        v && (a.svgElem = K = f.path().attr(p).add(x));
        if (H) H = d.getPlotLinePath({
          value: F,
          lineWidth: K.strokeWidth(),
          acrossPanes: C.acrossPanes
        });else if (I) H = d.getPlotBandPath(l, u, C);else return;
        !a.eventsAdded && z && (n(z, function (c, d) {
          K.on(d, function (c) {
            z[d].apply(a, [c]);
          });
        }), a.eventsAdded = !0);
        (v || !K.d) && H && H.length ? K.attr({
          d: H
        }) : K && (H ? (K.show(!0), K.animate({
          d: H
        })) : K.d && (K.hide(), c && (a.label = c = c.destroy())));
        y && (w(y.text) || w(y.formatter)) && H && H.length && 0 < d.width && 0 < d.height && !H.isFlat ? (y = t({
          align: b && I && "center",
          x: b ? !I && 4 : 10,
          verticalAlign: !b && I && "middle",
          y: b ? I ? 16 : 10 : I ? 6 : -4,
          rotation: b && !I && 90
        }, y), this.renderLabel(y, H, I, q)) : c && c.hide();
        return a;
      };
      d.prototype.renderLabel = function (a, d, b, h) {
        var e = this.axis,
          g = e.chart.renderer,
          q = this.label;
        q || (this.label = q = g.text(this.getLabelText(a), 0, 0, a.useHTML).attr({
          align: a.textAlign || a.align,
          rotation: a.rotation,
          "class": "highcharts-plot-" + (b ? "band" : "line") + "-label " + (a.className || ""),
          zIndex: h
        }).add(), e.chart.styledMode || q.css(t({
          textOverflow: "ellipsis"
        }, a.style)));
        h = d.xBounds || [d[0][1], d[1][1], b ? d[2][1] : d[0][1]];
        d = d.yBounds || [d[0][2], d[1][2], b ? d[2][2] : d[0][2]];
        b = E(h);
        g = E(d);
        q.align(a, !1, {
          x: b,
          y: g,
          width: v(h) - b,
          height: v(d) - g
        });
        q.alignValue && "left" !== q.alignValue || q.css({
          width: (90 === q.rotation ? e.height - (q.alignAttr.y - e.top) : e.width - (q.alignAttr.x - e.left)) + "px"
        });
        q.show(!0);
      };
      d.prototype.getLabelText = function (a) {
        return w(a.formatter) ? a.formatter.call(this) : a.text;
      };
      d.prototype.destroy = function () {
        B(this.axis.plotLinesAndBands, this);
        delete this.axis;
        D(this);
      };
      return d;
    }();
    "";
    "";
    return p;
  });
  G(b, "Core/Tooltip.js", [b["Core/FormatUtilities.js"], b["Core/Globals.js"], b["Core/Renderer/RendererUtilities.js"], b["Core/Renderer/RendererRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E, w) {
    var v = b.format,
      B = p.doc,
      k = A.distribute,
      t = w.addEvent,
      n = w.clamp,
      h = w.css,
      d = w.defined,
      a = w.discardElement,
      e = w.extend,
      g = w.fireEvent,
      x = w.isArray,
      C = w.isNumber,
      r = w.isString,
      q = w.merge,
      z = w.pick,
      m = w.splat,
      f = w.syncTimeout;
    b = function () {
      function b(c, a) {
        this.allowShared = !0;
        this.container = void 0;
        this.crosshairs = [];
        this.distance = 0;
        this.isHidden = !0;
        this.isSticky = !1;
        this.now = {};
        this.options = {};
        this.outside = !1;
        this.chart = c;
        this.init(c, a);
      }
      b.prototype.applyFilter = function () {
        var c = this.chart;
        c.renderer.definition({
          tagName: "filter",
          attributes: {
            id: "drop-shadow-" + c.index,
            opacity: .5
          },
          children: [{
            tagName: "feGaussianBlur",
            attributes: {
              "in": "SourceAlpha",
              stdDeviation: 1
            }
          }, {
            tagName: "feOffset",
            attributes: {
              dx: 1,
              dy: 1
            }
          }, {
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncA",
              attributes: {
                type: "linear",
                slope: .3
              }
            }]
          }, {
            tagName: "feMerge",
            children: [{
              tagName: "feMergeNode"
            }, {
              tagName: "feMergeNode",
              attributes: {
                "in": "SourceGraphic"
              }
            }]
          }]
        });
      };
      b.prototype.bodyFormatter = function (c) {
        return c.map(function (c) {
          var a = c.series.tooltipOptions;
          return (a[(c.point.formatPrefix || "point") + "Formatter"] || c.point.tooltipFormatter).call(c.point, a[(c.point.formatPrefix || "point") + "Format"] || "");
        });
      };
      b.prototype.cleanSplit = function (c) {
        this.chart.series.forEach(function (a) {
          var d = a && a.tt;
          d && (!d.isActive || c ? a.tt = d.destroy() : d.isActive = !1);
        });
      };
      b.prototype.defaultFormatter = function (c) {
        var a = this.points || m(this);
        var d = [c.tooltipFooterHeaderFormatter(a[0])];
        d = d.concat(c.bodyFormatter(a));
        d.push(c.tooltipFooterHeaderFormatter(a[0], !0));
        return d;
      };
      b.prototype.destroy = function () {
        this.label && (this.label = this.label.destroy());
        this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());
        this.renderer && (this.renderer = this.renderer.destroy(), a(this.container));
        w.clearTimeout(this.hideTimer);
        w.clearTimeout(this.tooltipTimeout);
      };
      b.prototype.getAnchor = function (c, a) {
        var d = this.chart,
          f = d.pointer,
          b = d.inverted,
          e = d.plotTop,
          g = d.plotLeft,
          h,
          u,
          y = 0,
          q = 0;
        c = m(c);
        this.followPointer && a ? ("undefined" === typeof a.chartX && (a = f.normalize(a)), f = [a.chartX - g, a.chartY - e]) : c[0].tooltipPos ? f = c[0].tooltipPos : (c.forEach(function (c) {
          h = c.series.yAxis;
          u = c.series.xAxis;
          y += c.plotX || 0;
          q += c.plotLow ? (c.plotLow + (c.plotHigh || 0)) / 2 : c.plotY || 0;
          u && h && (b ? (y += e + d.plotHeight - u.len - u.pos, q += g + d.plotWidth - h.len - h.pos) : (y += u.pos - g, q += h.pos - e));
        }), y /= c.length, q /= c.length, f = [b ? d.plotWidth - q : y, b ? d.plotHeight - y : q], this.shared && 1 < c.length && a && (b ? f[0] = a.chartX - g : f[1] = a.chartY - e));
        return f.map(Math.round);
      };
      b.prototype.getLabel = function () {
        var c = this,
          a = this.chart.styledMode,
          f = this.options,
          b = this.split && this.allowShared,
          e = "tooltip" + (d(f.className) ? " " + f.className : ""),
          g = f.style.pointerEvents || (!this.followPointer && f.stickOnContact ? "auto" : "none"),
          m = function () {
            c.inContact = !0;
          },
          y = function (a) {
            var d = c.chart.hoverSeries;
            c.inContact = c.shouldStickOnContact() && c.chart.pointer.inClass(a.relatedTarget, "highcharts-tooltip");
            if (!c.inContact && d && d.onMouseOut) d.onMouseOut();
          },
          q,
          k = this.chart.renderer;
        if (c.label) {
          var r = !c.label.hasClass("highcharts-label");
          (b && !r || !b && r) && c.destroy();
        }
        if (!this.label) {
          if (this.outside) {
            r = this.chart.options.chart.style;
            var n = E.getRendererType();
            this.container = q = p.doc.createElement("div");
            q.className = "highcharts-tooltip-container";
            h(q, {
              position: "absolute",
              top: "1px",
              pointerEvents: g,
              zIndex: Math.max(this.options.style.zIndex || 0, (r && r.zIndex || 0) + 3)
            });
            t(q, "mouseenter", m);
            t(q, "mouseleave", y);
            p.doc.body.appendChild(q);
            this.renderer = k = new n(q, 0, 0, r, void 0, void 0, k.styledMode);
          }
          b ? this.label = k.g(e) : (this.label = k.label("", 0, 0, f.shape, void 0, void 0, f.useHTML, void 0, e).attr({
            padding: f.padding,
            r: f.borderRadius
          }), a || this.label.attr({
            fill: f.backgroundColor,
            "stroke-width": f.borderWidth
          }).css(f.style).css({
            pointerEvents: g
          }).shadow(f.shadow));
          a && f.shadow && (this.applyFilter(), this.label.attr({
            filter: "url(#drop-shadow-" + this.chart.index + ")"
          }));
          if (c.outside && !c.split) {
            var z = this.label,
              x = z.xSetter,
              C = z.ySetter;
            z.xSetter = function (a) {
              x.call(z, c.distance);
              q.style.left = a + "px";
            };
            z.ySetter = function (a) {
              C.call(z, c.distance);
              q.style.top = a + "px";
            };
          }
          this.label.on("mouseenter", m).on("mouseleave", y).attr({
            zIndex: 8
          }).add();
        }
        return this.label;
      };
      b.prototype.getPosition = function (c, a, d) {
        var f = this.chart,
          l = this.distance,
          b = {},
          e = f.inverted && d.h || 0,
          g = this.outside,
          m = g ? B.documentElement.clientWidth - 2 * l : f.chartWidth,
          h = g ? Math.max(B.body.scrollHeight, B.documentElement.scrollHeight, B.body.offsetHeight, B.documentElement.offsetHeight, B.documentElement.clientHeight) : f.chartHeight,
          u = f.pointer.getChartPosition(),
          y = function (b) {
            var e = "x" === b;
            return [b, e ? m : h, e ? c : a].concat(g ? [e ? c * u.scaleX : a * u.scaleY, e ? u.left - l + (d.plotX + f.plotLeft) * u.scaleX : u.top - l + (d.plotY + f.plotTop) * u.scaleY, 0, e ? m : h] : [e ? c : a, e ? d.plotX + f.plotLeft : d.plotY + f.plotTop, e ? f.plotLeft : f.plotTop, e ? f.plotLeft + f.plotWidth : f.plotTop + f.plotHeight]);
          },
          q = y("y"),
          k = y("x"),
          r;
        y = !!d.negative;
        !f.polar && f.hoverSeries && f.hoverSeries.yAxis && f.hoverSeries.yAxis.reversed && (y = !y);
        var n = !this.followPointer && z(d.ttBelow, !f.inverted === y),
          x = function (c, a, d, f, m, h, y) {
            var q = g ? "y" === c ? l * u.scaleY : l * u.scaleX : l,
              k = (d - f) / 2,
              F = f < m - l,
              r = m + l + f < a,
              H = m - q - d + k;
            m = m + q - k;
            if (n && r) b[c] = m;else if (!n && F) b[c] = H;else if (F) b[c] = Math.min(y - f, 0 > H - e ? H : H - e);else if (r) b[c] = Math.max(h, m + e + d > a ? m : m + e);else return !1;
          },
          t = function (c, a, d, f, e) {
            var g;
            e < l || e > a - l ? g = !1 : b[c] = e < d / 2 ? 1 : e > a - f / 2 ? a - f - 2 : e - d / 2;
            return g;
          },
          C = function (c) {
            var a = q;
            q = k;
            k = a;
            r = c;
          },
          v = function () {
            !1 !== x.apply(0, q) ? !1 !== t.apply(0, k) || r || (C(!0), v()) : r ? b.x = b.y = 0 : (C(!0), v());
          };
        (f.inverted || 1 < this.len) && C();
        v();
        return b;
      };
      b.prototype.hide = function (c) {
        var a = this;
        w.clearTimeout(this.hideTimer);
        c = z(c, this.options.hideDelay);
        this.isHidden || (this.hideTimer = f(function () {
          a.getLabel().fadeOut(c ? void 0 : c);
          a.isHidden = !0;
        }, c));
      };
      b.prototype.init = function (c, a) {
        this.chart = c;
        this.options = a;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.split = a.split && !c.inverted && !c.polar;
        this.shared = a.shared || this.split;
        this.outside = z(a.outside, !(!c.scrollablePixelsX && !c.scrollablePixelsY));
      };
      b.prototype.shouldStickOnContact = function () {
        return !(this.followPointer || !this.options.stickOnContact);
      };
      b.prototype.isStickyOnContact = function () {
        return !(!this.shouldStickOnContact() || !this.inContact);
      };
      b.prototype.move = function (c, a, d, f) {
        var l = this,
          b = l.now,
          g = !1 !== l.options.animation && !l.isHidden && (1 < Math.abs(c - b.x) || 1 < Math.abs(a - b.y)),
          m = l.followPointer || 1 < l.len;
        e(b, {
          x: g ? (2 * b.x + c) / 3 : c,
          y: g ? (b.y + a) / 2 : a,
          anchorX: m ? void 0 : g ? (2 * b.anchorX + d) / 3 : d,
          anchorY: m ? void 0 : g ? (b.anchorY + f) / 2 : f
        });
        l.getLabel().attr(b);
        l.drawTracker();
        g && (w.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
          l && l.move(c, a, d, f);
        }, 32));
      };
      b.prototype.refresh = function (c, a) {
        var d = this.chart,
          f = this.options,
          b = m(c),
          e = b[0],
          h = [],
          u = f.formatter || this.defaultFormatter,
          y = this.shared,
          q = d.styledMode,
          k = {};
        if (f.enabled) {
          w.clearTimeout(this.hideTimer);
          this.allowShared = !(!x(c) && c.series && c.series.noSharedTooltip);
          this.followPointer = !this.split && e.series.tooltipOptions.followPointer;
          c = this.getAnchor(c, a);
          var r = c[0],
            n = c[1];
          y && this.allowShared ? (d.pointer.applyInactiveState(b), b.forEach(function (c) {
            c.setState("hover");
            h.push(c.getLabelConfig());
          }), k = {
            x: e.category,
            y: e.y
          }, k.points = h) : k = e.getLabelConfig();
          this.len = h.length;
          u = u.call(k, this);
          y = e.series;
          this.distance = z(y.tooltipOptions.distance, 16);
          if (!1 === u) this.hide();else {
            if (this.split && this.allowShared) this.renderSplit(u, b);else {
              var t = r,
                C = n;
              a && d.pointer.isDirectTouch && (t = a.chartX - d.plotLeft, C = a.chartY - d.plotTop);
              if (d.polar || !1 === y.options.clip || b.some(function (c) {
                return c.series.shouldShowTooltip(t, C);
              })) a = this.getLabel(), f.style.width && !q || a.css({
                width: this.chart.spacingBox.width + "px"
              }), a.attr({
                text: u && u.join ? u.join("") : u
              }), a.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + z(e.colorIndex, y.colorIndex)), q || a.attr({
                stroke: f.borderColor || e.color || y.color || "#666666"
              }), this.updatePosition({
                plotX: r,
                plotY: n,
                negative: e.negative,
                ttBelow: e.ttBelow,
                h: c[2] || 0
              });else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({
              opacity: 1
            }).show();
            this.isHidden = !1;
          }
          g(this, "refresh");
        }
      };
      b.prototype.renderSplit = function (c, a) {
        function d(c, a, d, b, l) {
          void 0 === l && (l = !0);
          d ? (a = V ? 0 : G, c = n(c - b / 2, P.left, P.right - b - (f.outside ? N : 0))) : (a -= ca, c = l ? c - b - D : c + D, c = n(c, l ? c : P.left, P.right));
          return {
            x: c,
            y: a
          };
        }
        var f = this,
          b = f.chart,
          g = f.chart,
          m = g.chartWidth,
          h = g.chartHeight,
          u = g.plotHeight,
          y = g.plotLeft,
          q = g.plotTop,
          x = g.pointer,
          t = g.scrollablePixelsY;
        t = void 0 === t ? 0 : t;
        var C = g.scrollablePixelsX,
          v = g.scrollingContainer;
        v = void 0 === v ? {
          scrollLeft: 0,
          scrollTop: 0
        } : v;
        var p = v.scrollLeft;
        v = v.scrollTop;
        var w = g.styledMode,
          D = f.distance,
          M = f.options,
          A = f.options.positioner,
          P = f.outside && "number" !== typeof C ? B.documentElement.getBoundingClientRect() : {
            left: p,
            right: p + m,
            top: v,
            bottom: v + h
          },
          E = f.getLabel(),
          S = this.renderer || b.renderer,
          V = !(!b.xAxis[0] || !b.xAxis[0].opposite);
        b = x.getChartPosition();
        var N = b.left;
        b = b.top;
        var ca = q + v,
          ea = 0,
          G = u - t;
        r(c) && (c = [!1, c]);
        c = c.slice(0, a.length + 1).reduce(function (c, b, l) {
          if (!1 !== b && "" !== b) {
            l = a[l - 1] || {
              isHeader: !0,
              plotX: a[0].plotX,
              plotY: u,
              series: {}
            };
            var e = l.isHeader,
              g = e ? f : l.series;
            b = b.toString();
            var m = g.tt,
              h = l.isHeader;
            var k = l.series;
            var r = "highcharts-color-" + z(l.colorIndex, k.colorIndex, "none");
            m || (m = {
              padding: M.padding,
              r: M.borderRadius
            }, w || (m.fill = M.backgroundColor, m["stroke-width"] = M.borderWidth), m = S.label("", 0, 0, M[h ? "headerShape" : "shape"], void 0, void 0, M.useHTML).addClass((h ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + r).attr(m).add(E));
            m.isActive = !0;
            m.attr({
              text: b
            });
            w || m.css(M.style).shadow(M.shadow).attr({
              stroke: M.borderColor || l.color || k.color || "#333333"
            });
            g = g.tt = m;
            h = g.getBBox();
            b = h.width + g.strokeWidth();
            e && (ea = h.height, G += ea, V && (ca -= ea));
            k = l.plotX;
            k = void 0 === k ? 0 : k;
            r = l.plotY;
            r = void 0 === r ? 0 : r;
            m = l.series;
            if (l.isHeader) {
              k = y + k;
              var F = q + u / 2;
            } else {
              var H = m.xAxis,
                x = m.yAxis;
              k = H.pos + n(k, -D, H.len + D);
              m.shouldShowTooltip(0, x.pos - q + r, {
                ignoreX: !0
              }) && (F = x.pos + r);
            }
            k = n(k, P.left - D, P.right + D);
            "number" === typeof F ? (h = h.height + 1, r = A ? A.call(f, b, h, l) : d(k, F, e, b), c.push({
              align: A ? 0 : void 0,
              anchorX: k,
              anchorY: F,
              boxWidth: b,
              point: l,
              rank: z(r.rank, e ? 1 : 0),
              size: h,
              target: r.y,
              tt: g,
              x: r.x
            })) : g.isActive = !1;
          }
          return c;
        }, []);
        !A && c.some(function (c) {
          var a = (f.outside ? N : 0) + c.anchorX;
          return a < P.left && a + c.boxWidth < P.right ? !0 : a < N - P.left + c.boxWidth && P.right - a > a;
        }) && (c = c.map(function (c) {
          var a = d(c.anchorX, c.anchorY, c.point.isHeader, c.boxWidth, !1);
          return e(c, {
            target: a.y,
            x: a.x
          });
        }));
        f.cleanSplit();
        k(c, G);
        var aa = N,
          fa = N;
        c.forEach(function (c) {
          var a = c.x,
            d = c.boxWidth;
          c = c.isHeader;
          c || (f.outside && N + a < aa && (aa = N + a), !c && f.outside && aa + d > fa && (fa = N + a));
        });
        c.forEach(function (c) {
          var a = c.x,
            d = c.anchorX,
            b = c.pos,
            l = c.point.isHeader;
          b = {
            visibility: "undefined" === typeof b ? "hidden" : "inherit",
            x: a,
            y: b + ca,
            anchorX: d,
            anchorY: c.anchorY
          };
          if (f.outside && a < d) {
            var e = N - aa;
            0 < e && (l || (b.x = a + e, b.anchorX = d + e), l && (b.x = (fa - aa) / 2, b.anchorX = d + e));
          }
          c.tt.attr(b);
        });
        c = f.container;
        t = f.renderer;
        f.outside && c && t && (g = E.getBBox(), t.setSize(g.width + g.x, g.height + g.y, !1), c.style.left = aa + "px", c.style.top = b + "px");
      };
      b.prototype.drawTracker = function () {
        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
          var c = this.chart,
            a = this.label,
            d = this.shared ? c.hoverPoints : c.hoverPoint;
          if (a && d) {
            var f = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
            d = this.getAnchor(d);
            var b = a.getBBox();
            d[0] += c.plotLeft - a.translateX;
            d[1] += c.plotTop - a.translateY;
            f.x = Math.min(0, d[0]);
            f.y = Math.min(0, d[1]);
            f.width = 0 > d[0] ? Math.max(Math.abs(d[0]), b.width - d[0]) : Math.max(Math.abs(d[0]), b.width);
            f.height = 0 > d[1] ? Math.max(Math.abs(d[1]), b.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), b.height);
            this.tracker ? this.tracker.attr(f) : (this.tracker = a.renderer.rect(f).addClass("highcharts-tracker").add(a), c.styledMode || this.tracker.attr({
              fill: "rgba(0,0,0,0)"
            }));
          }
        }
      };
      b.prototype.styledModeFormat = function (c) {
        return c.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
      };
      b.prototype.tooltipFooterHeaderFormatter = function (c, a) {
        var d = c.series,
          f = d.tooltipOptions,
          b = d.xAxis,
          e = b && b.dateTime;
        b = {
          isFooter: a,
          labelConfig: c
        };
        var m = f.xDateFormat,
          h = f[a ? "footerFormat" : "headerFormat"];
        g(this, "headerFormatter", b, function (a) {
          e && !m && C(c.key) && (m = e.getXDateFormat(c.key, f.dateTimeLabelFormats));
          e && m && (c.point && c.point.tooltipDateKeys || ["key"]).forEach(function (c) {
            h = h.replace("{point." + c + "}", "{point." + c + ":" + m + "}");
          });
          d.chart.styledMode && (h = this.styledModeFormat(h));
          a.text = v(h, {
            point: c,
            series: d
          }, this.chart);
        });
        return b.text;
      };
      b.prototype.update = function (c) {
        this.destroy();
        q(!0, this.chart.options.tooltip.userOptions, c);
        this.init(this.chart, q(!0, this.options, c));
      };
      b.prototype.updatePosition = function (c) {
        var a = this.chart,
          d = this.options,
          f = a.pointer,
          b = this.getLabel();
        f = f.getChartPosition();
        var e = (d.positioner || this.getPosition).call(this, b.width, b.height, c),
          g = c.plotX + a.plotLeft;
        c = c.plotY + a.plotTop;
        if (this.outside) {
          d = d.borderWidth + 2 * this.distance;
          this.renderer.setSize(b.width + d, b.height + d, !1);
          if (1 !== f.scaleX || 1 !== f.scaleY) h(this.container, {
            transform: "scale(" + f.scaleX + ", " + f.scaleY + ")"
          }), g *= f.scaleX, c *= f.scaleY;
          g += f.left - e.x;
          c += f.top - e.y;
        }
        this.move(Math.round(e.x), Math.round(e.y || 0), g, c);
      };
      return b;
    }();
    "";
    return b;
  });
  G(b, "Core/Series/Point.js", [b["Core/Renderer/HTML/AST.js"], b["Core/Animation/AnimationUtilities.js"], b["Core/DefaultOptions.js"], b["Core/FormatUtilities.js"], b["Core/Utilities.js"]], function (b, p, A, E, w) {
    var v = p.animObject,
      B = A.defaultOptions,
      k = E.format,
      t = w.addEvent,
      n = w.defined,
      h = w.erase,
      d = w.extend,
      a = w.fireEvent,
      e = w.getNestedProperty,
      g = w.isArray,
      x = w.isFunction,
      C = w.isNumber,
      r = w.isObject,
      q = w.merge,
      z = w.objectEach,
      m = w.pick,
      f = w.syncTimeout,
      y = w.removeEvent,
      c = w.uniqueKey;
    p = function () {
      function u() {
        this.colorIndex = this.category = void 0;
        this.formatPrefix = "point";
        this.id = void 0;
        this.isNull = !1;
        this.percentage = this.options = this.name = void 0;
        this.selected = !1;
        this.total = this.series = void 0;
        this.visible = !0;
        this.x = void 0;
      }
      u.prototype.animateBeforeDestroy = function () {
        var c = this,
          a = {
            x: c.startXPos,
            opacity: 0
          },
          f = c.getGraphicalProps();
        f.singular.forEach(function (d) {
          c[d] = c[d].animate("dataLabel" === d ? {
            x: c[d].startXPos,
            y: c[d].startYPos,
            opacity: 0
          } : a);
        });
        f.plural.forEach(function (a) {
          c[a].forEach(function (a) {
            a.element && a.animate(d({
              x: c.startXPos
            }, a.startYPos ? {
              x: a.startXPos,
              y: a.startYPos
            } : {}));
          });
        });
      };
      u.prototype.applyOptions = function (c, a) {
        var f = this.series,
          b = f.options.pointValKey || f.pointValKey;
        c = u.prototype.optionsToObject.call(this, c);
        d(this, c);
        this.options = this.options ? d(this.options, c) : c;
        c.group && delete this.group;
        c.dataLabels && delete this.dataLabels;
        b && (this.y = u.prototype.getNestedProperty.call(this, b));
        this.formatPrefix = (this.isNull = m(this.isValid && !this.isValid(), null === this.x || !C(this.y))) ? "null" : "point";
        this.selected && (this.state = "select");
        "name" in this && "undefined" === typeof a && f.xAxis && f.xAxis.hasNames && (this.x = f.xAxis.nameToX(this));
        "undefined" === typeof this.x && f ? this.x = "undefined" === typeof a ? f.autoIncrement() : a : C(c.x) && f.options.relativeXValue && (this.x = f.autoIncrement(c.x));
        return this;
      };
      u.prototype.destroy = function () {
        function c() {
          if (a.graphic || a.dataLabel || a.dataLabels) y(a), a.destroyElements();
          for (m in a) a[m] = null;
        }
        var a = this,
          d = a.series,
          b = d.chart;
        d = d.options.dataSorting;
        var e = b.hoverPoints,
          g = v(a.series.chart.renderer.globalAnimation),
          m;
        a.legendItem && b.legend.destroyItem(a);
        e && (a.setState(), h(e, a), e.length || (b.hoverPoints = null));
        if (a === b.hoverPoint) a.onMouseOut();
        d && d.enabled ? (this.animateBeforeDestroy(), f(c, g.duration)) : c();
        b.pointCount--;
      };
      u.prototype.destroyElements = function (c) {
        var a = this;
        c = a.getGraphicalProps(c);
        c.singular.forEach(function (c) {
          a[c] = a[c].destroy();
        });
        c.plural.forEach(function (c) {
          a[c].forEach(function (c) {
            c.element && c.destroy();
          });
          delete a[c];
        });
      };
      u.prototype.firePointEvent = function (c, d, f) {
        var b = this,
          l = this.series.options;
        (l.point.events[c] || b.options && b.options.events && b.options.events[c]) && b.importEvents();
        "click" === c && l.allowPointSelect && (f = function (c) {
          b.select && b.select(null, c.ctrlKey || c.metaKey || c.shiftKey);
        });
        a(b, c, d, f);
      };
      u.prototype.getClassName = function () {
        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
      };
      u.prototype.getGraphicalProps = function (c) {
        var a = this,
          d = [],
          f = {
            singular: [],
            plural: []
          },
          b;
        c = c || {
          graphic: 1,
          dataLabel: 1
        };
        c.graphic && d.push("graphic", "upperGraphic", "shadowGroup");
        c.dataLabel && d.push("dataLabel", "dataLabelUpper", "connector");
        for (b = d.length; b--;) {
          var l = d[b];
          a[l] && f.singular.push(l);
        }
        ["dataLabel", "connector"].forEach(function (d) {
          var b = d + "s";
          c[d] && a[b] && f.plural.push(b);
        });
        return f;
      };
      u.prototype.getLabelConfig = function () {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      };
      u.prototype.getNestedProperty = function (c) {
        if (c) return 0 === c.indexOf("custom.") ? e(c, this.options) : this[c];
      };
      u.prototype.getZone = function () {
        var c = this.series,
          a = c.zones;
        c = c.zoneAxis || "y";
        var d,
          f = 0;
        for (d = a[f]; this[c] >= d.value;) d = a[++f];
        this.nonZonedColor || (this.nonZonedColor = this.color);
        this.color = d && d.color && !this.options.color ? d.color : this.nonZonedColor;
        return d;
      };
      u.prototype.hasNewShapeType = function () {
        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
      };
      u.prototype.init = function (d, f, b) {
        this.series = d;
        this.applyOptions(f, b);
        this.id = n(this.id) ? this.id : c();
        this.resolveColor();
        d.chart.pointCount++;
        a(this, "afterInit");
        return this;
      };
      u.prototype.optionsToObject = function (c) {
        var a = this.series,
          d = a.options.keys,
          f = d || a.pointArrayMap || ["y"],
          b = f.length,
          l = {},
          e = 0,
          m = 0;
        if (C(c) || null === c) l[f[0]] = c;else if (g(c)) for (!d && c.length > b && (a = typeof c[0], "string" === a ? l.name = c[0] : "number" === a && (l.x = c[0]), e++); m < b;) d && "undefined" === typeof c[e] || (0 < f[m].indexOf(".") ? u.prototype.setNestedProperty(l, c[e], f[m]) : l[f[m]] = c[e]), e++, m++;else "object" === typeof c && (l = c, c.dataLabels && (a._hasPointLabels = !0), c.marker && (a._hasPointMarkers = !0));
        return l;
      };
      u.prototype.resolveColor = function () {
        var c = this.series,
          a = c.chart.styledMode;
        var d = c.chart.options.chart.colorCount;
        delete this.nonZonedColor;
        if (c.options.colorByPoint) {
          if (!a) {
            d = c.options.colors || c.chart.options.colors;
            var f = d[c.colorCounter];
            d = d.length;
          }
          a = c.colorCounter;
          c.colorCounter++;
          c.colorCounter === d && (c.colorCounter = 0);
        } else a || (f = c.color), a = c.colorIndex;
        this.colorIndex = m(this.options.colorIndex, a);
        this.color = m(this.options.color, f);
      };
      u.prototype.setNestedProperty = function (c, a, d) {
        d.split(".").reduce(function (c, d, f, b) {
          c[d] = b.length - 1 === f ? a : r(c[d], !0) ? c[d] : {};
          return c[d];
        }, c);
        return c;
      };
      u.prototype.tooltipFormatter = function (c) {
        var a = this.series,
          d = a.tooltipOptions,
          f = m(d.valueDecimals, ""),
          b = d.valuePrefix || "",
          l = d.valueSuffix || "";
        a.chart.styledMode && (c = a.chart.tooltip.styledModeFormat(c));
        (a.pointArrayMap || ["y"]).forEach(function (a) {
          a = "{point." + a;
          if (b || l) c = c.replace(RegExp(a + "}", "g"), b + a + "}" + l);
          c = c.replace(RegExp(a + "}", "g"), a + ":,." + f + "f}");
        });
        return k(c, {
          point: this,
          series: this.series
        }, a.chart);
      };
      u.prototype.update = function (c, a, d, f) {
        function b() {
          e.applyOptions(c);
          var f = g && e.hasDummyGraphic;
          f = null === e.y ? !f : f;
          g && f && (e.graphic = g.destroy(), delete e.hasDummyGraphic);
          r(c, !0) && (g && g.element && c && c.marker && "undefined" !== typeof c.marker.symbol && (e.graphic = g.destroy()), c && c.dataLabels && e.dataLabel && (e.dataLabel = e.dataLabel.destroy()), e.connector && (e.connector = e.connector.destroy()));
          u = e.index;
          l.updateParallelArrays(e, u);
          y.data[u] = r(y.data[u], !0) || r(c, !0) ? e.options : m(c, y.data[u]);
          l.isDirty = l.isDirtyData = !0;
          !l.fixedBox && l.hasCartesianSeries && (h.isDirtyBox = !0);
          "point" === y.legendType && (h.isDirtyLegend = !0);
          a && h.redraw(d);
        }
        var e = this,
          l = e.series,
          g = e.graphic,
          h = l.chart,
          y = l.options,
          u;
        a = m(a, !0);
        !1 === f ? b() : e.firePointEvent("update", {
          options: c
        }, b);
      };
      u.prototype.remove = function (c, a) {
        this.series.removePoint(this.series.data.indexOf(this), c, a);
      };
      u.prototype.select = function (c, a) {
        var d = this,
          f = d.series,
          b = f.chart;
        this.selectedStaging = c = m(c, !d.selected);
        d.firePointEvent(c ? "select" : "unselect", {
          accumulate: a
        }, function () {
          d.selected = d.options.selected = c;
          f.options.data[f.data.indexOf(d)] = d.options;
          d.setState(c && "select");
          a || b.getSelectedPoints().forEach(function (c) {
            var a = c.series;
            c.selected && c !== d && (c.selected = c.options.selected = !1, a.options.data[a.data.indexOf(c)] = c.options, c.setState(b.hoverPoints && a.options.inactiveOtherPoints ? "inactive" : ""), c.firePointEvent("unselect"));
          });
        });
        delete this.selectedStaging;
      };
      u.prototype.onMouseOver = function (c) {
        var a = this.series.chart,
          d = a.pointer;
        c = c ? d.normalize(c) : d.getChartCoordinatesFromPoint(this, a.inverted);
        d.runPointActions(c, this);
      };
      u.prototype.onMouseOut = function () {
        var c = this.series.chart;
        this.firePointEvent("mouseOut");
        this.series.options.inactiveOtherPoints || (c.hoverPoints || []).forEach(function (c) {
          c.setState();
        });
        c.hoverPoints = c.hoverPoint = null;
      };
      u.prototype.importEvents = function () {
        if (!this.hasImportedEvents) {
          var c = this,
            a = q(c.series.options.point, c.options).events;
          c.events = a;
          z(a, function (a, d) {
            x(a) && t(c, d, a);
          });
          this.hasImportedEvents = !0;
        }
      };
      u.prototype.setState = function (c, f) {
        var e = this.series,
          l = this.state,
          g = e.options.states[c || "normal"] || {},
          h = B.plotOptions[e.type].marker && e.options.marker,
          y = h && !1 === h.enabled,
          u = h && h.states && h.states[c || "normal"] || {},
          q = !1 === u.enabled,
          k = this.marker || {},
          r = e.chart,
          n = h && e.markerAttribs,
          z = e.halo,
          x,
          F = e.stateMarkerGraphic;
        c = c || "";
        if (!(c === this.state && !f || this.selected && "select" !== c || !1 === g.enabled || c && (q || y && !1 === u.enabled) || c && k.states && k.states[c] && !1 === k.states[c].enabled)) {
          this.state = c;
          n && (x = e.markerAttribs(this, c));
          if (this.graphic && !this.hasDummyGraphic) {
            l && this.graphic.removeClass("highcharts-point-" + l);
            c && this.graphic.addClass("highcharts-point-" + c);
            if (!r.styledMode) {
              var t = e.pointAttribs(this, c);
              var M = m(r.options.chart.animation, g.animation);
              e.options.inactiveOtherPoints && C(t.opacity) && ((this.dataLabels || []).forEach(function (c) {
                c && c.animate({
                  opacity: t.opacity
                }, M);
              }), this.connector && this.connector.animate({
                opacity: t.opacity
              }, M));
              this.graphic.animate(t, M);
            }
            x && this.graphic.animate(x, m(r.options.chart.animation, u.animation, h.animation));
            F && F.hide();
          } else {
            if (c && u) {
              l = k.symbol || e.symbol;
              F && F.currentSymbol !== l && (F = F.destroy());
              if (x) if (F) F[f ? "animate" : "attr"]({
                x: x.x,
                y: x.y
              });else l && (e.stateMarkerGraphic = F = r.renderer.symbol(l, x.x, x.y, x.width, x.height).add(e.markerGroup), F.currentSymbol = l);
              !r.styledMode && F && "inactive" !== this.state && F.attr(e.pointAttribs(this, c));
            }
            F && (F[c && this.isInside ? "show" : "hide"](), F.element.point = this, F.addClass(this.getClassName(), !0));
          }
          g = g.halo;
          x = (F = this.graphic || F) && F.visibility || "inherit";
          g && g.size && F && "hidden" !== x && !this.isCluster ? (z || (e.halo = z = r.renderer.path().add(F.parentGroup)), z.show()[f ? "animate" : "attr"]({
            d: this.haloPath(g.size)
          }), z.attr({
            "class": "highcharts-halo highcharts-color-" + m(this.colorIndex, e.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: x,
            zIndex: -1
          }), z.point = this, r.styledMode || z.attr(d({
            fill: this.color || e.color,
            "fill-opacity": g.opacity
          }, b.filterUserAttributes(g.attributes || {})))) : z && z.point && z.point.haloPath && z.animate({
            d: z.point.haloPath(0)
          }, null, z.hide);
          a(this, "afterSetState", {
            state: c
          });
        }
      };
      u.prototype.haloPath = function (c) {
        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - c, this.plotY - c, 2 * c, 2 * c);
      };
      return u;
    }();
    "";
    return p;
  });
  G(b, "Core/Pointer.js", [b["Core/Color/Color.js"], b["Core/Globals.js"], b["Core/Tooltip.js"], b["Core/Utilities.js"]], function (b, p, A, E) {
    var v = b.parse,
      D = p.charts,
      B = p.noop,
      k = E.addEvent,
      t = E.attr,
      n = E.css,
      h = E.defined,
      d = E.extend,
      a = E.find,
      e = E.fireEvent,
      g = E.isNumber,
      x = E.isObject,
      C = E.objectEach,
      r = E.offset,
      q = E.pick,
      z = E.splat;
    b = function () {
      function b(a, d) {
        this.lastValidTouch = {};
        this.pinchDown = [];
        this.runChartClick = !1;
        this.eventsToUnbind = [];
        this.chart = a;
        this.hasDragged = !1;
        this.options = d;
        this.init(a, d);
      }
      b.prototype.applyInactiveState = function (a) {
        var d = [],
          c;
        (a || []).forEach(function (a) {
          c = a.series;
          d.push(c);
          c.linkedParent && d.push(c.linkedParent);
          c.linkedSeries && (d = d.concat(c.linkedSeries));
          c.navigatorSeries && d.push(c.navigatorSeries);
        });
        this.chart.series.forEach(function (c) {
          -1 === d.indexOf(c) ? c.setState("inactive", !0) : c.options.inactiveOtherPoints && c.setAllPointsToState("inactive");
        });
      };
      b.prototype.destroy = function () {
        var a = this;
        this.eventsToUnbind.forEach(function (a) {
          return a();
        });
        this.eventsToUnbind = [];
        p.chartCount || (b.unbindDocumentMouseUp && (b.unbindDocumentMouseUp = b.unbindDocumentMouseUp()), b.unbindDocumentTouchEnd && (b.unbindDocumentTouchEnd = b.unbindDocumentTouchEnd()));
        clearInterval(a.tooltipTimeout);
        C(a, function (d, c) {
          a[c] = void 0;
        });
      };
      b.prototype.drag = function (a) {
        var d = this.chart,
          c = d.options.chart,
          f = this.zoomHor,
          b = this.zoomVert,
          e = d.plotLeft,
          g = d.plotTop,
          m = d.plotWidth,
          h = d.plotHeight,
          q = this.mouseDownX || 0,
          k = this.mouseDownY || 0,
          r = x(c.panning) ? c.panning && c.panning.enabled : c.panning,
          n = c.panKey && a[c.panKey + "Key"],
          z = a.chartX,
          t = a.chartY,
          C = this.selectionMarker;
        if (!C || !C.touch) if (z < e ? z = e : z > e + m && (z = e + m), t < g ? t = g : t > g + h && (t = g + h), this.hasDragged = Math.sqrt(Math.pow(q - z, 2) + Math.pow(k - t, 2)), 10 < this.hasDragged) {
          var p = d.isInsidePlot(q - e, k - g, {
            visiblePlotOnly: !0
          });
          !d.hasCartesianSeries && !d.mapView || !this.zoomX && !this.zoomY || !p || n || C || (this.selectionMarker = C = d.renderer.rect(e, g, f ? 1 : m, b ? 1 : h, 0).attr({
            "class": "highcharts-selection-marker",
            zIndex: 7
          }).add(), d.styledMode || C.attr({
            fill: c.selectionMarkerFill || v("#335cad").setOpacity(.25).get()
          }));
          C && f && (f = z - q, C.attr({
            width: Math.abs(f),
            x: (0 < f ? 0 : f) + q
          }));
          C && b && (f = t - k, C.attr({
            height: Math.abs(f),
            y: (0 < f ? 0 : f) + k
          }));
          p && !C && r && d.pan(a, c.panning);
        }
      };
      b.prototype.dragStart = function (a) {
        var d = this.chart;
        d.mouseIsDown = a.type;
        d.cancelClick = !1;
        d.mouseDownX = this.mouseDownX = a.chartX;
        d.mouseDownY = this.mouseDownY = a.chartY;
      };
      b.prototype.drop = function (a) {
        var f = this,
          c = this.chart,
          b = this.hasPinched;
        if (this.selectionMarker) {
          var l = this.selectionMarker,
            m = l.attr ? l.attr("x") : l.x,
            q = l.attr ? l.attr("y") : l.y,
            k = l.attr ? l.attr("width") : l.width,
            r = l.attr ? l.attr("height") : l.height,
            z = {
              originalEvent: a,
              xAxis: [],
              yAxis: [],
              x: m,
              y: q,
              width: k,
              height: r
            },
            x = !!c.mapView;
          if (this.hasDragged || b) c.axes.forEach(function (c) {
            if (c.zoomEnabled && h(c.min) && (b || f[{
              xAxis: "zoomX",
              yAxis: "zoomY"
            }[c.coll]]) && g(m) && g(q)) {
              var d = c.horiz,
                e = "touchend" === a.type ? c.minPixelPadding : 0,
                l = c.toValue((d ? m : q) + e);
              d = c.toValue((d ? m + k : q + r) - e);
              z[c.coll].push({
                axis: c,
                min: Math.min(l, d),
                max: Math.max(l, d)
              });
              x = !0;
            }
          }), x && e(c, "selection", z, function (a) {
            c.zoom(d(a, b ? {
              animation: !1
            } : null));
          });
          g(c.index) && (this.selectionMarker = this.selectionMarker.destroy());
          b && this.scaleGroups();
        }
        c && g(c.index) && (n(c.container, {
          cursor: c._cursor
        }), c.cancelClick = 10 < this.hasDragged, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
      };
      b.prototype.findNearestKDPoint = function (a, d, c) {
        var f = this.chart,
          b = f.hoverPoint;
        f = f.tooltip;
        if (b && f && f.isStickyOnContact()) return b;
        var e;
        a.forEach(function (a) {
          var f = !(a.noSharedTooltip && d) && 0 > a.options.findNearestPointBy.indexOf("y");
          a = a.searchPoint(c, f);
          if ((f = x(a, !0) && a.series) && !(f = !x(e, !0))) {
            f = e.distX - a.distX;
            var b = e.dist - a.dist,
              l = (a.series.group && a.series.group.zIndex) - (e.series.group && e.series.group.zIndex);
            f = 0 < (0 !== f && d ? f : 0 !== b ? b : 0 !== l ? l : e.series.index > a.series.index ? -1 : 1);
          }
          f && (e = a);
        });
        return e;
      };
      b.prototype.getChartCoordinatesFromPoint = function (a, d) {
        var c = a.series,
          f = c.xAxis;
        c = c.yAxis;
        var b = a.shapeArgs;
        if (f && c) {
          var e = q(a.clientX, a.plotX),
            m = a.plotY || 0;
          a.isNode && b && g(b.x) && g(b.y) && (e = b.x, m = b.y);
          return d ? {
            chartX: c.len + c.pos - m,
            chartY: f.len + f.pos - e
          } : {
            chartX: e + f.pos,
            chartY: m + c.pos
          };
        }
        if (b && b.x && b.y) return {
          chartX: b.x,
          chartY: b.y
        };
      };
      b.prototype.getChartPosition = function () {
        if (this.chartPosition) return this.chartPosition;
        var a = this.chart.container,
          d = r(a);
        this.chartPosition = {
          left: d.left,
          top: d.top,
          scaleX: 1,
          scaleY: 1
        };
        var c = a.offsetWidth;
        a = a.offsetHeight;
        2 < c && 2 < a && (this.chartPosition.scaleX = d.width / c, this.chartPosition.scaleY = d.height / a);
        return this.chartPosition;
      };
      b.prototype.getCoordinates = function (a) {
        var d = {
          xAxis: [],
          yAxis: []
        };
        this.chart.axes.forEach(function (c) {
          d[c.isXAxis ? "xAxis" : "yAxis"].push({
            axis: c,
            value: c.toValue(a[c.horiz ? "chartX" : "chartY"])
          });
        });
        return d;
      };
      b.prototype.getHoverData = function (d, b, c, g, l, m) {
        var f = [];
        g = !(!g || !d);
        var h = {
          chartX: m ? m.chartX : void 0,
          chartY: m ? m.chartY : void 0,
          shared: l
        };
        e(this, "beforeGetHoverData", h);
        var k = b && !b.stickyTracking ? [b] : c.filter(function (c) {
          return h.filter ? h.filter(c) : c.visible && !(!l && c.directTouch) && q(c.options.enableMouseTracking, !0) && c.stickyTracking;
        });
        var u = g || !m ? d : this.findNearestKDPoint(k, l, m);
        b = u && u.series;
        u && (l && !b.noSharedTooltip ? (k = c.filter(function (c) {
          return h.filter ? h.filter(c) : c.visible && !(!l && c.directTouch) && q(c.options.enableMouseTracking, !0) && !c.noSharedTooltip;
        }), k.forEach(function (c) {
          var d = a(c.points, function (c) {
            return c.x === u.x && !c.isNull;
          });
          x(d) && (c.chart.isBoosting && (d = c.getPoint(d)), f.push(d));
        })) : f.push(u));
        h = {
          hoverPoint: u
        };
        e(this, "afterGetHoverData", h);
        return {
          hoverPoint: h.hoverPoint,
          hoverSeries: b,
          hoverPoints: f
        };
      };
      b.prototype.getPointFromEvent = function (a) {
        a = a.target;
        for (var d; a && !d;) d = a.point, a = a.parentNode;
        return d;
      };
      b.prototype.onTrackerMouseOut = function (a) {
        a = a.relatedTarget || a.toElement;
        var d = this.chart.hoverSeries;
        this.isDirectTouch = !1;
        if (!(!d || !a || d.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + d.index) && this.inClass(a, "highcharts-tracker"))) d.onMouseOut();
      };
      b.prototype.inClass = function (a, d) {
        for (var c; a;) {
          if (c = t(a, "class")) {
            if (-1 !== c.indexOf(d)) return !0;
            if (-1 !== c.indexOf("highcharts-container")) return !1;
          }
          a = a.parentNode;
        }
      };
      b.prototype.init = function (a, d) {
        this.options = d;
        this.chart = a;
        this.runChartClick = !(!d.chart.events || !d.chart.events.click);
        this.pinchDown = [];
        this.lastValidTouch = {};
        A && (a.tooltip = new A(a, d.tooltip), this.followTouchMove = q(d.tooltip.followTouchMove, !0));
        this.setDOMEvents();
      };
      b.prototype.normalize = function (a, b) {
        var c = a.touches,
          f = c ? c.length ? c.item(0) : q(c.changedTouches, a.changedTouches)[0] : a;
        b || (b = this.getChartPosition());
        c = f.pageX - b.left;
        f = f.pageY - b.top;
        c /= b.scaleX;
        f /= b.scaleY;
        return d(a, {
          chartX: Math.round(c),
          chartY: Math.round(f)
        });
      };
      b.prototype.onContainerClick = function (a) {
        var f = this.chart,
          c = f.hoverPoint;
        a = this.normalize(a);
        var b = f.plotLeft,
          l = f.plotTop;
        f.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (e(c.series, "click", d(a, {
          point: c
        })), f.hoverPoint && c.firePointEvent("click", a)) : (d(a, this.getCoordinates(a)), f.isInsidePlot(a.chartX - b, a.chartY - l, {
          visiblePlotOnly: !0
        }) && e(f, "click", a)));
      };
      b.prototype.onContainerMouseDown = function (a) {
        var d = 1 === ((a.buttons || a.button) & 1);
        a = this.normalize(a);
        if (p.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);
        if ("undefined" === typeof a.button || d) this.zoomOption(a), d && a.preventDefault && a.preventDefault(), this.dragStart(a);
      };
      b.prototype.onContainerMouseLeave = function (a) {
        var d = D[q(b.hoverChartIndex, -1)],
          c = this.chart.tooltip;
        c && c.shouldStickOnContact() && this.inClass(a.relatedTarget, "highcharts-tooltip-container") || (a = this.normalize(a), d && (a.relatedTarget || a.toElement) && (d.pointer.reset(), d.pointer.chartPosition = void 0), c && !c.isHidden && this.reset());
      };
      b.prototype.onContainerMouseEnter = function (a) {
        delete this.chartPosition;
      };
      b.prototype.onContainerMouseMove = function (a) {
        var d = this.chart;
        a = this.normalize(a);
        this.setHoverChartIndex();
        a.preventDefault || (a.returnValue = !1);
        ("mousedown" === d.mouseIsDown || this.touchSelect(a)) && this.drag(a);
        d.openMenu || !this.inClass(a.target, "highcharts-tracker") && !d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop, {
          visiblePlotOnly: !0
        }) || (this.inClass(a.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(a));
      };
      b.prototype.onDocumentTouchEnd = function (a) {
        var d = D[q(b.hoverChartIndex, -1)];
        d && d.pointer.drop(a);
      };
      b.prototype.onContainerTouchMove = function (a) {
        if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);
      };
      b.prototype.onContainerTouchStart = function (a) {
        if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);
      };
      b.prototype.onDocumentMouseMove = function (a) {
        var d = this.chart,
          c = this.chartPosition;
        a = this.normalize(a, c);
        var b = d.tooltip;
        !c || b && b.isStickyOnContact() || d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop, {
          visiblePlotOnly: !0
        }) || this.inClass(a.target, "highcharts-tracker") || this.reset();
      };
      b.prototype.onDocumentMouseUp = function (a) {
        var d = D[q(b.hoverChartIndex, -1)];
        d && d.pointer.drop(a);
      };
      b.prototype.pinch = function (a) {
        var b = this,
          c = b.chart,
          f = b.pinchDown,
          l = a.touches || [],
          g = l.length,
          m = b.lastValidTouch,
          h = b.hasZoom,
          k = {},
          r = 1 === g && (b.inClass(a.target, "highcharts-tracker") && c.runTrackerClick || b.runChartClick),
          n = {},
          z = b.selectionMarker;
        1 < g ? b.initiated = !0 : 1 === g && this.followTouchMove && (b.initiated = !1);
        h && b.initiated && !r && !1 !== a.cancelable && a.preventDefault();
        [].map.call(l, function (c) {
          return b.normalize(c);
        });
        "touchstart" === a.type ? ([].forEach.call(l, function (c, a) {
          f[a] = {
            chartX: c.chartX,
            chartY: c.chartY
          };
        }), m.x = [f[0].chartX, f[1] && f[1].chartX], m.y = [f[0].chartY, f[1] && f[1].chartY], c.axes.forEach(function (a) {
          if (a.zoomEnabled) {
            var d = c.bounds[a.horiz ? "h" : "v"],
              b = a.minPixelPadding,
              f = a.toPixels(Math.min(q(a.options.min, a.dataMin), a.dataMin)),
              e = a.toPixels(Math.max(q(a.options.max, a.dataMax), a.dataMax)),
              l = Math.max(f, e);
            d.min = Math.min(a.pos, Math.min(f, e) - b);
            d.max = Math.max(a.pos + a.len, l + b);
          }
        }), b.res = !0) : b.followTouchMove && 1 === g ? this.runPointActions(b.normalize(a)) : f.length && (e(c, "touchpan", {
          originalEvent: a
        }, function () {
          z || (b.selectionMarker = z = d({
            destroy: B,
            touch: !0
          }, c.plotBox));
          b.pinchTranslate(f, l, k, z, n, m);
          b.hasPinched = h;
          b.scaleGroups(k, n);
        }), b.res && (b.res = !1, this.reset(!1, 0)));
      };
      b.prototype.pinchTranslate = function (a, d, c, b, e, g) {
        this.zoomHor && this.pinchTranslateDirection(!0, a, d, c, b, e, g);
        this.zoomVert && this.pinchTranslateDirection(!1, a, d, c, b, e, g);
      };
      b.prototype.pinchTranslateDirection = function (a, d, c, b, e, g, m, h) {
        var f = this.chart,
          l = a ? "x" : "y",
          q = a ? "X" : "Y",
          k = "chart" + q,
          u = a ? "width" : "height",
          r = f["plot" + (a ? "Left" : "Top")],
          n = f.inverted,
          y = f.bounds[a ? "h" : "v"],
          z = 1 === d.length,
          x = d[0][k],
          t = !z && d[1][k];
        d = function () {
          "number" === typeof p && 20 < Math.abs(x - t) && (H = h || Math.abs(v - p) / Math.abs(x - t));
          F = (r - v) / H + x;
          C = f["plot" + (a ? "Width" : "Height")] / H;
        };
        var C,
          F,
          H = h || 1,
          v = c[0][k],
          p = !z && c[1][k];
        d();
        c = F;
        if (c < y.min) {
          c = y.min;
          var B = !0;
        } else c + C > y.max && (c = y.max - C, B = !0);
        B ? (v -= .8 * (v - m[l][0]), "number" === typeof p && (p -= .8 * (p - m[l][1])), d()) : m[l] = [v, p];
        n || (g[l] = F - r, g[u] = C);
        g = n ? 1 / H : H;
        e[u] = C;
        e[l] = c;
        b[n ? a ? "scaleY" : "scaleX" : "scale" + q] = H;
        b["translate" + q] = g * r + (v - g * x);
      };
      b.prototype.reset = function (a, d) {
        var c = this.chart,
          b = c.hoverSeries,
          f = c.hoverPoint,
          e = c.hoverPoints,
          g = c.tooltip,
          m = g && g.shared ? e : f;
        a && m && z(m).forEach(function (c) {
          c.series.isCartesian && "undefined" === typeof c.plotX && (a = !1);
        });
        if (a) g && m && z(m).length && (g.refresh(m), g.shared && e ? e.forEach(function (c) {
          c.setState(c.state, !0);
          c.series.isCartesian && (c.series.xAxis.crosshair && c.series.xAxis.drawCrosshair(null, c), c.series.yAxis.crosshair && c.series.yAxis.drawCrosshair(null, c));
        }) : f && (f.setState(f.state, !0), c.axes.forEach(function (c) {
          c.crosshair && f.series[c.coll] === c && c.drawCrosshair(null, f);
        })));else {
          if (f) f.onMouseOut();
          e && e.forEach(function (c) {
            c.setState();
          });
          if (b) b.onMouseOut();
          g && g.hide(d);
          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
          c.axes.forEach(function (c) {
            c.hideCrosshair();
          });
          this.hoverX = c.hoverPoints = c.hoverPoint = null;
        }
      };
      b.prototype.runPointActions = function (d, e) {
        var c = this.chart,
          f = c.tooltip && c.tooltip.options.enabled ? c.tooltip : void 0,
          l = f ? f.shared : !1,
          g = e || c.hoverPoint,
          m = g && g.series || c.hoverSeries;
        e = this.getHoverData(g, m, c.series, (!d || "touchmove" !== d.type) && (!!e || m && m.directTouch && this.isDirectTouch), l, d);
        g = e.hoverPoint;
        m = e.hoverSeries;
        var h = e.hoverPoints;
        e = m && m.tooltipOptions.followPointer && !m.tooltipOptions.split;
        l = l && m && !m.noSharedTooltip;
        if (g && (g !== c.hoverPoint || f && f.isHidden)) {
          (c.hoverPoints || []).forEach(function (c) {
            -1 === h.indexOf(c) && c.setState();
          });
          if (c.hoverSeries !== m) m.onMouseOver();
          this.applyInactiveState(h);
          (h || []).forEach(function (c) {
            c.setState("hover");
          });
          c.hoverPoint && c.hoverPoint.firePointEvent("mouseOut");
          if (!g.series) return;
          c.hoverPoints = h;
          c.hoverPoint = g;
          g.firePointEvent("mouseOver");
          f && f.refresh(l ? h : g, d);
        } else e && f && !f.isHidden && (g = f.getAnchor([{}], d), c.isInsidePlot(g[0], g[1], {
          visiblePlotOnly: !0
        }) && f.updatePosition({
          plotX: g[0],
          plotY: g[1]
        }));
        this.unDocMouseMove || (this.unDocMouseMove = k(c.container.ownerDocument, "mousemove", function (c) {
          var a = D[b.hoverChartIndex];
          if (a) a.pointer.onDocumentMouseMove(c);
        }), this.eventsToUnbind.push(this.unDocMouseMove));
        c.axes.forEach(function (b) {
          var f = q((b.crosshair || {}).snap, !0),
            e;
          f && ((e = c.hoverPoint) && e.series[b.coll] === b || (e = a(h, function (c) {
            return c.series[b.coll] === b;
          })));
          e || !f ? b.drawCrosshair(d, e) : b.hideCrosshair();
        });
      };
      b.prototype.scaleGroups = function (a, d) {
        var c = this.chart;
        c.series.forEach(function (b) {
          var f = a || b.getPlotBox();
          b.group && (b.xAxis && b.xAxis.zoomEnabled || c.mapView) && (b.group.attr(f), b.markerGroup && (b.markerGroup.attr(f), b.markerGroup.clip(d ? c.clipRect : null)), b.dataLabelsGroup && b.dataLabelsGroup.attr(f));
        });
        c.clipRect.attr(d || c.clipBox);
      };
      b.prototype.setDOMEvents = function () {
        var a = this,
          d = this.chart.container,
          c = d.ownerDocument;
        d.onmousedown = this.onContainerMouseDown.bind(this);
        d.onmousemove = this.onContainerMouseMove.bind(this);
        d.onclick = this.onContainerClick.bind(this);
        this.eventsToUnbind.push(k(d, "mouseenter", this.onContainerMouseEnter.bind(this)));
        this.eventsToUnbind.push(k(d, "mouseleave", this.onContainerMouseLeave.bind(this)));
        b.unbindDocumentMouseUp || (b.unbindDocumentMouseUp = k(c, "mouseup", this.onDocumentMouseUp.bind(this)));
        for (var e = this.chart.renderTo.parentElement; e && "BODY" !== e.tagName;) this.eventsToUnbind.push(k(e, "scroll", function () {
          delete a.chartPosition;
        })), e = e.parentElement;
        p.hasTouch && (this.eventsToUnbind.push(k(d, "touchstart", this.onContainerTouchStart.bind(this), {
          passive: !1
        })), this.eventsToUnbind.push(k(d, "touchmove", this.onContainerTouchMove.bind(this), {
          passive: !1
        })), b.unbindDocumentTouchEnd || (b.unbindDocumentTouchEnd = k(c, "touchend", this.onDocumentTouchEnd.bind(this), {
          passive: !1
        })));
      };
      b.prototype.setHoverChartIndex = function () {
        var a = this.chart,
          d = p.charts[q(b.hoverChartIndex, -1)];
        if (d && d !== a) d.pointer.onContainerMouseLeave({
          relatedTarget: !0
        });
        d && d.mouseIsDown || (b.hoverChartIndex = a.index);
      };
      b.prototype.touch = function (a, d) {
        var c = this.chart,
          b;
        this.setHoverChartIndex();
        if (1 === a.touches.length) {
          if (a = this.normalize(a), (b = c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
            visiblePlotOnly: !0
          })) && !c.openMenu) {
            d && this.runPointActions(a);
            if ("touchmove" === a.type) {
              d = this.pinchDown;
              var f = d[0] ? 4 <= Math.sqrt(Math.pow(d[0].chartX - a.chartX, 2) + Math.pow(d[0].chartY - a.chartY, 2)) : !1;
            }
            q(f, !0) && this.pinch(a);
          } else d && this.reset();
        } else 2 === a.touches.length && this.pinch(a);
      };
      b.prototype.touchSelect = function (a) {
        return !(!this.chart.options.chart.zoomBySingleTouch || !a.touches || 1 !== a.touches.length);
      };
      b.prototype.zoomOption = function (a) {
        var d = this.chart,
          c = d.options.chart;
        d = d.inverted;
        var b = c.zoomType || "";
        /touch/.test(a.type) && (b = q(c.pinchType, b));
        this.zoomX = a = /x/.test(b);
        this.zoomY = c = /y/.test(b);
        this.zoomHor = a && !d || c && d;
        this.zoomVert = c && !d || a && d;
        this.hasZoom = a || c;
      };
      return b;
    }();
    "";
    return b;
  });
  G(b, "Core/MSPointer.js", [b["Core/Globals.js"], b["Core/Pointer.js"], b["Core/Utilities.js"]], function (b, p, A) {
    function v() {
      var d = [];
      d.item = function (a) {
        return this[a];
      };
      a(g, function (a) {
        d.push({
          pageX: a.pageX,
          pageY: a.pageY,
          target: a.target
        });
      });
      return d;
    }
    function w(a, d, b, e) {
      var g = B[p.hoverChartIndex || NaN];
      "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !g || (g = g.pointer, e(a), g[d]({
        type: b,
        target: a.currentTarget,
        preventDefault: t,
        touches: v()
      }));
    }
    var D = this && this.__extends || function () {
        var a = function (d, b) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var b in d) d.hasOwnProperty(b) && (a[b] = d[b]);
          };
          return a(d, b);
        };
        return function (d, b) {
          function e() {
            this.constructor = d;
          }
          a(d, b);
          d.prototype = null === b ? Object.create(b) : (e.prototype = b.prototype, new e());
        };
      }(),
      B = b.charts,
      k = b.doc,
      t = b.noop,
      n = b.win,
      h = A.addEvent,
      d = A.css,
      a = A.objectEach,
      e = A.removeEvent,
      g = {},
      x = !!n.PointerEvent;
    return function (a) {
      function r() {
        return null !== a && a.apply(this, arguments) || this;
      }
      D(r, a);
      r.isRequired = function () {
        return !(b.hasTouch || !n.PointerEvent && !n.MSPointerEvent);
      };
      r.prototype.batchMSEvents = function (a) {
        a(this.chart.container, x ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
        a(this.chart.container, x ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
        a(k, x ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
      };
      r.prototype.destroy = function () {
        this.batchMSEvents(e);
        a.prototype.destroy.call(this);
      };
      r.prototype.init = function (b, e) {
        a.prototype.init.call(this, b, e);
        this.hasZoom && d(b.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      };
      r.prototype.onContainerPointerDown = function (a) {
        w(a, "onContainerTouchStart", "touchstart", function (a) {
          g[a.pointerId] = {
            pageX: a.pageX,
            pageY: a.pageY,
            target: a.currentTarget
          };
        });
      };
      r.prototype.onContainerPointerMove = function (a) {
        w(a, "onContainerTouchMove", "touchmove", function (a) {
          g[a.pointerId] = {
            pageX: a.pageX,
            pageY: a.pageY
          };
          g[a.pointerId].target || (g[a.pointerId].target = a.currentTarget);
        });
      };
      r.prototype.onDocumentPointerUp = function (a) {
        w(a, "onDocumentTouchEnd", "touchend", function (a) {
          delete g[a.pointerId];
        });
      };
      r.prototype.setDOMEvents = function () {
        a.prototype.setDOMEvents.call(this);
        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(h);
      };
      return r;
    }(p);
  });
  G(b, "Core/Legend/Legend.js", [b["Core/Animation/AnimationUtilities.js"], b["Core/FormatUtilities.js"], b["Core/Globals.js"], b["Core/Series/Point.js"], b["Core/Renderer/RendererUtilities.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D) {
    var v = b.animObject,
      k = b.setAnimation,
      t = p.format;
    b = A.isFirefox;
    var n = A.marginNames;
    A = A.win;
    var h = w.distribute,
      d = D.addEvent,
      a = D.createElement,
      e = D.css,
      g = D.defined,
      x = D.discardElement,
      C = D.find,
      r = D.fireEvent,
      q = D.isNumber,
      z = D.merge,
      m = D.pick,
      f = D.relativeLength,
      y = D.stableSort,
      c = D.syncTimeout;
    w = D.wrap;
    D = function () {
      function b(c, a) {
        this.allItems = [];
        this.contentGroup = this.box = void 0;
        this.display = !1;
        this.group = void 0;
        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
        this.options = {};
        this.padding = 0;
        this.pages = [];
        this.proximate = !1;
        this.scrollGroup = void 0;
        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
        this.chart = c;
        this.init(c, a);
      }
      b.prototype.init = function (c, a) {
        this.chart = c;
        this.setOptions(a);
        a.enabled && (this.render(), d(this.chart, "endResize", function () {
          this.legend.positionCheckboxes();
        }), this.proximate ? this.unchartrender = d(this.chart, "render", function () {
          this.legend.proximatePositions();
          this.legend.positionItems();
        }) : this.unchartrender && this.unchartrender());
      };
      b.prototype.setOptions = function (c) {
        var a = m(c.padding, 8);
        this.options = c;
        this.chart.styledMode || (this.itemStyle = c.itemStyle, this.itemHiddenStyle = z(this.itemStyle, c.itemHiddenStyle));
        this.itemMarginTop = c.itemMarginTop || 0;
        this.itemMarginBottom = c.itemMarginBottom || 0;
        this.padding = a;
        this.initialItemY = a - 5;
        this.symbolWidth = m(c.symbolWidth, 16);
        this.pages = [];
        this.proximate = "proximate" === c.layout && !this.chart.inverted;
        this.baseline = void 0;
      };
      b.prototype.update = function (c, a) {
        var d = this.chart;
        this.setOptions(z(!0, this.options, c));
        this.destroy();
        d.isDirtyLegend = d.isDirtyBox = !0;
        m(a, !0) && d.redraw();
        r(this, "afterUpdate");
      };
      b.prototype.colorizeItem = function (c, a) {
        c.legendGroup[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
        if (!this.chart.styledMode) {
          var d = this.options,
            b = c.legendItem,
            f = c.legendLine,
            e = c.legendSymbol,
            g = this.itemHiddenStyle.color;
          d = a ? d.itemStyle.color : g;
          var l = a ? c.color || g : g,
            m = c.options && c.options.marker,
            h = {
              fill: l
            };
          b && b.css({
            fill: d,
            color: d
          });
          f && f.attr({
            stroke: l
          });
          e && (m && e.isMarker && (h = c.pointAttribs(), a || (h.stroke = h.fill = g)), e.attr(h));
        }
        r(this, "afterColorizeItem", {
          item: c,
          visible: a
        });
      };
      b.prototype.positionItems = function () {
        this.allItems.forEach(this.positionItem, this);
        this.chart.isResizing || this.positionCheckboxes();
      };
      b.prototype.positionItem = function (c) {
        var a = this,
          d = this.options,
          b = d.symbolPadding,
          f = !d.rtl,
          e = c._legendItemPos;
        d = e[0];
        e = e[1];
        var l = c.checkbox,
          m = c.legendGroup;
        m && m.element && (b = {
          translateX: f ? d : this.legendWidth - d - 2 * b - 4,
          translateY: e
        }, f = function () {
          r(a, "afterPositionItem", {
            item: c
          });
        }, g(m.translateY) ? m.animate(b, void 0, f) : (m.attr(b), f()));
        l && (l.x = d, l.y = e);
      };
      b.prototype.destroyItem = function (c) {
        var a = c.checkbox;
        ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (a) {
          c[a] && (c[a] = c[a].destroy());
        });
        a && x(c.checkbox);
      };
      b.prototype.destroy = function () {
        function c(c) {
          this[c] && (this[c] = this[c].destroy());
        }
        this.getAllItems().forEach(function (a) {
          ["legendItem", "legendGroup"].forEach(c, a);
        });
        "clipRect up down pager nav box title group".split(" ").forEach(c, this);
        this.display = null;
      };
      b.prototype.positionCheckboxes = function () {
        var c = this.group && this.group.alignAttr,
          a = this.clipHeight || this.legendHeight,
          d = this.titleHeight;
        if (c) {
          var b = c.translateY;
          this.allItems.forEach(function (f) {
            var g = f.checkbox;
            if (g) {
              var l = b + d + g.y + (this.scrollOffset || 0) + 3;
              e(g, {
                left: c.translateX + f.checkboxOffset + g.x - 20 + "px",
                top: l + "px",
                display: this.proximate || l > b - 6 && l < b + a - 6 ? "" : "none"
              });
            }
          }, this);
        }
      };
      b.prototype.renderTitle = function () {
        var c = this.options,
          a = this.padding,
          d = c.title,
          b = 0;
        d.text && (this.title || (this.title = this.chart.renderer.label(d.text, a - 3, a - 4, null, null, null, c.useHTML, null, "legend-title").attr({
          zIndex: 1
        }), this.chart.styledMode || this.title.css(d.style), this.title.add(this.group)), d.width || this.title.css({
          width: this.maxLegendWidth + "px"
        }), c = this.title.getBBox(), b = c.height, this.offsetWidth = c.width, this.contentGroup.attr({
          translateY: b
        }));
        this.titleHeight = b;
      };
      b.prototype.setText = function (c) {
        var a = this.options;
        c.legendItem.attr({
          text: a.labelFormat ? t(a.labelFormat, c, this.chart) : a.labelFormatter.call(c)
        });
      };
      b.prototype.renderItem = function (c) {
        var a = this.chart,
          d = a.renderer,
          b = this.options,
          f = this.symbolWidth,
          e = b.symbolPadding || 0,
          g = this.itemStyle,
          l = this.itemHiddenStyle,
          h = "horizontal" === b.layout ? m(b.itemDistance, 20) : 0,
          k = !b.rtl,
          q = !c.series,
          r = !q && c.series.drawLegendSymbol ? c.series : c,
          n = r.options,
          u = this.createCheckboxForItem && n && n.showCheckbox,
          y = b.useHTML,
          x = c.options.className,
          t = c.legendItem;
        n = f + e + h + (u ? 20 : 0);
        t || (c.legendGroup = d.g("legend-item").addClass("highcharts-" + r.type + "-series highcharts-color-" + c.colorIndex + (x ? " " + x : "") + (q ? " highcharts-series-" + c.index : "")).attr({
          zIndex: 1
        }).add(this.scrollGroup), c.legendItem = t = d.text("", k ? f + e : -e, this.baseline || 0, y), a.styledMode || t.css(z(c.visible ? g : l)), t.attr({
          align: k ? "left" : "right",
          zIndex: 2
        }).add(c.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(a.styledMode ? 12 : g.fontSize, t), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, t.attr("y", this.baseline), this.symbolHeight = b.symbolHeight || this.fontMetrics.f, b.squareSymbol && (this.symbolWidth = m(b.symbolWidth, Math.max(this.symbolHeight, 16)), n = this.symbolWidth + e + h + (u ? 20 : 0), k && t.attr("x", this.symbolWidth + e))), r.drawLegendSymbol(this, c), this.setItemEvents && this.setItemEvents(c, t, y));
        u && !c.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(c);
        this.colorizeItem(c, c.visible);
        !a.styledMode && g.width || t.css({
          width: (b.itemWidth || this.widthOption || a.spacingBox.width) - n + "px"
        });
        this.setText(c);
        a = t.getBBox();
        d = this.fontMetrics && this.fontMetrics.h || 0;
        c.itemWidth = c.checkboxOffset = b.itemWidth || c.legendItemWidth || a.width + n;
        this.maxItemWidth = Math.max(this.maxItemWidth, c.itemWidth);
        this.totalItemWidth += c.itemWidth;
        this.itemHeight = c.itemHeight = Math.round(c.legendItemHeight || (a.height > 1.5 * d ? a.height : d));
      };
      b.prototype.layoutItem = function (c) {
        var a = this.options,
          d = this.padding,
          b = "horizontal" === a.layout,
          f = c.itemHeight,
          e = this.itemMarginBottom,
          g = this.itemMarginTop,
          l = b ? m(a.itemDistance, 20) : 0,
          h = this.maxLegendWidth;
        a = a.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : c.itemWidth;
        b && this.itemX - d + a > h && (this.itemX = d, this.lastLineHeight && (this.itemY += g + this.lastLineHeight + e), this.lastLineHeight = 0);
        this.lastItemY = g + this.itemY + e;
        this.lastLineHeight = Math.max(f, this.lastLineHeight);
        c._legendItemPos = [this.itemX, this.itemY];
        b ? this.itemX += a : (this.itemY += g + f + e, this.lastLineHeight = f);
        this.offsetWidth = this.widthOption || Math.max((b ? this.itemX - d - (c.checkbox ? 0 : l) : a) + d, this.offsetWidth);
      };
      b.prototype.getAllItems = function () {
        var c = [];
        this.chart.series.forEach(function (a) {
          var d = a && a.options;
          a && m(d.showInLegend, g(d.linkedTo) ? !1 : void 0, !0) && (c = c.concat(a.legendItems || ("point" === d.legendType ? a.data : a)));
        });
        r(this, "afterGetAllItems", {
          allItems: c
        });
        return c;
      };
      b.prototype.getAlignment = function () {
        var c = this.options;
        return this.proximate ? c.align.charAt(0) + "tv" : c.floating ? "" : c.align.charAt(0) + c.verticalAlign.charAt(0) + c.layout.charAt(0);
      };
      b.prototype.adjustMargins = function (c, a) {
        var d = this.chart,
          b = this.options,
          f = this.getAlignment();
        f && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (e, l) {
          e.test(f) && !g(c[l]) && (d[n[l]] = Math.max(d[n[l]], d.legend[(l + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][l] * b[l % 2 ? "x" : "y"] + m(b.margin, 12) + a[l] + (d.titleOffset[l] || 0)));
        });
      };
      b.prototype.proximatePositions = function () {
        var c = this.chart,
          a = [],
          d = "left" === this.options.align;
        this.allItems.forEach(function (b) {
          var f;
          var e = d;
          if (b.yAxis) {
            b.xAxis.options.reversed && (e = !e);
            b.points && (f = C(e ? b.points : b.points.slice(0).reverse(), function (c) {
              return q(c.plotY);
            }));
            e = this.itemMarginTop + b.legendItem.getBBox().height + this.itemMarginBottom;
            var g = b.yAxis.top - c.plotTop;
            b.visible ? (f = f ? f.plotY : b.yAxis.height, f += g - .3 * e) : f = g + b.yAxis.height;
            a.push({
              target: f,
              size: e,
              item: b
            });
          }
        }, this);
        h(a, c.plotHeight).forEach(function (a) {
          a.item._legendItemPos && (a.item._legendItemPos[1] = c.plotTop - c.spacing[0] + a.pos);
        });
      };
      b.prototype.render = function () {
        var c = this.chart,
          a = c.renderer,
          d = this.options,
          b = this.padding,
          e = this.getAllItems(),
          g = this.group,
          m = this.box;
        this.itemX = b;
        this.itemY = this.initialItemY;
        this.lastItemY = this.offsetWidth = 0;
        this.widthOption = f(d.width, c.spacingBox.width - b);
        var h = c.spacingBox.width - 2 * b - d.x;
        -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (h /= 2);
        this.maxLegendWidth = this.widthOption || h;
        g || (this.group = g = a.g("legend").addClass(d.className || "").attr({
          zIndex: 7
        }).add(), this.contentGroup = a.g().attr({
          zIndex: 1
        }).add(g), this.scrollGroup = a.g().add(this.contentGroup));
        this.renderTitle();
        y(e, function (c, a) {
          return (c.options && c.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0);
        });
        d.reversed && e.reverse();
        this.allItems = e;
        this.display = h = !!e.length;
        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
        e.forEach(this.renderItem, this);
        e.forEach(this.layoutItem, this);
        e = (this.widthOption || this.offsetWidth) + b;
        var k = this.lastItemY + this.lastLineHeight + this.titleHeight;
        k = this.handleOverflow(k);
        k += b;
        m || (this.box = m = a.rect().addClass("highcharts-legend-box").attr({
          r: d.borderRadius
        }).add(g), m.isNew = !0);
        c.styledMode || m.attr({
          stroke: d.borderColor,
          "stroke-width": d.borderWidth || 0,
          fill: d.backgroundColor || "none"
        }).shadow(d.shadow);
        0 < e && 0 < k && (m[m.isNew ? "attr" : "animate"](m.crisp.call({}, {
          x: 0,
          y: 0,
          width: e,
          height: k
        }, m.strokeWidth())), m.isNew = !1);
        m[h ? "show" : "hide"]();
        c.styledMode && "none" === g.getStyle("display") && (e = k = 0);
        this.legendWidth = e;
        this.legendHeight = k;
        h && this.align();
        this.proximate || this.positionItems();
        r(this, "afterRender");
      };
      b.prototype.align = function (c) {
        void 0 === c && (c = this.chart.spacingBox);
        var a = this.chart,
          d = this.options,
          b = c.y;
        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? b += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (b -= a.titleOffset[2]);
        b !== c.y && (c = z(c, {
          y: b
        }));
        this.group.align(z(d, {
          width: this.legendWidth,
          height: this.legendHeight,
          verticalAlign: this.proximate ? "top" : d.verticalAlign
        }), !0, c);
      };
      b.prototype.handleOverflow = function (c) {
        var a = this,
          d = this.chart,
          b = d.renderer,
          f = this.options,
          e = f.y,
          g = "top" === f.verticalAlign,
          l = this.padding,
          h = f.maxHeight,
          k = f.navigation,
          q = m(k.animation, !0),
          r = k.arrowSize || 12,
          n = this.pages,
          u = this.allItems,
          y = function (c) {
            "number" === typeof c ? v.attr({
              height: c
            }) : v && (a.clipRect = v.destroy(), a.contentGroup.clip());
            a.contentGroup.div && (a.contentGroup.div.style.clip = c ? "rect(" + l + "px,9999px," + (l + c) + "px,0)" : "auto");
          },
          z = function (c) {
            a[c] = b.circle(0, 0, 1.3 * r).translate(r / 2, r / 2).add(C);
            d.styledMode || a[c].attr("fill", "rgba(0,0,0,0.0001)");
            return a[c];
          },
          x,
          t;
        e = d.spacingBox.height + (g ? -e : e) - l;
        var C = this.nav,
          v = this.clipRect;
        "horizontal" !== f.layout || "middle" === f.verticalAlign || f.floating || (e /= 2);
        h && (e = Math.min(e, h));
        n.length = 0;
        c && 0 < e && c > e && !1 !== k.enabled ? (this.clipHeight = x = Math.max(e - 20 - this.titleHeight - l, 0), this.currentPage = m(this.currentPage, 1), this.fullHeight = c, u.forEach(function (c, a) {
          var d = c._legendItemPos[1],
            b = Math.round(c.legendItem.getBBox().height),
            f = n.length;
          if (!f || d - n[f - 1] > x && (t || d) !== n[f - 1]) n.push(t || d), f++;
          c.pageIx = f - 1;
          t && (u[a - 1].pageIx = f - 1);
          a === u.length - 1 && d + b - n[f - 1] > x && b <= x && (n.push(d), c.pageIx = f);
          d !== t && (t = d);
        }), v || (v = a.clipRect = b.clipRect(0, l, 9999, 0), a.contentGroup.clip(v)), y(x), C || (this.nav = C = b.g().attr({
          zIndex: 1
        }).add(this.group), this.up = b.symbol("triangle", 0, 0, r, r).add(C), z("upTracker").on("click", function () {
          a.scroll(-1, q);
        }), this.pager = b.text("", 15, 10).addClass("highcharts-legend-navigation"), d.styledMode || this.pager.css(k.style), this.pager.add(C), this.down = b.symbol("triangle-down", 0, 0, r, r).add(C), z("downTracker").on("click", function () {
          a.scroll(1, q);
        })), a.scroll(0), c = e) : C && (y(), this.nav = C.destroy(), this.scrollGroup.attr({
          translateY: 1
        }), this.clipHeight = 0);
        return c;
      };
      b.prototype.scroll = function (a, d) {
        var b = this,
          f = this.chart,
          e = this.pages,
          g = e.length,
          l = this.clipHeight,
          h = this.options.navigation,
          q = this.pager,
          n = this.padding,
          u = this.currentPage + a;
        u > g && (u = g);
        0 < u && ("undefined" !== typeof d && k(d, f), this.nav.attr({
          translateX: n,
          translateY: l + this.padding + 7 + this.titleHeight,
          visibility: "visible"
        }), [this.up, this.upTracker].forEach(function (c) {
          c.attr({
            "class": 1 === u ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }), q.attr({
          text: u + "/" + g
        }), [this.down, this.downTracker].forEach(function (c) {
          c.attr({
            x: 18 + this.pager.getBBox().width,
            "class": u === g ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }, this), f.styledMode || (this.up.attr({
          fill: 1 === u ? h.inactiveColor : h.activeColor
        }), this.upTracker.css({
          cursor: 1 === u ? "default" : "pointer"
        }), this.down.attr({
          fill: u === g ? h.inactiveColor : h.activeColor
        }), this.downTracker.css({
          cursor: u === g ? "default" : "pointer"
        })), this.scrollOffset = -e[u - 1] + this.initialItemY, this.scrollGroup.animate({
          translateY: this.scrollOffset
        }), this.currentPage = u, this.positionCheckboxes(), a = v(m(d, f.renderer.globalAnimation, !0)), c(function () {
          r(b, "afterScroll", {
            currentPage: u
          });
        }, a.duration));
      };
      b.prototype.setItemEvents = function (c, a, d) {
        var b = this,
          f = b.chart.renderer.boxWrapper,
          e = c instanceof E,
          g = "highcharts-legend-" + (e ? "point" : "series") + "-active",
          l = b.chart.styledMode,
          m = function (a) {
            b.allItems.forEach(function (d) {
              c !== d && [d].concat(d.linkedSeries || []).forEach(function (c) {
                c.setState(a, !e);
              });
            });
          };
        (d ? [a, c.legendSymbol] : [c.legendGroup]).forEach(function (d) {
          if (d) d.on("mouseover", function () {
            c.visible && m("inactive");
            c.setState("hover");
            c.visible && f.addClass(g);
            l || a.css(b.options.itemHoverStyle);
          }).on("mouseout", function () {
            b.chart.styledMode || a.css(z(c.visible ? b.itemStyle : b.itemHiddenStyle));
            m("");
            f.removeClass(g);
            c.setState();
          }).on("click", function (a) {
            var d = function () {
              c.setVisible && c.setVisible();
              m(c.visible ? "inactive" : "");
            };
            f.removeClass(g);
            a = {
              browserEvent: a
            };
            c.firePointEvent ? c.firePointEvent("legendItemClick", a, d) : r(c, "legendItemClick", a, d);
          });
        });
      };
      b.prototype.createCheckboxForItem = function (c) {
        c.checkbox = a("input", {
          type: "checkbox",
          className: "highcharts-legend-checkbox",
          checked: c.selected,
          defaultChecked: c.selected
        }, this.options.itemCheckboxStyle, this.chart.container);
        d(c.checkbox, "click", function (a) {
          r(c.series || c, "checkboxClick", {
            checked: a.target.checked,
            item: c
          }, function () {
            c.select();
          });
        });
      };
      return b;
    }();
    (/Trident\/7\.0/.test(A.navigator && A.navigator.userAgent) || b) && w(D.prototype, "positionItem", function (c, a) {
      var d = this,
        b = function () {
          a._legendItemPos && c.call(d, a);
        };
      b();
      d.bubbleLegend || setTimeout(b);
    });
    "";
    return D;
  });
  G(b, "Core/Series/SeriesRegistry.js", [b["Core/Globals.js"], b["Core/DefaultOptions.js"], b["Core/Series/Point.js"], b["Core/Utilities.js"]], function (b, p, A, E) {
    var v = p.defaultOptions,
      D = E.error,
      B = E.extendClass,
      k = E.merge,
      t;
    (function (n) {
      function h(d, a) {
        var b = v.plotOptions || {},
          g = a.defaultOptions;
        a.prototype.pointClass || (a.prototype.pointClass = A);
        a.prototype.type = d;
        g && (b[d] = g);
        n.seriesTypes[d] = a;
      }
      n.seriesTypes = b.seriesTypes;
      n.getSeries = function (d, a) {
        void 0 === a && (a = {});
        var b = d.options.chart;
        b = a.type || b.type || b.defaultSeriesType || "";
        var g = n.seriesTypes[b];
        n || D(17, !0, d, {
          missingModuleFor: b
        });
        b = new g();
        "function" === typeof b.init && b.init(d, a);
        return b;
      };
      n.registerSeriesType = h;
      n.seriesType = function (d, a, b, g, x) {
        var e = v.plotOptions || {};
        a = a || "";
        e[d] = k(e[a], b);
        h(d, B(n.seriesTypes[a] || function () {}, g));
        n.seriesTypes[d].prototype.type = d;
        x && (n.seriesTypes[d].prototype.pointClass = B(A, x));
        return n.seriesTypes[d];
      };
    })(t || (t = {}));
    return t;
  });
  G(b, "Core/Chart/Chart.js", [b["Core/Animation/AnimationUtilities.js"], b["Core/Axis/Axis.js"], b["Core/FormatUtilities.js"], b["Core/Foundation.js"], b["Core/Globals.js"], b["Core/Legend/Legend.js"], b["Core/MSPointer.js"], b["Core/DefaultOptions.js"], b["Core/Pointer.js"], b["Core/Renderer/RendererRegistry.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Renderer/SVG/SVGRenderer.js"], b["Core/Time.js"], b["Core/Utilities.js"], b["Core/Renderer/HTML/AST.js"]], function (b, p, A, E, w, D, B, k, t, n, h, d, a, e, g) {
    var x = b.animate,
      C = b.animObject,
      r = b.setAnimation,
      q = A.numberFormat,
      z = E.registerEventOptions,
      m = w.charts,
      f = w.doc,
      y = w.marginNames,
      c = w.svg,
      u = w.win,
      l = k.defaultOptions,
      v = k.defaultTime,
      K = h.seriesTypes,
      H = e.addEvent,
      I = e.attr,
      Z = e.cleanRecursively,
      Q = e.createElement,
      O = e.css,
      R = e.defined,
      T = e.discardElement,
      G = e.erase,
      J = e.error,
      ba = e.extend,
      ha = e.find,
      L = e.fireEvent,
      W = e.getStyle,
      M = e.isArray,
      X = e.isNumber,
      P = e.isObject,
      U = e.isString,
      S = e.merge,
      V = e.objectEach,
      N = e.pick,
      ca = e.pInt,
      ea = e.relativeLength,
      ia = e.removeEvent,
      aa = e.splat,
      fa = e.syncTimeout,
      ja = e.uniqueKey;
    b = function () {
      function b(c, a, d) {
        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
        this.sharedClips = {};
        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
        this.getArgs(c, a, d);
      }
      b.chart = function (c, a, d) {
        return new b(c, a, d);
      };
      b.prototype.getArgs = function (c, a, d) {
        U(c) || c.nodeName ? (this.renderTo = c, this.init(a, d)) : this.init(c, a);
      };
      b.prototype.init = function (c, d) {
        var b = c.plotOptions || {};
        L(this, "init", {
          args: arguments
        }, function () {
          var f = S(l, c),
            e = f.chart;
          V(f.plotOptions, function (c, a) {
            P(c) && (c.tooltip = b[a] && S(b[a].tooltip) || void 0);
          });
          f.tooltip.userOptions = c.chart && c.chart.forExport && c.tooltip.userOptions || c.tooltip;
          this.userOptions = c;
          this.margin = [];
          this.spacing = [];
          this.bounds = {
            h: {},
            v: {}
          };
          this.labelCollectors = [];
          this.callback = d;
          this.isResizing = 0;
          this.options = f;
          this.axes = [];
          this.series = [];
          this.time = c.time && Object.keys(c.time).length ? new a(c.time) : w.time;
          this.numberFormatter = e.numberFormatter || q;
          this.styledMode = e.styledMode;
          this.hasCartesianSeries = e.showAxes;
          this.index = m.length;
          m.push(this);
          w.chartCount++;
          z(this, e);
          this.xAxis = [];
          this.yAxis = [];
          this.pointCount = this.colorCounter = this.symbolCounter = 0;
          L(this, "afterInit");
          this.firstRender();
        });
      };
      b.prototype.initSeries = function (c) {
        var a = this.options.chart;
        a = c.type || a.type || a.defaultSeriesType;
        var d = K[a];
        d || J(17, !0, this, {
          missingModuleFor: a
        });
        a = new d();
        "function" === typeof a.init && a.init(this, c);
        return a;
      };
      b.prototype.setSeriesData = function () {
        this.getSeriesOrderByLinks().forEach(function (c) {
          c.points || c.data || !c.enabledDataSorting || c.setData(c.options.data, !1);
        });
      };
      b.prototype.getSeriesOrderByLinks = function () {
        return this.series.concat().sort(function (c, a) {
          return c.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - c.linkedSeries.length : 0;
        });
      };
      b.prototype.orderSeries = function (c) {
        var a = this.series;
        c = c || 0;
        for (var d = a.length; c < d; ++c) a[c] && (a[c].index = c, a[c].name = a[c].getName());
      };
      b.prototype.isInsidePlot = function (c, a, d) {
        void 0 === d && (d = {});
        var b = this.inverted,
          f = this.plotBox,
          e = this.plotLeft,
          g = this.plotTop,
          m = this.scrollablePlotBox,
          l = 0;
        var h = 0;
        d.visiblePlotOnly && this.scrollingContainer && (h = this.scrollingContainer, l = h.scrollLeft, h = h.scrollTop);
        var k = d.series;
        f = d.visiblePlotOnly && m || f;
        m = d.inverted ? a : c;
        a = d.inverted ? c : a;
        c = {
          x: m,
          y: a,
          isInsidePlot: !0
        };
        if (!d.ignoreX) {
          var q = k && (b ? k.yAxis : k.xAxis) || {
            pos: e,
            len: Infinity
          };
          m = d.paneCoordinates ? q.pos + m : e + m;
          m >= Math.max(l + e, q.pos) && m <= Math.min(l + e + f.width, q.pos + q.len) || (c.isInsidePlot = !1);
        }
        !d.ignoreY && c.isInsidePlot && (b = k && (b ? k.xAxis : k.yAxis) || {
          pos: g,
          len: Infinity
        }, d = d.paneCoordinates ? b.pos + a : g + a, d >= Math.max(h + g, b.pos) && d <= Math.min(h + g + f.height, b.pos + b.len) || (c.isInsidePlot = !1));
        L(this, "afterIsInsidePlot", c);
        return c.isInsidePlot;
      };
      b.prototype.redraw = function (c) {
        L(this, "beforeRedraw");
        var a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
          d = this.series,
          b = this.pointer,
          f = this.legend,
          e = this.userOptions.legend,
          g = this.renderer,
          m = g.isHidden(),
          l = [],
          h = this.isDirtyBox,
          k = this.isDirtyLegend;
        this.setResponsive && this.setResponsive(!1);
        r(this.hasRendered ? c : !1, this);
        m && this.temporaryDisplay();
        this.layOutTitles();
        for (c = d.length; c--;) {
          var q = d[c];
          if (q.options.stacking || q.options.centerInCategory) {
            var n = !0;
            if (q.isDirty) {
              var u = !0;
              break;
            }
          }
        }
        if (u) for (c = d.length; c--;) q = d[c], q.options.stacking && (q.isDirty = !0);
        d.forEach(function (c) {
          c.isDirty && ("point" === c.options.legendType ? ("function" === typeof c.updateTotals && c.updateTotals(), k = !0) : e && (e.labelFormatter || e.labelFormat) && (k = !0));
          c.isDirtyData && L(c, "updatedData");
        });
        k && f && f.options.enabled && (f.render(), this.isDirtyLegend = !1);
        n && this.getStacks();
        a.forEach(function (c) {
          c.updateNames();
          c.setScale();
        });
        this.getMargins();
        a.forEach(function (c) {
          c.isDirty && (h = !0);
        });
        a.forEach(function (c) {
          var a = c.min + "," + c.max;
          c.extKey !== a && (c.extKey = a, l.push(function () {
            L(c, "afterSetExtremes", ba(c.eventArgs, c.getExtremes()));
            delete c.eventArgs;
          }));
          (h || n) && c.redraw();
        });
        h && this.drawChartBox();
        L(this, "predraw");
        d.forEach(function (c) {
          (h || c.isDirty) && c.visible && c.redraw();
          c.isDirtyData = !1;
        });
        b && b.reset(!0);
        g.draw();
        L(this, "redraw");
        L(this, "render");
        m && this.temporaryDisplay(!0);
        l.forEach(function (c) {
          c.call();
        });
      };
      b.prototype.get = function (c) {
        function a(a) {
          return a.id === c || a.options && a.options.id === c;
        }
        for (var d = this.series, b = ha(this.axes, a) || ha(this.series, a), f = 0; !b && f < d.length; f++) b = ha(d[f].points || [], a);
        return b;
      };
      b.prototype.getAxes = function () {
        var c = this,
          a = this.options,
          d = a.xAxis = aa(a.xAxis || {});
        a = a.yAxis = aa(a.yAxis || {});
        L(this, "getAxes");
        d.forEach(function (c, a) {
          c.index = a;
          c.isX = !0;
        });
        a.forEach(function (c, a) {
          c.index = a;
        });
        d.concat(a).forEach(function (a) {
          new p(c, a);
        });
        L(this, "afterGetAxes");
      };
      b.prototype.getSelectedPoints = function () {
        return this.series.reduce(function (c, a) {
          a.getPointsCollection().forEach(function (a) {
            N(a.selectedStaging, a.selected) && c.push(a);
          });
          return c;
        }, []);
      };
      b.prototype.getSelectedSeries = function () {
        return this.series.filter(function (c) {
          return c.selected;
        });
      };
      b.prototype.setTitle = function (c, a, d) {
        this.applyDescription("title", c);
        this.applyDescription("subtitle", a);
        this.applyDescription("caption", void 0);
        this.layOutTitles(d);
      };
      b.prototype.applyDescription = function (c, a) {
        var d = this,
          b = "title" === c ? {
            color: "#333333",
            fontSize: this.options.isStock ? "16px" : "18px"
          } : {
            color: "#666666"
          };
        b = this.options[c] = S(!this.styledMode && {
          style: b
        }, this.options[c], a);
        var f = this[c];
        f && a && (this[c] = f = f.destroy());
        b && !f && (f = this.renderer.text(b.text, 0, 0, b.useHTML).attr({
          align: b.align,
          "class": "highcharts-" + c,
          zIndex: b.zIndex || 4
        }).add(), f.update = function (a) {
          d[{
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }[c]](a);
        }, this.styledMode || f.css(b.style), this[c] = f);
      };
      b.prototype.layOutTitles = function (c) {
        var a = [0, 0, 0],
          d = this.renderer,
          b = this.spacingBox;
        ["title", "subtitle", "caption"].forEach(function (c) {
          var f = this[c],
            e = this.options[c],
            g = e.verticalAlign || "top";
          c = "title" === c ? "top" === g ? -3 : 0 : "top" === g ? a[0] + 2 : 0;
          var m;
          if (f) {
            this.styledMode || (m = e.style && e.style.fontSize);
            m = d.fontMetrics(m, f).b;
            f.css({
              width: (e.width || b.width + (e.widthAdjust || 0)) + "px"
            });
            var l = Math.round(f.getBBox(e.useHTML).height);
            f.align(ba({
              y: "bottom" === g ? m : c + m,
              height: l
            }, e), !1, "spacingBox");
            e.floating || ("top" === g ? a[0] = Math.ceil(a[0] + l) : "bottom" === g && (a[2] = Math.ceil(a[2] + l)));
          }
        }, this);
        a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
        a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
        var f = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
        this.titleOffset = a;
        L(this, "afterLayOutTitles");
        !this.isDirtyBox && f && (this.isDirtyBox = this.isDirtyLegend = f, this.hasRendered && N(c, !0) && this.isDirtyBox && this.redraw());
      };
      b.prototype.getChartSize = function () {
        var c = this.options.chart,
          a = c.width;
        c = c.height;
        var d = this.renderTo;
        R(a) || (this.containerWidth = W(d, "width"));
        R(c) || (this.containerHeight = W(d, "height"));
        this.chartWidth = Math.max(0, a || this.containerWidth || 600);
        this.chartHeight = Math.max(0, ea(c, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
      };
      b.prototype.temporaryDisplay = function (c) {
        var a = this.renderTo;
        if (c) for (; a && a.style;) a.hcOrigStyle && (O(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (f.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {
          f.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, f.body.appendChild(a));
          if ("none" === W(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
            display: a.style.display,
            height: a.style.height,
            overflow: a.style.overflow
          }, c = {
            display: "block",
            overflow: "hidden"
          }, a !== this.renderTo && (c.height = 0), O(a, c), a.offsetWidth || a.style.setProperty("display", "block", "important");
          a = a.parentNode;
          if (a === f.body) break;
        }
      };
      b.prototype.setClassName = function (c) {
        this.container.className = "highcharts-container " + (c || "");
      };
      b.prototype.getContainer = function () {
        var a = this.options,
          b = a.chart,
          e = ja(),
          l,
          h = this.renderTo;
        h || (this.renderTo = h = b.renderTo);
        U(h) && (this.renderTo = h = f.getElementById(h));
        h || J(13, !0, this);
        var k = ca(I(h, "data-highcharts-chart"));
        X(k) && m[k] && m[k].hasRendered && m[k].destroy();
        I(h, "data-highcharts-chart", this.index);
        h.innerHTML = g.emptyHTML;
        b.skipClone || h.offsetWidth || this.temporaryDisplay();
        this.getChartSize();
        k = this.chartWidth;
        var q = this.chartHeight;
        O(h, {
          overflow: "hidden"
        });
        this.styledMode || (l = ba({
          position: "relative",
          overflow: "hidden",
          width: k + "px",
          height: q + "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
          userSelect: "none",
          "touch-action": "manipulation",
          outline: "none"
        }, b.style || {}));
        this.container = e = Q("div", {
          id: e
        }, l, h);
        this._cursor = e.style.cursor;
        this.renderer = new (b.renderer || !c ? n.getRendererType(b.renderer) : d)(e, k, q, void 0, b.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);
        r(void 0, this);
        this.setClassName(b.className);
        if (this.styledMode) for (var u in a.defs) this.renderer.definition(a.defs[u]);else this.renderer.setStyle(b.style);
        this.renderer.chartIndex = this.index;
        L(this, "afterGetContainer");
      };
      b.prototype.getMargins = function (c) {
        var a = this.spacing,
          d = this.margin,
          b = this.titleOffset;
        this.resetMargins();
        b[0] && !R(d[0]) && (this.plotTop = Math.max(this.plotTop, b[0] + a[0]));
        b[2] && !R(d[2]) && (this.marginBottom = Math.max(this.marginBottom, b[2] + a[2]));
        this.legend && this.legend.display && this.legend.adjustMargins(d, a);
        L(this, "getMargins");
        c || this.getAxisMargins();
      };
      b.prototype.getAxisMargins = function () {
        var c = this,
          a = c.axisOffset = [0, 0, 0, 0],
          d = c.colorAxis,
          b = c.margin,
          f = function (c) {
            c.forEach(function (c) {
              c.visible && c.getOffset();
            });
          };
        c.hasCartesianSeries ? f(c.axes) : d && d.length && f(d);
        y.forEach(function (d, f) {
          R(b[f]) || (c[d] += a[f]);
        });
        c.setChartSize();
      };
      b.prototype.reflow = function (c) {
        var a = this,
          d = a.options.chart,
          b = a.renderTo,
          g = R(d.width) && R(d.height),
          m = d.width || W(b, "width");
        d = d.height || W(b, "height");
        b = c ? c.target : u;
        delete a.pointer.chartPosition;
        if (!g && !a.isPrinting && m && d && (b === u || b === f)) {
          if (m !== a.containerWidth || d !== a.containerHeight) e.clearTimeout(a.reflowTimeout), a.reflowTimeout = fa(function () {
            a.container && a.setSize(void 0, void 0, !1);
          }, c ? 100 : 0);
          a.containerWidth = m;
          a.containerHeight = d;
        }
      };
      b.prototype.setReflow = function (c) {
        var a = this;
        !1 === c || this.unbindReflow ? !1 === c && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = H(u, "resize", function (c) {
          a.options && a.reflow(c);
        }), H(this, "destroy", this.unbindReflow));
      };
      b.prototype.setSize = function (c, a, d) {
        var b = this,
          f = b.renderer;
        b.isResizing += 1;
        r(d, b);
        d = f.globalAnimation;
        b.oldChartHeight = b.chartHeight;
        b.oldChartWidth = b.chartWidth;
        "undefined" !== typeof c && (b.options.chart.width = c);
        "undefined" !== typeof a && (b.options.chart.height = a);
        b.getChartSize();
        b.styledMode || (d ? x : O)(b.container, {
          width: b.chartWidth + "px",
          height: b.chartHeight + "px"
        }, d);
        b.setChartSize(!0);
        f.setSize(b.chartWidth, b.chartHeight, d);
        b.axes.forEach(function (c) {
          c.isDirty = !0;
          c.setScale();
        });
        b.isDirtyLegend = !0;
        b.isDirtyBox = !0;
        b.layOutTitles();
        b.getMargins();
        b.redraw(d);
        b.oldChartHeight = null;
        L(b, "resize");
        fa(function () {
          b && L(b, "endResize", null, function () {
            --b.isResizing;
          });
        }, C(d).duration);
      };
      b.prototype.setChartSize = function (c) {
        var a = this.inverted,
          d = this.renderer,
          b = this.chartWidth,
          f = this.chartHeight,
          e = this.options.chart,
          g = this.spacing,
          m = this.clipOffset,
          l,
          h,
          k,
          q;
        this.plotLeft = l = Math.round(this.plotLeft);
        this.plotTop = h = Math.round(this.plotTop);
        this.plotWidth = k = Math.max(0, Math.round(b - l - this.marginRight));
        this.plotHeight = q = Math.max(0, Math.round(f - h - this.marginBottom));
        this.plotSizeX = a ? q : k;
        this.plotSizeY = a ? k : q;
        this.plotBorderWidth = e.plotBorderWidth || 0;
        this.spacingBox = d.spacingBox = {
          x: g[3],
          y: g[0],
          width: b - g[3] - g[1],
          height: f - g[0] - g[2]
        };
        this.plotBox = d.plotBox = {
          x: l,
          y: h,
          width: k,
          height: q
        };
        a = 2 * Math.floor(this.plotBorderWidth / 2);
        b = Math.ceil(Math.max(a, m[3]) / 2);
        f = Math.ceil(Math.max(a, m[0]) / 2);
        this.clipBox = {
          x: b,
          y: f,
          width: Math.floor(this.plotSizeX - Math.max(a, m[1]) / 2 - b),
          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, m[2]) / 2 - f))
        };
        c || (this.axes.forEach(function (c) {
          c.setAxisSize();
          c.setAxisTranslation();
        }), d.alignElements());
        L(this, "afterSetChartSize", {
          skipAxes: c
        });
      };
      b.prototype.resetMargins = function () {
        L(this, "resetMargins");
        var c = this,
          a = c.options.chart;
        ["margin", "spacing"].forEach(function (d) {
          var b = a[d],
            f = P(b) ? b : [b, b, b, b];
          ["Top", "Right", "Bottom", "Left"].forEach(function (b, e) {
            c[d][e] = N(a[d + b], f[e]);
          });
        });
        y.forEach(function (a, d) {
          c[a] = N(c.margin[d], c.spacing[d]);
        });
        c.axisOffset = [0, 0, 0, 0];
        c.clipOffset = [0, 0, 0, 0];
      };
      b.prototype.drawChartBox = function () {
        var c = this.options.chart,
          a = this.renderer,
          d = this.chartWidth,
          b = this.chartHeight,
          f = this.styledMode,
          e = this.plotBGImage,
          g = c.backgroundColor,
          m = c.plotBackgroundColor,
          l = c.plotBackgroundImage,
          h = this.plotLeft,
          k = this.plotTop,
          q = this.plotWidth,
          r = this.plotHeight,
          n = this.plotBox,
          u = this.clipRect,
          y = this.clipBox,
          z = this.chartBackground,
          x = this.plotBackground,
          t = this.plotBorder,
          C,
          v = "animate";
        z || (this.chartBackground = z = a.rect().addClass("highcharts-background").add(), v = "attr");
        if (f) var M = C = z.strokeWidth();else {
          M = c.borderWidth || 0;
          C = M + (c.shadow ? 8 : 0);
          g = {
            fill: g || "none"
          };
          if (M || z["stroke-width"]) g.stroke = c.borderColor, g["stroke-width"] = M;
          z.attr(g).shadow(c.shadow);
        }
        z[v]({
          x: C / 2,
          y: C / 2,
          width: d - C - M % 2,
          height: b - C - M % 2,
          r: c.borderRadius
        });
        v = "animate";
        x || (v = "attr", this.plotBackground = x = a.rect().addClass("highcharts-plot-background").add());
        x[v](n);
        f || (x.attr({
          fill: m || "none"
        }).shadow(c.plotShadow), l && (e ? (l !== e.attr("href") && e.attr("href", l), e.animate(n)) : this.plotBGImage = a.image(l, h, k, q, r).add()));
        u ? u.animate({
          width: y.width,
          height: y.height
        }) : this.clipRect = a.clipRect(y);
        v = "animate";
        t || (v = "attr", this.plotBorder = t = a.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
        }).add());
        f || t.attr({
          stroke: c.plotBorderColor,
          "stroke-width": c.plotBorderWidth || 0,
          fill: "none"
        });
        t[v](t.crisp({
          x: h,
          y: k,
          width: q,
          height: r
        }, -t.strokeWidth()));
        this.isDirtyBox = !1;
        L(this, "afterDrawChartBox");
      };
      b.prototype.propFromSeries = function () {
        var c = this,
          a = c.options.chart,
          d = c.options.series,
          b,
          f,
          e;
        ["inverted", "angular", "polar"].forEach(function (g) {
          f = K[a.type || a.defaultSeriesType];
          e = a[g] || f && f.prototype[g];
          for (b = d && d.length; !e && b--;) (f = K[d[b].type]) && f.prototype[g] && (e = !0);
          c[g] = e;
        });
      };
      b.prototype.linkSeries = function () {
        var c = this,
          a = c.series;
        a.forEach(function (c) {
          c.linkedSeries.length = 0;
        });
        a.forEach(function (a) {
          var d = a.options.linkedTo;
          U(d) && (d = ":previous" === d ? c.series[a.index - 1] : c.get(d)) && d.linkedParent !== a && (d.linkedSeries.push(a), a.linkedParent = d, d.enabledDataSorting && a.setDataSortingOptions(), a.visible = N(a.options.visible, d.options.visible, a.visible));
        });
        L(this, "afterLinkSeries");
      };
      b.prototype.renderSeries = function () {
        this.series.forEach(function (c) {
          c.translate();
          c.render();
        });
      };
      b.prototype.renderLabels = function () {
        var c = this,
          a = c.options.labels;
        a.items && a.items.forEach(function (d) {
          var b = ba(a.style, d.style),
            f = ca(b.left) + c.plotLeft,
            e = ca(b.top) + c.plotTop + 12;
          delete b.left;
          delete b.top;
          c.renderer.text(d.html, f, e).attr({
            zIndex: 2
          }).css(b).add();
        });
      };
      b.prototype.render = function () {
        var c = this.axes,
          a = this.colorAxis,
          d = this.renderer,
          b = this.options,
          f = function (c) {
            c.forEach(function (c) {
              c.visible && c.render();
            });
          },
          e = 0;
        this.setTitle();
        this.legend = new D(this, b.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        b = this.plotWidth;
        c.some(function (c) {
          if (c.horiz && c.visible && c.options.labels.enabled && c.series.length) return e = 21, !0;
        });
        var g = this.plotHeight = Math.max(this.plotHeight - e, 0);
        c.forEach(function (c) {
          c.setScale();
        });
        this.getAxisMargins();
        var m = 1.1 < b / this.plotWidth,
          l = 1.05 < g / this.plotHeight;
        if (m || l) c.forEach(function (c) {
          (c.horiz && m || !c.horiz && l) && c.setTickInterval(!0);
        }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries ? f(c) : a && a.length && f(a);
        this.seriesGroup || (this.seriesGroup = d.g("series-group").attr({
          zIndex: 3
        }).add());
        this.renderSeries();
        this.renderLabels();
        this.addCredits();
        this.setResponsive && this.setResponsive();
        this.hasRendered = !0;
      };
      b.prototype.addCredits = function (c) {
        var a = this,
          d = S(!0, this.options.credits, c);
        d.enabled && !this.credits && (this.credits = this.renderer.text(d.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
          d.href && (u.location.href = d.href);
        }).attr({
          align: d.position.align,
          zIndex: 8
        }), a.styledMode || this.credits.css(d.style), this.credits.add().align(d.position), this.credits.update = function (c) {
          a.credits = a.credits.destroy();
          a.addCredits(c);
        });
      };
      b.prototype.destroy = function () {
        var c = this,
          a = c.axes,
          d = c.series,
          b = c.container,
          f = b && b.parentNode,
          e;
        L(c, "destroy");
        c.renderer.forExport ? G(m, c) : m[c.index] = void 0;
        w.chartCount--;
        c.renderTo.removeAttribute("data-highcharts-chart");
        ia(c);
        for (e = a.length; e--;) a[e] = a[e].destroy();
        this.scroller && this.scroller.destroy && this.scroller.destroy();
        for (e = d.length; e--;) d[e] = d[e].destroy();
        "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
          var d = c[a];
          d && d.destroy && (c[a] = d.destroy());
        });
        b && (b.innerHTML = g.emptyHTML, ia(b), f && T(b));
        V(c, function (a, d) {
          delete c[d];
        });
      };
      b.prototype.firstRender = function () {
        var c = this,
          a = c.options;
        if (!c.isReadyToRender || c.isReadyToRender()) {
          c.getContainer();
          c.resetMargins();
          c.setChartSize();
          c.propFromSeries();
          c.getAxes();
          (M(a.series) ? a.series : []).forEach(function (a) {
            c.initSeries(a);
          });
          c.linkSeries();
          c.setSeriesData();
          L(c, "beforeRender");
          t && (B.isRequired() ? c.pointer = new B(c, a) : c.pointer = new t(c, a));
          c.render();
          c.pointer.getChartPosition();
          if (!c.renderer.imgCount && !c.hasLoaded) c.onload();
          c.temporaryDisplay(!0);
        }
      };
      b.prototype.onload = function () {
        this.callbacks.concat([this.callback]).forEach(function (c) {
          c && "undefined" !== typeof this.index && c.apply(this, [this]);
        }, this);
        L(this, "load");
        L(this, "render");
        R(this.index) && this.setReflow(this.options.chart.reflow);
        this.hasLoaded = !0;
      };
      b.prototype.addSeries = function (c, a, d) {
        var b = this,
          f;
        c && (a = N(a, !0), L(b, "addSeries", {
          options: c
        }, function () {
          f = b.initSeries(c);
          b.isDirtyLegend = !0;
          b.linkSeries();
          f.enabledDataSorting && f.setData(c.data, !1);
          L(b, "afterAddSeries", {
            series: f
          });
          a && b.redraw(d);
        }));
        return f;
      };
      b.prototype.addAxis = function (c, a, d, b) {
        return this.createAxis(a ? "xAxis" : "yAxis", {
          axis: c,
          redraw: d,
          animation: b
        });
      };
      b.prototype.addColorAxis = function (c, a, d) {
        return this.createAxis("colorAxis", {
          axis: c,
          redraw: a,
          animation: d
        });
      };
      b.prototype.createAxis = function (c, a) {
        c = new p(this, S(a.axis, {
          index: this[c].length,
          isX: "xAxis" === c
        }));
        N(a.redraw, !0) && this.redraw(a.animation);
        return c;
      };
      b.prototype.showLoading = function (c) {
        var a = this,
          d = a.options,
          b = d.loading,
          f = function () {
            e && O(e, {
              left: a.plotLeft + "px",
              top: a.plotTop + "px",
              width: a.plotWidth + "px",
              height: a.plotHeight + "px"
            });
          },
          e = a.loadingDiv,
          m = a.loadingSpan;
        e || (a.loadingDiv = e = Q("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, a.container));
        m || (a.loadingSpan = m = Q("span", {
          className: "highcharts-loading-inner"
        }, null, e), H(a, "redraw", f));
        e.className = "highcharts-loading";
        g.setElementHTML(m, N(c, d.lang.loading, ""));
        a.styledMode || (O(e, ba(b.style, {
          zIndex: 10
        })), O(m, b.labelStyle), a.loadingShown || (O(e, {
          opacity: 0,
          display: ""
        }), x(e, {
          opacity: b.style.opacity || .5
        }, {
          duration: b.showDuration || 0
        })));
        a.loadingShown = !0;
        f();
      };
      b.prototype.hideLoading = function () {
        var c = this.options,
          a = this.loadingDiv;
        a && (a.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || x(a, {
          opacity: 0
        }, {
          duration: c.loading.hideDuration || 100,
          complete: function () {
            O(a, {
              display: "none"
            });
          }
        }));
        this.loadingShown = !1;
      };
      b.prototype.update = function (c, d, b, f) {
        var e = this,
          g = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          },
          m = c.isResponsiveOptions,
          l = [],
          h,
          k;
        L(e, "update", {
          options: c
        });
        m || e.setResponsive(!1, !0);
        c = Z(c, e.options);
        e.userOptions = S(e.userOptions, c);
        var q = c.chart;
        if (q) {
          S(!0, e.options.chart, q);
          "className" in q && e.setClassName(q.className);
          "reflow" in q && e.setReflow(q.reflow);
          if ("inverted" in q || "polar" in q || "type" in q) {
            e.propFromSeries();
            var r = !0;
          }
          "alignTicks" in q && (r = !0);
          "events" in q && z(this, q);
          V(q, function (c, a) {
            -1 !== e.propsRequireUpdateSeries.indexOf("chart." + a) && (h = !0);
            -1 !== e.propsRequireDirtyBox.indexOf(a) && (e.isDirtyBox = !0);
            -1 !== e.propsRequireReflow.indexOf(a) && (m ? e.isDirtyBox = !0 : k = !0);
          });
          !e.styledMode && q.style && e.renderer.setStyle(e.options.chart.style || {});
        }
        !e.styledMode && c.colors && (this.options.colors = c.colors);
        c.time && (this.time === v && (this.time = new a(c.time)), S(!0, e.options.time, c.time));
        V(c, function (a, d) {
          if (e[d] && "function" === typeof e[d].update) e[d].update(a, !1);else if ("function" === typeof e[g[d]]) e[g[d]](a);else "colors" !== d && -1 === e.collectionsWithUpdate.indexOf(d) && S(!0, e.options[d], c[d]);
          "chart" !== d && -1 !== e.propsRequireUpdateSeries.indexOf(d) && (h = !0);
        });
        this.collectionsWithUpdate.forEach(function (a) {
          if (c[a]) {
            var d = [];
            e[a].forEach(function (c, a) {
              c.options.isInternal || d.push(N(c.options.index, a));
            });
            aa(c[a]).forEach(function (c, f) {
              var g = R(c.id),
                m;
              g && (m = e.get(c.id));
              !m && e[a] && (m = e[a][d ? d[f] : f]) && g && R(m.options.id) && (m = void 0);
              m && m.coll === a && (m.update(c, !1), b && (m.touched = !0));
              !m && b && e.collectionsWithInit[a] && (e.collectionsWithInit[a][0].apply(e, [c].concat(e.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);
            });
            b && e[a].forEach(function (c) {
              c.touched || c.options.isInternal ? delete c.touched : l.push(c);
            });
          }
        });
        l.forEach(function (c) {
          c.chart && c.remove && c.remove(!1);
        });
        r && e.axes.forEach(function (c) {
          c.update({}, !1);
        });
        h && e.getSeriesOrderByLinks().forEach(function (c) {
          c.chart && c.update({}, !1);
        }, this);
        r = q && q.width;
        q = q && (U(q.height) ? ea(q.height, r || e.chartWidth) : q.height);
        k || X(r) && r !== e.chartWidth || X(q) && q !== e.chartHeight ? e.setSize(r, q, f) : N(d, !0) && e.redraw(f);
        L(e, "afterUpdate", {
          options: c,
          redraw: d,
          animation: f
        });
      };
      b.prototype.setSubtitle = function (c, a) {
        this.applyDescription("subtitle", c);
        this.layOutTitles(a);
      };
      b.prototype.setCaption = function (c, a) {
        this.applyDescription("caption", c);
        this.layOutTitles(a);
      };
      b.prototype.showResetZoom = function () {
        function c() {
          a.zoomOut();
        }
        var a = this,
          d = l.lang,
          b = a.options.chart.resetZoomButton,
          f = b.theme,
          e = f.states,
          g = "chart" === b.relativeTo || "spacingBox" === b.relativeTo ? null : "scrollablePlotBox";
        L(this, "beforeShowResetZoom", null, function () {
          a.resetZoomButton = a.renderer.button(d.resetZoom, null, null, c, f, e && e.hover).attr({
            align: b.position.align,
            title: d.resetZoomTitle
          }).addClass("highcharts-reset-zoom").add().align(b.position, !1, g);
        });
        L(this, "afterShowResetZoom");
      };
      b.prototype.zoomOut = function () {
        L(this, "selection", {
          resetSelection: !0
        }, this.zoom);
      };
      b.prototype.zoom = function (c) {
        var a = this,
          d = a.pointer,
          b = a.inverted ? d.mouseDownX : d.mouseDownY,
          f = !1,
          e;
        !c || c.resetSelection ? (a.axes.forEach(function (c) {
          e = c.zoom();
        }), d.initiated = !1) : c.xAxis.concat(c.yAxis).forEach(function (c) {
          var g = c.axis,
            m = a.inverted ? g.left : g.top,
            l = a.inverted ? m + g.width : m + g.height,
            h = g.isXAxis,
            k = !1;
          if (!h && b >= m && b <= l || h || !R(b)) k = !0;
          d[h ? "zoomX" : "zoomY"] && k && (e = g.zoom(c.min, c.max), g.displayBtn && (f = !0));
        });
        var g = a.resetZoomButton;
        f && !g ? a.showResetZoom() : !f && P(g) && (a.resetZoomButton = g.destroy());
        e && a.redraw(N(a.options.chart.animation, c && c.animation, 100 > a.pointCount));
      };
      b.prototype.pan = function (c, a) {
        var d = this,
          b = d.hoverPoints;
        a = "object" === typeof a ? a : {
          enabled: a,
          type: "x"
        };
        var f = d.options.chart,
          e = d.options.mapNavigation && d.options.mapNavigation.enabled;
        f && f.panning && (f.panning = a);
        var g = a.type,
          m;
        L(this, "pan", {
          originalEvent: c
        }, function () {
          b && b.forEach(function (c) {
            c.setState();
          });
          var a = d.xAxis;
          "xy" === g ? a = a.concat(d.yAxis) : "y" === g && (a = d.yAxis);
          var f = {};
          a.forEach(function (a) {
            if (a.options.panningEnabled && !a.options.isInternal) {
              var b = a.horiz,
                l = c[b ? "chartX" : "chartY"];
              b = b ? "mouseDownX" : "mouseDownY";
              var h = d[b],
                k = a.minPointOffset || 0,
                q = a.reversed && !d.inverted || !a.reversed && d.inverted ? -1 : 1,
                r = a.getExtremes(),
                n = a.toValue(h - l, !0) + k * q,
                u = a.toValue(h + a.len - l, !0) - (k * q || a.isXAxis && a.pointRangePadding || 0),
                y = u < n;
              q = a.hasVerticalPanning();
              h = y ? u : n;
              n = y ? n : u;
              var z = a.panningState;
              !q || a.isXAxis || z && !z.isDirty || a.series.forEach(function (c) {
                var a = c.getProcessedData(!0);
                a = c.getExtremes(a.yData, !0);
                z || (z = {
                  startMin: Number.MAX_VALUE,
                  startMax: -Number.MAX_VALUE
                });
                X(a.dataMin) && X(a.dataMax) && (z.startMin = Math.min(N(c.options.threshold, Infinity), a.dataMin, z.startMin), z.startMax = Math.max(N(c.options.threshold, -Infinity), a.dataMax, z.startMax));
              });
              q = Math.min(N(z && z.startMin, r.dataMin), k ? r.min : a.toValue(a.toPixels(r.min) - a.minPixelPadding));
              u = Math.max(N(z && z.startMax, r.dataMax), k ? r.max : a.toValue(a.toPixels(r.max) + a.minPixelPadding));
              a.panningState = z;
              a.isOrdinal || (k = q - h, 0 < k && (n += k, h = q), k = n - u, 0 < k && (n = u, h -= k), a.series.length && h !== r.min && n !== r.max && h >= q && n <= u && (a.setExtremes(h, n, !1, !1, {
                trigger: "pan"
              }), d.resetZoomButton || e || h === q || n === u || !g.match("y") || (d.showResetZoom(), a.displayBtn = !1), m = !0), f[b] = l);
            }
          });
          V(f, function (c, a) {
            d[a] = c;
          });
          m && d.redraw(!1);
          O(d.container, {
            cursor: "move"
          });
        });
      };
      return b;
    }();
    ba(b.prototype, {
      callbacks: [],
      collectionsWithInit: {
        xAxis: [b.prototype.addAxis, [!0]],
        yAxis: [b.prototype.addAxis, [!1]],
        series: [b.prototype.addSeries]
      },
      collectionsWithUpdate: ["xAxis", "yAxis", "series"],
      propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
      propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
    });
    "";
    return b;
  });
  G(b, "Core/Legend/LegendSymbol.js", [b["Core/Utilities.js"]], function (b) {
    var v = b.merge,
      A = b.pick,
      E;
    (function (b) {
      b.drawLineMarker = function (b) {
        var p = this.options,
          k = b.symbolWidth,
          t = b.symbolHeight,
          n = t / 2,
          h = this.chart.renderer,
          d = this.legendGroup;
        b = b.baseline - Math.round(.3 * b.fontMetrics.b);
        var a = {},
          e = p.marker;
        this.chart.styledMode || (a = {
          "stroke-width": p.lineWidth || 0
        }, p.dashStyle && (a.dashstyle = p.dashStyle));
        this.legendLine = h.path([["M", 0, b], ["L", k, b]]).addClass("highcharts-graph").attr(a).add(d);
        e && !1 !== e.enabled && k && (p = Math.min(A(e.radius, n), n), 0 === this.symbol.indexOf("url") && (e = v(e, {
          width: t,
          height: t
        }), p = 0), this.legendSymbol = k = h.symbol(this.symbol, k / 2 - p, b - p, 2 * p, 2 * p, e).addClass("highcharts-point").add(d), k.isMarker = !0);
      };
      b.drawRectangle = function (b, v) {
        var k = b.symbolHeight,
          t = b.options.squareSymbol;
        v.legendSymbol = this.chart.renderer.rect(t ? (b.symbolWidth - k) / 2 : 0, b.baseline - k + 1, t ? k : b.symbolWidth, k, A(b.options.symbolRadius, k / 2)).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(v.legendGroup);
      };
    })(E || (E = {}));
    return E;
  });
  G(b, "Core/Series/SeriesDefaults.js", [], function () {
    return {
      lineWidth: 2,
      allowPointSelect: !1,
      crisp: !0,
      showCheckbox: !1,
      animation: {
        duration: 1E3
      },
      events: {},
      marker: {
        enabledThreshold: 2,
        lineColor: "#ffffff",
        lineWidth: 0,
        radius: 4,
        states: {
          normal: {
            animation: !0
          },
          hover: {
            animation: {
              duration: 50
            },
            enabled: !0,
            radiusPlus: 2,
            lineWidthPlus: 1
          },
          select: {
            fillColor: "#cccccc",
            lineColor: "#000000",
            lineWidth: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        animation: {},
        align: "center",
        defer: !0,
        formatter: function () {
          var b = this.series.chart.numberFormatter;
          return "number" !== typeof this.y ? "" : b(this.y, -1);
        },
        padding: 5,
        style: {
          fontSize: "11px",
          fontWeight: "bold",
          color: "contrast",
          textOutline: "1px contrast"
        },
        verticalAlign: "bottom",
        x: 0,
        y: 0
      },
      cropThreshold: 300,
      opacity: 1,
      pointRange: 0,
      softThreshold: !0,
      states: {
        normal: {
          animation: !0
        },
        hover: {
          animation: {
            duration: 50
          },
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10,
            opacity: .25
          }
        },
        select: {
          animation: {
            duration: 0
          }
        },
        inactive: {
          animation: {
            duration: 50
          },
          opacity: .2
        }
      },
      stickyTracking: !0,
      turboThreshold: 1E3,
      findNearestPointBy: "x"
    };
  });
  G(b, "Core/Series/Series.js", [b["Core/Animation/AnimationUtilities.js"], b["Core/DefaultOptions.js"], b["Core/Foundation.js"], b["Core/Globals.js"], b["Core/Legend/LegendSymbol.js"], b["Core/Series/Point.js"], b["Core/Series/SeriesDefaults.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Renderer/SVG/SVGElement.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D, B, k, t, n) {
    var h = b.animObject,
      d = b.setAnimation,
      a = p.defaultOptions,
      e = A.registerEventOptions,
      g = E.hasTouch,
      x = E.svg,
      C = E.win,
      r = k.seriesTypes,
      q = n.addEvent,
      z = n.arrayMax,
      m = n.arrayMin,
      f = n.clamp,
      y = n.cleanRecursively,
      c = n.correctFloat,
      u = n.defined,
      l = n.erase,
      v = n.error,
      K = n.extend,
      H = n.find,
      I = n.fireEvent,
      Z = n.getNestedProperty,
      Q = n.isArray,
      O = n.isNumber,
      R = n.isString,
      T = n.merge,
      G = n.objectEach,
      J = n.pick,
      ba = n.removeEvent,
      ha = n.splat,
      L = n.syncTimeout;
    b = function () {
      function b() {
        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
      }
      b.prototype.init = function (c, a) {
        I(this, "init", {
          options: a
        });
        var d = this,
          b = c.series;
        this.eventsToUnbind = [];
        d.chart = c;
        d.options = d.setOptions(a);
        a = d.options;
        d.linkedSeries = [];
        d.bindAxes();
        K(d, {
          name: a.name,
          state: "",
          visible: !1 !== a.visible,
          selected: !0 === a.selected
        });
        e(this, a);
        var f = a.events;
        if (f && f.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) c.runTrackerClick = !0;
        d.getColor();
        d.getSymbol();
        d.parallelArrays.forEach(function (c) {
          d[c + "Data"] || (d[c + "Data"] = []);
        });
        d.isCartesian && (c.hasCartesianSeries = !0);
        var g;
        b.length && (g = b[b.length - 1]);
        d._i = J(g && g._i, -1) + 1;
        d.opacity = d.options.opacity;
        c.orderSeries(this.insert(b));
        a.dataSorting && a.dataSorting.enabled ? d.setDataSortingOptions() : d.points || d.data || d.setData(a.data, !1);
        I(this, "afterInit");
      };
      b.prototype.is = function (c) {
        return r[c] && this instanceof r[c];
      };
      b.prototype.insert = function (c) {
        var a = this.options.index,
          d;
        if (O(a)) {
          for (d = c.length; d--;) if (a >= J(c[d].options.index, c[d]._i)) {
            c.splice(d + 1, 0, this);
            break;
          }
          -1 === d && c.unshift(this);
          d += 1;
        } else c.push(this);
        return J(d, c.length - 1);
      };
      b.prototype.bindAxes = function () {
        var c = this,
          a = c.options,
          d = c.chart,
          b;
        I(this, "bindAxes", null, function () {
          (c.axisTypes || []).forEach(function (f) {
            var e = 0;
            d[f].forEach(function (d) {
              b = d.options;
              if (a[f] === e && !b.isInternal || "undefined" !== typeof a[f] && a[f] === b.id || "undefined" === typeof a[f] && 0 === b.index) c.insert(d.series), c[f] = d, d.isDirty = !0;
              b.isInternal || e++;
            });
            c[f] || c.optionalAxis === f || v(18, !0, d);
          });
        });
        I(this, "afterBindAxes");
      };
      b.prototype.updateParallelArrays = function (c, a) {
        var d = c.series,
          b = arguments,
          f = O(a) ? function (b) {
            var f = "y" === b && d.toYData ? d.toYData(c) : c[b];
            d[b + "Data"][a] = f;
          } : function (c) {
            Array.prototype[a].apply(d[c + "Data"], Array.prototype.slice.call(b, 2));
          };
        d.parallelArrays.forEach(f);
      };
      b.prototype.hasData = function () {
        return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
      };
      b.prototype.autoIncrement = function (c) {
        var a = this.options,
          d = a.pointIntervalUnit,
          b = a.relativeXValue,
          f = this.chart.time,
          e = this.xIncrement,
          g;
        e = J(e, a.pointStart, 0);
        this.pointInterval = g = J(this.pointInterval, a.pointInterval, 1);
        b && O(c) && (g *= c);
        d && (a = new f.Date(e), "day" === d ? f.set("Date", a, f.get("Date", a) + g) : "month" === d ? f.set("Month", a, f.get("Month", a) + g) : "year" === d && f.set("FullYear", a, f.get("FullYear", a) + g), g = a.getTime() - e);
        if (b && O(c)) return e + g;
        this.xIncrement = e + g;
        return e;
      };
      b.prototype.setDataSortingOptions = function () {
        var c = this.options;
        K(this, {
          requireSorting: !1,
          sorted: !1,
          enabledDataSorting: !0,
          allowDG: !1
        });
        u(c.pointRange) || (c.pointRange = 1);
      };
      b.prototype.setOptions = function (c) {
        var d = this.chart,
          b = d.options,
          f = b.plotOptions,
          e = d.userOptions || {};
        c = T(c);
        d = d.styledMode;
        var g = {
          plotOptions: f,
          userOptions: c
        };
        I(this, "setOptions", g);
        var m = g.plotOptions[this.type],
          l = e.plotOptions || {};
        this.userOptions = g.userOptions;
        e = T(m, f.series, e.plotOptions && e.plotOptions[this.type], c);
        this.tooltipOptions = T(a.tooltip, a.plotOptions.series && a.plotOptions.series.tooltip, a.plotOptions[this.type].tooltip, b.tooltip.userOptions, f.series && f.series.tooltip, f[this.type].tooltip, c.tooltip);
        this.stickyTracking = J(c.stickyTracking, l[this.type] && l[this.type].stickyTracking, l.series && l.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : e.stickyTracking);
        null === m.marker && delete e.marker;
        this.zoneAxis = e.zoneAxis;
        f = this.zones = (e.zones || []).slice();
        !e.negativeColor && !e.negativeFillColor || e.zones || (b = {
          value: e[this.zoneAxis + "Threshold"] || e.threshold || 0,
          className: "highcharts-negative"
        }, d || (b.color = e.negativeColor, b.fillColor = e.negativeFillColor), f.push(b));
        f.length && u(f[f.length - 1].value) && f.push(d ? {} : {
          color: this.color,
          fillColor: this.fillColor
        });
        I(this, "afterSetOptions", {
          options: e
        });
        return e;
      };
      b.prototype.getName = function () {
        return J(this.options.name, "Series " + (this.index + 1));
      };
      b.prototype.getCyclic = function (c, a, d) {
        var b = this.chart,
          f = this.userOptions,
          e = c + "Index",
          g = c + "Counter",
          m = d ? d.length : J(b.options.chart[c + "Count"], b[c + "Count"]);
        if (!a) {
          var l = J(f[e], f["_" + e]);
          u(l) || (b.series.length || (b[g] = 0), f["_" + e] = l = b[g] % m, b[g] += 1);
          d && (a = d[l]);
        }
        "undefined" !== typeof l && (this[e] = l);
        this[c] = a;
      };
      b.prototype.getColor = function () {
        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || a.plotOptions[this.type].color, this.chart.options.colors);
      };
      b.prototype.getPointsCollection = function () {
        return (this.hasGroupedData ? this.points : this.data) || [];
      };
      b.prototype.getSymbol = function () {
        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
      };
      b.prototype.findPointIndex = function (c, a) {
        var d = c.id,
          b = c.x,
          f = this.points,
          e = this.options.dataSorting,
          g,
          m;
        if (d) e = this.chart.get(d), e instanceof D && (g = e);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (g = function (a) {
          return !a.touched && a.index === c.index;
        }, e && e.matchByName ? g = function (a) {
          return !a.touched && a.name === c.name;
        } : this.options.relativeXValue && (g = function (a) {
          return !a.touched && a.options.x === c.x;
        }), g = H(f, g), !g) return;
        if (g) {
          var l = g && g.index;
          "undefined" !== typeof l && (m = !0);
        }
        "undefined" === typeof l && O(b) && (l = this.xData.indexOf(b, a));
        -1 !== l && "undefined" !== typeof l && this.cropped && (l = l >= this.cropStart ? l - this.cropStart : l);
        !m && O(l) && f[l] && f[l].touched && (l = void 0);
        return l;
      };
      b.prototype.updateData = function (c, a) {
        var d = this.options,
          b = d.dataSorting,
          f = this.points,
          e = [],
          g = this.requireSorting,
          m = c.length === f.length,
          l,
          h,
          k,
          q = !0;
        this.xIncrement = null;
        c.forEach(function (c, a) {
          var h = u(c) && this.pointClass.prototype.optionsToObject.call({
              series: this
            }, c) || {},
            q = h.x;
          if (h.id || O(q)) {
            if (h = this.findPointIndex(h, k), -1 === h || "undefined" === typeof h ? e.push(c) : f[h] && c !== d.data[h] ? (f[h].update(c, !1, null, !1), f[h].touched = !0, g && (k = h + 1)) : f[h] && (f[h].touched = !0), !m || a !== h || b && b.enabled || this.hasDerivedData) l = !0;
          } else e.push(c);
        }, this);
        if (l) for (c = f.length; c--;) (h = f[c]) && !h.touched && h.remove && h.remove(!1, a);else !m || b && b.enabled ? q = !1 : (c.forEach(function (c, a) {
          c !== f[a].y && f[a].update && f[a].update(c, !1, null, !1);
        }), e.length = 0);
        f.forEach(function (c) {
          c && (c.touched = !1);
        });
        if (!q) return !1;
        e.forEach(function (c) {
          this.addPoint(c, !1, null, null, !1);
        }, this);
        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = z(this.xData), this.autoIncrement());
        return !0;
      };
      b.prototype.setData = function (c, a, d, b) {
        var f = this,
          e = f.points,
          g = e && e.length || 0,
          m = f.options,
          l = f.chart,
          h = m.dataSorting,
          k = f.xAxis,
          q = m.turboThreshold,
          r = this.xData,
          n = this.yData,
          u = f.pointArrayMap;
        u = u && u.length;
        var z = m.keys,
          y,
          x = 0,
          t = 1,
          C = null;
        c = c || [];
        var p = c.length;
        a = J(a, !0);
        h && h.enabled && (c = this.sortData(c));
        !1 !== b && p && g && !f.cropped && !f.hasGroupedData && f.visible && !f.isSeriesBoosting && (y = this.updateData(c, d));
        if (!y) {
          f.xIncrement = null;
          f.colorCounter = 0;
          this.parallelArrays.forEach(function (c) {
            f[c + "Data"].length = 0;
          });
          if (q && p > q) {
            if (C = f.getFirstValidPoint(c), O(C)) for (d = 0; d < p; d++) r[d] = this.autoIncrement(), n[d] = c[d];else if (Q(C)) {
              if (u) {
                if (C.length === u) for (d = 0; d < p; d++) r[d] = this.autoIncrement(), n[d] = c[d];else for (d = 0; d < p; d++) b = c[d], r[d] = b[0], n[d] = b.slice(1, u + 1);
              } else if (z && (x = z.indexOf("x"), t = z.indexOf("y"), x = 0 <= x ? x : 0, t = 0 <= t ? t : 1), 1 === C.length && (t = 0), x === t) for (d = 0; d < p; d++) r[d] = this.autoIncrement(), n[d] = c[d][t];else for (d = 0; d < p; d++) b = c[d], r[d] = b[x], n[d] = b[t];
            } else v(12, !1, l);
          } else for (d = 0; d < p; d++) "undefined" !== typeof c[d] && (b = {
            series: f
          }, f.pointClass.prototype.applyOptions.apply(b, [c[d]]), f.updateParallelArrays(b, d));
          n && R(n[0]) && v(14, !0, l);
          f.data = [];
          f.options.data = f.userOptions.data = c;
          for (d = g; d--;) e[d] && e[d].destroy && e[d].destroy();
          k && (k.minRange = k.userMinRange);
          f.isDirty = l.isDirtyBox = !0;
          f.isDirtyData = !!e;
          d = !1;
        }
        "point" === m.legendType && (this.processData(), this.generatePoints());
        a && l.redraw(d);
      };
      b.prototype.sortData = function (c) {
        var a = this,
          d = a.options.dataSorting.sortKey || "y",
          b = function (c, a) {
            return u(a) && c.pointClass.prototype.optionsToObject.call({
              series: c
            }, a) || {};
          };
        c.forEach(function (d, f) {
          c[f] = b(a, d);
          c[f].index = f;
        }, this);
        c.concat().sort(function (c, a) {
          c = Z(d, c);
          a = Z(d, a);
          return a < c ? -1 : a > c ? 1 : 0;
        }).forEach(function (c, a) {
          c.x = a;
        }, this);
        a.linkedSeries && a.linkedSeries.forEach(function (a) {
          var d = a.options,
            f = d.data;
          d.dataSorting && d.dataSorting.enabled || !f || (f.forEach(function (d, e) {
            f[e] = b(a, d);
            c[e] && (f[e].x = c[e].x, f[e].index = e);
          }), a.setData(f, !1));
        });
        return c;
      };
      b.prototype.getProcessedData = function (c) {
        var a = this.xAxis,
          d = this.options,
          b = d.cropThreshold,
          f = c || this.getExtremesFromAll || d.getExtremesFromAll,
          e = this.isCartesian;
        c = a && a.val2lin;
        d = !(!a || !a.logarithmic);
        var g = 0,
          m = this.xData,
          l = this.yData,
          h = this.requireSorting;
        var k = !1;
        var q = m.length;
        if (a) {
          k = a.getExtremes();
          var r = k.min;
          var n = k.max;
          k = a.categories && !a.names.length;
        }
        if (e && this.sorted && !f && (!b || q > b || this.forceCrop)) if (m[q - 1] < r || m[0] > n) m = [], l = [];else if (this.yData && (m[0] < r || m[q - 1] > n)) {
          var u = this.cropData(this.xData, this.yData, r, n);
          m = u.xData;
          l = u.yData;
          g = u.start;
          u = !0;
        }
        for (b = m.length || 1; --b;) if (a = d ? c(m[b]) - c(m[b - 1]) : m[b] - m[b - 1], 0 < a && ("undefined" === typeof z || a < z)) var z = a;else 0 > a && h && !k && (v(15, !1, this.chart), h = !1);
        return {
          xData: m,
          yData: l,
          cropped: u,
          cropStart: g,
          closestPointRange: z
        };
      };
      b.prototype.processData = function (c) {
        var a = this.xAxis;
        if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !c) return !1;
        c = this.getProcessedData();
        this.cropped = c.cropped;
        this.cropStart = c.cropStart;
        this.processedXData = c.xData;
        this.processedYData = c.yData;
        this.closestPointRange = this.basePointRange = c.closestPointRange;
        I(this, "afterProcessData");
      };
      b.prototype.cropData = function (c, a, d, b, f) {
        var e = c.length,
          g,
          m = 0,
          l = e;
        f = J(f, this.cropShoulder);
        for (g = 0; g < e; g++) if (c[g] >= d) {
          m = Math.max(0, g - f);
          break;
        }
        for (d = g; d < e; d++) if (c[d] > b) {
          l = d + f;
          break;
        }
        return {
          xData: c.slice(m, l),
          yData: a.slice(m, l),
          start: m,
          end: l
        };
      };
      b.prototype.generatePoints = function () {
        var c = this.options,
          a = c.data,
          d = this.processedXData,
          b = this.processedYData,
          f = this.pointClass,
          e = d.length,
          g = this.cropStart || 0,
          m = this.hasGroupedData,
          l = c.keys,
          h = [];
        c = c.dataGrouping && c.dataGrouping.groupAll ? g : 0;
        var k,
          q,
          r = this.data;
        if (!r && !m) {
          var n = [];
          n.length = a.length;
          r = this.data = n;
        }
        l && m && (this.options.keys = !1);
        for (q = 0; q < e; q++) {
          n = g + q;
          if (m) {
            var u = new f().init(this, [d[q]].concat(ha(b[q])));
            u.dataGroup = this.groupMap[c + q];
            u.dataGroup.options && (u.options = u.dataGroup.options, K(u, u.dataGroup.options), delete u.dataLabels);
          } else (u = r[n]) || "undefined" === typeof a[n] || (r[n] = u = new f().init(this, a[n], d[q]));
          u && (u.index = m ? c + q : n, h[q] = u);
        }
        this.options.keys = l;
        if (r && (e !== (k = r.length) || m)) for (q = 0; q < k; q++) q !== g || m || (q += e), r[q] && (r[q].destroyElements(), r[q].plotX = void 0);
        this.data = r;
        this.points = h;
        I(this, "afterGeneratePoints");
      };
      b.prototype.getXExtremes = function (c) {
        return {
          min: m(c),
          max: z(c)
        };
      };
      b.prototype.getExtremes = function (c, a) {
        var d = this.xAxis,
          b = this.yAxis,
          f = this.processedXData || this.xData,
          e = [],
          g = this.requireSorting ? this.cropShoulder : 0;
        b = b ? b.positiveValuesOnly : !1;
        var l,
          h = 0,
          q = 0,
          k = 0;
        c = c || this.stackedYData || this.processedYData || [];
        var r = c.length;
        if (d) {
          var n = d.getExtremes();
          h = n.min;
          q = n.max;
        }
        for (l = 0; l < r; l++) {
          var u = f[l];
          n = c[l];
          var y = (O(n) || Q(n)) && (n.length || 0 < n || !b);
          u = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !d || (f[l + g] || u) >= h && (f[l - g] || u) <= q;
          if (y && u) if (y = n.length) for (; y--;) O(n[y]) && (e[k++] = n[y]);else e[k++] = n;
        }
        c = {
          activeYData: e,
          dataMin: m(e),
          dataMax: z(e)
        };
        I(this, "afterGetExtremes", {
          dataExtremes: c
        });
        return c;
      };
      b.prototype.applyExtremes = function () {
        var c = this.getExtremes();
        this.dataMin = c.dataMin;
        this.dataMax = c.dataMax;
        return c;
      };
      b.prototype.getFirstValidPoint = function (c) {
        for (var a = c.length, d = 0, b = null; null === b && d < a;) b = c[d], d++;
        return b;
      };
      b.prototype.translate = function () {
        this.processedXData || this.processData();
        this.generatePoints();
        var a = this.options,
          d = a.stacking,
          b = this.xAxis,
          e = b.categories,
          g = this.enabledDataSorting,
          m = this.yAxis,
          l = this.points,
          h = l.length,
          q = this.pointPlacementToXValue(),
          k = !!q,
          r = a.threshold,
          n = a.startFromThreshold ? r : 0,
          z = this.zoneAxis || "y",
          y,
          x,
          t = Number.MAX_VALUE;
        for (y = 0; y < h; y++) {
          var C = l[y],
            v = C.x,
            p = void 0,
            F = void 0,
            H = C.y,
            B = C.low,
            w = d && m.stacking && m.stacking.stacks[(this.negStacks && H < (n ? 0 : r) ? "-" : "") + this.stackKey];
          if (m.positiveValuesOnly && !m.validatePositiveValue(H) || b.positiveValuesOnly && !b.validatePositiveValue(v)) C.isNull = !0;
          C.plotX = x = c(f(b.translate(v, 0, 0, 0, 1, q, "flags" === this.type), -1E5, 1E5));
          if (d && this.visible && w && w[v]) {
            var A = this.getStackIndicator(A, v, this.index);
            C.isNull || (p = w[v], F = p.points[A.key]);
          }
          Q(F) && (B = F[0], H = F[1], B === n && A.key === w[v].base && (B = J(O(r) && r, m.min)), m.positiveValuesOnly && 0 >= B && (B = null), C.total = C.stackTotal = p.total, C.percentage = p.total && C.y / p.total * 100, C.stackY = H, this.irregularWidths || p.setOffset(this.pointXOffset || 0, this.barW || 0));
          C.yBottom = u(B) ? f(m.translate(B, 0, 1, 0, 1), -1E5, 1E5) : null;
          this.dataModify && (H = this.dataModify.modifyValue(H, y));
          C.plotY = void 0;
          O(H) && (p = m.translate(H, !1, !0, !1, !0), "undefined" !== typeof p && (C.plotY = f(p, -1E5, 1E5)));
          C.isInside = this.isPointInside(C);
          C.clientX = k ? c(b.translate(v, 0, 0, 0, 1, q)) : x;
          C.negative = C[z] < (a[z + "Threshold"] || r || 0);
          C.category = e && "undefined" !== typeof e[C.x] ? e[C.x] : C.x;
          if (!C.isNull && !1 !== C.visible) {
            "undefined" !== typeof D && (t = Math.min(t, Math.abs(x - D)));
            var D = x;
          }
          C.zone = this.zones.length ? C.getZone() : void 0;
          !C.graphic && this.group && g && (C.isNew = !0);
        }
        this.closestPointRangePx = t;
        I(this, "afterTranslate");
      };
      b.prototype.getValidPoints = function (c, a, d) {
        var b = this.chart;
        return (c || this.points || []).filter(function (c) {
          return a && !b.isInsidePlot(c.plotX, c.plotY, {
            inverted: b.inverted
          }) ? !1 : !1 !== c.visible && (d || !c.isNull);
        });
      };
      b.prototype.getClipBox = function () {
        var c = this.chart,
          a = this.xAxis,
          d = this.yAxis,
          b = T(c.clipBox);
        a && a.len !== c.plotSizeX && (b.width = a.len);
        d && d.len !== c.plotSizeY && (b.height = d.len);
        return b;
      };
      b.prototype.getSharedClipKey = function () {
        return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
      };
      b.prototype.setClip = function () {
        var c = this.chart,
          a = this.group,
          d = this.markerGroup,
          b = c.sharedClips;
        c = c.renderer;
        var f = this.getClipBox(),
          e = this.getSharedClipKey(),
          g = b[e];
        g ? g.animate(f) : b[e] = g = c.clipRect(f);
        a && a.clip(!1 === this.options.clip ? void 0 : g);
        d && d.clip();
      };
      b.prototype.animate = function (c) {
        var a = this.chart,
          d = this.group,
          b = this.markerGroup,
          f = a.inverted,
          e = h(this.options.animation),
          g = [this.getSharedClipKey(), e.duration, e.easing, e.defer].join(),
          m = a.sharedClips[g],
          l = a.sharedClips[g + "m"];
        if (c && d) e = this.getClipBox(), m ? m.attr("height", e.height) : (e.width = 0, f && (e.x = a.plotHeight), m = a.renderer.clipRect(e), a.sharedClips[g] = m, l = a.renderer.clipRect({
          x: f ? (a.plotSizeX || 0) + 99 : -99,
          y: f ? -a.plotLeft : -a.plotTop,
          width: 99,
          height: f ? a.chartWidth : a.chartHeight
        }), a.sharedClips[g + "m"] = l), d.clip(m), b && b.clip(l);else if (m && !m.hasClass("highcharts-animating")) {
          a = this.getClipBox();
          var q = e.step;
          b && b.element.childNodes.length && (e.step = function (c, a) {
            q && q.apply(a, arguments);
            l && l.element && l.attr(a.prop, "width" === a.prop ? c + 99 : c);
          });
          m.addClass("highcharts-animating").animate(a, e);
        }
      };
      b.prototype.afterAnimate = function () {
        var c = this;
        this.setClip();
        G(this.chart.sharedClips, function (a, d, b) {
          a && !c.chart.container.querySelector('[clip-path="url(#' + a.id + ')"]') && (a.destroy(), delete b[d]);
        });
        this.finishedAnimating = !0;
        I(this, "afterAnimate");
      };
      b.prototype.drawPoints = function () {
        var c = this.points,
          a = this.chart,
          d = this.options.marker,
          b = this[this.specialGroup] || this.markerGroup,
          f = this.xAxis,
          e = J(d.enabled, !f || f.isRadial ? !0 : null, this.closestPointRangePx >= d.enabledThreshold * d.radius),
          g,
          m;
        if (!1 !== d.enabled || this._hasPointMarkers) for (g = 0; g < c.length; g++) {
          var l = c[g];
          var h = (m = l.graphic) ? "animate" : "attr";
          var q = l.marker || {};
          var k = !!l.marker;
          if ((e && "undefined" === typeof q.enabled || q.enabled) && !l.isNull && !1 !== l.visible) {
            var r = J(q.symbol, this.symbol, "rect");
            var n = this.markerAttribs(l, l.selected && "select");
            this.enabledDataSorting && (l.startXPos = f.reversed ? -(n.width || 0) : f.width);
            var u = !1 !== l.isInside;
            m ? m[u ? "show" : "hide"](u).animate(n) : u && (0 < (n.width || 0) || l.hasImage) && (l.graphic = m = a.renderer.symbol(r, n.x, n.y, n.width, n.height, k ? q : d).add(b), this.enabledDataSorting && a.hasRendered && (m.attr({
              x: l.startXPos
            }), h = "animate"));
            m && "animate" === h && m[u ? "show" : "hide"](u).animate(n);
            if (m && !a.styledMode) m[h](this.pointAttribs(l, l.selected && "select"));
            m && m.addClass(l.getClassName(), !0);
          } else m && (l.graphic = m.destroy());
        }
      };
      b.prototype.markerAttribs = function (c, a) {
        var d = this.options,
          b = d.marker,
          f = c.marker || {},
          e = f.symbol || b.symbol,
          g = J(f.radius, b.radius);
        a && (b = b.states[a], a = f.states && f.states[a], g = J(a && a.radius, b && b.radius, g + (b && b.radiusPlus || 0)));
        c.hasImage = e && 0 === e.indexOf("url");
        c.hasImage && (g = 0);
        c = {
          x: d.crisp ? Math.floor(c.plotX - g) : c.plotX - g,
          y: c.plotY - g
        };
        g && (c.width = c.height = 2 * g);
        return c;
      };
      b.prototype.pointAttribs = function (c, a) {
        var d = this.options.marker,
          b = c && c.options,
          f = b && b.marker || {},
          e = b && b.color,
          g = c && c.color,
          m = c && c.zone && c.zone.color,
          l = this.color;
        c = J(f.lineWidth, d.lineWidth);
        b = 1;
        l = e || m || g || l;
        e = f.fillColor || d.fillColor || l;
        g = f.lineColor || d.lineColor || l;
        a = a || "normal";
        d = d.states[a] || {};
        a = f.states && f.states[a] || {};
        c = J(a.lineWidth, d.lineWidth, c + J(a.lineWidthPlus, d.lineWidthPlus, 0));
        e = a.fillColor || d.fillColor || e;
        g = a.lineColor || d.lineColor || g;
        b = J(a.opacity, d.opacity, b);
        return {
          stroke: g,
          "stroke-width": c,
          fill: e,
          opacity: b
        };
      };
      b.prototype.destroy = function (c) {
        var a = this,
          d = a.chart,
          b = /AppleWebKit\/533/.test(C.navigator.userAgent),
          f = a.data || [],
          e,
          g,
          m,
          h;
        I(a, "destroy");
        this.removeEvents(c);
        (a.axisTypes || []).forEach(function (c) {
          (h = a[c]) && h.series && (l(h.series, a), h.isDirty = h.forceRedraw = !0);
        });
        a.legendItem && a.chart.legend.destroyItem(a);
        for (g = f.length; g--;) (m = f[g]) && m.destroy && m.destroy();
        a.clips && a.clips.forEach(function (c) {
          return c.destroy();
        });
        n.clearTimeout(a.animationTimeout);
        G(a, function (c, a) {
          c instanceof t && !c.survive && (e = b && "group" === a ? "hide" : "destroy", c[e]());
        });
        d.hoverSeries === a && (d.hoverSeries = void 0);
        l(d.series, a);
        d.orderSeries();
        G(a, function (d, b) {
          c && "hcEvents" === b || delete a[b];
        });
      };
      b.prototype.applyZones = function () {
        var c = this,
          a = this.chart,
          d = a.renderer,
          b = this.zones,
          e = this.clips || [],
          g = this.graph,
          m = this.area,
          l = Math.max(a.chartWidth, a.chartHeight),
          h = this[(this.zoneAxis || "y") + "Axis"],
          q = a.inverted,
          k,
          n,
          r,
          u,
          z,
          y,
          x,
          t,
          C = !1;
        if (b.length && (g || m) && h && "undefined" !== typeof h.min) {
          var v = h.reversed;
          var p = h.horiz;
          g && !this.showLine && g.hide();
          m && m.hide();
          var H = h.getExtremes();
          b.forEach(function (b, F) {
            k = v ? p ? a.plotWidth : 0 : p ? 0 : h.toPixels(H.min) || 0;
            k = f(J(n, k), 0, l);
            n = f(Math.round(h.toPixels(J(b.value, H.max), !0) || 0), 0, l);
            C && (k = n = h.toPixels(H.max));
            u = Math.abs(k - n);
            z = Math.min(k, n);
            y = Math.max(k, n);
            h.isXAxis ? (r = {
              x: q ? y : z,
              y: 0,
              width: u,
              height: l
            }, p || (r.x = a.plotHeight - r.x)) : (r = {
              x: 0,
              y: q ? y : z,
              width: l,
              height: u
            }, p && (r.y = a.plotWidth - r.y));
            q && d.isVML && (r = h.isXAxis ? {
              x: 0,
              y: v ? z : y,
              height: r.width,
              width: a.chartWidth
            } : {
              x: r.y - a.plotLeft - a.spacingBox.x,
              y: 0,
              width: r.height,
              height: a.chartHeight
            });
            e[F] ? e[F].animate(r) : e[F] = d.clipRect(r);
            x = c["zone-area-" + F];
            t = c["zone-graph-" + F];
            g && t && t.clip(e[F]);
            m && x && x.clip(e[F]);
            C = b.value > H.max;
            c.resetZones && 0 === n && (n = void 0);
          });
          this.clips = e;
        } else c.visible && (g && g.show(!0), m && m.show(!0));
      };
      b.prototype.invertGroups = function (c) {
        function a() {
          ["group", "markerGroup"].forEach(function (a) {
            d[a] && (b.renderer.isVML && d[a].attr({
              width: d.yAxis.len,
              height: d.xAxis.len
            }), d[a].width = d.yAxis.len, d[a].height = d.xAxis.len, d[a].invert(d.isRadialSeries ? !1 : c));
          });
        }
        var d = this,
          b = d.chart;
        d.xAxis && (d.eventsToUnbind.push(q(b, "resize", a)), a(), d.invertGroups = a);
      };
      b.prototype.plotGroup = function (c, a, d, b, f) {
        var e = this[c],
          g = !e;
        d = {
          visibility: d,
          zIndex: b || .1
        };
        "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (d.opacity = this.opacity);
        g && (this[c] = e = this.chart.renderer.g().add(f));
        e.addClass("highcharts-" + a + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (u(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (e.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
        e.attr(d)[g ? "attr" : "animate"](this.getPlotBox());
        return e;
      };
      b.prototype.getPlotBox = function () {
        var c = this.chart,
          a = this.xAxis,
          d = this.yAxis;
        c.inverted && (a = d, d = this.xAxis);
        return {
          translateX: a ? a.left : c.plotLeft,
          translateY: d ? d.top : c.plotTop,
          scaleX: 1,
          scaleY: 1
        };
      };
      b.prototype.removeEvents = function (c) {
        c || ba(this);
        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (c) {
          c();
        }), this.eventsToUnbind.length = 0);
      };
      b.prototype.render = function () {
        var c = this,
          a = c.chart,
          d = c.options,
          b = h(d.animation),
          f = c.visible ? "inherit" : "hidden",
          e = d.zIndex,
          g = c.hasRendered,
          m = a.seriesGroup,
          l = a.inverted;
        a = !c.finishedAnimating && a.renderer.isSVG ? b.duration : 0;
        I(this, "render");
        var q = c.plotGroup("group", "series", f, e, m);
        c.markerGroup = c.plotGroup("markerGroup", "markers", f, e, m);
        !1 !== d.clip && c.setClip();
        c.animate && a && c.animate(!0);
        q.inverted = J(c.invertible, c.isCartesian) ? l : !1;
        c.drawGraph && (c.drawGraph(), c.applyZones());
        c.visible && c.drawPoints();
        c.drawDataLabels && c.drawDataLabels();
        c.redrawPoints && c.redrawPoints();
        c.drawTracker && !1 !== c.options.enableMouseTracking && c.drawTracker();
        c.invertGroups(l);
        c.animate && a && c.animate();
        g || (a && b.defer && (a += b.defer), c.animationTimeout = L(function () {
          c.afterAnimate();
        }, a || 0));
        c.isDirty = !1;
        c.hasRendered = !0;
        I(c, "afterRender");
      };
      b.prototype.redraw = function () {
        var c = this.chart,
          a = this.isDirty || this.isDirtyData,
          d = this.group,
          b = this.xAxis,
          f = this.yAxis;
        d && (c.inverted && d.attr({
          width: c.plotWidth,
          height: c.plotHeight
        }), d.animate({
          translateX: J(b && b.left, c.plotLeft),
          translateY: J(f && f.top, c.plotTop)
        }));
        this.translate();
        this.render();
        a && delete this.kdTree;
      };
      b.prototype.searchPoint = function (c, a) {
        var d = this.xAxis,
          b = this.yAxis,
          f = this.chart.inverted;
        return this.searchKDTree({
          clientX: f ? d.len - c.chartY + d.pos : c.chartX - d.pos,
          plotY: f ? b.len - c.chartX + b.pos : c.chartY - b.pos
        }, a, c);
      };
      b.prototype.buildKDTree = function (c) {
        function a(c, b, f) {
          var e = c && c.length;
          if (e) {
            var g = d.kdAxisArray[b % f];
            c.sort(function (c, a) {
              return c[g] - a[g];
            });
            e = Math.floor(e / 2);
            return {
              point: c[e],
              left: a(c.slice(0, e), b + 1, f),
              right: a(c.slice(e + 1), b + 1, f)
            };
          }
        }
        this.buildingKdTree = !0;
        var d = this,
          b = -1 < d.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        delete d.kdTree;
        L(function () {
          d.kdTree = a(d.getValidPoints(null, !d.directTouch), b, b);
          d.buildingKdTree = !1;
        }, d.options.kdNow || c && "touchstart" === c.type ? 0 : 1);
      };
      b.prototype.searchKDTree = function (c, a, d) {
        function b(c, a, d, l) {
          var h = a.point,
            q = f.kdAxisArray[d % l],
            k = h,
            r = u(c[e]) && u(h[e]) ? Math.pow(c[e] - h[e], 2) : null;
          var n = u(c[g]) && u(h[g]) ? Math.pow(c[g] - h[g], 2) : null;
          n = (r || 0) + (n || 0);
          h.dist = u(n) ? Math.sqrt(n) : Number.MAX_VALUE;
          h.distX = u(r) ? Math.sqrt(r) : Number.MAX_VALUE;
          q = c[q] - h[q];
          n = 0 > q ? "left" : "right";
          r = 0 > q ? "right" : "left";
          a[n] && (n = b(c, a[n], d + 1, l), k = n[m] < k[m] ? n : h);
          a[r] && Math.sqrt(q * q) < k[m] && (c = b(c, a[r], d + 1, l), k = c[m] < k[m] ? c : k);
          return k;
        }
        var f = this,
          e = this.kdAxisArray[0],
          g = this.kdAxisArray[1],
          m = a ? "distX" : "dist";
        a = -1 < f.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        this.kdTree || this.buildingKdTree || this.buildKDTree(d);
        if (this.kdTree) return b(c, this.kdTree, a, a);
      };
      b.prototype.pointPlacementToXValue = function () {
        var c = this.options,
          a = c.pointRange,
          d = this.xAxis;
        c = c.pointPlacement;
        "between" === c && (c = d.reversed ? -.5 : .5);
        return O(c) ? c * (a || d.pointRange) : 0;
      };
      b.prototype.isPointInside = function (c) {
        var a = this.chart,
          d = this.xAxis,
          b = this.yAxis;
        return "undefined" !== typeof c.plotY && "undefined" !== typeof c.plotX && 0 <= c.plotY && c.plotY <= (b ? b.len : a.plotHeight) && 0 <= c.plotX && c.plotX <= (d ? d.len : a.plotWidth);
      };
      b.prototype.drawTracker = function () {
        var c = this,
          a = c.options,
          d = a.trackByArea,
          b = [].concat(d ? c.areaPath : c.graphPath),
          f = c.chart,
          e = f.pointer,
          m = f.renderer,
          l = f.options.tooltip.snap,
          h = c.tracker,
          q = function (a) {
            if (f.hoverSeries !== c) c.onMouseOver();
          },
          k = "rgba(192,192,192," + (x ? .0001 : .002) + ")";
        h ? h.attr({
          d: b
        }) : c.graph && (c.tracker = m.path(b).attr({
          visibility: c.visible ? "visible" : "hidden",
          zIndex: 2
        }).addClass(d ? "highcharts-tracker-area" : "highcharts-tracker-line").add(c.group), f.styledMode || c.tracker.attr({
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          stroke: k,
          fill: d ? k : "none",
          "stroke-width": c.graph.strokeWidth() + (d ? 0 : 2 * l)
        }), [c.tracker, c.markerGroup, c.dataLabelsGroup].forEach(function (c) {
          if (c && (c.addClass("highcharts-tracker").on("mouseover", q).on("mouseout", function (c) {
            e.onTrackerMouseOut(c);
          }), a.cursor && !f.styledMode && c.css({
            cursor: a.cursor
          }), g)) c.on("touchstart", q);
        }));
        I(this, "afterDrawTracker");
      };
      b.prototype.addPoint = function (c, a, d, b, f) {
        var e = this.options,
          g = this.data,
          m = this.chart,
          l = this.xAxis;
        l = l && l.hasNames && l.names;
        var h = e.data,
          q = this.xData,
          k;
        a = J(a, !0);
        var n = {
          series: this
        };
        this.pointClass.prototype.applyOptions.apply(n, [c]);
        var r = n.x;
        var u = q.length;
        if (this.requireSorting && r < q[u - 1]) for (k = !0; u && q[u - 1] > r;) u--;
        this.updateParallelArrays(n, "splice", u, 0, 0);
        this.updateParallelArrays(n, u);
        l && n.name && (l[r] = n.name);
        h.splice(u, 0, c);
        k && (this.data.splice(u, 0, null), this.processData());
        "point" === e.legendType && this.generatePoints();
        d && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(n, "shift"), h.shift()));
        !1 !== f && I(this, "addPoint", {
          point: n
        });
        this.isDirtyData = this.isDirty = !0;
        a && m.redraw(b);
      };
      b.prototype.removePoint = function (c, a, b) {
        var f = this,
          e = f.data,
          g = e[c],
          m = f.points,
          l = f.chart,
          h = function () {
            m && m.length === e.length && m.splice(c, 1);
            e.splice(c, 1);
            f.options.data.splice(c, 1);
            f.updateParallelArrays(g || {
              series: f
            }, "splice", c, 1);
            g && g.destroy();
            f.isDirty = !0;
            f.isDirtyData = !0;
            a && l.redraw();
          };
        d(b, l);
        a = J(a, !0);
        g ? g.firePointEvent("remove", null, h) : h();
      };
      b.prototype.remove = function (c, a, d, b) {
        function f() {
          e.destroy(b);
          g.isDirtyLegend = g.isDirtyBox = !0;
          g.linkSeries();
          J(c, !0) && g.redraw(a);
        }
        var e = this,
          g = e.chart;
        !1 !== d ? I(e, "remove", null, f) : f();
      };
      b.prototype.update = function (c, a) {
        c = y(c, this.userOptions);
        I(this, "update", {
          options: c
        });
        var d = this,
          b = d.chart,
          f = d.userOptions,
          e = d.initialType || d.type,
          g = b.options.plotOptions,
          m = r[e].prototype,
          l = d.finishedAnimating && {
            animation: !1
          },
          h = {},
          q,
          k = ["eventOptions", "navigatorSeries", "baseSeries"],
          n = c.type || f.type || b.options.chart.type,
          u = !(this.hasDerivedData || n && n !== this.type || "undefined" !== typeof c.pointStart || "undefined" !== typeof c.pointInterval || "undefined" !== typeof c.relativeXValue || d.hasOptionChanged("dataGrouping") || d.hasOptionChanged("pointStart") || d.hasOptionChanged("pointInterval") || d.hasOptionChanged("pointIntervalUnit") || d.hasOptionChanged("keys"));
        n = n || e;
        u && (k.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== c.visible && k.push("area", "graph"), d.parallelArrays.forEach(function (c) {
          k.push(c + "Data");
        }), c.data && (c.dataSorting && K(d.options.dataSorting, c.dataSorting), this.setData(c.data, !1)));
        c = T(f, l, {
          index: "undefined" === typeof f.index ? d.index : f.index,
          pointStart: J(g && g.series && g.series.pointStart, f.pointStart, d.xData[0])
        }, !u && {
          data: d.options.data
        }, c);
        u && c.data && (c.data = d.options.data);
        k = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(k);
        k.forEach(function (c) {
          k[c] = d[c];
          delete d[c];
        });
        g = !1;
        if (r[n]) {
          if (g = n !== d.type, d.remove(!1, !1, !1, !0), g) if (Object.setPrototypeOf) Object.setPrototypeOf(d, r[n].prototype);else {
            l = Object.hasOwnProperty.call(d, "hcEvents") && d.hcEvents;
            for (q in m) d[q] = void 0;
            K(d, r[n].prototype);
            l ? d.hcEvents = l : delete d.hcEvents;
          }
        } else v(17, !0, b, {
          missingModuleFor: n
        });
        k.forEach(function (c) {
          d[c] = k[c];
        });
        d.init(b, c);
        if (u && this.points) {
          var z = d.options;
          !1 === z.visible ? (h.graphic = 1, h.dataLabel = 1) : d._hasPointLabels || (c = z.marker, m = z.dataLabels, !c || !1 !== c.enabled && (f.marker && f.marker.symbol) === c.symbol || (h.graphic = 1), m && !1 === m.enabled && (h.dataLabel = 1));
          this.points.forEach(function (c) {
            c && c.series && (c.resolveColor(), Object.keys(h).length && c.destroyElements(h), !1 === z.showInLegend && c.legendItem && b.legend.destroyItem(c));
          }, this);
        }
        d.initialType = e;
        b.linkSeries();
        g && d.linkedSeries.length && (d.isDirtyData = !0);
        I(this, "afterUpdate");
        J(a, !0) && b.redraw(u ? void 0 : !1);
      };
      b.prototype.setName = function (c) {
        this.name = this.options.name = this.userOptions.name = c;
        this.chart.isDirtyLegend = !0;
      };
      b.prototype.hasOptionChanged = function (c) {
        var a = this.options[c],
          d = this.chart.options.plotOptions,
          b = this.userOptions[c];
        return b ? a !== b : a !== J(d && d[this.type] && d[this.type][c], d && d.series && d.series[c], a);
      };
      b.prototype.onMouseOver = function () {
        var c = this.chart,
          a = c.hoverSeries;
        c.pointer.setHoverChartIndex();
        if (a && a !== this) a.onMouseOut();
        this.options.events.mouseOver && I(this, "mouseOver");
        this.setState("hover");
        c.hoverSeries = this;
      };
      b.prototype.onMouseOut = function () {
        var c = this.options,
          a = this.chart,
          d = a.tooltip,
          b = a.hoverPoint;
        a.hoverSeries = null;
        if (b) b.onMouseOut();
        this && c.events.mouseOut && I(this, "mouseOut");
        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();
        a.series.forEach(function (c) {
          c.setState("", !0);
        });
      };
      b.prototype.setState = function (c, a) {
        var d = this,
          b = d.options,
          f = d.graph,
          e = b.inactiveOtherPoints,
          g = b.states,
          m = J(g[c || "normal"] && g[c || "normal"].animation, d.chart.options.chart.animation),
          l = b.lineWidth,
          h = 0,
          q = b.opacity;
        c = c || "";
        if (d.state !== c && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (a) {
          a && (d.state && a.removeClass("highcharts-series-" + d.state), c && a.addClass("highcharts-series-" + c));
        }), d.state = c, !d.chart.styledMode)) {
          if (g[c] && !1 === g[c].enabled) return;
          c && (l = g[c].lineWidth || l + (g[c].lineWidthPlus || 0), q = J(g[c].opacity, q));
          if (f && !f.dashstyle) for (b = {
            "stroke-width": l
          }, f.animate(b, m); d["zone-graph-" + h];) d["zone-graph-" + h].animate(b, m), h += 1;
          e || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (c) {
            c && c.animate({
              opacity: q
            }, m);
          });
        }
        a && e && d.points && d.setAllPointsToState(c || void 0);
      };
      b.prototype.setAllPointsToState = function (c) {
        this.points.forEach(function (a) {
          a.setState && a.setState(c);
        });
      };
      b.prototype.setVisible = function (c, a) {
        var d = this,
          b = d.chart,
          f = d.legendItem,
          e = b.options.chart.ignoreHiddenSeries,
          g = d.visible,
          m = (d.visible = c = d.options.visible = d.userOptions.visible = "undefined" === typeof c ? !g : c) ? "show" : "hide";
        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (c) {
          if (d[c]) d[c][m]();
        });
        if (b.hoverSeries === d || (b.hoverPoint && b.hoverPoint.series) === d) d.onMouseOut();
        f && b.legend.colorizeItem(d, c);
        d.isDirty = !0;
        d.options.stacking && b.series.forEach(function (c) {
          c.options.stacking && c.visible && (c.isDirty = !0);
        });
        d.linkedSeries.forEach(function (a) {
          a.setVisible(c, !1);
        });
        e && (b.isDirtyBox = !0);
        I(d, m);
        !1 !== a && b.redraw();
      };
      b.prototype.show = function () {
        this.setVisible(!0);
      };
      b.prototype.hide = function () {
        this.setVisible(!1);
      };
      b.prototype.select = function (c) {
        this.selected = c = this.options.selected = "undefined" === typeof c ? !this.selected : c;
        this.checkbox && (this.checkbox.checked = c);
        I(this, c ? "select" : "unselect");
      };
      b.prototype.shouldShowTooltip = function (c, a, d) {
        void 0 === d && (d = {});
        d.series = this;
        d.visiblePlotOnly = !0;
        return this.chart.isInsidePlot(c, a, d);
      };
      b.defaultOptions = B;
      return b;
    }();
    K(b.prototype, {
      axisTypes: ["xAxis", "yAxis"],
      coll: "series",
      colorCounter: 0,
      cropShoulder: 1,
      directTouch: !1,
      drawLegendSymbol: w.drawLineMarker,
      isCartesian: !0,
      kdAxisArray: ["clientX", "plotY"],
      parallelArrays: ["x", "y"],
      pointClass: D,
      requireSorting: !0,
      sorted: !0
    });
    k.series = b;
    "";
    "";
    return b;
  });
  G(b, "Extensions/ScrollablePlotArea.js", [b["Core/Animation/AnimationUtilities.js"], b["Core/Axis/Axis.js"], b["Core/Chart/Chart.js"], b["Core/Series/Series.js"], b["Core/Renderer/RendererRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D) {
    var v = b.stop,
      k = D.addEvent,
      t = D.createElement,
      n = D.merge,
      h = D.pick;
    k(A, "afterSetChartSize", function (d) {
      var a = this.options.chart.scrollablePlotArea,
        b = a && a.minWidth;
      a = a && a.minHeight;
      if (!this.renderer.forExport) {
        if (b) {
          if (this.scrollablePixelsX = b = Math.max(0, b - this.chartWidth)) {
            this.scrollablePlotBox = this.renderer.scrollablePlotBox = n(this.plotBox);
            this.plotBox.width = this.plotWidth += b;
            this.inverted ? this.clipBox.height += b : this.clipBox.width += b;
            var g = {
              1: {
                name: "right",
                value: b
              }
            };
          }
        } else a && (this.scrollablePixelsY = b = Math.max(0, a - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = n(this.plotBox), this.plotBox.height = this.plotHeight += b, this.inverted ? this.clipBox.width += b : this.clipBox.height += b, g = {
          2: {
            name: "bottom",
            value: b
          }
        });
        g && !d.skipAxes && this.axes.forEach(function (a) {
          g[a.side] ? a.getPlotLinePath = function () {
            var d = g[a.side].name,
              b = this[d];
            this[d] = b - g[a.side].value;
            var e = p.prototype.getPlotLinePath.apply(this, arguments);
            this[d] = b;
            return e;
          } : (a.setAxisSize(), a.setAxisTranslation());
        });
      }
    });
    k(A, "render", function () {
      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
    });
    A.prototype.setUpScrolling = function () {
      var d = this,
        a = {
          WebkitOverflowScrolling: "touch",
          overflowX: "hidden",
          overflowY: "hidden"
        };
      this.scrollablePixelsX && (a.overflowX = "auto");
      this.scrollablePixelsY && (a.overflowY = "auto");
      this.scrollingParent = t("div", {
        className: "highcharts-scrolling-parent"
      }, {
        position: "relative"
      }, this.renderTo);
      this.scrollingContainer = t("div", {
        className: "highcharts-scrolling"
      }, a, this.scrollingParent);
      k(this.scrollingContainer, "scroll", function () {
        d.pointer && delete d.pointer.chartPosition;
      });
      this.innerContainer = t("div", {
        className: "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null;
    };
    A.prototype.moveFixedElements = function () {
      var d = this.container,
        a = this.fixedRenderer,
        b = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
        g;
      this.scrollablePixelsX && !this.inverted ? g = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (g = ".highcharts-yaxis");
      g && b.push(g + ":not(.highcharts-radial-axis)", g + "-labels:not(.highcharts-radial-axis-labels)");
      b.forEach(function (b) {
        [].forEach.call(d.querySelectorAll(b), function (d) {
          (d.namespaceURI === a.SVG_NS ? a.box : a.box.parentNode).appendChild(d);
          d.style.pointerEvents = "auto";
        });
      });
    };
    A.prototype.applyFixed = function () {
      var d = !this.fixedDiv,
        a = this.options.chart,
        b = a.scrollablePlotArea,
        g = w.getRendererType();
      d ? (this.fixedDiv = t("div", {
        className: "highcharts-fixed"
      }, {
        position: "absolute",
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: (a.style && a.style.zIndex || 0) + 2,
        top: 0
      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = a = new g(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = a.path().attr({
        fill: this.options.chart.backgroundColor || "#fff",
        "fill-opacity": h(b.opacity, .85),
        zIndex: -1
      }).addClass("highcharts-scrollable-mask").add(), k(this, "afterShowResetZoom", this.moveFixedElements), k(this, "afterDrilldown", this.moveFixedElements), k(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      if (this.scrollableDirty || d) this.scrollableDirty = !1, this.moveFixedElements();
      a = this.chartWidth + (this.scrollablePixelsX || 0);
      g = this.chartHeight + (this.scrollablePixelsY || 0);
      v(this.container);
      this.container.style.width = a + "px";
      this.container.style.height = g + "px";
      this.renderer.boxWrapper.attr({
        width: a,
        height: g,
        viewBox: [0, 0, a, g].join(" ")
      });
      this.chartBackground.attr({
        width: a,
        height: g
      });
      this.scrollingContainer.style.height = this.chartHeight + "px";
      d && (b.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * b.scrollPositionX), b.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * b.scrollPositionY));
      g = this.axisOffset;
      d = this.plotTop - g[0] - 1;
      b = this.plotLeft - g[3] - 1;
      a = this.plotTop + this.plotHeight + g[2] + 1;
      g = this.plotLeft + this.plotWidth + g[1] + 1;
      var n = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
        C = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
      d = this.scrollablePixelsX ? [["M", 0, d], ["L", this.plotLeft - 1, d], ["L", this.plotLeft - 1, a], ["L", 0, a], ["Z"], ["M", n, d], ["L", this.chartWidth, d], ["L", this.chartWidth, a], ["L", n, a], ["Z"]] : this.scrollablePixelsY ? [["M", b, 0], ["L", b, this.plotTop - 1], ["L", g, this.plotTop - 1], ["L", g, 0], ["Z"], ["M", b, C], ["L", b, this.chartHeight], ["L", g, this.chartHeight], ["L", g, C], ["Z"]] : [["M", 0, 0]];
      "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
        d: d
      });
    };
    k(p, "afterInit", function () {
      this.chart.scrollableDirty = !0;
    });
    k(E, "show", function () {
      this.chart.scrollableDirty = !0;
    });
    "";
  });
  G(b, "Core/Axis/StackingAxis.js", [b["Core/Animation/AnimationUtilities.js"], b["Core/Axis/Axis.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = b.getDeferredAnimation,
      w = A.addEvent,
      D = A.destroyObjectProperties,
      B = A.fireEvent,
      k = A.isNumber,
      t = A.objectEach,
      n;
    (function (b) {
      function d() {
        var a = this.stacking;
        if (a) {
          var d = a.stacks;
          t(d, function (a, b) {
            D(a);
            d[b] = null;
          });
          a && a.stackTotalGroup && a.stackTotalGroup.destroy();
        }
      }
      function a() {
        this.stacking || (this.stacking = new g(this));
      }
      var e = [];
      b.compose = function (b) {
        -1 === e.indexOf(b) && (e.push(b), w(b, "init", a), w(b, "destroy", d));
        return b;
      };
      var g = function () {
        function a(a) {
          this.oldStacks = {};
          this.stacks = {};
          this.stacksTouched = 0;
          this.axis = a;
        }
        a.prototype.buildStacks = function () {
          var a = this.axis,
            d = a.series,
            b = a.options.reversedStacks,
            e = d.length,
            g;
          if (!a.isXAxis) {
            this.usePercentage = !1;
            for (g = e; g--;) {
              var f = d[b ? g : e - g - 1];
              f.setStackedPoints();
              f.setGroupedPoints();
            }
            for (g = 0; g < e; g++) d[g].modifyStacks();
            B(a, "afterBuildStacks");
          }
        };
        a.prototype.cleanStacks = function () {
          if (!this.axis.isXAxis) {
            if (this.oldStacks) var a = this.stacks = this.oldStacks;
            t(a, function (a) {
              t(a, function (a) {
                a.cumulative = a.total;
              });
            });
          }
        };
        a.prototype.resetStacks = function () {
          var a = this,
            d = a.stacks;
          a.axis.isXAxis || t(d, function (d) {
            t(d, function (b, e) {
              k(b.touched) && b.touched < a.stacksTouched ? (b.destroy(), delete d[e]) : (b.total = null, b.cumulative = null);
            });
          });
        };
        a.prototype.renderStackTotals = function () {
          var a = this.axis,
            d = a.chart,
            b = d.renderer,
            e = this.stacks;
          a = v(d, a.options.stackLabels && a.options.stackLabels.animation || !1);
          var g = this.stackTotalGroup = this.stackTotalGroup || b.g("stack-labels").attr({
            visibility: "visible",
            zIndex: 6,
            opacity: 0
          }).add();
          g.translate(d.plotLeft, d.plotTop);
          t(e, function (a) {
            t(a, function (a) {
              a.render(g);
            });
          });
          g.animate({
            opacity: 1
          }, a);
        };
        return a;
      }();
      b.Additions = g;
    })(n || (n = {}));
    return n;
  });
  G(b, "Extensions/Stacking.js", [b["Core/Axis/Axis.js"], b["Core/Chart/Chart.js"], b["Core/FormatUtilities.js"], b["Core/Globals.js"], b["Core/Series/Series.js"], b["Core/Axis/StackingAxis.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D, B) {
    var k = A.format,
      t = B.correctFloat,
      n = B.defined,
      h = B.destroyObjectProperties,
      d = B.isArray,
      a = B.isNumber,
      e = B.objectEach,
      g = B.pick,
      x = function () {
        function d(a, d, b, e, f) {
          var g = a.chart.inverted;
          this.axis = a;
          this.isNegative = b;
          this.options = d = d || {};
          this.x = e;
          this.total = null;
          this.points = {};
          this.hasValidPoints = !1;
          this.stack = f;
          this.rightCliff = this.leftCliff = 0;
          this.alignOptions = {
            align: d.align || (g ? b ? "left" : "right" : "center"),
            verticalAlign: d.verticalAlign || (g ? "middle" : b ? "bottom" : "top"),
            y: d.y,
            x: d.x
          };
          this.textAlign = d.textAlign || (g ? b ? "right" : "left" : "center");
        }
        d.prototype.destroy = function () {
          h(this, this.axis);
        };
        d.prototype.render = function (a) {
          var d = this.axis.chart,
            b = this.options,
            e = b.format;
          e = e ? k(e, this, d) : b.formatter.call(this);
          this.label ? this.label.attr({
            text: e,
            visibility: "hidden"
          }) : (this.label = d.renderer.label(e, null, null, b.shape, null, null, b.useHTML, !1, "stack-labels"), e = {
            r: b.borderRadius || 0,
            text: e,
            rotation: b.rotation,
            padding: g(b.padding, 5),
            visibility: "hidden"
          }, d.styledMode || (e.fill = b.backgroundColor, e.stroke = b.borderColor, e["stroke-width"] = b.borderWidth, this.label.css(b.style)), this.label.attr(e), this.label.added || this.label.add(a));
          this.label.labelrank = d.plotSizeY;
        };
        d.prototype.setOffset = function (d, b, e, m, f) {
          var h = this.axis,
            c = h.chart;
          m = h.translate(h.stacking.usePercentage ? 100 : m ? m : this.total, 0, 0, 0, 1);
          e = h.translate(e ? e : 0);
          e = n(m) && Math.abs(m - e);
          d = g(f, c.xAxis[0].translate(this.x)) + d;
          h = n(m) && this.getStackBox(c, this, d, m, b, e, h);
          b = this.label;
          e = this.isNegative;
          d = "justify" === g(this.options.overflow, "justify");
          var k = this.textAlign;
          b && h && (f = b.getBBox(), m = b.padding, k = "left" === k ? c.inverted ? -m : m : "right" === k ? f.width : c.inverted && "center" === k ? f.width / 2 : c.inverted ? e ? f.width + m : -m : f.width / 2, e = c.inverted ? f.height / 2 : e ? -m : f.height, this.alignOptions.x = g(this.options.x, 0), this.alignOptions.y = g(this.options.y, 0), h.x -= k, h.y -= e, b.align(this.alignOptions, null, h), c.isInsidePlot(b.alignAttr.x + k - this.alignOptions.x, b.alignAttr.y + e - this.alignOptions.y) ? b.show() : (b.alignAttr.y = -9999, d = !1), d && w.prototype.justifyDataLabel.call(this.axis, b, this.alignOptions, b.alignAttr, f, h), b.attr({
            x: b.alignAttr.x,
            y: b.alignAttr.y
          }), g(!d && this.options.crop, !0) && ((c = a(b.x) && a(b.y) && c.isInsidePlot(b.x - m + b.width, b.y) && c.isInsidePlot(b.x + m, b.y)) || b.hide()));
        };
        d.prototype.getStackBox = function (a, d, b, e, f, g, c) {
          var m = d.axis.reversed,
            l = a.inverted,
            h = c.height + c.pos - (l ? a.plotLeft : a.plotTop);
          d = d.isNegative && !m || !d.isNegative && m;
          return {
            x: l ? d ? e - c.right : e - g + c.pos - a.plotLeft : b + a.xAxis[0].transB - a.plotLeft,
            y: l ? c.height - b - f : d ? h - e - g : h - e,
            width: l ? g : f,
            height: l ? f : g
          };
        };
        return d;
      }();
    p.prototype.getStacks = function () {
      var a = this,
        d = a.inverted;
      a.yAxis.forEach(function (a) {
        a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);
      });
      a.series.forEach(function (b) {
        var e = b.xAxis && b.xAxis.options || {};
        !b.options.stacking || !0 !== b.visible && !1 !== a.options.chart.ignoreHiddenSeries || (b.stackKey = [b.type, g(b.options.stack, ""), d ? e.top : e.left, d ? e.height : e.width].join());
      });
    };
    D.compose(b);
    w.prototype.setGroupedPoints = function () {
      var a = this.yAxis.stacking;
      this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? w.prototype.setStackedPoints.call(this, "group") : a && e(a.stacks, function (d, b) {
        "group" === b.slice(-5) && (e(d, function (a) {
          return a.destroy();
        }), delete a.stacks[b]);
      });
    };
    w.prototype.setStackedPoints = function (a) {
      var b = a || this.options.stacking;
      if (b && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
        var e = this.processedXData,
          h = this.processedYData,
          m = [],
          f = h.length,
          k = this.options,
          c = k.threshold,
          u = g(k.startFromThreshold && c, 0);
        k = k.stack;
        a = a ? this.type + "," + b : this.stackKey;
        var l = "-" + a,
          C = this.negStacks,
          p = this.yAxis,
          v = p.stacking.stacks,
          B = p.stacking.oldStacks,
          w,
          A;
        p.stacking.stacksTouched += 1;
        for (A = 0; A < f; A++) {
          var D = e[A];
          var E = h[A];
          var T = this.getStackIndicator(T, D, this.index);
          var G = T.key;
          var J = (w = C && E < (u ? 0 : c)) ? l : a;
          v[J] || (v[J] = {});
          v[J][D] || (B[J] && B[J][D] ? (v[J][D] = B[J][D], v[J][D].total = null) : v[J][D] = new x(p, p.options.stackLabels, w, D, k));
          J = v[J][D];
          null !== E ? (J.points[G] = J.points[this.index] = [g(J.cumulative, u)], n(J.cumulative) || (J.base = G), J.touched = p.stacking.stacksTouched, 0 < T.index && !1 === this.singleStacks && (J.points[G][0] = J.points[this.index + "," + D + ",0"][0])) : J.points[G] = J.points[this.index] = null;
          "percent" === b ? (w = w ? a : l, C && v[w] && v[w][D] ? (w = v[w][D], J.total = w.total = Math.max(w.total, J.total) + Math.abs(E) || 0) : J.total = t(J.total + (Math.abs(E) || 0))) : "group" === b ? (d(E) && (E = E[0]), null !== E && (J.total = (J.total || 0) + 1)) : J.total = t(J.total + (E || 0));
          J.cumulative = "group" === b ? (J.total || 1) - 1 : g(J.cumulative, u) + (E || 0);
          null !== E && (J.points[G].push(J.cumulative), m[A] = J.cumulative, J.hasValidPoints = !0);
        }
        "percent" === b && (p.stacking.usePercentage = !0);
        "group" !== b && (this.stackedYData = m);
        p.stacking.oldStacks = {};
      }
    };
    w.prototype.modifyStacks = function () {
      var a = this,
        d = a.stackKey,
        b = a.yAxis.stacking.stacks,
        e = a.processedXData,
        g,
        f = a.options.stacking;
      a[f + "Stacker"] && [d, "-" + d].forEach(function (d) {
        for (var c = e.length, m, l; c--;) if (m = e[c], g = a.getStackIndicator(g, m, a.index, d), l = (m = b[d] && b[d][m]) && m.points[g.key]) a[f + "Stacker"](l, m, c);
      });
    };
    w.prototype.percentStacker = function (a, d, b) {
      d = d.total ? 100 / d.total : 0;
      a[0] = t(a[0] * d);
      a[1] = t(a[1] * d);
      this.stackedYData[b] = a[1];
    };
    w.prototype.getStackIndicator = function (a, d, b, e) {
      !n(a) || a.x !== d || e && a.key !== e ? a = {
        x: d,
        index: 0,
        key: e
      } : a.index++;
      a.key = [b, d, a.index].join();
      return a;
    };
    E.StackItem = x;
    "";
    return E.StackItem;
  });
  G(b, "Series/Line/LineSeries.js", [b["Core/Series/Series.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = this && this.__extends || function () {
        var b = function (k, t) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (b, h) {
            b.__proto__ = h;
          } || function (b, h) {
            for (var d in h) h.hasOwnProperty(d) && (b[d] = h[d]);
          };
          return b(k, t);
        };
        return function (k, t) {
          function n() {
            this.constructor = k;
          }
          b(k, t);
          k.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());
        };
      }(),
      w = A.defined,
      D = A.merge;
    A = function (p) {
      function k() {
        var b = null !== p && p.apply(this, arguments) || this;
        b.data = void 0;
        b.options = void 0;
        b.points = void 0;
        return b;
      }
      v(k, p);
      k.prototype.drawGraph = function () {
        var b = this,
          k = this.options,
          h = (this.gappedPath || this.getGraphPath).call(this),
          d = this.chart.styledMode,
          a = [["graph", "highcharts-graph"]];
        d || a[0].push(k.lineColor || this.color || "#cccccc", k.dashStyle);
        a = b.getZonesGraphs(a);
        a.forEach(function (a, g) {
          var e = a[0],
            n = b[e],
            r = n ? "animate" : "attr";
          n ? (n.endX = b.preventGraphAnimation ? null : h.xMap, n.animate({
            d: h
          })) : h.length && (b[e] = n = b.chart.renderer.path(h).addClass(a[1]).attr({
            zIndex: 1
          }).add(b.group));
          n && !d && (e = {
            stroke: a[2],
            "stroke-width": k.lineWidth,
            fill: b.fillGraph && b.color || "none"
          }, a[3] ? e.dashstyle = a[3] : "square" !== k.linecap && (e["stroke-linecap"] = e["stroke-linejoin"] = "round"), n[r](e).shadow(2 > g && k.shadow));
          n && (n.startX = h.xMap, n.isArea = h.isArea);
        });
      };
      k.prototype.getGraphPath = function (b, k, h) {
        var d = this,
          a = d.options,
          e = [],
          g = [],
          n,
          t = a.step;
        b = b || d.points;
        var r = b.reversed;
        r && b.reverse();
        (t = {
          right: 1,
          center: 2
        }[t] || t && 3) && r && (t = 4 - t);
        b = this.getValidPoints(b, !1, !(a.connectNulls && !k && !h));
        b.forEach(function (q, r) {
          var m = q.plotX,
            f = q.plotY,
            y = b[r - 1];
          (q.leftCliff || y && y.rightCliff) && !h && (n = !0);
          q.isNull && !w(k) && 0 < r ? n = !a.connectNulls : q.isNull && !k ? n = !0 : (0 === r || n ? r = [["M", q.plotX, q.plotY]] : d.getPointSpline ? r = [d.getPointSpline(b, q, r)] : t ? (r = 1 === t ? [["L", y.plotX, f]] : 2 === t ? [["L", (y.plotX + m) / 2, y.plotY], ["L", (y.plotX + m) / 2, f]] : [["L", m, y.plotY]], r.push(["L", m, f])) : r = [["L", m, f]], g.push(q.x), t && (g.push(q.x), 2 === t && g.push(q.x)), e.push.apply(e, r), n = !1);
        });
        e.xMap = g;
        return d.graphPath = e;
      };
      k.prototype.getZonesGraphs = function (b) {
        this.zones.forEach(function (k, h) {
          h = ["zone-graph-" + h, "highcharts-graph highcharts-zone-graph-" + h + " " + (k.className || "")];
          this.chart.styledMode || h.push(k.color || this.color, k.dashStyle || this.options.dashStyle);
          b.push(h);
        }, this);
        return b;
      };
      k.defaultOptions = D(b.defaultOptions, {});
      return k;
    }(b);
    p.registerSeriesType("line", A);
    "";
    return A;
  });
  G(b, "Series/Area/AreaSeries.js", [b["Core/Color/Color.js"], b["Core/Legend/LegendSymbol.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E) {
    var v = this && this.__extends || function () {
        var b = function (d, a) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var b in d) d.hasOwnProperty(b) && (a[b] = d[b]);
          };
          return b(d, a);
        };
        return function (d, a) {
          function e() {
            this.constructor = d;
          }
          b(d, a);
          d.prototype = null === a ? Object.create(a) : (e.prototype = a.prototype, new e());
        };
      }(),
      D = b.parse,
      B = A.seriesTypes.line;
    b = E.extend;
    var k = E.merge,
      t = E.objectEach,
      n = E.pick;
    E = function (b) {
      function d() {
        var a = null !== b && b.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      v(d, b);
      d.prototype.drawGraph = function () {
        this.areaPath = [];
        b.prototype.drawGraph.apply(this);
        var a = this,
          d = this.areaPath,
          g = this.options,
          h = [["area", "highcharts-area", this.color, g.fillColor]];
        this.zones.forEach(function (d, b) {
          h.push(["zone-area-" + b, "highcharts-area highcharts-zone-area-" + b + " " + d.className, d.color || a.color, d.fillColor || g.fillColor]);
        });
        h.forEach(function (b) {
          var e = b[0],
            h = a[e],
            k = h ? "animate" : "attr",
            m = {};
          h ? (h.endX = a.preventGraphAnimation ? null : d.xMap, h.animate({
            d: d
          })) : (m.zIndex = 0, h = a[e] = a.chart.renderer.path(d).addClass(b[1]).add(a.group), h.isArea = !0);
          a.chart.styledMode || (m.fill = n(b[3], D(b[2]).setOpacity(n(g.fillOpacity, .75)).get()));
          h[k](m);
          h.startX = d.xMap;
          h.shiftUnit = g.step ? 2 : 1;
        });
      };
      d.prototype.getGraphPath = function (a) {
        var d = B.prototype.getGraphPath,
          b = this.options,
          h = b.stacking,
          k = this.yAxis,
          r,
          q = [],
          t = [],
          m = this.index,
          f = k.stacking.stacks[this.stackKey],
          y = b.threshold,
          c = Math.round(k.getThreshold(b.threshold));
        b = n(b.connectNulls, "percent" === h);
        var u = function (d, b, e) {
          var g = a[d];
          d = h && f[g.x].points[m];
          var l = g[e + "Null"] || 0;
          e = g[e + "Cliff"] || 0;
          g = !0;
          if (e || l) {
            var n = (l ? d[0] : d[1]) + e;
            var u = d[0] + e;
            g = !!l;
          } else !h && a[b] && a[b].isNull && (n = u = y);
          "undefined" !== typeof n && (t.push({
            plotX: p,
            plotY: null === n ? c : k.getThreshold(n),
            isNull: g,
            isCliff: !0
          }), q.push({
            plotX: p,
            plotY: null === u ? c : k.getThreshold(u),
            doCurve: !1
          }));
        };
        a = a || this.points;
        h && (a = this.getStackPoints(a));
        for (r = 0; r < a.length; r++) {
          h || (a[r].leftCliff = a[r].rightCliff = a[r].leftNull = a[r].rightNull = void 0);
          var l = a[r].isNull;
          var p = n(a[r].rectPlotX, a[r].plotX);
          var v = h ? n(a[r].yBottom, c) : c;
          if (!l || b) b || u(r, r - 1, "left"), l && !h && b || (t.push(a[r]), q.push({
            x: r,
            plotX: p,
            plotY: v
          })), b || u(r, r + 1, "right");
        }
        r = d.call(this, t, !0, !0);
        q.reversed = !0;
        l = d.call(this, q, !0, !0);
        (v = l[0]) && "M" === v[0] && (l[0] = ["L", v[1], v[2]]);
        l = r.concat(l);
        l.length && l.push(["Z"]);
        d = d.call(this, t, !1, b);
        l.xMap = r.xMap;
        this.areaPath = l;
        return d;
      };
      d.prototype.getStackPoints = function (a) {
        var d = this,
          b = [],
          h = [],
          k = this.xAxis,
          r = this.yAxis,
          q = r.stacking.stacks[this.stackKey],
          z = {},
          m = r.series,
          f = m.length,
          y = r.options.reversedStacks ? 1 : -1,
          c = m.indexOf(d);
        a = a || this.points;
        if (this.options.stacking) {
          for (var u = 0; u < a.length; u++) a[u].leftNull = a[u].rightNull = void 0, z[a[u].x] = a[u];
          t(q, function (c, a) {
            null !== c.total && h.push(a);
          });
          h.sort(function (c, a) {
            return c - a;
          });
          var l = m.map(function (c) {
            return c.visible;
          });
          h.forEach(function (a, e) {
            var g = 0,
              u,
              t;
            if (z[a] && !z[a].isNull) b.push(z[a]), [-1, 1].forEach(function (b) {
              var g = 1 === b ? "rightNull" : "leftNull",
                k = 0,
                n = q[h[e + b]];
              if (n) for (var r = c; 0 <= r && r < f;) {
                var x = m[r].index;
                u = n.points[x];
                u || (x === d.index ? z[a][g] = !0 : l[r] && (t = q[a].points[x]) && (k -= t[1] - t[0]));
                r += y;
              }
              z[a][1 === b ? "rightCliff" : "leftCliff"] = k;
            });else {
              for (var x = c; 0 <= x && x < f;) {
                if (u = q[a].points[m[x].index]) {
                  g = u[1];
                  break;
                }
                x += y;
              }
              g = n(g, 0);
              g = r.translate(g, 0, 1, 0, 1);
              b.push({
                isNull: !0,
                plotX: k.translate(a, 0, 0, 0, 1),
                x: a,
                plotY: g,
                yBottom: g
              });
            }
          });
        }
        return b;
      };
      d.defaultOptions = k(B.defaultOptions, {
        threshold: 0
      });
      return d;
    }(B);
    b(E.prototype, {
      singleStacks: !1,
      drawLegendSymbol: p.drawRectangle
    });
    A.registerSeriesType("area", E);
    "";
    return E;
  });
  G(b, "Series/Spline/SplineSeries.js", [b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = this && this.__extends || function () {
        var b = function (k, t) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (b, h) {
            b.__proto__ = h;
          } || function (b, h) {
            for (var d in h) h.hasOwnProperty(d) && (b[d] = h[d]);
          };
          return b(k, t);
        };
        return function (k, t) {
          function n() {
            this.constructor = k;
          }
          b(k, t);
          k.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());
        };
      }(),
      E = b.seriesTypes.line,
      w = p.merge,
      D = p.pick;
    p = function (b) {
      function k() {
        var k = null !== b && b.apply(this, arguments) || this;
        k.data = void 0;
        k.options = void 0;
        k.points = void 0;
        return k;
      }
      v(k, b);
      k.prototype.getPointSpline = function (b, k, h) {
        var d = k.plotX || 0,
          a = k.plotY || 0,
          e = b[h - 1];
        h = b[h + 1];
        if (e && !e.isNull && !1 !== e.doCurve && !k.isCliff && h && !h.isNull && !1 !== h.doCurve && !k.isCliff) {
          b = e.plotY || 0;
          var g = h.plotX || 0;
          h = h.plotY || 0;
          var n = 0;
          var t = (1.5 * d + (e.plotX || 0)) / 2.5;
          var r = (1.5 * a + b) / 2.5;
          g = (1.5 * d + g) / 2.5;
          var q = (1.5 * a + h) / 2.5;
          g !== t && (n = (q - r) * (g - d) / (g - t) + a - q);
          r += n;
          q += n;
          r > b && r > a ? (r = Math.max(b, a), q = 2 * a - r) : r < b && r < a && (r = Math.min(b, a), q = 2 * a - r);
          q > h && q > a ? (q = Math.max(h, a), r = 2 * a - q) : q < h && q < a && (q = Math.min(h, a), r = 2 * a - q);
          k.rightContX = g;
          k.rightContY = q;
        }
        k = ["C", D(e.rightContX, e.plotX, 0), D(e.rightContY, e.plotY, 0), D(t, d, 0), D(r, a, 0), d, a];
        e.rightContX = e.rightContY = void 0;
        return k;
      };
      k.defaultOptions = w(E.defaultOptions);
      return k;
    }(E);
    b.registerSeriesType("spline", p);
    "";
    return p;
  });
  G(b, "Series/AreaSpline/AreaSplineSeries.js", [b["Series/Area/AreaSeries.js"], b["Series/Spline/SplineSeries.js"], b["Core/Legend/LegendSymbol.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E, w) {
    var v = this && this.__extends || function () {
        var b = function (h, d) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var b in d) d.hasOwnProperty(b) && (a[b] = d[b]);
          };
          return b(h, d);
        };
        return function (h, d) {
          function a() {
            this.constructor = h;
          }
          b(h, d);
          h.prototype = null === d ? Object.create(d) : (a.prototype = d.prototype, new a());
        };
      }(),
      B = b.prototype,
      k = w.extend,
      t = w.merge;
    w = function (k) {
      function h() {
        var d = null !== k && k.apply(this, arguments) || this;
        d.data = void 0;
        d.points = void 0;
        d.options = void 0;
        return d;
      }
      v(h, k);
      h.defaultOptions = t(p.defaultOptions, b.defaultOptions);
      return h;
    }(p);
    k(w.prototype, {
      getGraphPath: B.getGraphPath,
      getStackPoints: B.getStackPoints,
      drawGraph: B.drawGraph,
      drawLegendSymbol: A.drawRectangle
    });
    E.registerSeriesType("areaspline", w);
    "";
    return w;
  });
  G(b, "Series/Column/ColumnSeries.js", [b["Core/Animation/AnimationUtilities.js"], b["Core/Color/Color.js"], b["Core/Globals.js"], b["Core/Legend/LegendSymbol.js"], b["Core/Series/Series.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D, B) {
    var k = this && this.__extends || function () {
        var a = function (d, c) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (c, a) {
            c.__proto__ = a;
          } || function (c, a) {
            for (var d in a) a.hasOwnProperty(d) && (c[d] = a[d]);
          };
          return a(d, c);
        };
        return function (d, c) {
          function b() {
            this.constructor = d;
          }
          a(d, c);
          d.prototype = null === c ? Object.create(c) : (b.prototype = c.prototype, new b());
        };
      }(),
      t = b.animObject,
      n = p.parse,
      h = A.hasTouch;
    b = A.noop;
    var d = B.clamp,
      a = B.css,
      e = B.defined,
      g = B.extend,
      x = B.fireEvent,
      v = B.isArray,
      r = B.isNumber,
      q = B.merge,
      z = B.pick,
      m = B.objectEach;
    B = function (b) {
      function f() {
        var c = null !== b && b.apply(this, arguments) || this;
        c.borderWidth = void 0;
        c.data = void 0;
        c.group = void 0;
        c.options = void 0;
        c.points = void 0;
        return c;
      }
      k(f, b);
      f.prototype.animate = function (c) {
        var a = this,
          b = this.yAxis,
          f = a.options,
          e = this.chart.inverted,
          m = {},
          h = e ? "translateX" : "translateY";
        if (c) m.scaleY = .001, c = d(b.toPixels(f.threshold), b.pos, b.pos + b.len), e ? m.translateX = c - b.len : m.translateY = c, a.clipBox && a.setClip(), a.group.attr(m);else {
          var k = Number(a.group.attr(h));
          a.group.animate({
            scaleY: 1
          }, g(t(a.options.animation), {
            step: function (c, d) {
              a.group && (m[h] = k + d.pos * (b.pos - k), a.group.attr(m));
            }
          }));
        }
      };
      f.prototype.init = function (c, a) {
        b.prototype.init.apply(this, arguments);
        var d = this;
        c = d.chart;
        c.hasRendered && c.series.forEach(function (c) {
          c.type === d.type && (c.isDirty = !0);
        });
      };
      f.prototype.getColumnMetrics = function () {
        var c = this,
          a = c.options,
          d = c.xAxis,
          b = c.yAxis,
          f = d.options.reversedStacks;
        f = d.reversed && !f || !d.reversed && f;
        var e = {},
          g,
          m = 0;
        !1 === a.grouping ? m = 1 : c.chart.series.forEach(function (a) {
          var d = a.yAxis,
            f = a.options;
          if (a.type === c.type && (a.visible || !c.chart.options.chart.ignoreHiddenSeries) && b.len === d.len && b.pos === d.pos) {
            if (f.stacking && "group" !== f.stacking) {
              g = a.stackKey;
              "undefined" === typeof e[g] && (e[g] = m++);
              var h = e[g];
            } else !1 !== f.grouping && (h = m++);
            a.columnIndex = h;
          }
        });
        var h = Math.min(Math.abs(d.transA) * (d.ordinal && d.ordinal.slope || a.pointRange || d.closestPointRange || d.tickInterval || 1), d.len),
          k = h * a.groupPadding,
          q = (h - 2 * k) / (m || 1);
        a = Math.min(a.maxPointWidth || d.len, z(a.pointWidth, q * (1 - 2 * a.pointPadding)));
        c.columnMetrics = {
          width: a,
          offset: (q - a) / 2 + (k + ((c.columnIndex || 0) + (f ? 1 : 0)) * q - h / 2) * (f ? -1 : 1),
          paddedWidth: q,
          columnCount: m
        };
        return c.columnMetrics;
      };
      f.prototype.crispCol = function (c, a, d, b) {
        var f = this.chart,
          e = this.borderWidth,
          g = -(e % 2 ? .5 : 0);
        e = e % 2 ? .5 : 1;
        f.inverted && f.renderer.isVML && (e += 1);
        this.options.crisp && (d = Math.round(c + d) + g, c = Math.round(c) + g, d -= c);
        b = Math.round(a + b) + e;
        g = .5 >= Math.abs(a) && .5 < b;
        a = Math.round(a) + e;
        b -= a;
        g && b && (--a, b += 1);
        return {
          x: c,
          y: a,
          width: d,
          height: b
        };
      };
      f.prototype.adjustForMissingColumns = function (c, a, d, b) {
        var f = this,
          e = this.options.stacking;
        if (!d.isNull && 1 < b.columnCount) {
          var g = 0,
            h = 0;
          m(this.yAxis.stacking && this.yAxis.stacking.stacks, function (c) {
            if ("number" === typeof d.x && (c = c[d.x.toString()])) {
              var a = c.points[f.index],
                b = c.total;
              e ? (a && (g = h), c.hasValidPoints && h++) : v(a) && (g = a[1], h = b || 0);
            }
          });
          c = (d.plotX || 0) + ((h - 1) * b.paddedWidth + a) / 2 - a - g * b.paddedWidth;
        }
        return c;
      };
      f.prototype.translate = function () {
        var c = this,
          a = c.chart,
          b = c.options,
          f = c.dense = 2 > c.closestPointRange * c.xAxis.transA;
        f = c.borderWidth = z(b.borderWidth, f ? 0 : 1);
        var g = c.xAxis,
          m = c.yAxis,
          h = b.threshold,
          k = c.translatedThreshold = m.getThreshold(h),
          q = z(b.minPointLength, 5),
          n = c.getColumnMetrics(),
          y = n.width,
          t = c.pointXOffset = n.offset,
          x = c.dataMin,
          p = c.dataMax,
          v = c.barW = Math.max(y, 1 + 2 * f);
        a.inverted && (k -= .5);
        b.pointPadding && (v = Math.ceil(v));
        w.prototype.translate.apply(c);
        c.points.forEach(function (f) {
          var l = z(f.yBottom, k),
            u = 999 + Math.abs(l),
            C = f.plotX || 0;
          u = d(f.plotY, -u, m.len + u);
          var w = Math.min(u, l),
            B = Math.max(u, l) - w,
            F = y,
            A = C + t,
            D = v;
          q && Math.abs(B) < q && (B = q, C = !m.reversed && !f.negative || m.reversed && f.negative, r(h) && r(p) && f.y === h && p <= h && (m.min || 0) < h && (x !== p || (m.max || 0) <= h) && (C = !C), w = Math.abs(w - k) > q ? l - q : k - (C ? q : 0));
          e(f.options.pointWidth) && (F = D = Math.ceil(f.options.pointWidth), A -= Math.round((F - y) / 2));
          b.centerInCategory && (A = c.adjustForMissingColumns(A, F, f, n));
          f.barX = A;
          f.pointWidth = F;
          f.tooltipPos = a.inverted ? [d(m.len + m.pos - a.plotLeft - u, m.pos - a.plotLeft, m.len + m.pos - a.plotLeft), g.len + g.pos - a.plotTop - A - D / 2, B] : [g.left - a.plotLeft + A + D / 2, d(u + m.pos - a.plotTop, m.pos - a.plotTop, m.len + m.pos - a.plotTop), B];
          f.shapeType = c.pointClass.prototype.shapeType || "rect";
          f.shapeArgs = c.crispCol.apply(c, f.isNull ? [A, k, D, 0] : [A, w, D, B]);
        });
      };
      f.prototype.drawGraph = function () {
        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
      };
      f.prototype.pointAttribs = function (c, a) {
        var d = this.options,
          b = this.pointAttrToOptions || {},
          f = b.stroke || "borderColor",
          e = b["stroke-width"] || "borderWidth",
          g = c && c.color || this.color,
          m = c && c[f] || d[f] || g;
        b = c && c.options.dashStyle || d.dashStyle;
        var h = c && c[e] || d[e] || this[e] || 0,
          k = z(c && c.opacity, d.opacity, 1);
        if (c && this.zones.length) {
          var r = c.getZone();
          g = c.options.color || r && (r.color || c.nonZonedColor) || this.color;
          r && (m = r.borderColor || m, b = r.dashStyle || b, h = r.borderWidth || h);
        }
        a && c && (c = q(d.states[a], c.options.states && c.options.states[a] || {}), a = c.brightness, g = c.color || "undefined" !== typeof a && n(g).brighten(c.brightness).get() || g, m = c[f] || m, h = c[e] || h, b = c.dashStyle || b, k = z(c.opacity, k));
        f = {
          fill: g,
          stroke: m,
          "stroke-width": h,
          opacity: k
        };
        b && (f.dashstyle = b);
        return f;
      };
      f.prototype.drawPoints = function () {
        var c = this,
          a = this.chart,
          d = c.options,
          b = a.renderer,
          f = d.animationLimit || 250,
          e;
        c.points.forEach(function (g) {
          var m = g.graphic,
            h = !!m,
            l = m && a.pointCount < f ? "animate" : "attr";
          if (r(g.plotY) && null !== g.y) {
            e = g.shapeArgs;
            m && g.hasNewShapeType() && (m = m.destroy());
            c.enabledDataSorting && (g.startXPos = c.xAxis.reversed ? -(e ? e.width || 0 : 0) : c.xAxis.width);
            m || (g.graphic = m = b[g.shapeType](e).add(g.group || c.group)) && c.enabledDataSorting && a.hasRendered && a.pointCount < f && (m.attr({
              x: g.startXPos
            }), h = !0, l = "animate");
            if (m && h) m[l](q(e));
            if (d.borderRadius) m[l]({
              r: d.borderRadius
            });
            a.styledMode || m[l](c.pointAttribs(g, g.selected && "select")).shadow(!1 !== g.allowShadow && d.shadow, null, d.stacking && !d.borderRadius);
            m && (m.addClass(g.getClassName(), !0), m.attr({
              visibility: g.visible ? "inherit" : "hidden"
            }));
          } else m && (g.graphic = m.destroy());
        });
      };
      f.prototype.drawTracker = function () {
        var c = this,
          d = c.chart,
          b = d.pointer,
          f = function (c) {
            var a = b.getPointFromEvent(c);
            "undefined" !== typeof a && (b.isDirectTouch = !0, a.onMouseOver(c));
          },
          e;
        c.points.forEach(function (c) {
          e = v(c.dataLabels) ? c.dataLabels : c.dataLabel ? [c.dataLabel] : [];
          c.graphic && (c.graphic.element.point = c);
          e.forEach(function (a) {
            a.div ? a.div.point = c : a.element.point = c;
          });
        });
        c._hasTracking || (c.trackerGroups.forEach(function (e) {
          if (c[e]) {
            c[e].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function (c) {
              b.onTrackerMouseOut(c);
            });
            if (h) c[e].on("touchstart", f);
            !d.styledMode && c.options.cursor && c[e].css(a).css({
              cursor: c.options.cursor
            });
          }
        }), c._hasTracking = !0);
        x(this, "afterDrawTracker");
      };
      f.prototype.remove = function () {
        var c = this,
          a = c.chart;
        a.hasRendered && a.series.forEach(function (a) {
          a.type === c.type && (a.isDirty = !0);
        });
        w.prototype.remove.apply(c, arguments);
      };
      f.defaultOptions = q(w.defaultOptions, {
        borderRadius: 0,
        centerInCategory: !1,
        groupPadding: .2,
        marker: null,
        pointPadding: .1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
          hover: {
            halo: !1,
            brightness: .1
          },
          select: {
            color: "#cccccc",
            borderColor: "#000000"
          }
        },
        dataLabels: {
          align: void 0,
          verticalAlign: void 0,
          y: void 0
        },
        startFromThreshold: !0,
        stickyTracking: !1,
        tooltip: {
          distance: 6
        },
        threshold: 0,
        borderColor: "#ffffff"
      });
      return f;
    }(w);
    g(B.prototype, {
      cropShoulder: 0,
      directTouch: !0,
      drawLegendSymbol: E.drawRectangle,
      getSymbol: b,
      negStacks: !0,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    D.registerSeriesType("column", B);
    "";
    "";
    return B;
  });
  G(b, "Core/Series/DataLabel.js", [b["Core/Animation/AnimationUtilities.js"], b["Core/FormatUtilities.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = b.getDeferredAnimation,
      w = p.format,
      D = A.defined,
      B = A.extend,
      k = A.fireEvent,
      t = A.isArray,
      n = A.merge,
      h = A.objectEach,
      d = A.pick,
      a = A.splat,
      e;
    (function (b) {
      function e(a, c, b, f, e) {
        var g = this,
          m = this.chart,
          h = this.isCartesian && m.inverted,
          l = this.enabledDataSorting,
          k = d(a.dlBox && a.dlBox.centerX, a.plotX, -9999),
          q = d(a.plotY, -9999),
          n = c.getBBox(),
          r = b.rotation,
          u = b.align,
          t = m.isInsidePlot(k, Math.round(q), {
            inverted: h,
            paneCoordinates: !0,
            series: g
          }),
          y = function (d) {
            l && g.xAxis && !z && g.setDataLabelStartPos(a, c, e, t, d);
          },
          z = "justify" === d(b.overflow, l ? "none" : "justify"),
          x = this.visible && !1 !== a.visible && (a.series.forceDL || l && !z || t || d(b.inside, !!this.options.stacking) && f && m.isInsidePlot(k, h ? f.x + 1 : f.y + f.height - 1, {
            inverted: h,
            paneCoordinates: !0,
            series: g
          }));
        if (x) {
          var p = m.renderer.fontMetrics(m.styledMode ? void 0 : b.style.fontSize, c).b;
          f = B({
            x: h ? this.yAxis.len - q : k,
            y: Math.round(h ? this.xAxis.len - k : q),
            width: 0,
            height: 0
          }, f);
          B(b, {
            width: n.width,
            height: n.height
          });
          r ? (z = !1, k = m.renderer.rotCorr(p, r), k = {
            x: f.x + (b.x || 0) + f.width / 2 + k.x,
            y: f.y + (b.y || 0) + {
              top: 0,
              middle: .5,
              bottom: 1
            }[b.verticalAlign] * f.height
          }, y(k), c[e ? "attr" : "animate"](k).attr({
            align: u
          }), y = (r + 720) % 360, y = 180 < y && 360 > y, "left" === u ? k.y -= y ? n.height : 0 : "center" === u ? (k.x -= n.width / 2, k.y -= n.height / 2) : "right" === u && (k.x -= n.width, k.y -= y ? 0 : n.height), c.placed = !0, c.alignAttr = k) : (y(f), c.align(b, void 0, f), k = c.alignAttr);
          z && 0 <= f.height ? this.justifyDataLabel(c, b, k, n, f, e) : d(b.crop, !0) && (x = m.isInsidePlot(k.x, k.y, {
            paneCoordinates: !0,
            series: g
          }) && m.isInsidePlot(k.x + n.width, k.y + n.height, {
            paneCoordinates: !0,
            series: g
          }));
          if (b.shape && !r) c[e ? "attr" : "animate"]({
            anchorX: h ? m.plotWidth - a.plotY : a.plotX,
            anchorY: h ? m.plotHeight - a.plotX : a.plotY
          });
        }
        e && l && (c.placed = !1);
        x || l && !z || (c.hide(!0), c.placed = !1);
      }
      function g(a, c) {
        var d = c.filter;
        return d ? (c = d.operator, a = a[d.property], d = d.value, ">" === c && a > d || "<" === c && a < d || ">=" === c && a >= d || "<=" === c && a <= d || "==" === c && a == d || "===" === c && a === d ? !0 : !1) : !0;
      }
      function r() {
        var b = this,
          c = b.chart,
          f = b.options,
          e = b.points,
          m = b.hasRendered || 0,
          q = c.renderer,
          n = f.dataLabels,
          r,
          x = n.animation;
        x = n.defer ? v(c, x, b) : {
          defer: 0,
          duration: 0
        };
        n = z(z(c.options.plotOptions && c.options.plotOptions.series && c.options.plotOptions.series.dataLabels, c.options.plotOptions && c.options.plotOptions[b.type] && c.options.plotOptions[b.type].dataLabels), n);
        k(this, "drawDataLabels");
        if (t(n) || n.enabled || b._hasPointLabels) {
          var p = b.plotGroup("dataLabelsGroup", "data-labels", m ? "inherit" : "hidden", n.zIndex || 6);
          p.attr({
            opacity: +m
          });
          !m && (m = b.dataLabelsGroup) && (b.visible && p.show(!0), m[f.animation ? "animate" : "attr"]({
            opacity: 1
          }, x));
          e.forEach(function (e) {
            r = a(z(n, e.dlOptions || e.options && e.options.dataLabels));
            r.forEach(function (a, m) {
              var l = a.enabled && (!e.isNull || e.dataLabelOnNull) && g(e, a),
                k = e.connectors ? e.connectors[m] : e.connector,
                n = e.dataLabels ? e.dataLabels[m] : e.dataLabel,
                r = d(a.distance, e.labelDistance),
                u = !n;
              if (l) {
                var t = e.getLabelConfig();
                var z = d(a[e.formatPrefix + "Format"], a.format);
                t = D(z) ? w(z, t, c) : (a[e.formatPrefix + "Formatter"] || a.formatter).call(t, a);
                z = a.style;
                var y = a.rotation;
                c.styledMode || (z.color = d(a.color, z.color, b.color, "#000000"), "contrast" === z.color ? (e.contrastColor = q.getContrast(e.color || b.color), z.color = !D(r) && a.inside || 0 > r || f.stacking ? e.contrastColor : "#000000") : delete e.contrastColor, f.cursor && (z.cursor = f.cursor));
                var x = {
                  r: a.borderRadius || 0,
                  rotation: y,
                  padding: a.padding,
                  zIndex: 1
                };
                c.styledMode || (x.fill = a.backgroundColor, x.stroke = a.borderColor, x["stroke-width"] = a.borderWidth);
                h(x, function (c, a) {
                  "undefined" === typeof c && delete x[a];
                });
              }
              !n || l && D(t) && !!n.div === !!a.useHTML || (e.dataLabel = n = e.dataLabel && e.dataLabel.destroy(), e.dataLabels && (1 === e.dataLabels.length ? delete e.dataLabels : delete e.dataLabels[m]), m || delete e.dataLabel, k && (e.connector = e.connector.destroy(), e.connectors && (1 === e.connectors.length ? delete e.connectors : delete e.connectors[m])));
              l && D(t) && (n ? x.text = t : (e.dataLabels = e.dataLabels || [], n = e.dataLabels[m] = y ? q.text(t, 0, -9999, a.useHTML).addClass("highcharts-data-label") : q.label(t, 0, -9999, a.shape, null, null, a.useHTML, null, "data-label"), m || (e.dataLabel = n), n.addClass(" highcharts-data-label-color-" + e.colorIndex + " " + (a.className || "") + (a.useHTML ? " highcharts-tracker" : ""))), n.options = a, n.attr(x), c.styledMode || n.css(z).shadow(a.shadow), n.added || n.add(p), a.textPath && !a.useHTML && (n.setTextPath(e.getDataLabelPath && e.getDataLabelPath(n) || e.graphic, a.textPath), e.dataLabelPath && !a.textPath.enabled && (e.dataLabelPath = e.dataLabelPath.destroy())), b.alignDataLabel(e, n, a, null, u));
            });
          });
        }
        k(this, "afterDrawDataLabels");
      }
      function q(a, c, d, b, f, e) {
        var g = this.chart,
          m = c.align,
          h = c.verticalAlign,
          l = a.box ? 0 : a.padding || 0,
          k = c.x;
        k = void 0 === k ? 0 : k;
        var n = c.y;
        n = void 0 === n ? 0 : n;
        var q = (d.x || 0) + l;
        if (0 > q) {
          "right" === m && 0 <= k ? (c.align = "left", c.inside = !0) : k -= q;
          var r = !0;
        }
        q = (d.x || 0) + b.width - l;
        q > g.plotWidth && ("left" === m && 0 >= k ? (c.align = "right", c.inside = !0) : k += g.plotWidth - q, r = !0);
        q = d.y + l;
        0 > q && ("bottom" === h && 0 <= n ? (c.verticalAlign = "top", c.inside = !0) : n -= q, r = !0);
        q = (d.y || 0) + b.height - l;
        q > g.plotHeight && ("top" === h && 0 >= n ? (c.verticalAlign = "bottom", c.inside = !0) : n += g.plotHeight - q, r = !0);
        r && (c.x = k, c.y = n, a.placed = !e, a.align(c, void 0, f));
        return r;
      }
      function z(a, c) {
        var d = [],
          b;
        if (t(a) && !t(c)) d = a.map(function (a) {
          return n(a, c);
        });else if (t(c) && !t(a)) d = c.map(function (c) {
          return n(a, c);
        });else if (t(a) || t(c)) for (b = Math.max(a.length, c.length); b--;) d[b] = n(a[b], c[b]);else d = n(a, c);
        return d;
      }
      function m(a, c, d, b, f) {
        var e = this.chart,
          g = e.inverted,
          m = this.xAxis,
          h = m.reversed,
          l = g ? c.height / 2 : c.width / 2;
        a = (a = a.pointWidth) ? a / 2 : 0;
        c.startXPos = g ? f.x : h ? -l - a : m.width - l + a;
        c.startYPos = g ? h ? this.yAxis.height - l + a : -l - a : f.y;
        b ? "hidden" === c.visibility && (c.show(), c.attr({
          opacity: 0
        }).animate({
          opacity: 1
        })) : c.attr({
          opacity: 1
        }).animate({
          opacity: 0
        }, void 0, c.hide);
        e.hasRendered && (d && c.attr({
          x: c.startXPos,
          y: c.startYPos
        }), c.placed = !0);
      }
      var f = [];
      b.compose = function (a) {
        if (-1 === f.indexOf(a)) {
          var c = a.prototype;
          f.push(a);
          c.alignDataLabel = e;
          c.drawDataLabels = r;
          c.justifyDataLabel = q;
          c.setDataLabelStartPos = m;
        }
      };
    })(e || (e = {}));
    "";
    return e;
  });
  G(b, "Series/Column/ColumnDataLabel.js", [b["Core/Series/DataLabel.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = p.series,
      w = A.merge,
      D = A.pick,
      B;
    (function (k) {
      function t(b, d, a, e, g) {
        var h = this.chart.inverted,
          k = b.series,
          n = (k.xAxis ? k.xAxis.len : this.chart.plotSizeX) || 0;
        k = (k.yAxis ? k.yAxis.len : this.chart.plotSizeY) || 0;
        var q = b.dlBox || b.shapeArgs,
          t = D(b.below, b.plotY > D(this.translatedThreshold, k)),
          m = D(a.inside, !!this.options.stacking);
        q && (e = w(q), 0 > e.y && (e.height += e.y, e.y = 0), q = e.y + e.height - k, 0 < q && q < e.height && (e.height -= q), h && (e = {
          x: k - e.y - e.height,
          y: n - e.x - e.width,
          width: e.height,
          height: e.width
        }), m || (h ? (e.x += t ? 0 : e.width, e.width = 0) : (e.y += t ? e.height : 0, e.height = 0)));
        a.align = D(a.align, !h || m ? "center" : t ? "right" : "left");
        a.verticalAlign = D(a.verticalAlign, h || m ? "middle" : t ? "top" : "bottom");
        v.prototype.alignDataLabel.call(this, b, d, a, e, g);
        a.inside && b.contrastColor && d.css({
          color: b.contrastColor
        });
      }
      var n = [];
      k.compose = function (h) {
        b.compose(v);
        -1 === n.indexOf(h) && (n.push(h), h.prototype.alignDataLabel = t);
      };
    })(B || (B = {}));
    return B;
  });
  G(b, "Series/Bar/BarSeries.js", [b["Series/Column/ColumnSeries.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = this && this.__extends || function () {
        var b = function (k, t) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (b, h) {
            b.__proto__ = h;
          } || function (b, h) {
            for (var d in h) h.hasOwnProperty(d) && (b[d] = h[d]);
          };
          return b(k, t);
        };
        return function (k, t) {
          function n() {
            this.constructor = k;
          }
          b(k, t);
          k.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());
        };
      }(),
      w = A.extend,
      D = A.merge;
    A = function (p) {
      function k() {
        var b = null !== p && p.apply(this, arguments) || this;
        b.data = void 0;
        b.options = void 0;
        b.points = void 0;
        return b;
      }
      v(k, p);
      k.defaultOptions = D(b.defaultOptions, {});
      return k;
    }(b);
    w(A.prototype, {
      inverted: !0
    });
    p.registerSeriesType("bar", A);
    "";
    return A;
  });
  G(b, "Series/Scatter/ScatterSeries.js", [b["Series/Column/ColumnSeries.js"], b["Series/Line/LineSeries.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E) {
    var v = this && this.__extends || function () {
        var b = function (k, h) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, a) {
            d.__proto__ = a;
          } || function (d, a) {
            for (var b in a) a.hasOwnProperty(b) && (d[b] = a[b]);
          };
          return b(k, h);
        };
        return function (k, h) {
          function d() {
            this.constructor = k;
          }
          b(k, h);
          k.prototype = null === h ? Object.create(h) : (d.prototype = h.prototype, new d());
        };
      }(),
      D = E.addEvent,
      B = E.extend,
      k = E.merge;
    E = function (b) {
      function n() {
        var h = null !== b && b.apply(this, arguments) || this;
        h.data = void 0;
        h.options = void 0;
        h.points = void 0;
        return h;
      }
      v(n, b);
      n.prototype.applyJitter = function () {
        var b = this,
          d = this.options.jitter,
          a = this.points.length;
        d && this.points.forEach(function (e, g) {
          ["x", "y"].forEach(function (h, k) {
            var n = "plot" + h.toUpperCase();
            if (d[h] && !e.isNull) {
              var q = b[h + "Axis"];
              var t = d[h] * q.transA;
              if (q && !q.isLog) {
                var m = Math.max(0, e[n] - t);
                q = Math.min(q.len, e[n] + t);
                k = 1E4 * Math.sin(g + k * a);
                e[n] = m + (q - m) * (k - Math.floor(k));
                "x" === h && (e.clientX = e.plotX);
              }
            }
          });
        });
      };
      n.prototype.drawGraph = function () {
        this.options.lineWidth ? b.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
      };
      n.defaultOptions = k(p.defaultOptions, {
        lineWidth: 0,
        findNearestPointBy: "xy",
        jitter: {
          x: 0,
          y: 0
        },
        marker: {
          enabled: !0
        },
        tooltip: {
          headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
          pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
        }
      });
      return n;
    }(p);
    B(E.prototype, {
      drawTracker: b.prototype.drawTracker,
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1
    });
    D(E, "afterTranslate", function () {
      this.applyJitter();
    });
    A.registerSeriesType("scatter", E);
    "";
    return E;
  });
  G(b, "Series/CenteredUtilities.js", [b["Core/Globals.js"], b["Core/Series/Series.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = b.deg2rad,
      w = A.isNumber,
      D = A.pick,
      B = A.relativeLength,
      k;
    (function (b) {
      b.getCenter = function () {
        var b = this.options,
          h = this.chart,
          d = 2 * (b.slicedOffset || 0),
          a = h.plotWidth - 2 * d,
          e = h.plotHeight - 2 * d,
          g = b.center,
          k = Math.min(a, e),
          t = b.size,
          r = b.innerSize || 0;
        "string" === typeof t && (t = parseFloat(t));
        "string" === typeof r && (r = parseFloat(r));
        b = [D(g[0], "50%"), D(g[1], "50%"), D(t && 0 > t ? void 0 : b.size, "100%"), D(r && 0 > r ? void 0 : b.innerSize || 0, "0%")];
        !h.angular || this instanceof p || (b[3] = 0);
        for (g = 0; 4 > g; ++g) t = b[g], h = 2 > g || 2 === g && /%$/.test(t), b[g] = B(t, [a, e, k, b[2]][g]) + (h ? d : 0);
        b[3] > b[2] && (b[3] = b[2]);
        return b;
      };
      b.getStartAndEndRadians = function (b, h) {
        b = w(b) ? b : 0;
        h = w(h) && h > b && 360 > h - b ? h : b + 360;
        return {
          start: v * (b + -90),
          end: v * (h + -90)
        };
      };
    })(k || (k = {}));
    "";
    return k;
  });
  G(b, "Series/Pie/PiePoint.js", [b["Core/Animation/AnimationUtilities.js"], b["Core/Series/Point.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = this && this.__extends || function () {
        var b = function (d, a) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var b in d) d.hasOwnProperty(b) && (a[b] = d[b]);
          };
          return b(d, a);
        };
        return function (d, a) {
          function e() {
            this.constructor = d;
          }
          b(d, a);
          d.prototype = null === a ? Object.create(a) : (e.prototype = a.prototype, new e());
        };
      }(),
      w = b.setAnimation,
      D = A.addEvent,
      B = A.defined;
    b = A.extend;
    var k = A.isNumber,
      t = A.pick,
      n = A.relativeLength;
    p = function (b) {
      function d() {
        var a = null !== b && b.apply(this, arguments) || this;
        a.labelDistance = void 0;
        a.options = void 0;
        a.series = void 0;
        return a;
      }
      v(d, b);
      d.prototype.getConnectorPath = function () {
        var a = this.labelPosition,
          d = this.series.options.dataLabels,
          b = this.connectorShapes,
          h = d.connectorShape;
        b[h] && (h = b[h]);
        return h.call(this, {
          x: a.final.x,
          y: a.final.y,
          alignment: a.alignment
        }, a.connectorPosition, d);
      };
      d.prototype.getTranslate = function () {
        return this.sliced ? this.slicedTranslation : {
          translateX: 0,
          translateY: 0
        };
      };
      d.prototype.haloPath = function (a) {
        var d = this.shapeArgs;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(d.x, d.y, d.r + a, d.r + a, {
          innerR: d.r - 1,
          start: d.start,
          end: d.end
        });
      };
      d.prototype.init = function () {
        var a = this;
        b.prototype.init.apply(this, arguments);
        this.name = t(this.name, "Slice");
        var d = function (d) {
          a.slice("select" === d.type);
        };
        D(this, "select", d);
        D(this, "unselect", d);
        return this;
      };
      d.prototype.isValid = function () {
        return k(this.y) && 0 <= this.y;
      };
      d.prototype.setVisible = function (a, d) {
        var b = this,
          e = this.series,
          h = e.chart,
          k = e.options.ignoreHiddenPoint;
        d = t(d, k);
        a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a, e.options.data[e.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (d) {
          if (b[d]) b[d][a ? "show" : "hide"](a);
        }), this.legendItem && h.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""), k && (e.isDirty = !0), d && h.redraw());
      };
      d.prototype.slice = function (a, d, b) {
        var e = this.series;
        w(b, e.chart);
        t(d, !0);
        this.sliced = this.options.sliced = B(a) ? a : !this.sliced;
        e.options.data[e.data.indexOf(this)] = this.options;
        this.graphic && this.graphic.animate(this.getTranslate());
        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
      };
      return d;
    }(p);
    b(p.prototype, {
      connectorShapes: {
        fixedOffset: function (b, d, a) {
          var e = d.breakAt;
          d = d.touchingSliceAt;
          return [["M", b.x, b.y], a.softConnector ? ["C", b.x + ("left" === b.alignment ? -5 : 5), b.y, 2 * e.x - d.x, 2 * e.y - d.y, e.x, e.y] : ["L", e.x, e.y], ["L", d.x, d.y]];
        },
        straight: function (b, d) {
          d = d.touchingSliceAt;
          return [["M", b.x, b.y], ["L", d.x, d.y]];
        },
        crookedLine: function (b, d, a) {
          d = d.touchingSliceAt;
          var e = this.series,
            g = e.center[0],
            h = e.chart.plotWidth,
            k = e.chart.plotLeft;
          e = b.alignment;
          var r = this.shapeArgs.r;
          a = n(a.crookDistance, 1);
          h = "left" === e ? g + r + (h + k - g - r) * (1 - a) : k + (g - r) * a;
          a = ["L", h, b.y];
          g = !0;
          if ("left" === e ? h > b.x || h < d.x : h < b.x || h > d.x) g = !1;
          b = [["M", b.x, b.y]];
          g && b.push(a);
          b.push(["L", d.x, d.y]);
          return b;
        }
      }
    });
    return p;
  });
  G(b, "Series/Pie/PieSeries.js", [b["Series/CenteredUtilities.js"], b["Series/Column/ColumnSeries.js"], b["Core/Globals.js"], b["Core/Legend/LegendSymbol.js"], b["Series/Pie/PiePoint.js"], b["Core/Series/Series.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Renderer/SVG/Symbols.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D, B, k, t) {
    var n = this && this.__extends || function () {
        var a = function (d, b) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var b in d) d.hasOwnProperty(b) && (a[b] = d[b]);
          };
          return a(d, b);
        };
        return function (d, b) {
          function e() {
            this.constructor = d;
          }
          a(d, b);
          d.prototype = null === b ? Object.create(b) : (e.prototype = b.prototype, new e());
        };
      }(),
      h = b.getStartAndEndRadians;
    A = A.noop;
    var d = t.clamp,
      a = t.extend,
      e = t.fireEvent,
      g = t.merge,
      x = t.pick,
      v = t.relativeLength;
    t = function (a) {
      function b() {
        var d = null !== a && a.apply(this, arguments) || this;
        d.center = void 0;
        d.data = void 0;
        d.maxLabelDistance = void 0;
        d.options = void 0;
        d.points = void 0;
        return d;
      }
      n(b, a);
      b.prototype.animate = function (a) {
        var d = this,
          b = d.points,
          e = d.startAngleRad;
        a || b.forEach(function (c) {
          var a = c.graphic,
            b = c.shapeArgs;
          a && b && (a.attr({
            r: x(c.startR, d.center && d.center[3] / 2),
            start: e,
            end: e
          }), a.animate({
            r: b.r,
            start: b.start,
            end: b.end
          }, d.options.animation));
        });
      };
      b.prototype.drawEmpty = function () {
        var a = this.startAngleRad,
          d = this.endAngleRad,
          b = this.options;
        if (0 === this.total && this.center) {
          var e = this.center[0];
          var c = this.center[1];
          this.graph || (this.graph = this.chart.renderer.arc(e, c, this.center[1] / 2, 0, a, d).addClass("highcharts-empty-series").add(this.group));
          this.graph.attr({
            d: k.arc(e, c, this.center[2] / 2, 0, {
              start: a,
              end: d,
              innerR: this.center[3] / 2
            })
          });
          this.chart.styledMode || this.graph.attr({
            "stroke-width": b.borderWidth,
            fill: b.fillColor || "none",
            stroke: b.color || "#cccccc"
          });
        } else this.graph && (this.graph = this.graph.destroy());
      };
      b.prototype.drawPoints = function () {
        var a = this.chart.renderer;
        this.points.forEach(function (d) {
          d.graphic && d.hasNewShapeType() && (d.graphic = d.graphic.destroy());
          d.graphic || (d.graphic = a[d.shapeType](d.shapeArgs).add(d.series.group), d.delayedRendering = !0);
        });
      };
      b.prototype.generatePoints = function () {
        a.prototype.generatePoints.call(this);
        this.updateTotals();
      };
      b.prototype.getX = function (a, b, f) {
        var e = this.center,
          c = this.radii ? this.radii[f.index] || 0 : e[2] / 2;
        a = Math.asin(d((a - e[1]) / (c + f.labelDistance), -1, 1));
        return e[0] + (b ? -1 : 1) * Math.cos(a) * (c + f.labelDistance) + (0 < f.labelDistance ? (b ? -1 : 1) * this.options.dataLabels.padding : 0);
      };
      b.prototype.hasData = function () {
        return !!this.processedXData.length;
      };
      b.prototype.redrawPoints = function () {
        var a = this,
          d = a.chart,
          b = d.renderer,
          e = a.options.shadow,
          c,
          h,
          l,
          k;
        this.drawEmpty();
        !e || a.shadowGroup || d.styledMode || (a.shadowGroup = b.g("shadow").attr({
          zIndex: -1
        }).add(a.group));
        a.points.forEach(function (f) {
          var m = {};
          h = f.graphic;
          if (!f.isNull && h) {
            var n = void 0;
            k = f.shapeArgs;
            c = f.getTranslate();
            d.styledMode || (n = f.shadowGroup, e && !n && (n = f.shadowGroup = b.g("shadow").add(a.shadowGroup)), n && n.attr(c), l = a.pointAttribs(f, f.selected && "select"));
            f.delayedRendering ? (h.setRadialReference(a.center).attr(k).attr(c), d.styledMode || h.attr(l).attr({
              "stroke-linejoin": "round"
            }).shadow(e, n), f.delayedRendering = !1) : (h.setRadialReference(a.center), d.styledMode || g(!0, m, l), g(!0, m, k, c), h.animate(m));
            h.attr({
              visibility: f.visible ? "inherit" : "hidden"
            });
            h.addClass(f.getClassName(), !0);
          } else h && (f.graphic = h.destroy());
        });
      };
      b.prototype.sortByAngle = function (a, d) {
        a.sort(function (a, b) {
          return "undefined" !== typeof a.angle && (b.angle - a.angle) * d;
        });
      };
      b.prototype.translate = function (a) {
        this.generatePoints();
        var d = this.options,
          b = d.slicedOffset,
          g = b + (d.borderWidth || 0),
          c = h(d.startAngle, d.endAngle),
          k = this.startAngleRad = c.start;
        c = (this.endAngleRad = c.end) - k;
        var l = this.points,
          n = d.dataLabels.distance;
        d = d.ignoreHiddenPoint;
        var q = l.length,
          r,
          t = 0;
        a || (this.center = a = this.getCenter());
        for (r = 0; r < q; r++) {
          var z = l[r];
          var p = k + t * c;
          !z.isValid() || d && !z.visible || (t += z.percentage / 100);
          var C = k + t * c;
          var w = {
            x: a[0],
            y: a[1],
            r: a[2] / 2,
            innerR: a[3] / 2,
            start: Math.round(1E3 * p) / 1E3,
            end: Math.round(1E3 * C) / 1E3
          };
          z.shapeType = "arc";
          z.shapeArgs = w;
          z.labelDistance = x(z.options.dataLabels && z.options.dataLabels.distance, n);
          z.labelDistance = v(z.labelDistance, w.r);
          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, z.labelDistance);
          C = (C + p) / 2;
          C > 1.5 * Math.PI ? C -= 2 * Math.PI : C < -Math.PI / 2 && (C += 2 * Math.PI);
          z.slicedTranslation = {
            translateX: Math.round(Math.cos(C) * b),
            translateY: Math.round(Math.sin(C) * b)
          };
          w = Math.cos(C) * a[2] / 2;
          var B = Math.sin(C) * a[2] / 2;
          z.tooltipPos = [a[0] + .7 * w, a[1] + .7 * B];
          z.half = C < -Math.PI / 2 || C > Math.PI / 2 ? 1 : 0;
          z.angle = C;
          p = Math.min(g, z.labelDistance / 5);
          z.labelPosition = {
            natural: {
              x: a[0] + w + Math.cos(C) * z.labelDistance,
              y: a[1] + B + Math.sin(C) * z.labelDistance
            },
            "final": {},
            alignment: 0 > z.labelDistance ? "center" : z.half ? "right" : "left",
            connectorPosition: {
              breakAt: {
                x: a[0] + w + Math.cos(C) * p,
                y: a[1] + B + Math.sin(C) * p
              },
              touchingSliceAt: {
                x: a[0] + w,
                y: a[1] + B
              }
            }
          };
        }
        e(this, "afterTranslate");
      };
      b.prototype.updateTotals = function () {
        var a = this.points,
          d = a.length,
          b = this.options.ignoreHiddenPoint,
          e,
          c = 0;
        for (e = 0; e < d; e++) {
          var g = a[e];
          !g.isValid() || b && !g.visible || (c += g.y);
        }
        this.total = c;
        for (e = 0; e < d; e++) g = a[e], g.percentage = 0 < c && (g.visible || !b) ? g.y / c * 100 : 0, g.total = c;
      };
      b.defaultOptions = g(D.defaultOptions, {
        center: [null, null],
        clip: !1,
        colorByPoint: !0,
        dataLabels: {
          allowOverlap: !0,
          connectorPadding: 5,
          connectorShape: "fixedOffset",
          crookDistance: "70%",
          distance: 30,
          enabled: !0,
          formatter: function () {
            return this.point.isNull ? void 0 : this.point.name;
          },
          softConnector: !0,
          x: 0
        },
        fillColor: void 0,
        ignoreHiddenPoint: !0,
        inactiveOtherPoints: !0,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: !1,
        slicedOffset: 10,
        stickyTracking: !1,
        tooltip: {
          followPointer: !0
        },
        borderColor: "#ffffff",
        borderWidth: 1,
        lineWidth: void 0,
        states: {
          hover: {
            brightness: .1
          }
        }
      });
      return b;
    }(D);
    a(t.prototype, {
      axisTypes: [],
      directTouch: !0,
      drawGraph: void 0,
      drawLegendSymbol: E.drawRectangle,
      drawTracker: p.prototype.drawTracker,
      getCenter: b.getCenter,
      getSymbol: A,
      isCartesian: !1,
      noSharedTooltip: !0,
      pointAttribs: p.prototype.pointAttribs,
      pointClass: w,
      requireSorting: !1,
      searchPoint: A,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    B.registerSeriesType("pie", t);
    "";
    return t;
  });
  G(b, "Series/Pie/PieDataLabel.js", [b["Core/Series/DataLabel.js"], b["Core/Globals.js"], b["Core/Renderer/RendererUtilities.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E, w) {
    var v = p.noop,
      B = A.distribute,
      k = E.series,
      t = w.arrayMax,
      n = w.clamp,
      h = w.defined,
      d = w.merge,
      a = w.pick,
      e = w.relativeLength,
      g;
    (function (g) {
      function x() {
        var b = this,
          e = b.data,
          c = b.chart,
          g = b.options.dataLabels || {},
          m = g.connectorPadding,
          n = c.plotWidth,
          q = c.plotHeight,
          r = c.plotLeft,
          z = Math.round(c.chartWidth / 3),
          x = b.center,
          p = x[2] / 2,
          v = x[1],
          C = [[], []],
          w = [0, 0, 0, 0],
          A = b.dataLabelPositioners,
          D,
          E,
          G,
          L,
          W,
          M,
          X,
          P,
          U,
          S,
          V,
          N;
        b.visible && (g.enabled || b._hasPointLabels) && (e.forEach(function (c) {
          c.dataLabel && c.visible && c.dataLabel.shortened && (c.dataLabel.attr({
            width: "auto"
          }).css({
            width: "auto",
            textOverflow: "clip"
          }), c.dataLabel.shortened = !1);
        }), k.prototype.drawDataLabels.apply(b), e.forEach(function (c) {
          c.dataLabel && (c.visible ? (C[c.half].push(c), c.dataLabel._pos = null, !h(g.style.width) && !h(c.options.dataLabels && c.options.dataLabels.style && c.options.dataLabels.style.width) && c.dataLabel.getBBox().width > z && (c.dataLabel.css({
            width: Math.round(.7 * z) + "px"
          }), c.dataLabel.shortened = !0)) : (c.dataLabel = c.dataLabel.destroy(), c.dataLabels && 1 === c.dataLabels.length && delete c.dataLabels));
        }), C.forEach(function (d, f) {
          var e = d.length,
            l = [],
            k;
          if (e) {
            b.sortByAngle(d, f - .5);
            if (0 < b.maxLabelDistance) {
              var u = Math.max(0, v - p - b.maxLabelDistance);
              var t = Math.min(v + p + b.maxLabelDistance, c.plotHeight);
              d.forEach(function (a) {
                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, v - p - a.labelDistance), a.bottom = Math.min(v + p + a.labelDistance, c.plotHeight), k = a.dataLabel.getBBox().height || 21, a.distributeBox = {
                  target: a.labelPosition.natural.y - a.top + k / 2,
                  size: k,
                  rank: a.y
                }, l.push(a.distributeBox));
              });
              u = t + k - u;
              B(l, u, u / 5);
            }
            for (V = 0; V < e; V++) {
              D = d[V];
              M = D.labelPosition;
              L = D.dataLabel;
              S = !1 === D.visible ? "hidden" : "inherit";
              U = u = M.natural.y;
              l && h(D.distributeBox) && ("undefined" === typeof D.distributeBox.pos ? S = "hidden" : (X = D.distributeBox.size, U = A.radialDistributionY(D)));
              delete D.positionIndex;
              if (g.justify) P = A.justify(D, p, x);else switch (g.alignTo) {
                case "connectors":
                  P = A.alignToConnectors(d, f, n, r);
                  break;
                case "plotEdges":
                  P = A.alignToPlotEdges(L, f, n, r);
                  break;
                default:
                  P = A.radialDistributionX(b, D, U, u);
              }
              L._attr = {
                visibility: S,
                align: M.alignment
              };
              N = D.options.dataLabels || {};
              L._pos = {
                x: P + a(N.x, g.x) + ({
                  left: m,
                  right: -m
                }[M.alignment] || 0),
                y: U + a(N.y, g.y) - 10
              };
              M.final.x = P;
              M.final.y = U;
              a(g.crop, !0) && (W = L.getBBox().width, u = null, P - W < m && 1 === f ? (u = Math.round(W - P + m), w[3] = Math.max(u, w[3])) : P + W > n - m && 0 === f && (u = Math.round(P + W - n + m), w[1] = Math.max(u, w[1])), 0 > U - X / 2 ? w[0] = Math.max(Math.round(-U + X / 2), w[0]) : U + X / 2 > q && (w[2] = Math.max(Math.round(U + X / 2 - q), w[2])), L.sideOverflow = u);
            }
          }
        }), 0 === t(w) || this.verifyDataLabelOverflow(w)) && (this.placeDataLabels(), this.points.forEach(function (f) {
          N = d(g, f.options.dataLabels);
          if (E = a(N.connectorWidth, 1)) {
            var e;
            G = f.connector;
            if ((L = f.dataLabel) && L._pos && f.visible && 0 < f.labelDistance) {
              S = L._attr.visibility;
              if (e = !G) f.connector = G = c.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + f.colorIndex + (f.className ? " " + f.className : "")).add(b.dataLabelsGroup), c.styledMode || G.attr({
                "stroke-width": E,
                stroke: N.connectorColor || f.color || "#666666"
              });
              G[e ? "attr" : "animate"]({
                d: f.getConnectorPath()
              });
              G.attr("visibility", S);
            } else G && (f.connector = G.destroy());
          }
        }));
      }
      function r() {
        this.points.forEach(function (a) {
          var d = a.dataLabel,
            c;
          d && a.visible && ((c = d._pos) ? (d.sideOverflow && (d._attr.width = Math.max(d.getBBox().width - d.sideOverflow, 0), d.css({
            width: d._attr.width + "px",
            textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
          }), d.shortened = !0), d.attr(d._attr), d[d.moved ? "animate" : "attr"](c), d.moved = !0) : d && d.attr({
            y: -9999
          }));
          delete a.distributeBox;
        }, this);
      }
      function q(a) {
        var d = this.center,
          c = this.options,
          b = c.center,
          f = c.minSize || 80,
          g = null !== c.size;
        if (!g) {
          if (null !== b[0]) var m = Math.max(d[2] - Math.max(a[1], a[3]), f);else m = Math.max(d[2] - a[1] - a[3], f), d[0] += (a[3] - a[1]) / 2;
          null !== b[1] ? m = n(m, f, d[2] - Math.max(a[0], a[2])) : (m = n(m, f, d[2] - a[0] - a[2]), d[1] += (a[0] - a[2]) / 2);
          m < d[2] ? (d[2] = m, d[3] = Math.min(e(c.innerSize || 0, m), m), this.translate(d), this.drawDataLabels && this.drawDataLabels()) : g = !0;
        }
        return g;
      }
      var z = [],
        m = {
          radialDistributionY: function (a) {
            return a.top + a.distributeBox.pos;
          },
          radialDistributionX: function (a, d, c, b) {
            return a.getX(c < d.top + 2 || c > d.bottom - 2 ? b : c, d.half, d);
          },
          justify: function (a, d, c) {
            return c[0] + (a.half ? -1 : 1) * (d + a.labelDistance);
          },
          alignToPlotEdges: function (a, d, c, b) {
            a = a.getBBox().width;
            return d ? a + b : c - a - b;
          },
          alignToConnectors: function (a, d, c, b) {
            var f = 0,
              e;
            a.forEach(function (c) {
              e = c.dataLabel.getBBox().width;
              e > f && (f = e);
            });
            return d ? f + b : c - f - b;
          }
        };
      g.compose = function (a) {
        b.compose(k);
        -1 === z.indexOf(a) && (z.push(a), a = a.prototype, a.dataLabelPositioners = m, a.alignDataLabel = v, a.drawDataLabels = x, a.placeDataLabels = r, a.verifyDataLabelOverflow = q);
      };
    })(g || (g = {}));
    return g;
  });
  G(b, "Extensions/OverlappingDataLabels.js", [b["Core/Chart/Chart.js"], b["Core/Utilities.js"]], function (b, p) {
    function v(b, h) {
      var d = !1;
      if (b) {
        var a = b.newOpacity;
        b.oldOpacity !== a && (b.alignAttr && b.placed ? (b[a ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), d = !0, b.alignAttr.opacity = a, b[b.isOld ? "animate" : "attr"](b.alignAttr, null, function () {
          h.styledMode || b.css({
            pointerEvents: a ? "auto" : "none"
          });
        }), w(h, "afterHideOverlappingLabel")) : b.attr({
          opacity: a
        }));
        b.isOld = !0;
      }
      return d;
    }
    var E = p.addEvent,
      w = p.fireEvent,
      D = p.isArray,
      B = p.isNumber,
      k = p.objectEach,
      t = p.pick;
    E(b, "render", function () {
      var b = this,
        h = [];
      (this.labelCollectors || []).forEach(function (d) {
        h = h.concat(d());
      });
      (this.yAxis || []).forEach(function (d) {
        d.stacking && d.options.stackLabels && !d.options.stackLabels.allowOverlap && k(d.stacking.stacks, function (a) {
          k(a, function (a) {
            a.label && "hidden" !== a.label.visibility && h.push(a.label);
          });
        });
      });
      (this.series || []).forEach(function (d) {
        var a = d.options.dataLabels;
        d.visible && (!1 !== a.enabled || d._hasPointLabels) && (a = function (a) {
          return a.forEach(function (a) {
            a.visible && (D(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : []).forEach(function (d) {
              var e = d.options;
              d.labelrank = t(e.labelrank, a.labelrank, a.shapeArgs && a.shapeArgs.height);
              e.allowOverlap ? (d.oldOpacity = d.opacity, d.newOpacity = 1, v(d, b)) : h.push(d);
            });
          });
        }, a(d.nodes || []), a(d.points));
      });
      this.hideOverlappingLabels(h);
    });
    b.prototype.hideOverlappingLabels = function (b) {
      var h = this,
        d = b.length,
        a = h.renderer,
        e,
        g,
        k,
        n = !1;
      var r = function (d) {
        var b,
          e = d.box ? 0 : d.padding || 0,
          c = b = 0,
          g;
        if (d && (!d.alignAttr || d.placed)) {
          var m = d.alignAttr || {
            x: d.attr("x"),
            y: d.attr("y")
          };
          var h = d.parentGroup;
          d.width || (b = d.getBBox(), d.width = b.width, d.height = b.height, b = a.fontMetrics(null, d.element).h);
          var k = d.width - 2 * e;
          (g = {
            left: "0",
            center: "0.5",
            right: "1"
          }[d.alignValue]) ? c = +g * k : B(d.x) && Math.round(d.x) !== d.translateX && (c = d.x - d.translateX);
          return {
            x: m.x + (h.translateX || 0) + e - (c || 0),
            y: m.y + (h.translateY || 0) + e - b,
            width: d.width - 2 * e,
            height: d.height - 2 * e
          };
        }
      };
      for (g = 0; g < d; g++) if (e = b[g]) e.oldOpacity = e.opacity, e.newOpacity = 1, e.absoluteBox = r(e);
      b.sort(function (a, d) {
        return (d.labelrank || 0) - (a.labelrank || 0);
      });
      for (g = 0; g < d; g++) {
        var q = (r = b[g]) && r.absoluteBox;
        for (e = g + 1; e < d; ++e) {
          var t = (k = b[e]) && k.absoluteBox;
          !q || !t || r === k || 0 === r.newOpacity || 0 === k.newOpacity || t.x >= q.x + q.width || t.x + t.width <= q.x || t.y >= q.y + q.height || t.y + t.height <= q.y || ((r.labelrank < k.labelrank ? r : k).newOpacity = 0);
        }
      }
      b.forEach(function (a) {
        v(a, h) && (n = !0);
      });
      n && w(h, "afterHideAllOverlappingLabels");
    };
  });
  G(b, "Core/Responsive.js", [b["Core/Utilities.js"]], function (b) {
    var p = b.extend,
      v = b.find,
      E = b.isArray,
      w = b.isObject,
      D = b.merge,
      B = b.objectEach,
      k = b.pick,
      t = b.splat,
      n = b.uniqueKey,
      h;
    (function (d) {
      var a = [];
      d.compose = function (d) {
        -1 === a.indexOf(d) && (a.push(d), p(d.prototype, b.prototype));
        return d;
      };
      var b = function () {
        function a() {}
        a.prototype.currentOptions = function (a) {
          function d(a, e, f, g) {
            var c;
            B(a, function (a, h) {
              if (!g && -1 < b.collectionsWithUpdate.indexOf(h) && e[h]) for (a = t(a), f[h] = [], c = 0; c < Math.max(a.length, e[h].length); c++) e[h][c] && (void 0 === a[c] ? f[h][c] = e[h][c] : (f[h][c] = {}, d(a[c], e[h][c], f[h][c], g + 1)));else w(a) ? (f[h] = E(a) ? [] : {}, d(a, e[h] || {}, f[h], g + 1)) : f[h] = "undefined" === typeof e[h] ? null : e[h];
            });
          }
          var b = this,
            e = {};
          d(a, this.options, e, 0);
          return e;
        };
        a.prototype.matchResponsiveRule = function (a, d) {
          var b = a.condition;
          (b.callback || function () {
            return this.chartWidth <= k(b.maxWidth, Number.MAX_VALUE) && this.chartHeight <= k(b.maxHeight, Number.MAX_VALUE) && this.chartWidth >= k(b.minWidth, 0) && this.chartHeight >= k(b.minHeight, 0);
          }).call(this) && d.push(a._id);
        };
        a.prototype.setResponsive = function (a, d) {
          var b = this,
            e = this.options.responsive,
            g = this.currentResponsive,
            h = [];
          !d && e && e.rules && e.rules.forEach(function (a) {
            "undefined" === typeof a._id && (a._id = n());
            b.matchResponsiveRule(a, h);
          }, this);
          d = D.apply(void 0, h.map(function (a) {
            return v((e || {}).rules || [], function (d) {
              return d._id === a;
            });
          }).map(function (a) {
            return a && a.chartOptions;
          }));
          d.isResponsiveOptions = !0;
          h = h.toString() || void 0;
          h !== (g && g.ruleIds) && (g && this.update(g.undoOptions, a, !0), h ? (g = this.currentOptions(d), g.isResponsiveOptions = !0, this.currentResponsive = {
            ruleIds: h,
            mergedOptions: d,
            undoOptions: g
          }, this.update(d, a, !0)) : this.currentResponsive = void 0);
        };
        return a;
      }();
    })(h || (h = {}));
    "";
    "";
    return h;
  });
  G(b, "masters/highcharts.src.js", [b["Core/Globals.js"], b["Core/Utilities.js"], b["Core/DefaultOptions.js"], b["Core/Animation/Fx.js"], b["Core/Animation/AnimationUtilities.js"], b["Core/Renderer/HTML/AST.js"], b["Core/FormatUtilities.js"], b["Core/Renderer/RendererUtilities.js"], b["Core/Renderer/SVG/SVGElement.js"], b["Core/Renderer/SVG/SVGRenderer.js"], b["Core/Renderer/HTML/HTMLElement.js"], b["Core/Renderer/HTML/HTMLRenderer.js"], b["Core/Axis/Axis.js"], b["Core/Axis/DateTimeAxis.js"], b["Core/Axis/LogarithmicAxis.js"], b["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], b["Core/Axis/Tick.js"], b["Core/Tooltip.js"], b["Core/Series/Point.js"], b["Core/Pointer.js"], b["Core/MSPointer.js"], b["Core/Legend/Legend.js"], b["Core/Chart/Chart.js"], b["Core/Series/Series.js"], b["Core/Series/SeriesRegistry.js"], b["Series/Column/ColumnSeries.js"], b["Series/Column/ColumnDataLabel.js"], b["Series/Pie/PieSeries.js"], b["Series/Pie/PieDataLabel.js"], b["Core/Series/DataLabel.js"], b["Core/Responsive.js"], b["Core/Color/Color.js"], b["Core/Time.js"]], function (b, p, A, E, w, D, B, k, t, n, h, d, a, e, g, x, C, r, q, z, m, f, y, c, u, l, F, K, H, I, G, Q, O) {
    b.animate = w.animate;
    b.animObject = w.animObject;
    b.getDeferredAnimation = w.getDeferredAnimation;
    b.setAnimation = w.setAnimation;
    b.stop = w.stop;
    b.timers = E.timers;
    b.AST = D;
    b.Axis = a;
    b.Chart = y;
    b.chart = y.chart;
    b.Fx = E;
    b.Legend = f;
    b.PlotLineOrBand = x;
    b.Point = q;
    b.Pointer = m.isRequired() ? m : z;
    b.Series = c;
    b.SVGElement = t;
    b.SVGRenderer = n;
    b.Tick = C;
    b.Time = O;
    b.Tooltip = r;
    b.Color = Q;
    b.color = Q.parse;
    d.compose(n);
    h.compose(t);
    b.defaultOptions = A.defaultOptions;
    b.getOptions = A.getOptions;
    b.time = A.defaultTime;
    b.setOptions = A.setOptions;
    b.dateFormat = B.dateFormat;
    b.format = B.format;
    b.numberFormat = B.numberFormat;
    b.addEvent = p.addEvent;
    b.arrayMax = p.arrayMax;
    b.arrayMin = p.arrayMin;
    b.attr = p.attr;
    b.clearTimeout = p.clearTimeout;
    b.correctFloat = p.correctFloat;
    b.createElement = p.createElement;
    b.css = p.css;
    b.defined = p.defined;
    b.destroyObjectProperties = p.destroyObjectProperties;
    b.discardElement = p.discardElement;
    b.distribute = k.distribute;
    b.erase = p.erase;
    b.error = p.error;
    b.extend = p.extend;
    b.extendClass = p.extendClass;
    b.find = p.find;
    b.fireEvent = p.fireEvent;
    b.getMagnitude = p.getMagnitude;
    b.getStyle = p.getStyle;
    b.inArray = p.inArray;
    b.isArray = p.isArray;
    b.isClass = p.isClass;
    b.isDOMElement = p.isDOMElement;
    b.isFunction = p.isFunction;
    b.isNumber = p.isNumber;
    b.isObject = p.isObject;
    b.isString = p.isString;
    b.keys = p.keys;
    b.merge = p.merge;
    b.normalizeTickInterval = p.normalizeTickInterval;
    b.objectEach = p.objectEach;
    b.offset = p.offset;
    b.pad = p.pad;
    b.pick = p.pick;
    b.pInt = p.pInt;
    b.relativeLength = p.relativeLength;
    b.removeEvent = p.removeEvent;
    b.seriesType = u.seriesType;
    b.splat = p.splat;
    b.stableSort = p.stableSort;
    b.syncTimeout = p.syncTimeout;
    b.timeUnits = p.timeUnits;
    b.uniqueKey = p.uniqueKey;
    b.useSerialIds = p.useSerialIds;
    b.wrap = p.wrap;
    F.compose(l);
    I.compose(c);
    e.compose(a);
    g.compose(a);
    H.compose(K);
    x.compose(a);
    G.compose(y);
    return b;
  });
  G(b, "Core/Axis/Color/ColorAxisComposition.js", [b["Core/Color/Color.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = b.parse,
      E = p.addEvent,
      w = p.extend,
      D = p.merge,
      B = p.pick,
      k = p.splat,
      t;
    (function (b) {
      function h() {
        var a = this,
          d = this.options;
        this.colorAxis = [];
        d.colorAxis && (d.colorAxis = k(d.colorAxis), d.colorAxis.forEach(function (c, d) {
          c.index = d;
          new p(a, c);
        }));
      }
      function d(a) {
        var c = this,
          d = function (d) {
            d = a.allItems.indexOf(d);
            -1 !== d && (c.destroyItem(a.allItems[d]), a.allItems.splice(d, 1));
          },
          b = [],
          f,
          e;
        (this.chart.colorAxis || []).forEach(function (a) {
          (f = a.options) && f.showInLegend && (f.dataClasses && f.visible ? b = b.concat(a.getDataClassLegendSymbols()) : f.visible && b.push(a), a.series.forEach(function (a) {
            if (!a.options.showInLegend || f.dataClasses) "point" === a.options.legendType ? a.points.forEach(function (a) {
              d(a);
            }) : d(a);
          }));
        });
        for (e = b.length; e--;) a.allItems.unshift(b[e]);
      }
      function a(a) {
        a.visible && a.item.legendColor && a.item.legendSymbol.attr({
          fill: a.item.legendColor
        });
      }
      function e() {
        var a = this.chart.colorAxis;
        a && a.forEach(function (a, c, d) {
          a.update({}, d);
        });
      }
      function g() {
        (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();
      }
      function n() {
        var a = this.axisTypes;
        a ? -1 === a.indexOf("colorAxis") && a.push("colorAxis") : this.axisTypes = ["colorAxis"];
      }
      function t(a) {
        var c = this,
          d = a ? "show" : "hide";
        c.visible = c.options.visible = !!a;
        ["graphic", "dataLabel"].forEach(function (a) {
          if (c[a]) c[a][d]();
        });
        this.series.buildKDTree();
      }
      function r() {
        var a = this,
          d = this.options.nullColor,
          b = this.colorAxis,
          f = this.colorKey;
        (this.data.length ? this.data : this.points).forEach(function (c) {
          var e = c.getNestedProperty(f);
          (e = c.options.color || (c.isNull || null === c.value ? d : b && "undefined" !== typeof e ? b.toColor(e, c) : c.color || a.color)) && c.color !== e && (c.color = e, "point" === a.options.legendType && c.legendItem && a.chart.legend.colorizeItem(c, c.visible));
        });
      }
      function q(a) {
        var c = a.prototype.createAxis;
        a.prototype.createAxis = function (a, d) {
          if ("colorAxis" !== a) return c.apply(this, arguments);
          var b = new p(this, D(d.axis, {
            index: this[a].length,
            isX: !1
          }));
          this.isDirtyLegend = !0;
          this.axes.forEach(function (a) {
            a.series = [];
          });
          this.series.forEach(function (a) {
            a.bindAxes();
            a.isDirtyData = !0;
          });
          B(d.redraw, !0) && this.redraw(d.animation);
          return b;
        };
      }
      function z() {
        this.elem.attr("fill", v(this.start).tweenTo(v(this.end), this.pos), void 0, !0);
      }
      function m() {
        this.elem.attr("stroke", v(this.start).tweenTo(v(this.end), this.pos), void 0, !0);
      }
      var f = [],
        p;
      b.compose = function (c, b, k, x, y) {
        p || (p = c);
        -1 === f.indexOf(b) && (f.push(b), c = b.prototype, c.collectionsWithUpdate.push("colorAxis"), c.collectionsWithInit.colorAxis = [c.addColorAxis], E(b, "afterGetAxes", h), q(b));
        -1 === f.indexOf(k) && (f.push(k), b = k.prototype, b.fillSetter = z, b.strokeSetter = m);
        -1 === f.indexOf(x) && (f.push(x), E(x, "afterGetAllItems", d), E(x, "afterColorizeItem", a), E(x, "afterUpdate", e));
        -1 === f.indexOf(y) && (f.push(y), w(y.prototype, {
          optionalAxis: "colorAxis",
          translateColors: r
        }), w(y.prototype.pointClass.prototype, {
          setVisible: t
        }), E(y, "afterTranslate", g), E(y, "bindAxes", n));
      };
      b.pointSetVisible = t;
    })(t || (t = {}));
    return t;
  });
  G(b, "Core/Axis/Color/ColorAxisDefaults.js", [], function () {
    return {
      lineWidth: 0,
      minPadding: 0,
      maxPadding: 0,
      gridLineWidth: 1,
      tickPixelInterval: 72,
      startOnTick: !0,
      endOnTick: !0,
      offset: 0,
      marker: {
        animation: {
          duration: 50
        },
        width: .01,
        color: "#999999"
      },
      labels: {
        overflow: "justify",
        rotation: 0
      },
      minColor: "#e6ebf5",
      maxColor: "#003399",
      tickLength: 5,
      showInLegend: !0
    };
  });
  G(b, "Core/Axis/Color/ColorAxis.js", [b["Core/Axis/Axis.js"], b["Core/Color/Color.js"], b["Core/Axis/Color/ColorAxisComposition.js"], b["Core/Axis/Color/ColorAxisDefaults.js"], b["Core/Globals.js"], b["Core/Legend/LegendSymbol.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D, B, k) {
    var t = this && this.__extends || function () {
        var a = function (d, b) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var b in d) d.hasOwnProperty(b) && (a[b] = d[b]);
          };
          return a(d, b);
        };
        return function (d, b) {
          function e() {
            this.constructor = d;
          }
          a(d, b);
          d.prototype = null === b ? Object.create(b) : (e.prototype = b.prototype, new e());
        };
      }(),
      n = p.parse,
      h = w.noop,
      d = B.series,
      a = k.extend,
      e = k.isNumber,
      g = k.merge,
      x = k.pick;
    p = function (b) {
      function k(a, d) {
        var e = b.call(this, a, d) || this;
        e.beforePadding = !1;
        e.chart = void 0;
        e.coll = "colorAxis";
        e.dataClasses = void 0;
        e.legendItem = void 0;
        e.legendItems = void 0;
        e.name = "";
        e.options = void 0;
        e.stops = void 0;
        e.visible = !0;
        e.init(a, d);
        return e;
      }
      t(k, b);
      k.compose = function (a, d, b, f) {
        A.compose(k, a, d, b, f);
      };
      k.prototype.init = function (a, d) {
        var e = a.options.legend || {},
          f = d.layout ? "vertical" !== d.layout : "vertical" !== e.layout,
          h = d.visible;
        e = g(k.defaultColorAxisOptions, d, {
          showEmpty: !1,
          title: null,
          visible: e.enabled && !1 !== h
        });
        this.coll = "colorAxis";
        this.side = d.side || f ? 2 : 1;
        this.reversed = d.reversed || !f;
        this.opposite = !f;
        b.prototype.init.call(this, a, e);
        this.userOptions.visible = h;
        d.dataClasses && this.initDataClasses(d);
        this.initStops();
        this.horiz = f;
        this.zoomEnabled = !1;
      };
      k.prototype.initDataClasses = function (a) {
        var d = this.chart,
          b = this.options,
          f = a.dataClasses.length,
          e,
          c = 0,
          h = d.options.chart.colorCount;
        this.dataClasses = e = [];
        this.legendItems = [];
        (a.dataClasses || []).forEach(function (a, m) {
          a = g(a);
          e.push(a);
          if (d.styledMode || !a.color) "category" === b.dataClassColor ? (d.styledMode || (m = d.options.colors, h = m.length, a.color = m[c]), a.colorIndex = c, c++, c === h && (c = 0)) : a.color = n(b.minColor).tweenTo(n(b.maxColor), 2 > f ? .5 : m / (f - 1));
        });
      };
      k.prototype.hasData = function () {
        return !!(this.tickPositions || []).length;
      };
      k.prototype.setTickPositions = function () {
        if (!this.dataClasses) return b.prototype.setTickPositions.call(this);
      };
      k.prototype.initStops = function () {
        this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];
        this.stops.forEach(function (a) {
          a.color = n(a[1]);
        });
      };
      k.prototype.setOptions = function (a) {
        b.prototype.setOptions.call(this, a);
        this.options.crosshair = this.options.marker;
      };
      k.prototype.setAxisSize = function () {
        var a = this.legendSymbol,
          d = this.chart,
          b = d.options.legend || {},
          f,
          e;
        a ? (this.left = b = a.attr("x"), this.top = f = a.attr("y"), this.width = e = a.attr("width"), this.height = a = a.attr("height"), this.right = d.chartWidth - b - e, this.bottom = d.chartHeight - f - a, this.len = this.horiz ? e : a, this.pos = this.horiz ? b : f) : this.len = (this.horiz ? b.symbolWidth : b.symbolHeight) || k.defaultLegendLength;
      };
      k.prototype.normalizedValue = function (a) {
        this.logarithmic && (a = this.logarithmic.log2lin(a));
        return 1 - (this.max - a) / (this.max - this.min || 1);
      };
      k.prototype.toColor = function (a, d) {
        var b = this.dataClasses,
          f = this.stops,
          e;
        if (b) for (e = b.length; e--;) {
          var c = b[e];
          var g = c.from;
          f = c.to;
          if (("undefined" === typeof g || a >= g) && ("undefined" === typeof f || a <= f)) {
            var h = c.color;
            d && (d.dataClass = e, d.colorIndex = c.colorIndex);
            break;
          }
        } else {
          a = this.normalizedValue(a);
          for (e = f.length; e-- && !(a > f[e][0]););
          g = f[e] || f[e + 1];
          f = f[e + 1] || g;
          a = 1 - (f[0] - a) / (f[0] - g[0] || 1);
          h = g.color.tweenTo(f.color, a);
        }
        return h;
      };
      k.prototype.getOffset = function () {
        var a = this.legendGroup,
          d = this.chart.axisOffset[this.side];
        a && (this.axisParent = a, b.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = d);
      };
      k.prototype.setLegendColor = function () {
        var a = this.reversed,
          d = a ? 1 : 0;
        a = a ? 0 : 1;
        d = this.horiz ? [d, 0, a, 0] : [0, a, 0, d];
        this.legendColor = {
          linearGradient: {
            x1: d[0],
            y1: d[1],
            x2: d[2],
            y2: d[3]
          },
          stops: this.stops
        };
      };
      k.prototype.drawLegendSymbol = function (a, d) {
        var b = a.padding,
          e = a.options,
          g = this.horiz,
          c = x(e.symbolWidth, g ? k.defaultLegendLength : 12),
          h = x(e.symbolHeight, g ? 12 : k.defaultLegendLength),
          l = x(e.labelPadding, g ? 16 : 30);
        e = x(e.itemDistance, 10);
        this.setLegendColor();
        d.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, c, h).attr({
          zIndex: 1
        }).add(d.legendGroup);
        this.legendItemWidth = c + b + (g ? e : l);
        this.legendItemHeight = h + b + (g ? l : 0);
      };
      k.prototype.setState = function (a) {
        this.series.forEach(function (d) {
          d.setState(a);
        });
      };
      k.prototype.setVisible = function () {};
      k.prototype.getSeriesExtremes = function () {
        var a = this.series,
          b = a.length,
          e;
        this.dataMin = Infinity;
        for (this.dataMax = -Infinity; b--;) {
          var f = a[b];
          var g = f.colorKey = x(f.options.colorKey, f.colorKey, f.pointValKey, f.zoneAxis, "y");
          var c = f.pointArrayMap;
          var h = f[g + "Min"] && f[g + "Max"];
          if (f[g + "Data"]) var k = f[g + "Data"];else if (c) {
            k = [];
            c = c.indexOf(g);
            var n = f.yData;
            if (0 <= c && n) for (e = 0; e < n.length; e++) k.push(x(n[e][c], n[e]));
          } else k = f.yData;
          h ? (f.minColorValue = f[g + "Min"], f.maxColorValue = f[g + "Max"]) : (k = d.prototype.getExtremes.call(f, k), f.minColorValue = k.dataMin, f.maxColorValue = k.dataMax);
          "undefined" !== typeof f.minColorValue && (this.dataMin = Math.min(this.dataMin, f.minColorValue), this.dataMax = Math.max(this.dataMax, f.maxColorValue));
          h || d.prototype.applyExtremes.call(f);
        }
      };
      k.prototype.drawCrosshair = function (a, d) {
        var e = d && d.plotX,
          f = d && d.plotY,
          g = this.pos,
          c = this.len;
        if (d) {
          var h = this.toPixels(d.getNestedProperty(d.series.colorKey));
          h < g ? h = g - 2 : h > g + c && (h = g + c + 2);
          d.plotX = h;
          d.plotY = this.len - h;
          b.prototype.drawCrosshair.call(this, a, d);
          d.plotX = e;
          d.plotY = f;
          this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass("highcharts-coloraxis-marker").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.chart.styledMode || "object" !== typeof this.crosshair || this.cross.attr({
            fill: this.crosshair.color
          }));
        }
      };
      k.prototype.getPlotLinePath = function (a) {
        var d = this.left,
          g = a.translatedValue,
          f = this.top;
        return e(g) ? this.horiz ? [["M", g - 4, f - 6], ["L", g + 4, f - 6], ["L", g, f], ["Z"]] : [["M", d, g], ["L", d - 6, g + 6], ["L", d - 6, g - 6], ["Z"]] : b.prototype.getPlotLinePath.call(this, a);
      };
      k.prototype.update = function (a, d) {
        var e = this.chart.legend;
        this.series.forEach(function (a) {
          a.isDirtyData = !0;
        });
        (a.dataClasses && e.allItems || this.dataClasses) && this.destroyItems();
        b.prototype.update.call(this, a, d);
        this.legendItem && (this.setLegendColor(), e.colorizeItem(this, !0));
      };
      k.prototype.destroyItems = function () {
        var a = this.chart;
        this.legendItem ? a.legend.destroyItem(this) : this.legendItems && this.legendItems.forEach(function (d) {
          a.legend.destroyItem(d);
        });
        a.isDirtyLegend = !0;
      };
      k.prototype.destroy = function () {
        this.chart.isDirtyLegend = !0;
        this.destroyItems();
        b.prototype.destroy.apply(this, [].slice.call(arguments));
      };
      k.prototype.remove = function (a) {
        this.destroyItems();
        b.prototype.remove.call(this, a);
      };
      k.prototype.getDataClassLegendSymbols = function () {
        var d = this,
          b = d.chart,
          e = d.legendItems,
          f = b.options.legend,
          g = f.valueDecimals,
          c = f.valueSuffix || "",
          k;
        e.length || d.dataClasses.forEach(function (f, m) {
          var l = f.from,
            n = f.to,
            q = b.numberFormatter,
            r = !0;
          k = "";
          "undefined" === typeof l ? k = "< " : "undefined" === typeof n && (k = "> ");
          "undefined" !== typeof l && (k += q(l, g) + c);
          "undefined" !== typeof l && "undefined" !== typeof n && (k += " - ");
          "undefined" !== typeof n && (k += q(n, g) + c);
          e.push(a({
            chart: b,
            name: k,
            options: {},
            drawLegendSymbol: D.drawRectangle,
            visible: !0,
            setState: h,
            isDataClass: !0,
            setVisible: function () {
              r = d.visible = !r;
              d.series.forEach(function (a) {
                a.points.forEach(function (a) {
                  a.dataClass === m && a.setVisible(r);
                });
              });
              b.legend.colorizeItem(this, r);
            }
          }, f));
        });
        return e;
      };
      k.defaultColorAxisOptions = E;
      k.defaultLegendLength = 200;
      k.keepProps = ["legendGroup", "legendItemHeight", "legendItemWidth", "legendItem", "legendSymbol"];
      return k;
    }(b);
    Array.prototype.push.apply(b.keepProps, p.keepProps);
    "";
    return p;
  });
  G(b, "Maps/MapNavigationOptionsDefault.js", [b["Core/DefaultOptions.js"], b["Core/Utilities.js"]], function (b, p) {
    p = p.extend;
    var v = {
      buttonOptions: {
        alignTo: "plotBox",
        align: "left",
        verticalAlign: "top",
        x: 0,
        width: 18,
        height: 18,
        padding: 5,
        style: {
          fontSize: "15px",
          fontWeight: "bold"
        },
        theme: {
          "stroke-width": 1,
          "text-align": "center"
        }
      },
      buttons: {
        zoomIn: {
          onclick: function () {
            this.mapZoom(.5);
          },
          text: "+",
          y: 0
        },
        zoomOut: {
          onclick: function () {
            this.mapZoom(2);
          },
          text: "-",
          y: 28
        }
      },
      mouseWheelSensitivity: 1.1
    };
    p(b.defaultOptions.lang, {
      zoomIn: "Zoom in",
      zoomOut: "Zoom out"
    });
    return b.defaultOptions.mapNavigation = v;
  });
  G(b, "Maps/MapNavigation.js", [b["Core/Chart/Chart.js"], b["Core/Globals.js"], b["Core/Utilities.js"]], function (b, p, A) {
    function v(a) {
      a && (a.preventDefault && a.preventDefault(), a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0);
    }
    function w(a) {
      this.init(a);
    }
    var D = p.doc,
      B = A.addEvent,
      k = A.extend,
      t = A.isNumber,
      n = A.merge,
      h = A.objectEach,
      d = A.pick;
    w.prototype.init = function (a) {
      this.chart = a;
      a.mapNavButtons = [];
    };
    w.prototype.update = function (a) {
      var b = this.chart,
        g = b.options.mapNavigation,
        t,
        p,
        r,
        q,
        z = function (a) {
          this.handler.call(b, a);
          v(a);
        },
        m = b.mapNavButtons;
      a && (g = b.options.mapNavigation = n(b.options.mapNavigation, a));
      for (; m.length;) m.pop().destroy();
      d(g.enableButtons, g.enabled) && !b.renderer.forExport && h(g.buttons, function (a, d) {
        a = n(g.buttonOptions, a);
        !b.styledMode && a.theme && (t = a.theme, t.style = n(a.theme.style, a.style), r = (p = t.states) && p.hover, q = p && p.select, delete t.states);
        var c = b.renderer.button(a.text || "", 0, 0, z, t, r, q, void 0, "zoomIn" === d ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation highcharts-" + {
          zoomIn: "zoom-in",
          zoomOut: "zoom-out"
        }[d]).attr({
          width: a.width,
          height: a.height,
          title: b.options.lang[d],
          padding: a.padding,
          zIndex: 5
        }).add();
        c.handler = a.onclick;
        B(c.element, "dblclick", v);
        m.push(c);
        k(a, {
          width: c.width,
          height: 2 * c.height
        });
        if (b.hasLoaded) c.align(a, !1, a.alignTo);else var e = B(b, "load", function () {
          c.element && c.align(a, !1, a.alignTo);
          e();
        });
      });
      this.updateEvents(g);
    };
    w.prototype.updateEvents = function (a) {
      var b = this.chart;
      d(a.enableDoubleClickZoom, a.enabled) || a.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || B(b.container, "dblclick", function (a) {
        b.pointer.onContainerDblClick(a);
      }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());
      d(a.enableMouseWheelZoom, a.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || B(b.container, void 0 !== D.onwheel ? "wheel" : void 0 !== D.onmousewheel ? "mousewheel" : "DOMMouseScroll", function (a) {
        b.pointer.inClass(a.target, "highcharts-no-mousewheel") || (b.pointer.onContainerMouseWheel(a), v(a));
        return !1;
      }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());
    };
    k(b.prototype, {
      fitToBox: function (a, d) {
        [["x", "width"], ["y", "height"]].forEach(function (b) {
          var e = b[0];
          b = b[1];
          a[e] + a[b] > d[e] + d[b] && (a[b] > d[b] ? (a[b] = d[b], a[e] = d[e]) : a[e] = d[e] + d[b] - a[b]);
          a[b] > d[b] && (a[b] = d[b]);
          a[e] < d[e] && (a[e] = d[e]);
        });
        return a;
      },
      mapZoom: function (a, d, b, h, k) {
        this.mapView && (t(a) && (a = Math.log(a) / Math.log(.5)), this.mapView.zoomBy(a, t(d) && t(b) ? this.mapView.projection.inverse([d, b]) : void 0, t(h) && t(k) ? [h, k] : void 0));
      }
    });
    B(b, "beforeRender", function () {
      this.mapNavigation = new w(this);
      this.mapNavigation.update();
    });
    p.MapNavigation = w;
  });
  G(b, "Maps/MapPointer.js", [b["Core/Pointer.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = p.defined,
      E = p.extend,
      w = p.pick;
    p = p.wrap;
    var D = 0,
      B;
    E(b.prototype, {
      onContainerDblClick: function (b) {
        var k = this.chart;
        b = this.normalize(b);
        k.options.mapNavigation.enableDoubleClickZoomTo ? k.pointer.inClass(b.target, "highcharts-tracker") && k.hoverPoint && k.hoverPoint.zoomTo() : k.isInsidePlot(b.chartX - k.plotLeft, b.chartY - k.plotTop) && k.mapZoom(.5, void 0, void 0, b.chartX, b.chartY);
      },
      onContainerMouseWheel: function (b) {
        var k = this.chart;
        b = this.normalize(b);
        var n = v(b.wheelDelta) && -b.wheelDelta / 120 || b.deltaY || b.detail;
        1 <= Math.abs(n) && (D += Math.abs(n), B && clearTimeout(B), B = setTimeout(function () {
          D = 0;
        }, 50));
        10 > D && k.isInsidePlot(b.chartX - k.plotLeft, b.chartY - k.plotTop) && k.mapView && k.mapView.zoomBy((k.options.mapNavigation.mouseWheelSensitivity - 1) * -n, void 0, [b.chartX, b.chartY], 1 > Math.abs(n) ? !1 : void 0);
      }
    });
    p(b.prototype, "zoomOption", function (b) {
      var k = this.chart.options.mapNavigation;
      w(k.enableTouchZoom, k.enabled) && (this.chart.options.chart.pinchType = "xy");
      b.apply(this, [].slice.call(arguments, 1));
    });
    p(b.prototype, "pinchTranslate", function (b, t, n, h, d, a, e) {
      b.call(this, t, n, h, d, a, e);
      "map" === this.chart.options.chart.type && this.hasZoom && (b = h.scaleX > h.scaleY, this.pinchTranslateDirection(!b, t, n, h, d, a, e, b ? h.scaleX : h.scaleY));
    });
  });
  G(b, "Series/ColorMapMixin.js", [b["Core/Globals.js"], b["Core/Series/Point.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = b.noop;
    b = b.seriesTypes;
    var w = A.defined;
    A = A.addEvent;
    A(p, "afterSetState", function (b) {
      this.moveToTopOnHover && this.graphic && this.graphic.attr({
        zIndex: b && "hover" === b.state ? 1 : 0
      });
    });
    return {
      PointMixin: {
        dataLabelOnNull: !0,
        moveToTopOnHover: !0,
        isValid: function () {
          return null !== this.value && Infinity !== this.value && -Infinity !== this.value;
        }
      },
      SeriesMixin: {
        pointArrayMap: ["value"],
        axisTypes: ["xAxis", "yAxis", "colorAxis"],
        trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
        getSymbol: v,
        parallelArrays: ["x", "y", "value"],
        colorKey: "value",
        pointAttribs: b.column.prototype.pointAttribs,
        colorAttribs: function (b) {
          var p = {};
          !w(b.color) || b.state && "normal" !== b.state || (p[this.colorProp || "fill"] = b.color);
          return p;
        }
      }
    };
  });
  G(b, "Maps/MapViewOptionsDefault.js", [], function () {
    return {
      center: [0, 0],
      maxZoom: void 0,
      padding: 0,
      projection: void 0,
      zoom: void 0
    };
  });
  G(b, "Maps/Projections/LambertConformalConic.js", [], function () {
    var b = Math.sign || function (b) {
        return 0 === b ? 0 : 0 < b ? 1 : -1;
      },
      p = Math.PI / 180,
      A = Math.PI / 2,
      E = 0,
      w = 0;
    return {
      init: function (v) {
        var B = (v.parallels || []).map(function (b) {
          return b * p;
        });
        v = B[0] || 0;
        B = B[1] || v;
        var k = Math.cos(v);
        E = v === B ? Math.sin(v) : Math.log(k / Math.cos(B)) / Math.log(Math.tan((A + B) / 2) / Math.tan((A + v) / 2));
        1e-10 > Math.abs(E) && (E = 1e-10 * (b(E) || 1));
        w = k * Math.pow(Math.tan((A + v) / 2), E) / E;
      },
      forward: function (b) {
        var v = b[0] * p;
        b = b[1] * p;
        0 < w ? b < -A + .000001 && (b = -A + .000001) : b > A - .000001 && (b = A - .000001);
        b = w / Math.pow(Math.tan((A + b) / 2), E);
        return [b * Math.sin(E * v) * 63.78137, 63.78137 * (w - b * Math.cos(E * v))];
      },
      inverse: function (v) {
        var B = v[0] / 63.78137;
        v = w - v[1] / 63.78137;
        var k = b(E) * Math.sqrt(B * B + v * v),
          t = Math.atan2(B, Math.abs(v)) * b(v);
        0 > v * E && (t -= Math.PI * b(B) * b(v));
        return [t / E / p, (2 * Math.atan(Math.pow(w / k, 1 / E)) - A) / p];
      }
    };
  });
  G(b, "Maps/Projections/EqualEarth.js", [], function () {
    var b = Math.sqrt(3) / 2;
    return {
      forward: function (p) {
        var v = Math.PI / 180,
          E = Math.asin(b * Math.sin(p[1] * v)),
          w = E * E,
          D = w * w * w;
        return [p[0] * v * Math.cos(E) * 74.03120656864502 / (b * (1.340264 + 3 * -.081106 * w + D * (7 * .000893 + .034164 * w))), 74.03120656864502 * E * (1.340264 + -.081106 * w + D * (.000893 + .003796 * w))];
      },
      inverse: function (p) {
        var v = p[0] / 74.03120656864502;
        p = p[1] / 74.03120656864502;
        var E = 180 / Math.PI,
          w = p,
          D;
        for (D = 0; 12 > D; ++D) {
          var B = w * w;
          var k = B * B * B;
          var t = w * (1.340264 + -.081106 * B + k * (.000893 + .003796 * B)) - p;
          B = 1.340264 + 3 * -.081106 * B + k * (7 * .000893 + .034164 * B);
          w -= t /= B;
          if (1e-9 > Math.abs(t)) break;
        }
        B = w * w;
        return [E * b * v * (1.340264 + 3 * -.081106 * B + B * B * B * (7 * .000893 + .034164 * B)) / Math.cos(w), E * Math.asin(Math.sin(w) / b)];
      }
    };
  });
  G(b, "Maps/Projections/Miller.js", [], function () {
    var b = Math.PI / 4,
      p = Math.PI / 180;
    return {
      forward: function (v) {
        return [v[0] * p * 63.78137, 79.7267125 * Math.log(Math.tan(b + .4 * v[1] * p))];
      },
      inverse: function (v) {
        return [v[0] / 63.78137 / p, 2.5 * (Math.atan(Math.exp(v[1] / 63.78137 * .8)) - b) / p];
      }
    };
  });
  G(b, "Maps/Projections/Orthographic.js", [], function () {
    var b = Math.PI / 180;
    return {
      forward: function (p) {
        var v = p[0];
        if (-90 > v || 90 < v) return [NaN, NaN];
        p = p[1] * b;
        return [Math.cos(p) * Math.sin(v * b) * 63.78460826781007, 63.78460826781007 * Math.sin(p)];
      },
      inverse: function (p) {
        var v = p[0] / 63.78460826781007;
        p = p[1] / 63.78460826781007;
        var E = Math.sqrt(v * v + p * p),
          w = Math.asin(E),
          D = Math.sin(w);
        return [Math.atan2(v * D, E * Math.cos(w)) / b, Math.asin(E && p * D / E) / b];
      }
    };
  });
  G(b, "Maps/Projections/WebMercator.js", [], function () {
    var b = Math.PI / 180;
    return {
      forward: function (p) {
        if (85.0511287798 < Math.abs(p[1])) return [NaN, NaN];
        var v = Math.sin(p[1] * b);
        return [63.78137 * p[0] * b, 63.78137 * Math.log((1 + v) / (1 - v)) / 2];
      },
      inverse: function (p) {
        return [p[0] / (63.78137 * b), (2 * Math.atan(Math.exp(p[1] / 63.78137)) - Math.PI / 2) / b];
      },
      maxLatitude: 85.0511287798
    };
  });
  G(b, "Maps/Projections/ProjectionRegistry.js", [b["Maps/Projections/LambertConformalConic.js"], b["Maps/Projections/EqualEarth.js"], b["Maps/Projections/Miller.js"], b["Maps/Projections/Orthographic.js"], b["Maps/Projections/WebMercator.js"]], function (b, p, A, E, w) {
    return {
      EqualEarth: p,
      LambertConformalConic: b,
      Miller: A,
      Orthographic: E,
      WebMercator: w
    };
  });
  G(b, "Maps/Projection.js", [b["Maps/Projections/ProjectionRegistry.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = this && this.__spreadArrays || function () {
        for (var b = 0, k = 0, t = arguments.length; k < t; k++) b += arguments[k].length;
        b = Array(b);
        var n = 0;
        for (k = 0; k < t; k++) for (var h = arguments[k], d = 0, a = h.length; d < a; d++, n++) b[n] = h[d];
        return b;
      },
      E = p.erase,
      w = 2 * Math.PI / 360,
      D = function (b) {
        -180 > b && (b += 360);
        180 < b && (b -= 360);
        return b;
      };
    return function () {
      function p(b) {
        void 0 === b && (b = {});
        this.hasGeoProjection = this.hasCoordinates = !1;
        this.maxLatitude = 90;
        this.options = b;
        var k = b.name,
          n = b.rotation;
        this.rotator = n ? this.getRotator(n) : void 0;
        var h = this.def = k ? p.registry[k] : void 0,
          d = this.rotator;
        h && (h.init && h.init(b), this.maxLatitude = h.maxLatitude || 90, this.hasGeoProjection = !0);
        d && h ? (this.forward = function (a) {
          a = d.forward(a);
          return h.forward(a);
        }, this.inverse = function (a) {
          a = h.inverse(a);
          return d.inverse(a);
        }) : h ? (this.forward = h.forward, this.inverse = h.inverse) : d && (this.forward = d.forward, this.inverse = d.inverse);
      }
      p.add = function (b, t) {
        p.registry[b] = t;
      };
      p.greatCircle = function (b, t, n) {
        var h = Math.atan2,
          d = Math.cos,
          a = Math.sin,
          e = Math.sqrt,
          g = b[1] * w,
          k = b[0] * w,
          p = t[1] * w,
          r = t[0] * w,
          q = p - g,
          z = r - k;
        q = a(q / 2) * a(q / 2) + d(g) * d(p) * a(z / 2) * a(z / 2);
        q = 2 * h(e(q), e(1 - q));
        var m = Math.round(6371E3 * q / 5E5);
        z = [];
        n && z.push(b);
        if (1 < m) for (m = b = 1 / m; .999 > m; m += b) {
          var f = a((1 - m) * q) / a(q),
            v = a(m * q) / a(q),
            c = f * d(g) * d(k) + v * d(p) * d(r),
            u = f * d(g) * a(k) + v * d(p) * a(r);
          f = f * a(g) + v * a(p);
          f = h(f, e(c * c + u * u));
          c = h(u, c);
          z.push([c / w, f / w]);
        }
        n && z.push(t);
        return z;
      };
      p.insertGreatCircles = function (b) {
        for (var k = b.length - 1; k--;) if (10 < Math.max(Math.abs(b[k][0] - b[k + 1][0]), Math.abs(b[k][1] - b[k + 1][1]))) {
          var n = p.greatCircle(b[k], b[k + 1]);
          n.length && b.splice.apply(b, v([k + 1, 0], n));
        }
      };
      p.toString = function (b) {
        b = b || {};
        var k = b.rotation;
        return [b.name, k && k.join(",")].join(";");
      };
      p.prototype.getRotator = function (b) {
        var k = b[0] * w,
          n = (b[1] || 0) * w;
        b = (b[2] || 0) * w;
        var h = Math.cos(n),
          d = Math.sin(n),
          a = Math.cos(b),
          e = Math.sin(b);
        if (0 !== k || 0 !== n || 0 !== b) return {
          forward: function (b) {
            var g = b[0] * w + k,
              n = b[1] * w,
              r = Math.cos(n);
            b = Math.cos(g) * r;
            g = Math.sin(g) * r;
            n = Math.sin(n);
            r = n * h + b * d;
            return [Math.atan2(g * a - r * e, b * h - n * d) / w, Math.asin(r * a + g * e) / w];
          },
          inverse: function (b) {
            var g = b[0] * w,
              n = b[1] * w,
              r = Math.cos(n);
            b = Math.cos(g) * r;
            g = Math.sin(g) * r;
            n = Math.sin(n);
            r = n * a - g * e;
            return [(Math.atan2(g * a + n * e, b * h + r * d) - k) / w, Math.asin(r * h - b * d) / w];
          }
        };
      };
      p.prototype.forward = function (b) {
        return b;
      };
      p.prototype.inverse = function (b) {
        return b;
      };
      p.prototype.clipOnAntimeridian = function (b, t) {
        var k = [],
          h = [b];
        b.forEach(function (a, d) {
          var e = b[d - 1];
          if (!d) {
            if (!t) return;
            e = b[b.length - 1];
          }
          var g = e[0],
            f = a[0];
          (-90 > g || 90 < g) && (-90 > f || 90 < f) && 0 < g !== 0 < f && k.push({
            i: d,
            lat: e[1] + (180 - e[0]) / (a[0] - e[0]) * (a[1] - e[1]),
            direction: 0 > g ? 1 : -1,
            previousLonLat: e,
            lonLat: a
          });
        });
        if (k.length) if (t) {
          if (1 === k.length % 2) {
            var d = k.slice().sort(function (a, b) {
              return Math.abs(b.lat) - Math.abs(a.lat);
            })[0];
            E(k, d);
          }
          for (var a = k.length - 2; 0 <= a;) {
            var e = k[a].i,
              g = D(180 + .000001 * k[a].direction),
              x = D(180 - .000001 * k[a].direction);
            e = b.splice.apply(b, v([e, k[a + 1].i - e], p.greatCircle([g, k[a].lat], [g, k[a + 1].lat], !0)));
            e.push.apply(e, p.greatCircle([x, k[a + 1].lat], [x, k[a].lat], !0));
            h.push(e);
            a -= 2;
          }
          if (d) for (e = 0; e < h.length; e++) if (a = h[e], x = a.indexOf(d.lonLat), -1 < x) {
            e = (0 > d.lat ? -1 : 1) * this.maxLatitude;
            g = D(180 + .000001 * d.direction);
            var w = D(180 - .000001 * d.direction);
            d = p.greatCircle([g, d.lat], [g, e], !0).concat(p.greatCircle([w, e], [w, d.lat], !0));
            a.splice.apply(a, v([x, 0], d));
            break;
          }
        } else for (a = k.length; a--;) e = k[a].i, e = b.splice(e, b.length, [D(180 + .000001 * k[a].direction), k[a].lat]), e.unshift([D(180 - .000001 * k[a].direction), k[a].lat]), h.push(e);
        return h;
      };
      p.prototype.path = function (b) {
        var k = this,
          n = this.def,
          h = this.rotator,
          d = [],
          a = "Polygon" === b.type || "MultiPolygon" === b.type,
          e = this.hasGeoProjection,
          g = "Orthographic" !== this.options.name,
          x = g ? h : void 0,
          v = g ? n || this : this,
          r = function (b) {
            b = b.map(function (a) {
              if (g) {
                x && (a = x.forward(a));
                var b = a[0];
                .000001 > Math.abs(b - 180) && (b = 180 > b ? 179.999999 : 180.000001);
                a = [b, a[1]];
              }
              return a;
            });
            var h = [b];
            e && (p.insertGreatCircles(b), g && (h = k.clipOnAntimeridian(b, a)));
            h.forEach(function (b) {
              if (!(2 > b.length)) for (var f = !1, g, c, h = !1, m = function (a) {
                  f ? d.push(["L", a[0], a[1]]) : (d.push(["M", a[0], a[1]]), f = !0);
                }, n = 0; n < b.length; n++) {
                var q = b[n],
                  r = v.forward(q);
                isNaN(r[0]) || isNaN(r[1]) || e && !(q[1] <= k.maxLatitude && q[1] >= -k.maxLatitude) ? h = !0 : (a && !g && (g = q, b.push(q)), h && c && (a && e ? p.greatCircle(c, q).forEach(function (a) {
                  return m(v.forward(a));
                }) : f = !1), m(r), c = q, h = !1);
              }
            });
          };
        "LineString" === b.type ? r(b.coordinates) : "MultiLineString" === b.type ? b.coordinates.forEach(function (a) {
          return r(a);
        }) : "Polygon" === b.type ? (b.coordinates.forEach(function (a) {
          return r(a);
        }), d.length && d.push(["Z"])) : "MultiPolygon" === b.type && (b.coordinates.forEach(function (a) {
          a.forEach(function (a) {
            return r(a);
          });
        }), d.length && d.push(["Z"]));
        return d;
      };
      p.registry = b;
      return p;
    }();
  });
  G(b, "Maps/MapView.js", [b["Maps/MapViewOptionsDefault.js"], b["Maps/Projection.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = A.addEvent,
      w = A.clamp,
      D = A.fireEvent,
      B = A.isNumber,
      k = A.merge,
      t = A.pick,
      n = A.relativeLength;
    return function () {
      function h(d, a) {
        var e = this;
        this.userOptions = a || {};
        a = k(b, a);
        this.chart = d;
        this.center = a.center;
        this.options = a;
        this.projection = new p(a.projection);
        this.zoom = a.zoom || 0;
        v(d, "afterSetChartSize", function () {
          if (void 0 === e.minZoom || e.minZoom === e.zoom) e.fitToBounds(void 0, void 0, !1), B(e.userOptions.zoom) && (e.zoom = e.userOptions.zoom), e.userOptions.center && k(!0, e.center, e.userOptions.center);
        });
        var g, h, n;
        a = function (a) {
          var b = d.pointer.pinchDown,
            k = d.mouseDownX,
            m = d.mouseDownY;
          1 === b.length && (k = b[0].chartX, m = b[0].chartY);
          if ("number" === typeof k && "number" === typeof m) {
            var f = k + "," + m,
              r = a.originalEvent;
            b = r.chartX;
            r = r.chartY;
            f !== h && (h = f, g = e.projection.forward(e.center), n = (e.projection.options.rotation || [0, 0]).slice());
            "Orthographic" === e.projection.options.name && 3 > (e.minZoom || Infinity) ? (f = 440 / (e.getScale() * Math.min(d.plotWidth, d.plotHeight)), n && (k = (k - b) * f - n[0], m = w(-n[1] - (m - r) * f, -80, 80), e.update({
              projection: {
                rotation: [-k, -m]
              },
              center: [k, m],
              zoom: e.zoom
            }, !0, !1))) : (f = e.getScale(), m = e.projection.inverse([g[0] + (k - b) / f, g[1] - (m - r) / f]), e.setView(m, void 0, !0, !1));
            a.preventDefault();
          }
        };
        v(d, "pan", a);
        v(d, "touchpan", a);
        v(d, "selection", function (a) {
          if (a.resetSelection) e.zoomBy();else {
            var b = a.x - d.plotLeft,
              g = a.y - d.plotTop,
              h = e.pixelsToProjectedUnits({
                x: b,
                y: g
              }),
              f = h.y;
            h = h.x;
            b = e.pixelsToProjectedUnits({
              x: b + a.width,
              y: g + a.height
            });
            e.fitToBounds({
              x1: h,
              y1: f,
              x2: b.x,
              y2: b.y
            }, void 0, !0, a.originalEvent.touches ? !1 : void 0);
            /^touch/.test(a.originalEvent.type) || d.showResetZoom();
            a.preventDefault();
          }
        });
      }
      h.prototype.fitToBounds = function (b, a, e, g) {
        void 0 === e && (e = !0);
        var d = b || this.getProjectedBounds();
        if (d) {
          var h = this.chart,
            k = h.plotWidth;
          h = h.plotHeight;
          var q = t(a, b ? 0 : this.options.padding);
          a = n(q, k);
          q = n(q, h);
          k = Math.log(400.979322 / Math.max((d.x2 - d.x1) / ((k - a) / 256), (d.y2 - d.y1) / ((h - q) / 256))) / Math.log(2);
          b || (this.minZoom = k);
          b = this.projection.inverse([(d.x2 + d.x1) / 2, (d.y2 + d.y1) / 2]);
          this.setView(b, k, e, g);
        }
      };
      h.prototype.getProjectedBounds = function () {
        var b = this.chart.series.reduce(function (a, b) {
          (b = b.getProjectedBounds && b.getProjectedBounds()) && a.push(b);
          return a;
        }, []);
        return h.compositeBounds(b);
      };
      h.prototype.getScale = function () {
        return 256 / 400.979322 * Math.pow(2, this.zoom);
      };
      h.prototype.redraw = function (b) {
        this.chart.series.forEach(function (a) {
          a.useMapGeometry && (a.isDirty = !0);
        });
        this.chart.redraw(b);
      };
      h.prototype.setView = function (b, a, e, g) {
        void 0 === e && (e = !0);
        var d = !1;
        b && (this.center = b);
        "number" === typeof a && ("number" === typeof this.minZoom && (a = Math.max(a, this.minZoom)), "number" === typeof this.options.maxZoom && (a = Math.min(a, this.options.maxZoom)), d = a > this.zoom, this.zoom = a);
        var h = this.getProjectedBounds();
        if (h && !d) {
          d = this.projection.forward(this.center);
          a = this.chart;
          b = a.plotWidth;
          a = a.plotHeight;
          var k = this.getScale(),
            n = this.projectedUnitsToPixels({
              x: h.x1,
              y: h.y1
            }),
            t = this.projectedUnitsToPixels({
              x: h.x2,
              y: h.y2
            });
          h = [(h.x1 + h.x2) / 2, (h.y1 + h.y2) / 2];
          var m = n.x,
            f = t.y;
          t = t.x;
          n = n.y;
          t - m < b ? d[0] = h[0] : 0 > m && t < b ? d[0] += Math.max(m, t - b) / k : t > b && 0 < m && (d[0] += Math.min(t - b, m) / k);
          n - f < a ? d[1] = h[1] : 0 > f && n < a ? d[1] -= Math.max(f, n - a) / k : n > a && 0 < f && (d[1] -= Math.min(n - a, f) / k);
          this.center = this.projection.inverse(d);
        }
        D(this, "afterSetView");
        e && this.redraw(g);
      };
      h.prototype.projectedUnitsToPixels = function (b) {
        var a = this.getScale(),
          d = this.projection.forward(this.center);
        return {
          x: this.chart.plotWidth / 2 - a * (d[0] - b.x),
          y: this.chart.plotHeight / 2 + a * (d[1] - b.y)
        };
      };
      h.prototype.pixelsToProjectedUnits = function (b) {
        var a = b.x;
        b = b.y;
        var d = this.getScale(),
          g = this.projection.forward(this.center);
        return {
          x: g[0] + (a - this.chart.plotWidth / 2) / d,
          y: g[1] - (b - this.chart.plotHeight / 2) / d
        };
      };
      h.prototype.update = function (b, a, e) {
        void 0 === a && (a = !0);
        var d = b.projection;
        d = d && p.toString(d) !== p.toString(this.options.projection);
        k(!0, this.userOptions, b);
        k(!0, this.options, b);
        d && (this.chart.series.forEach(function (a) {
          a.clearBounds && a.clearBounds();
          a.isDirty = !0;
          a.isDirtyData = !0;
        }), this.projection = new p(this.options.projection), b.center || B(b.zoom) || this.fitToBounds(void 0, void 0, !1));
        (b.center || B(b.zoom)) && this.setView(this.options.center, b.zoom, !1);
        a && this.chart.redraw(e);
      };
      h.prototype.zoomBy = function (b, a, e, g) {
        var d = this.chart,
          h = this.projection.forward(this.center);
        a = a ? this.projection.forward(a) : [];
        var k = a[0],
          n = a[1];
        "number" === typeof b ? (b = this.zoom + b, a = void 0, e && (k = e[0], n = e[1], e = this.getScale(), k = k - d.plotLeft - d.plotWidth / 2, d = n - d.plotTop - d.plotHeight / 2, k = h[0] + k / e, n = h[1] + d / e), "number" === typeof k && "number" === typeof n && (e = 1 - Math.pow(2, this.zoom) / Math.pow(2, b), k = h[0] - k, d = h[1] - n, h[0] -= k * e, h[1] += d * e, a = this.projection.inverse(h)), this.setView(a, b, void 0, g)) : this.fitToBounds(void 0, void 0, void 0, g);
      };
      h.compositeBounds = function (b) {
        if (b.length) return b.slice(1).reduce(function (a, b) {
          a.x1 = Math.min(a.x1, b.x1);
          a.y1 = Math.min(a.y1, b.y1);
          a.x2 = Math.max(a.x2, b.x2);
          a.y2 = Math.max(a.y2, b.y2);
          return a;
        }, k(b[0]));
      };
      return h;
    }();
  });
  G(b, "Maps/MapSymbols.js", [b["Core/Renderer/SVG/SVGRenderer.js"]], function (b) {
    function p(b, p, v, D, B, k, t, n) {
      return [["M", b + B, p], ["L", b + v - k, p], ["C", b + v - k / 2, p, b + v, p + k / 2, b + v, p + k], ["L", b + v, p + D - t], ["C", b + v, p + D - t / 2, b + v - t / 2, p + D, b + v - t, p + D], ["L", b + n, p + D], ["C", b + n / 2, p + D, b, p + D - n / 2, b, p + D - n], ["L", b, p + B], ["C", b, p + B / 2, b + B / 2, p, b + B, p], ["Z"]];
    }
    b = b.prototype.symbols;
    b.bottombutton = function (b, v, w, D, B) {
      B = B && B.r || 0;
      return p(b - 1, v - 1, w, D, 0, 0, B, B);
    };
    b.topbutton = function (b, v, w, D, B) {
      B = B && B.r || 0;
      return p(b - 1, v - 1, w, D, B, B, 0, 0);
    };
    return b;
  });
  G(b, "Core/Chart/MapChart.js", [b["Core/Chart/Chart.js"], b["Core/DefaultOptions.js"], b["Maps/MapView.js"], b["Core/Renderer/SVG/SVGRenderer.js"], b["Core/Utilities.js"]], function (b, p, A, E, w) {
    var v = this && this.__extends || function () {
        var b = function (d, a) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, b) {
            a.__proto__ = b;
          } || function (a, b) {
            for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
          };
          return b(d, a);
        };
        return function (d, a) {
          function e() {
            this.constructor = d;
          }
          b(d, a);
          d.prototype = null === a ? Object.create(a) : (e.prototype = a.prototype, new e());
        };
      }(),
      B = p.getOptions,
      k = w.addEvent,
      t = w.merge,
      n = w.pick;
    b = function (b) {
      function d() {
        return null !== b && b.apply(this, arguments) || this;
      }
      v(d, b);
      d.prototype.init = function (a, d) {
        k(this, "afterInit", function () {
          this.mapView = new A(this, this.options.mapView);
        });
        var e = B().credits;
        a = t({
          chart: {
            panning: {
              enabled: !0,
              type: "xy"
            },
            type: "map"
          },
          credits: {
            mapText: n(e.mapText, ' \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>'),
            mapTextFull: n(e.mapTextFull, "{geojson.copyright}")
          },
          mapView: {},
          tooltip: {
            followTouchMove: !1
          }
        }, a);
        b.prototype.init.call(this, a, d);
      };
      return d;
    }(b);
    (function (b) {
      b.maps = {};
      b.mapChart = function (d, a, e) {
        return new b(d, a, e);
      };
      b.splitPath = function (b) {
        "string" === typeof b && (b = b.replace(/([A-Za-z])/g, " $1 ").replace(/^\s*/, "").replace(/\s*$/, ""), b = b.split(/[ ,;]+/).map(function (a) {
          return /[A-za-z]/.test(a) ? a : parseFloat(a);
        }));
        return E.prototype.pathToSegments(b);
      };
    })(b || (b = {}));
    return b;
  });
  G(b, "Series/Map/MapPoint.js", [b["Series/ColorMapMixin.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = this && this.__extends || function () {
        var b = function (p, k) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (b, k) {
            b.__proto__ = k;
          } || function (b, k) {
            for (var h in k) k.hasOwnProperty(h) && (b[h] = k[h]);
          };
          return b(p, k);
        };
        return function (p, k) {
          function t() {
            this.constructor = p;
          }
          b(p, k);
          p.prototype = null === k ? Object.create(k) : (t.prototype = k.prototype, new t());
        };
      }(),
      w = A.extend;
    p = function (b) {
      function p() {
        var k = null !== b && b.apply(this, arguments) || this;
        k.options = void 0;
        k.path = void 0;
        k.series = void 0;
        return k;
      }
      v(p, b);
      p.getProjectedPath = function (b, p) {
        b.projectedPath || (p && b.geometry ? (p.hasCoordinates = !0, b.projectedPath = p.path(b.geometry)) : b.projectedPath = b.path);
        return b.projectedPath || [];
      };
      p.prototype.applyOptions = function (k, p) {
        var n = this.series;
        k = b.prototype.applyOptions.call(this, k, p);
        p = n.joinBy;
        n.mapData && n.mapMap && (p = b.prototype.getNestedProperty.call(k, p[1]), (n = "undefined" !== typeof p && n.mapMap[p]) ? w(k, n) : k.value = k.value || null);
        return k;
      };
      p.prototype.onMouseOver = function (k) {
        A.clearTimeout(this.colorInterval);
        if (null !== this.value || this.series.options.nullInteraction) b.prototype.onMouseOver.call(this, k);else this.series.onMouseOut(k);
      };
      p.prototype.zoomTo = function () {
        var b = this.series.chart;
        b.mapView && this.bounds && (b.mapView.fitToBounds(this.bounds, void 0, !1), this.series.isDirty = !0, b.redraw());
      };
      return p;
    }(p.seriesTypes.scatter.prototype.pointClass);
    w(p.prototype, {
      dataLabelOnNull: b.PointMixin.dataLabelOnNull,
      isValid: b.PointMixin.isValid,
      moveToTopOnHover: b.PointMixin.moveToTopOnHover
    });
    return p;
  });
  G(b, "Series/Map/MapSeries.js", [b["Core/Animation/AnimationUtilities.js"], b["Series/ColorMapMixin.js"], b["Series/CenteredUtilities.js"], b["Core/Globals.js"], b["Core/Legend/LegendSymbol.js"], b["Core/Chart/MapChart.js"], b["Series/Map/MapPoint.js"], b["Maps/MapView.js"], b["Core/Series/Series.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Renderer/SVG/SVGRenderer.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D, B, k, t, n, h, d) {
    var a = this && this.__extends || function () {
        var a = function (c, b) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);
          };
          return a(c, b);
        };
        return function (c, b) {
          function d() {
            this.constructor = c;
          }
          a(c, b);
          c.prototype = null === b ? Object.create(b) : (d.prototype = b.prototype, new d());
        };
      }(),
      e = b.animObject;
    b = E.noop;
    var g = D.maps,
      x = D.splitPath;
    D = n.seriesTypes;
    var v = D.column,
      r = D.scatter;
    D = d.extend;
    var q = d.fireEvent,
      z = d.getNestedProperty,
      m = d.isArray,
      f = d.isNumber,
      y = d.merge,
      c = d.objectEach,
      u = d.pick,
      l = d.splat;
    d = function (b) {
      function d() {
        var a = null !== b && b.apply(this, arguments) || this;
        a.chart = void 0;
        a.data = void 0;
        a.group = void 0;
        a.joinBy = void 0;
        a.options = void 0;
        a.points = void 0;
        a.transformGroup = void 0;
        return a;
      }
      a(d, b);
      d.prototype.animate = function (a) {
        var c = this.chart,
          b = this.group,
          d = e(this.options.animation);
        c.renderer.isSVG && (a ? b.attr({
          translateX: c.plotLeft + c.plotWidth / 2,
          translateY: c.plotTop + c.plotHeight / 2,
          scaleX: .001,
          scaleY: .001
        }) : b.animate({
          translateX: c.plotLeft,
          translateY: c.plotTop,
          scaleX: 1,
          scaleY: 1
        }, d));
      };
      d.prototype.animateDrilldown = function (a) {
        var c = this.chart,
          b = this.group;
        c.renderer.isSVG && (a ? b.attr({
          translateX: c.plotLeft + c.plotWidth / 2,
          translateY: c.plotTop + c.plotHeight / 2,
          scaleX: .1,
          scaleY: .1,
          opacity: .01
        }) : b.animate({
          translateX: c.plotLeft,
          translateY: c.plotTop,
          scaleX: 1,
          scaleY: 1,
          opacity: 1
        }));
      };
      d.prototype.animateDrillupFrom = function () {
        var a = this.chart;
        a.renderer.isSVG && this.group.animate({
          translateX: a.plotLeft + a.plotWidth / 2,
          translateY: a.plotTop + a.plotHeight / 2,
          scaleX: .1,
          scaleY: .1,
          opacity: .01
        });
      };
      d.prototype.animateDrillupTo = function (a) {
        v.prototype.animateDrillupTo.call(this, a);
      };
      d.prototype.clearBounds = function () {
        this.points.forEach(function (a) {
          delete a.bounds;
          delete a.projectedPath;
        });
        delete this.bounds;
      };
      d.prototype.doFullTranslate = function () {
        return !(!(this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML) && this.hasRendered);
      };
      d.prototype.drawMapDataLabels = function () {
        t.prototype.drawDataLabels.call(this);
        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
      };
      d.prototype.drawPoints = function () {
        var a = this,
          c = this.chart,
          b = this.group,
          d = this.svgTransform,
          e = c.mapView,
          f = c.renderer;
        this.transformGroup || (this.transformGroup = f.g().add(b), this.transformGroup.survive = !0);
        this.doFullTranslate() && (c.hasRendered && !c.styledMode && this.points.forEach(function (c) {
          c.shapeArgs && (c.shapeArgs.fill = a.pointAttribs(c, c.state).fill);
        }), this.group = this.transformGroup, v.prototype.drawPoints.apply(this), this.group = b, this.points.forEach(function (b) {
          if (b.graphic) {
            var d = "";
            b.name && (d += "highcharts-name-" + b.name.replace(/ /g, "-").toLowerCase());
            b.properties && b.properties["hc-key"] && (d += " highcharts-key-" + b.properties["hc-key"].toLowerCase());
            d && b.graphic.addClass(d);
            c.styledMode && b.graphic.css(a.pointAttribs(b, b.selected && "select" || void 0));
          }
        }));
        if (e && d) {
          var g = u(this.options[this.pointAttrToOptions && this.pointAttrToOptions["stroke-width"] || "borderWidth"], 1),
            h = d.scaleX,
            k = 0 < d.scaleY ? 1 : -1,
            m = this.transformGroup;
          if (f.globalAnimation && c.hasRendered) {
            var l = Number(m.attr("translateX")),
              n = Number(m.attr("translateY")),
              q = Number(m.attr("scaleX"));
            m.attr({
              animator: 0
            }).animate({
              animator: 1
            }, {
              step: function (a, c) {
                a = q + (h - q) * c.pos;
                m.attr({
                  translateX: l + (d.translateX - l) * c.pos,
                  translateY: n + (d.translateY - n) * c.pos,
                  scaleX: a,
                  scaleY: a * k
                });
                b.element.setAttribute("stroke-width", g / a);
              }
            });
          } else m.attr(d), b.element.setAttribute("stroke-width", g / h);
        }
        this.drawMapDataLabels();
      };
      d.prototype.getProjectedBounds = function () {
        if (!this.bounds) {
          var a = Number.MAX_VALUE,
            c = this.chart.mapView && this.chart.mapView.projection,
            b = [];
          (this.points || []).forEach(function (d) {
            if (d.path || d.geometry) {
              "string" === typeof d.path ? d.path = x(d.path) : m(d.path) && "M" === d.path[0] && (d.path = h.prototype.pathToSegments(d.path));
              if (!d.bounds) {
                var e = B.getProjectedPath(d, c),
                  g = d.properties,
                  k = -a,
                  l = a,
                  n = -a,
                  q = a,
                  r;
                e.forEach(function (a) {
                  var c = a[a.length - 2];
                  a = a[a.length - 1];
                  "number" === typeof c && "number" === typeof a && (l = Math.min(l, c), k = Math.max(k, c), q = Math.min(q, a), n = Math.max(n, a), r = !0);
                });
                r && (e = g && g["hc-middle-x"], e = l + (k - l) * u(d.middleX, f(e) ? e : .5), g = g && g["hc-middle-y"], g = u(d.middleY, f(g) ? g : .5), d.geometry || (g = 1 - g), d.bounds = {
                  midX: e,
                  midY: n - (n - q) * g,
                  x1: l,
                  y1: q,
                  x2: k,
                  y2: n
                }, d.labelrank = u(d.labelrank, (k - l) * (n - q)));
              }
              d.bounds && b.push(d.bounds);
            }
          });
          this.bounds = k.compositeBounds(b);
        }
        return this.bounds;
      };
      d.prototype.hasData = function () {
        return !!this.processedXData.length;
      };
      d.prototype.pointAttribs = function (a, c) {
        var b = a.series.chart,
          d = b.mapView;
        c = b.styledMode ? this.colorAttribs(a) : v.prototype.pointAttribs.call(this, a, c);
        (a = a.options[this.pointAttrToOptions && this.pointAttrToOptions["stroke-width"] || "borderWidth"]) && d && (a /= d.getScale());
        c.dashstyle && d && this.options.borderWidth && (a = this.options.borderWidth / d.getScale());
        c["stroke-width"] = u(a, "inherit");
        return c;
      };
      d.prototype.setData = function (a, b, d, e) {
        var h = this.options,
          k = this.chart.options.chart,
          l = k && k.map,
          n = h.mapData,
          q = this.joinBy,
          r = h.keys || this.pointArrayMap,
          p = [],
          u = {},
          v = this.chart.mapTransforms;
        !n && l && (n = "string" === typeof l ? g[l] : l);
        a && a.forEach(function (c, b) {
          var d = 0;
          if (f(c)) a[b] = {
            value: c
          };else if (m(c)) {
            a[b] = {};
            !h.keys && c.length > r.length && "string" === typeof c[0] && (a[b]["hc-key"] = c[0], ++d);
            for (var e = 0; e < r.length; ++e, ++d) r[e] && "undefined" !== typeof c[d] && (0 < r[e].indexOf(".") ? B.prototype.setNestedProperty(a[b], c[d], r[e]) : a[b][r[e]] = c[d]);
          }
          q && "_i" === q[0] && (a[b]._i = b);
        });
        (this.chart.mapTransforms = v = k.mapTransforms || n && n["hc-transform"] || v) && c(v, function (a) {
          a.rotation && (a.cosAngle = Math.cos(a.rotation), a.sinAngle = Math.sin(a.rotation));
        });
        if (n) {
          "FeatureCollection" === n.type && (this.mapTitle = n.title, n = E.geojson(n, this.type, this));
          this.mapData = n;
          this.mapMap = {};
          for (v = 0; v < n.length; v++) k = n[v], l = k.properties, k._i = v, q[0] && l && l[q[0]] && (k[q[0]] = l[q[0]]), u[k[q[0]]] = k;
          this.mapMap = u;
          if (a && q[1]) {
            var x = q[1];
            a.forEach(function (a) {
              a = z(x, a);
              u[a] && p.push(u[a]);
            });
          }
          if (h.allAreas) {
            a = a || [];
            if (q[1]) {
              var w = q[1];
              a.forEach(function (a) {
                p.push(z(w, a));
              });
            }
            p = "|" + p.map(function (a) {
              return a && a[q[0]];
            }).join("|") + "|";
            n.forEach(function (c) {
              q[0] && -1 !== p.indexOf("|" + c[q[0]] + "|") || (a.push(y(c, {
                value: null
              })), e = !1);
            });
          }
        }
        t.prototype.setData.call(this, a, b, d, e);
        this.processData();
        this.generatePoints();
      };
      d.prototype.setOptions = function (a) {
        a = t.prototype.setOptions.call(this, a);
        var c = a.joinBy;
        null === c && (c = "_i");
        c = this.joinBy = l(c);
        c[1] || (c[1] = c[0]);
        return a;
      };
      d.prototype.translate = function () {
        var a = this.doFullTranslate(),
          c = this.chart.mapView,
          b = c && c.projection;
        !this.chart.hasRendered || !this.isDirtyData && this.hasRendered || (this.processData(), this.generatePoints(), delete this.bounds, this.getProjectedBounds());
        var d;
        if (c) {
          var e = c.getScale(),
            g = c.projection.forward(c.center);
          c = c.projection.hasCoordinates ? -1 : 1;
          this.svgTransform = d = {
            scaleX: e,
            scaleY: e * c,
            translateX: this.chart.plotWidth / 2 - g[0] * e,
            translateY: this.chart.plotHeight / 2 - g[1] * e * c
          };
        }
        this.points.forEach(function (c) {
          d && c.bounds && f(c.bounds.midX) && f(c.bounds.midY) && (c.plotX = c.bounds.midX * d.scaleX + d.translateX, c.plotY = c.bounds.midY * d.scaleY + d.translateY);
          a && (c.shapeType = "path", c.shapeArgs = {
            d: B.getProjectedPath(c, b)
          });
        });
        q(this, "afterTranslate");
      };
      d.defaultOptions = y(r.defaultOptions, {
        animation: !1,
        dataLabels: {
          crop: !1,
          formatter: function () {
            var a = this.series.chart.numberFormatter,
              c = this.point.value;
            return f(c) ? a(c, -1) : "";
          },
          inside: !0,
          overflow: !1,
          padding: 0,
          verticalAlign: "middle"
        },
        marker: null,
        nullColor: "#f7f7f7",
        stickyTracking: !1,
        tooltip: {
          followPointer: !0,
          pointFormat: "{point.name}: {point.value}<br/>"
        },
        turboThreshold: 0,
        allAreas: !0,
        borderColor: "#cccccc",
        borderWidth: 1,
        joinBy: "hc-key",
        states: {
          hover: {
            halo: null,
            brightness: .2
          },
          normal: {
            animation: !0
          },
          select: {
            color: "#cccccc"
          },
          inactive: {
            opacity: 1
          }
        }
      });
      return d;
    }(r);
    D(d.prototype, {
      type: "map",
      axisTypes: p.SeriesMixin.axisTypes,
      colorAttribs: p.SeriesMixin.colorAttribs,
      colorKey: p.SeriesMixin.colorKey,
      directTouch: !0,
      drawDataLabels: b,
      drawGraph: b,
      drawLegendSymbol: w.drawRectangle,
      forceDL: !0,
      getCenter: A.getCenter,
      getExtremesFromAll: !0,
      getSymbol: p.SeriesMixin.getSymbol,
      isCartesian: !1,
      parallelArrays: p.SeriesMixin.parallelArrays,
      pointArrayMap: p.SeriesMixin.pointArrayMap,
      pointClass: B,
      preserveAspectRatio: !0,
      searchPoint: b,
      trackerGroups: p.SeriesMixin.trackerGroups,
      useMapGeometry: !0
    });
    n.registerSeriesType("map", d);
    "";
    return d;
  });
  G(b, "Series/MapLine/MapLineSeries.js", [b["Series/Map/MapSeries.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = this && this.__extends || function () {
        var b = function (k, n) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (b, d) {
            b.__proto__ = d;
          } || function (b, d) {
            for (var a in d) d.hasOwnProperty(a) && (b[a] = d[a]);
          };
          return b(k, n);
        };
        return function (k, n) {
          function h() {
            this.constructor = k;
          }
          b(k, n);
          k.prototype = null === n ? Object.create(n) : (h.prototype = n.prototype, new h());
        };
      }(),
      w = p.series,
      D = A.extend,
      B = A.merge;
    A = function (k) {
      function p() {
        var b = null !== k && k.apply(this, arguments) || this;
        b.data = void 0;
        b.options = void 0;
        b.points = void 0;
        return b;
      }
      v(p, k);
      p.prototype.pointAttribs = function (k, h) {
        k = b.prototype.pointAttribs.call(this, k, h);
        k.fill = this.options.fillColor;
        return k;
      };
      p.defaultOptions = B(b.defaultOptions, {
        lineWidth: 1,
        fillColor: "none"
      });
      return p;
    }(b);
    D(A.prototype, {
      type: "mapline",
      colorProp: "stroke",
      drawLegendSymbol: w.prototype.drawLegendSymbol,
      pointAttrToOptions: {
        stroke: "color",
        "stroke-width": "lineWidth"
      }
    });
    p.registerSeriesType("mapline", A);
    "";
    return A;
  });
  G(b, "Series/MapPoint/MapPointPoint.js", [b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = this && this.__extends || function () {
        var b = function (p, k) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (b, k) {
            b.__proto__ = k;
          } || function (b, k) {
            for (var h in k) k.hasOwnProperty(h) && (b[h] = k[h]);
          };
          return b(p, k);
        };
        return function (p, k) {
          function t() {
            this.constructor = p;
          }
          b(p, k);
          p.prototype = null === k ? Object.create(k) : (t.prototype = k.prototype, new t());
        };
      }(),
      E = p.isNumber,
      w = p.merge;
    return function (b) {
      function p() {
        var k = null !== b && b.apply(this, arguments) || this;
        k.options = void 0;
        k.series = void 0;
        return k;
      }
      v(p, b);
      p.prototype.applyOptions = function (k, p) {
        k = "undefined" !== typeof k.lat && "undefined" !== typeof k.lon ? w(k, this.series.chart.fromLatLonToPoint(k)) : k;
        return b.prototype.applyOptions.call(this, k, p);
      };
      p.prototype.isValid = function () {
        return !!(this.options.geometry || E(this.x) && E(this.y));
      };
      return p;
    }(b.seriesTypes.scatter.prototype.pointClass);
  });
  G(b, "Series/MapPoint/MapPointSeries.js", [b["Core/Globals.js"], b["Series/MapPoint/MapPointPoint.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E) {
    var v = this && this.__extends || function () {
      var b = function (d, a) {
        b = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (a, b) {
          a.__proto__ = b;
        } || function (a, b) {
          for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
        };
        return b(d, a);
      };
      return function (d, a) {
        function e() {
          this.constructor = d;
        }
        b(d, a);
        d.prototype = null === a ? Object.create(a) : (e.prototype = a.prototype, new e());
      };
    }();
    b = b.noop;
    var D = A.seriesTypes.scatter,
      B = E.extend,
      k = E.fireEvent,
      t = E.isNumber,
      n = E.merge;
    E = function (b) {
      function d() {
        var a = null !== b && b.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      v(d, b);
      d.prototype.drawDataLabels = function () {
        b.prototype.drawDataLabels.call(this);
        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
      };
      d.prototype.translate = function () {
        var a = this,
          b = this.chart.mapView;
        this.processedXData || this.processData();
        this.generatePoints();
        if (b) {
          var d = b.projection,
            h = d.forward,
            n = d.hasCoordinates;
          this.points.forEach(function (d) {
            var e = d.x;
            e = void 0 === e ? void 0 : e;
            var g = d.y;
            g = void 0 === g ? void 0 : g;
            var k = d.options.geometry;
            (k = k && "Point" === k.type && k.coordinates) ? (g = h(k), e = g[0], g = g[1]) : d.bounds && (e = d.bounds.midX, g = d.bounds.midY);
            t(e) && t(g) ? (e = b.projectedUnitsToPixels({
              x: e,
              y: g
            }), d.plotX = e.x, d.plotY = n ? e.y : a.chart.plotHeight - e.y) : (d.plotX = void 0, d.plotY = void 0);
            d.isInside = a.isPointInside(d);
            d.zone = a.zones.length ? d.getZone() : void 0;
          });
        }
        k(this, "afterTranslate");
      };
      d.defaultOptions = n(D.defaultOptions, {
        dataLabels: {
          crop: !1,
          defer: !1,
          enabled: !0,
          formatter: function () {
            return this.point.name;
          },
          overflow: !1,
          style: {
            color: "#000000"
          }
        }
      });
      return d;
    }(D);
    B(E.prototype, {
      type: "mappoint",
      axisTypes: ["colorAxis"],
      forceDL: !0,
      isCartesian: !1,
      pointClass: p,
      searchPoint: b,
      useMapGeometry: !0
    });
    A.registerSeriesType("mappoint", E);
    "";
    return E;
  });
  G(b, "Series/Bubble/BubbleLegendDefaults.js", [], function () {
    return {
      borderColor: void 0,
      borderWidth: 2,
      className: void 0,
      color: void 0,
      connectorClassName: void 0,
      connectorColor: void 0,
      connectorDistance: 60,
      connectorWidth: 1,
      enabled: !1,
      labels: {
        className: void 0,
        allowOverlap: !1,
        format: "",
        formatter: void 0,
        align: "right",
        style: {
          fontSize: "10px",
          color: "#000000"
        },
        x: 0,
        y: 0
      },
      maxSize: 60,
      minSize: 10,
      legendIndex: 0,
      ranges: {
        value: void 0,
        borderColor: void 0,
        color: void 0,
        connectorColor: void 0
      },
      sizeBy: "area",
      sizeByAbsoluteValue: !1,
      zIndex: 1,
      zThreshold: 0
    };
  });
  G(b, "Series/Bubble/BubbleLegendItem.js", [b["Core/Color/Color.js"], b["Core/FormatUtilities.js"], b["Core/Globals.js"], b["Core/Utilities.js"]], function (b, p, A, E) {
    var v = b.parse,
      D = A.noop,
      B = E.arrayMax,
      k = E.arrayMin,
      t = E.isNumber,
      n = E.merge,
      h = E.pick,
      d = E.stableSort;
    "";
    return function () {
      function a(a, b) {
        this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legendSymbol = this.legendItemWidth = this.legendItemHeight = this.legendItem = this.legendGroup = this.legend = this.fontMetrics = this.chart = void 0;
        this.setState = D;
        this.init(a, b);
      }
      a.prototype.init = function (a, b) {
        this.options = a;
        this.visible = !0;
        this.chart = b.chart;
        this.legend = b;
      };
      a.prototype.addToLegend = function (a) {
        a.splice(this.options.legendIndex, 0, this);
      };
      a.prototype.drawLegendSymbol = function (a) {
        var b = this.chart,
          e = this.options,
          k = h(a.options.itemDistance, 20),
          n = e.ranges,
          q = e.connectorDistance;
        this.fontMetrics = b.renderer.fontMetrics(e.labels.style.fontSize);
        n && n.length && t(n[0].value) ? (d(n, function (a, b) {
          return b.value - a.value;
        }), this.ranges = n, this.setOptions(), this.render(), a = this.getMaxLabelSize(), n = this.ranges[0].radius, b = 2 * n, q = q - n + a.width, q = 0 < q ? q : 0, this.maxLabel = a, this.movementX = "left" === e.labels.align ? q : 0, this.legendItemWidth = b + q + k, this.legendItemHeight = b + this.fontMetrics.h / 2) : a.options.bubbleLegend.autoRanges = !0;
      };
      a.prototype.setOptions = function () {
        var a = this.ranges,
          b = this.options,
          d = this.chart.series[b.seriesIndex],
          k = this.legend.baseline,
          r = {
            zIndex: b.zIndex,
            "stroke-width": b.borderWidth
          },
          q = {
            zIndex: b.zIndex,
            "stroke-width": b.connectorWidth
          },
          p = {
            align: this.legend.options.rtl || "left" === b.labels.align ? "right" : "left",
            zIndex: b.zIndex
          },
          m = d.options.marker.fillOpacity,
          f = this.chart.styledMode;
        a.forEach(function (e, c) {
          f || (r.stroke = h(e.borderColor, b.borderColor, d.color), r.fill = h(e.color, b.color, 1 !== m ? v(d.color).setOpacity(m).get("rgba") : d.color), q.stroke = h(e.connectorColor, b.connectorColor, d.color));
          a[c].radius = this.getRangeRadius(e.value);
          a[c] = n(a[c], {
            center: a[0].radius - a[c].radius + k
          });
          f || n(!0, a[c], {
            bubbleAttribs: n(r),
            connectorAttribs: n(q),
            labelAttribs: p
          });
        }, this);
      };
      a.prototype.getRangeRadius = function (a) {
        var b = this.options;
        return this.chart.series[this.options.seriesIndex].getRadius.call(this, b.ranges[b.ranges.length - 1].value, b.ranges[0].value, b.minSize, b.maxSize, a);
      };
      a.prototype.render = function () {
        var a = this.chart.renderer,
          b = this.options.zThreshold;
        this.symbols || (this.symbols = {
          connectors: [],
          bubbleItems: [],
          labels: []
        });
        this.legendSymbol = a.g("bubble-legend");
        this.legendItem = a.g("bubble-legend-item");
        this.legendSymbol.translateX = 0;
        this.legendSymbol.translateY = 0;
        this.ranges.forEach(function (a) {
          a.value >= b && this.renderRange(a);
        }, this);
        this.legendSymbol.add(this.legendItem);
        this.legendItem.add(this.legendGroup);
        this.hideOverlappingLabels();
      };
      a.prototype.renderRange = function (a) {
        var b = this.options,
          d = b.labels,
          e = this.chart,
          h = e.series[b.seriesIndex],
          k = e.renderer,
          n = this.symbols;
        e = n.labels;
        var m = a.center,
          f = Math.abs(a.radius),
          p = b.connectorDistance || 0,
          c = d.align,
          t = b.connectorWidth,
          l = this.ranges[0].radius || 0,
          v = m - f - b.borderWidth / 2 + t / 2,
          w = this.fontMetrics;
        w = w.f / 2 - (w.h - w.f) / 2;
        var B = k.styledMode;
        p = this.legend.options.rtl || "left" === c ? -p : p;
        "center" === c && (p = 0, b.connectorDistance = 0, a.labelAttribs.align = "center");
        c = v + b.labels.y;
        var D = l + p + b.labels.x;
        n.bubbleItems.push(k.circle(l, m + ((v % 1 ? 1 : .5) - (t % 2 ? 0 : .5)), f).attr(B ? {} : a.bubbleAttribs).addClass((B ? "highcharts-color-" + h.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (b.className || "")).add(this.legendSymbol));
        n.connectors.push(k.path(k.crispLine([["M", l, v], ["L", l + p, v]], b.connectorWidth)).attr(B ? {} : a.connectorAttribs).addClass((B ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (b.connectorClassName || "")).add(this.legendSymbol));
        a = k.text(this.formatLabel(a), D, c + w).attr(B ? {} : a.labelAttribs).css(B ? {} : d.style).addClass("highcharts-bubble-legend-labels " + (b.labels.className || "")).add(this.legendSymbol);
        e.push(a);
        a.placed = !0;
        a.alignAttr = {
          x: D,
          y: c + w
        };
      };
      a.prototype.getMaxLabelSize = function () {
        var a, b;
        this.symbols.labels.forEach(function (d) {
          b = d.getBBox(!0);
          a = a ? b.width > a.width ? b : a : b;
        });
        return a || {};
      };
      a.prototype.formatLabel = function (a) {
        var b = this.options,
          d = b.labels.formatter;
        b = b.labels.format;
        var e = this.chart.numberFormatter;
        return b ? p.format(b, a) : d ? d.call(a) : e(a.value, 1);
      };
      a.prototype.hideOverlappingLabels = function () {
        var a = this.chart,
          b = this.symbols;
        !this.options.labels.allowOverlap && b && (a.hideOverlappingLabels(b.labels), b.labels.forEach(function (a, d) {
          a.newOpacity ? a.newOpacity !== a.oldOpacity && b.connectors[d].show() : b.connectors[d].hide();
        }));
      };
      a.prototype.getRanges = function () {
        var a = this.legend.bubbleLegend,
          b = a.options.ranges,
          d,
          p = Number.MAX_VALUE,
          r = -Number.MAX_VALUE;
        a.chart.series.forEach(function (a) {
          a.isBubble && !a.ignoreSeries && (d = a.zData.filter(t), d.length && (p = h(a.options.zMin, Math.min(p, Math.max(k(d), !1 === a.options.displayNegative ? a.options.zThreshold : -Number.MAX_VALUE))), r = h(a.options.zMax, Math.max(r, B(d)))));
        });
        var q = p === r ? [{
          value: r
        }] : [{
          value: p
        }, {
          value: (p + r) / 2
        }, {
          value: r,
          autoRanges: !0
        }];
        b.length && b[0].radius && q.reverse();
        q.forEach(function (a, d) {
          b && b[d] && (q[d] = n(b[d], a));
        });
        return q;
      };
      a.prototype.predictBubbleSizes = function () {
        var a = this.chart,
          b = this.fontMetrics,
          d = a.legend.options,
          h = d.floating,
          k = (d = "horizontal" === d.layout) ? a.legend.lastLineHeight : 0,
          n = a.plotSizeX,
          p = a.plotSizeY,
          m = a.series[this.options.seriesIndex],
          f = m.getPxExtremes();
        a = Math.ceil(f.minPxSize);
        f = Math.ceil(f.maxPxSize);
        var t = Math.min(p, n);
        m = m.options.maxSize;
        if (h || !/%$/.test(m)) b = f;else if (m = parseFloat(m), b = (t + k - b.h / 2) * m / 100 / (m / 100 + 1), d && p - b >= n || !d && n - b >= p) b = f;
        return [a, Math.ceil(b)];
      };
      a.prototype.updateRanges = function (a, b) {
        var d = this.legend.options.bubbleLegend;
        d.minSize = a;
        d.maxSize = b;
        d.ranges = this.getRanges();
      };
      a.prototype.correctSizes = function () {
        var a = this.legend,
          b = this.chart.series[this.options.seriesIndex].getPxExtremes();
        1 < Math.abs(Math.ceil(b.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, b.maxPxSize), a.render());
      };
      return a;
    }();
  });
  G(b, "Series/Bubble/BubbleLegendComposition.js", [b["Series/Bubble/BubbleLegendDefaults.js"], b["Series/Bubble/BubbleLegendItem.js"], b["Core/DefaultOptions.js"], b["Core/Utilities.js"]], function (b, p, A, E) {
    var v = A.setOptions,
      D = E.addEvent,
      B = E.objectEach,
      k = E.wrap,
      t;
    (function (n) {
      function h(b, e, g) {
        var h = this.legend,
          f = 0 <= d(this);
        if (h && h.options.enabled && h.bubbleLegend && h.options.bubbleLegend.autoRanges && f) {
          var k = h.bubbleLegend.options;
          f = h.bubbleLegend.predictBubbleSizes();
          h.bubbleLegend.updateRanges(f[0], f[1]);
          k.placed || (h.group.placed = !1, h.allItems.forEach(function (a) {
            a.legendGroup.translateY = null;
          }));
          h.render();
          this.getMargins();
          this.axes.forEach(function (a) {
            a.visible && a.render();
            k.placed || (a.setScale(), a.updateNames(), B(a.ticks, function (a) {
              a.isNew = !0;
              a.isNewLabel = !0;
            }));
          });
          k.placed = !0;
          this.getMargins();
          b.call(this, e, g);
          h.bubbleLegend.correctSizes();
          t(h, a(h));
        } else b.call(this, e, g), h && h.options.enabled && h.bubbleLegend && (h.render(), t(h, a(h)));
      }
      function d(a) {
        a = a.series;
        for (var b = 0; b < a.length;) {
          if (a[b] && a[b].isBubble && a[b].visible && a[b].zData.length) return b;
          b++;
        }
        return -1;
      }
      function a(a) {
        a = a.allItems;
        var b = [],
          d = a.length,
          e,
          f = 0;
        for (e = 0; e < d; e++) if (a[e].legendItemHeight && (a[e].itemHeight = a[e].legendItemHeight), a[e] === a[d - 1] || a[e + 1] && a[e]._legendItemPos[1] !== a[e + 1]._legendItemPos[1]) {
          b.push({
            height: 0
          });
          var g = b[b.length - 1];
          for (f; f <= e; f++) a[f].itemHeight > g.height && (g.height = a[f].itemHeight);
          g.step = e;
        }
        return b;
      }
      function e(a) {
        var b = this.bubbleLegend,
          e = this.options,
          g = e.bubbleLegend,
          f = d(this.chart);
        b && b.ranges && b.ranges.length && (g.ranges.length && (g.autoRanges = !!g.ranges[0].autoRanges), this.destroyItem(b));
        0 <= f && e.enabled && g.enabled && (g.seriesIndex = f, this.bubbleLegend = new p(g, this), this.bubbleLegend.addToLegend(a.allItems));
      }
      function g() {
        var a = this.chart,
          b = this.visible,
          e = this.chart.legend;
        e && e.bubbleLegend && (this.visible = !b, this.ignoreSeries = b, a = 0 <= d(a), e.bubbleLegend.visible !== a && (e.update({
          bubbleLegend: {
            enabled: a
          }
        }), e.bubbleLegend.visible = a), this.visible = b);
      }
      function t(a, b) {
        var d = a.options.rtl,
          e,
          f,
          g,
          c = 0;
        a.allItems.forEach(function (a, h) {
          e = a.legendGroup.translateX;
          f = a._legendItemPos[1];
          if ((g = a.movementX) || d && a.ranges) g = d ? e - a.options.maxSize / 2 : e + g, a.legendGroup.attr({
            translateX: g
          });
          h > b[c].step && c++;
          a.legendGroup.attr({
            translateY: Math.round(f + b[c].height / 2)
          });
          a._legendItemPos[1] = f + b[c].height / 2;
        });
      }
      var w = [];
      n.compose = function (a, d, n) {
        -1 === w.indexOf(a) && (w.push(a), v({
          legend: {
            bubbleLegend: b
          }
        }), k(a.prototype, "drawChartBox", h));
        -1 === w.indexOf(d) && (w.push(d), D(d, "afterGetAllItems", e));
        -1 === w.indexOf(n) && (w.push(n), D(n, "legendItemClick", g));
      };
    })(t || (t = {}));
    return t;
  });
  G(b, "Series/Bubble/BubblePoint.js", [b["Core/Series/Point.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A) {
    var v = this && this.__extends || function () {
      var b = function (p, v) {
        b = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (b, p) {
          b.__proto__ = p;
        } || function (b, p) {
          for (var k in p) p.hasOwnProperty(k) && (b[k] = p[k]);
        };
        return b(p, v);
      };
      return function (p, v) {
        function k() {
          this.constructor = p;
        }
        b(p, v);
        p.prototype = null === v ? Object.create(v) : (k.prototype = v.prototype, new k());
      };
    }();
    A = A.extend;
    p = function (p) {
      function w() {
        var b = null !== p && p.apply(this, arguments) || this;
        b.options = void 0;
        b.series = void 0;
        return b;
      }
      v(w, p);
      w.prototype.haloPath = function (p) {
        return b.prototype.haloPath.call(this, 0 === p ? 0 : (this.marker ? this.marker.radius || 0 : 0) + p);
      };
      return w;
    }(p.seriesTypes.scatter.prototype.pointClass);
    A(p.prototype, {
      ttBelow: !1
    });
    return p;
  });
  G(b, "Series/Bubble/BubbleSeries.js", [b["Core/Axis/Axis.js"], b["Series/Bubble/BubbleLegendComposition.js"], b["Series/Bubble/BubblePoint.js"], b["Core/Color/Color.js"], b["Core/Globals.js"], b["Core/Series/Series.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D, B, k) {
    var t = this && this.__extends || function () {
        var a = function (b, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);
          };
          return a(b, d);
        };
        return function (b, d) {
          function e() {
            this.constructor = b;
          }
          a(b, d);
          b.prototype = null === d ? Object.create(d) : (e.prototype = d.prototype, new e());
        };
      }(),
      n = E.parse;
    E = w.noop;
    var h = B.seriesTypes;
    w = h.column;
    var d = h.scatter;
    h = k.addEvent;
    var a = k.arrayMax,
      e = k.arrayMin,
      g = k.clamp,
      v = k.extend,
      C = k.isNumber,
      r = k.merge,
      q = k.pick;
    k = function (b) {
      function h() {
        var a = null !== b && b.apply(this, arguments) || this;
        a.data = void 0;
        a.maxPxSize = void 0;
        a.minPxSize = void 0;
        a.options = void 0;
        a.points = void 0;
        a.radii = void 0;
        a.yData = void 0;
        a.zData = void 0;
        return a;
      }
      t(h, b);
      h.prototype.animate = function (a) {
        !a && this.points.length < this.options.animationLimit && this.points.forEach(function (a) {
          var c = a.graphic;
          c && c.width && (this.hasRendered || c.attr({
            x: a.plotX,
            y: a.plotY,
            width: 1,
            height: 1
          }), c.animate(this.markerAttribs(a), this.options.animation));
        }, this);
      };
      h.prototype.getRadii = function () {
        var a = this,
          b = this.zData,
          c = this.yData,
          d = [],
          e = this.chart.bubbleZExtremes;
        var g = this.getPxExtremes();
        var h = g.minPxSize,
          k = g.maxPxSize;
        if (!e) {
          var m = Number.MAX_VALUE,
            n = -Number.MAX_VALUE,
            p;
          this.chart.series.forEach(function (b) {
            b.bubblePadding && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && (b = b.getZExtremes()) && (m = Math.min(m || b.zMin, b.zMin), n = Math.max(n || b.zMax, b.zMax), p = !0);
          });
          p ? (e = {
            zMin: m,
            zMax: n
          }, this.chart.bubbleZExtremes = e) : e = {
            zMin: 0,
            zMax: 0
          };
        }
        var q = 0;
        for (g = b.length; q < g; q++) {
          var r = b[q];
          d.push(this.getRadius(e.zMin, e.zMax, h, k, r, c[q]));
        }
        this.radii = d;
      };
      h.prototype.getRadius = function (a, b, c, d, e, g) {
        var f = this.options,
          h = "width" !== f.sizeBy,
          k = f.zThreshold,
          l = b - a,
          m = .5;
        if (null === g || null === e) return null;
        if (C(e)) {
          f.sizeByAbsoluteValue && (e = Math.abs(e - k), l = Math.max(b - k, Math.abs(a - k)), a = 0);
          if (e < a) return c / 2 - 1;
          0 < l && (m = (e - a) / l);
        }
        h && 0 <= m && (m = Math.sqrt(m));
        return Math.ceil(c + m * (d - c)) / 2;
      };
      h.prototype.hasData = function () {
        return !!this.processedXData.length;
      };
      h.prototype.pointAttribs = function (a, b) {
        var c = this.options.marker.fillOpacity;
        a = D.prototype.pointAttribs.call(this, a, b);
        1 !== c && (a.fill = n(a.fill).setOpacity(c).get("rgba"));
        return a;
      };
      h.prototype.translate = function () {
        b.prototype.translate.call(this);
        this.getRadii();
        this.translateBubble();
      };
      h.prototype.translateBubble = function () {
        for (var a = this.data, b = this.radii, c = this.getPxExtremes().minPxSize, d = a.length; d--;) {
          var e = a[d],
            g = b ? b[d] : 0;
          C(g) && g >= c / 2 ? (e.marker = v(e.marker, {
            radius: g,
            width: 2 * g,
            height: 2 * g
          }), e.dlBox = {
            x: e.plotX - g,
            y: e.plotY - g,
            width: 2 * g,
            height: 2 * g
          }) : e.shapeArgs = e.plotY = e.dlBox = void 0;
        }
      };
      h.prototype.getPxExtremes = function () {
        var a = Math.min(this.chart.plotWidth, this.chart.plotHeight),
          b = function (b) {
            if ("string" === typeof b) {
              var c = /%$/.test(b);
              b = parseInt(b, 10);
            }
            return c ? a * b / 100 : b;
          },
          c = b(q(this.options.minSize, 8));
        b = Math.max(b(q(this.options.maxSize, "20%")), c);
        return {
          minPxSize: c,
          maxPxSize: b
        };
      };
      h.prototype.getZExtremes = function () {
        var b = this.options,
          d = (this.zData || []).filter(C);
        if (d.length) {
          var c = q(b.zMin, g(e(d), !1 === b.displayNegative ? b.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));
          b = q(b.zMax, a(d));
          if (C(c) && C(b)) return {
            zMin: c,
            zMax: b
          };
        }
      };
      h.compose = p.compose;
      h.defaultOptions = r(d.defaultOptions, {
        dataLabels: {
          formatter: function () {
            var a = this.series.chart.numberFormatter,
              b = this.point.z;
            return C(b) ? a(b, -1) : "";
          },
          inside: !0,
          verticalAlign: "middle"
        },
        animationLimit: 250,
        marker: {
          lineColor: null,
          lineWidth: 1,
          fillOpacity: .5,
          radius: null,
          states: {
            hover: {
              radiusPlus: 0
            }
          },
          symbol: "circle"
        },
        minSize: 8,
        maxSize: "20%",
        softThreshold: !1,
        states: {
          hover: {
            halo: {
              size: 5
            }
          }
        },
        tooltip: {
          pointFormat: "({point.x}, {point.y}), Size: {point.z}"
        },
        turboThreshold: 0,
        zThreshold: 0,
        zoneAxis: "z"
      });
      return h;
    }(d);
    v(k.prototype, {
      alignDataLabel: w.prototype.alignDataLabel,
      applyZones: E,
      bubblePadding: !0,
      buildKDTree: E,
      directTouch: !0,
      isBubble: !0,
      pointArrayMap: ["y", "z"],
      pointClass: A,
      parallelArrays: ["x", "y", "z"],
      trackerGroups: ["group", "dataLabelsGroup"],
      specialGroup: "group",
      zoneAxis: "z"
    });
    h(k, "updatedData", function (a) {
      delete a.target.chart.bubbleZExtremes;
    });
    b.prototype.beforePadding = function () {
      var a = this,
        b = this.len,
        d = this.chart,
        e = 0,
        c = b,
        g = this.isXAxis,
        h = g ? "xData" : "yData",
        k = this.min,
        n = this.max - k,
        p = b / n,
        r;
      this.series.forEach(function (b) {
        if (b.bubblePadding && (b.visible || !d.options.chart.ignoreHiddenSeries)) {
          r = a.allowZoomOutside = !0;
          var f = b[h];
          g && b.getRadii(0, 0, b);
          if (0 < n) for (var m = f.length; m--;) if (C(f[m]) && a.dataMin <= f[m] && f[m] <= a.max) {
            var l = b.radii && b.radii[m] || 0;
            e = Math.min((f[m] - k) * p - l, e);
            c = Math.max((f[m] - k) * p + l, c);
          }
        }
      });
      r && 0 < n && !this.logarithmic && (c -= b, p *= (b + Math.max(0, e) - Math.min(c, b)) / b, [["min", "userMin", e], ["max", "userMax", c]].forEach(function (b) {
        "undefined" === typeof q(a.options[b[0]], a[b[1]]) && (a[b[0]] += b[2] / p);
      }));
    };
    B.registerSeriesType("bubble", k);
    "";
    "";
    return k;
  });
  G(b, "Series/MapBubble/MapBubblePoint.js", [b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = this && this.__extends || function () {
      var b = function (p, k) {
        b = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (b, k) {
          b.__proto__ = k;
        } || function (b, k) {
          for (var h in k) k.hasOwnProperty(h) && (b[h] = k[h]);
        };
        return b(p, k);
      };
      return function (p, k) {
        function t() {
          this.constructor = p;
        }
        b(p, k);
        p.prototype = null === k ? Object.create(k) : (t.prototype = k.prototype, new t());
      };
    }();
    b = b.seriesTypes;
    var E = b.map,
      w = p.merge;
    return function (b) {
      function p() {
        return null !== b && b.apply(this, arguments) || this;
      }
      v(p, b);
      p.prototype.applyOptions = function (k, p) {
        return k && "undefined" !== typeof k.lat && "undefined" !== typeof k.lon ? b.prototype.applyOptions.call(this, w(k, this.series.chart.fromLatLonToPoint(k)), p) : E.prototype.pointClass.prototype.applyOptions.call(this, k, p);
      };
      p.prototype.isValid = function () {
        return "number" === typeof this.z;
      };
      return p;
    }(b.bubble.prototype.pointClass);
  });
  G(b, "Series/MapBubble/MapBubbleSeries.js", [b["Series/Bubble/BubbleSeries.js"], b["Series/MapBubble/MapBubblePoint.js"], b["Series/Map/MapSeries.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p, A, E, w) {
    var v = this && this.__extends || function () {
        var b = function (h, d) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, b) {
            a.__proto__ = b;
          } || function (a, b) {
            for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
          };
          return b(h, d);
        };
        return function (h, d) {
          function a() {
            this.constructor = h;
          }
          b(h, d);
          h.prototype = null === d ? Object.create(d) : (a.prototype = d.prototype, new a());
        };
      }(),
      B = E.seriesTypes.mappoint,
      k = w.extend,
      t = w.merge;
    w = function (k) {
      function h() {
        var b = null !== k && k.apply(this, arguments) || this;
        b.data = void 0;
        b.options = void 0;
        b.points = void 0;
        return b;
      }
      v(h, k);
      h.prototype.translate = function () {
        B.prototype.translate.call(this);
        this.getRadii();
        this.translateBubble();
      };
      h.compose = b.compose;
      h.defaultOptions = t(b.defaultOptions, {
        animationLimit: 500,
        tooltip: {
          pointFormat: "{point.name}: {point.z}"
        }
      });
      return h;
    }(b);
    k(w.prototype, {
      type: "mapbubble",
      axisTypes: ["colorAxis"],
      getProjectedBounds: A.prototype.getProjectedBounds,
      isCartesian: !1,
      pointArrayMap: ["z"],
      pointClass: p,
      setData: A.prototype.setData,
      setOptions: A.prototype.setOptions,
      useMapGeometry: !0,
      xyFromShape: !0
    });
    E.registerSeriesType("mapbubble", w);
    "";
    return w;
  });
  G(b, "Series/Heatmap/HeatmapPoint.js", [b["Core/Series/SeriesRegistry.js"], b["Core/Utilities.js"]], function (b, p) {
    var v = this && this.__extends || function () {
        var b = function (k, n) {
          b = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (b, d) {
            b.__proto__ = d;
          } || function (b, d) {
            for (var a in d) d.hasOwnProperty(a) && (b[a] = d[a]);
          };
          return b(k, n);
        };
        return function (k, n) {
          function h() {
            this.constructor = k;
          }
          b(k, n);
          k.prototype = null === n ? Object.create(n) : (h.prototype = n.prototype, new h());
        };
      }(),
      E = p.clamp,
      w = p.defined,
      D = p.extend,
      B = p.pick;
    b = function (b) {
      function k() {
        var k = null !== b && b.apply(this, arguments) || this;
        k.options = void 0;
        k.series = void 0;
        k.value = void 0;
        k.x = void 0;
        k.y = void 0;
        return k;
      }
      v(k, b);
      k.prototype.applyOptions = function (k, h) {
        k = b.prototype.applyOptions.call(this, k, h);
        k.formatPrefix = k.isNull || null === k.value ? "null" : "point";
        return k;
      };
      k.prototype.getCellAttributes = function () {
        var b = this.series,
          h = b.options,
          d = (h.colsize || 1) / 2,
          a = (h.rowsize || 1) / 2,
          e = b.xAxis,
          g = b.yAxis,
          k = this.options.marker || b.options.marker;
        b = b.pointPlacementToXValue();
        var p = B(this.pointPadding, h.pointPadding, 0),
          r = {
            x1: E(Math.round(e.len - (e.translate(this.x - d, !1, !0, !1, !0, -b) || 0)), -e.len, 2 * e.len),
            x2: E(Math.round(e.len - (e.translate(this.x + d, !1, !0, !1, !0, -b) || 0)), -e.len, 2 * e.len),
            y1: E(Math.round(g.translate(this.y - a, !1, !0, !1, !0) || 0), -g.len, 2 * g.len),
            y2: E(Math.round(g.translate(this.y + a, !1, !0, !1, !0) || 0), -g.len, 2 * g.len)
          };
        [["width", "x"], ["height", "y"]].forEach(function (a) {
          var b = a[0];
          a = a[1];
          var d = a + "1",
            e = a + "2",
            g = Math.abs(r[d] - r[e]),
            c = k && k.lineWidth || 0,
            h = Math.abs(r[d] + r[e]) / 2;
          b = k && k[b];
          w(b) && b < g && (b = b / 2 + c / 2, r[d] = h - b, r[e] = h + b);
          p && ("y" === a && (d = e, e = a + "1"), r[d] += p, r[e] -= p);
        });
        return r;
      };
      k.prototype.haloPath = function (b) {
        if (!b) return [];
        var h = this.shapeArgs;
        return ["M", h.x - b, h.y - b, "L", h.x - b, h.y + h.height + b, h.x + h.width + b, h.y + h.height + b, h.x + h.width + b, h.y - b, "Z"];
      };
      k.prototype.isValid = function () {
        return Infinity !== this.value && -Infinity !== this.value;
      };
      return k;
    }(b.seriesTypes.scatter.prototype.pointClass);
    D(b.prototype, {
      dataLabelOnNull: !0,
      moveToTopOnHover: !0,
      ttBelow: !1
    });
    return b;
  });
  G(b, "Series/Heatmap/HeatmapSeries.js", [b["Core/Color/Color.js"], b["Series/ColorMapMixin.js"], b["Series/Heatmap/HeatmapPoint.js"], b["Core/Legend/LegendSymbol.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Renderer/SVG/SVGRenderer.js"], b["Core/Utilities.js"]], function (b, p, A, E, w, D, B) {
    var k = this && this.__extends || function () {
        var a = function (b, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, b) {
            a.__proto__ = b;
          } || function (a, b) {
            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
          };
          return a(b, d);
        };
        return function (b, d) {
          function e() {
            this.constructor = b;
          }
          a(b, d);
          b.prototype = null === d ? Object.create(d) : (e.prototype = d.prototype, new e());
        };
      }(),
      t = w.series,
      n = w.seriesTypes,
      h = n.column,
      d = n.scatter,
      a = D.prototype.symbols,
      e = B.extend,
      g = B.fireEvent,
      v = B.isNumber,
      C = B.merge,
      r = B.pick;
    D = function (h) {
      function n() {
        var a = null !== h && h.apply(this, arguments) || this;
        a.colorAxis = void 0;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        a.valueMax = NaN;
        a.valueMin = NaN;
        return a;
      }
      k(n, h);
      n.prototype.drawPoints = function () {
        var a = this;
        if ((this.options.marker || {}).enabled || this._hasPointMarkers) t.prototype.drawPoints.call(this), this.points.forEach(function (b) {
          b.graphic && (b.graphic[a.chart.styledMode ? "css" : "animate"](a.colorAttribs(b)), a.options.borderRadius && b.graphic.attr({
            r: a.options.borderRadius
          }), (b.shapeArgs || {}).r = a.options.borderRadius, (b.shapeArgs || {}).d = b.graphic.pathArray, null === b.value && b.graphic.addClass("highcharts-null-point"));
        });
      };
      n.prototype.getExtremes = function () {
        var a = t.prototype.getExtremes.call(this, this.valueData),
          b = a.dataMin;
        a = a.dataMax;
        v(b) && (this.valueMin = b);
        v(a) && (this.valueMax = a);
        return t.prototype.getExtremes.call(this);
      };
      n.prototype.getValidPoints = function (a, b) {
        return t.prototype.getValidPoints.call(this, a, b, !0);
      };
      n.prototype.hasData = function () {
        return !!this.processedXData.length;
      };
      n.prototype.init = function () {
        t.prototype.init.apply(this, arguments);
        var b = this.options;
        b.pointRange = r(b.pointRange, b.colsize || 1);
        this.yAxis.axisPointRange = b.rowsize || 1;
        a.ellipse = a.circle;
      };
      n.prototype.markerAttribs = function (a, b) {
        var d = a.marker || {},
          c = this.options.marker || {},
          e = a.shapeArgs || {},
          f = {};
        if (a.hasImage) return {
          x: a.plotX,
          y: a.plotY
        };
        if (b) {
          var g = c.states[b] || {};
          var h = d.states && d.states[b] || {};
          [["width", "x"], ["height", "y"]].forEach(function (a) {
            f[a[0]] = (h[a[0]] || g[a[0]] || e[a[0]]) + (h[a[0] + "Plus"] || g[a[0] + "Plus"] || 0);
            f[a[1]] = e[a[1]] + (e[a[0]] - f[a[0]]) / 2;
          });
        }
        return b ? f : e;
      };
      n.prototype.pointAttribs = function (a, d) {
        var e = t.prototype.pointAttribs.call(this, a, d),
          c = this.options || {},
          f = this.chart.options.plotOptions || {},
          g = f.series || {},
          h = f.heatmap || {};
        f = a && a.options.borderColor || c.borderColor || h.borderColor || g.borderColor;
        g = a && a.options.borderWidth || c.borderWidth || h.borderWidth || g.borderWidth || e["stroke-width"];
        e.stroke = a && a.marker && a.marker.lineColor || c.marker && c.marker.lineColor || f || this.color;
        e["stroke-width"] = g;
        d && (a = C(c.states[d], c.marker && c.marker.states[d], a && a.options.states && a.options.states[d] || {}), d = a.brightness, e.fill = a.color || b.parse(e.fill).brighten(d || 0).get(), e.stroke = a.lineColor);
        return e;
      };
      n.prototype.setClip = function (a) {
        var b = this.chart;
        t.prototype.setClip.apply(this, arguments);
        (!1 !== this.options.clip || a) && this.markerGroup.clip((a || this.clipBox) && this.sharedClipKey ? b.sharedClips[this.sharedClipKey] : b.clipRect);
      };
      n.prototype.translate = function () {
        var b = this.options,
          d = b.marker && b.marker.symbol || "rect",
          h = a[d] ? d : "rect",
          c = -1 !== ["circle", "square"].indexOf(h);
        this.generatePoints();
        this.points.forEach(function (b) {
          var f = b.getCellAttributes(),
            g = {};
          g.x = Math.min(f.x1, f.x2);
          g.y = Math.min(f.y1, f.y2);
          g.width = Math.max(Math.abs(f.x2 - f.x1), 0);
          g.height = Math.max(Math.abs(f.y2 - f.y1), 0);
          var k = b.hasImage = 0 === (b.marker && b.marker.symbol || d || "").indexOf("url");
          if (c) {
            var m = Math.abs(g.width - g.height);
            g.x = Math.min(f.x1, f.x2) + (g.width < g.height ? 0 : m / 2);
            g.y = Math.min(f.y1, f.y2) + (g.width < g.height ? m / 2 : 0);
            g.width = g.height = Math.min(g.width, g.height);
          }
          m = {
            plotX: (f.x1 + f.x2) / 2,
            plotY: (f.y1 + f.y2) / 2,
            clientX: (f.x1 + f.x2) / 2,
            shapeType: "path",
            shapeArgs: C(!0, g, {
              d: a[h](g.x, g.y, g.width, g.height)
            })
          };
          k && (b.marker = {
            width: g.width,
            height: g.height
          });
          e(b, m);
        });
        g(this, "afterTranslate");
      };
      n.defaultOptions = C(d.defaultOptions, {
        animation: !1,
        borderRadius: 0,
        borderWidth: 0,
        nullColor: "#f7f7f7",
        dataLabels: {
          formatter: function () {
            var a = this.series.chart.numberFormatter,
              b = this.point.value;
            return v(b) ? a(b, -1) : "";
          },
          inside: !0,
          verticalAlign: "middle",
          crop: !1,
          overflow: !1,
          padding: 0
        },
        marker: {
          symbol: "rect",
          radius: 0,
          lineColor: void 0,
          states: {
            hover: {
              lineWidthPlus: 0
            },
            select: {}
          }
        },
        clip: !0,
        pointRange: null,
        tooltip: {
          pointFormat: "{point.x}, {point.y}: {point.value}<br/>"
        },
        states: {
          hover: {
            halo: !1,
            brightness: .2
          }
        }
      });
      return n;
    }(d);
    e(D.prototype, {
      alignDataLabel: h.prototype.alignDataLabel,
      axisTypes: p.SeriesMixin.axisTypes,
      colorAttribs: p.SeriesMixin.colorAttribs,
      colorKey: p.SeriesMixin.colorKey,
      directTouch: !0,
      drawLegendSymbol: E.drawRectangle,
      getExtremesFromAll: !0,
      getSymbol: t.prototype.getSymbol,
      parallelArrays: p.SeriesMixin.parallelArrays,
      pointArrayMap: ["y", "value"],
      pointClass: A,
      trackerGroups: p.SeriesMixin.trackerGroups
    });
    w.registerSeriesType("heatmap", D);
    "";
    "";
    return D;
  });
  G(b, "Extensions/GeoJSON.js", [b["Core/Chart/Chart.js"], b["Core/FormatUtilities.js"], b["Core/Globals.js"], b["Core/Utilities.js"]], function (b, p, A, E) {
    function v(b, d) {
      var a,
        e = !1,
        g = b.x,
        h = b.y;
      b = 0;
      for (a = d.length - 1; b < d.length; a = b++) {
        var k = d[b][1] > h;
        var n = d[a][1] > h;
        k !== n && g < (d[a][0] - d[b][0]) * (h - d[b][1]) / (d[a][1] - d[b][1]) + d[b][0] && (e = !e);
      }
      return e;
    }
    var D = p.format,
      B = A.win,
      k = E.error,
      t = E.extend,
      n = E.merge;
    p = E.wrap;
    "";
    b.prototype.transformFromLatLon = function (b, d) {
      var a = this.options.chart.proj4 || B.proj4;
      if (!a) return k(21, !1, this), {
        x: 0,
        y: null
      };
      var e = d.jsonmarginX;
      e = void 0 === e ? 0 : e;
      var g = d.jsonmarginY;
      g = void 0 === g ? 0 : g;
      var h = d.jsonres;
      h = void 0 === h ? 1 : h;
      var n = d.scale;
      n = void 0 === n ? 1 : n;
      var p = d.xoffset;
      p = void 0 === p ? 0 : p;
      var q = d.xpan;
      q = void 0 === q ? 0 : q;
      var t = d.yoffset;
      t = void 0 === t ? 0 : t;
      var m = d.ypan;
      m = void 0 === m ? 0 : m;
      b = a(d.crs, [b.lon, b.lat]);
      a = d.cosAngle || d.rotation && Math.cos(d.rotation);
      var f = d.sinAngle || d.rotation && Math.sin(d.rotation);
      d = d.rotation ? [b[0] * a + b[1] * f, -b[0] * f + b[1] * a] : b;
      return {
        x: ((d[0] - p) * n + q) * h + e,
        y: -(((t - d[1]) * n + m) * h - g)
      };
    };
    b.prototype.transformToLatLon = function (b, d) {
      if (!this.options.chart.proj4 && !B.proj4) k(21, !1, this);else if (null !== b.y) {
        var a = d.jsonmarginX,
          e = d.jsonmarginY,
          g = d.jsonres;
        g = void 0 === g ? 1 : g;
        var h = d.scale;
        h = void 0 === h ? 1 : h;
        var n = d.xoffset,
          p = d.xpan,
          q = d.yoffset,
          t = d.ypan;
        b = {
          x: ((b.x - (void 0 === a ? 0 : a)) / g - (void 0 === p ? 0 : p)) / h + (void 0 === n ? 0 : n),
          y: ((b.y - (void 0 === e ? 0 : e)) / g + (void 0 === t ? 0 : t)) / h + (void 0 === q ? 0 : q)
        };
        a = d.cosAngle || d.rotation && Math.cos(d.rotation);
        e = d.sinAngle || d.rotation && Math.sin(d.rotation);
        d = B.proj4(d.crs, "WGS84", d.rotation ? {
          x: b.x * a + b.y * -e,
          y: b.x * e + b.y * a
        } : b);
        return {
          lat: d.y,
          lon: d.x
        };
      }
    };
    b.prototype.fromPointToLatLon = function (b) {
      var d = this.mapTransforms;
      if (d) {
        for (var a in d) if (Object.hasOwnProperty.call(d, a) && d[a].hitZone && v(b, d[a].hitZone.coordinates[0])) return this.transformToLatLon(b, d[a]);
        return this.transformToLatLon(b, d["default"]);
      }
      k(22, !1, this);
    };
    b.prototype.fromLatLonToPoint = function (b) {
      var d = this.mapTransforms,
        a;
      if (!d) return k(22, !1, this), {
        x: 0,
        y: null
      };
      for (a in d) if (Object.hasOwnProperty.call(d, a) && d[a].hitZone) {
        var e = this.transformFromLatLon(b, d[a]);
        if (v(e, d[a].hitZone.coordinates[0])) return e;
      }
      return this.transformFromLatLon(b, d["default"]);
    };
    A.geojson = function (b, d, a) {
      void 0 === d && (d = "map");
      var e = [];
      b.features.forEach(function (a) {
        var b = a.geometry || {},
          g = b.type;
        b = b.coordinates;
        a = a.properties;
        var h;
        "map" !== d && "mapbubble" !== d || "Polygon" !== g && "MultiPolygon" !== g ? "mapline" !== d || "LineString" !== g && "MultiLineString" !== g ? "mappoint" === d && "Point" === g && b.length && (h = {
          geometry: {
            coordinates: b,
            type: g
          }
        }) : b.length && (h = {
          geometry: {
            coordinates: b,
            type: g
          }
        }) : b.length && (h = {
          geometry: {
            coordinates: b,
            type: g
          }
        });
        h && e.push(t(h, {
          name: a.name || a.NAME,
          properties: a
        }));
      });
      a && b.copyrightShort && (a.chart.mapCredits = D(a.chart.options.credits.mapText, {
        geojson: b
      }), a.chart.mapCreditsFull = D(a.chart.options.credits.mapTextFull, {
        geojson: b
      }));
      return e;
    };
    p(b.prototype, "addCredits", function (b, d) {
      d = n(!0, this.options.credits, d);
      this.mapCredits && (d.href = null);
      b.call(this, d);
      this.credits && this.mapCreditsFull && this.credits.attr({
        title: this.mapCreditsFull
      });
    });
  });
  G(b, "masters/modules/map.src.js", [b["Core/Globals.js"], b["Core/Axis/Color/ColorAxis.js"], b["Series/MapBubble/MapBubbleSeries.js"], b["Core/Chart/MapChart.js"]], function (b, p, A, E) {
    b.ColorAxis = p;
    b.MapChart = E;
    b.mapChart = b.Map = E.mapChart;
    b.maps = E.maps;
    p.compose(b.Chart, b.Fx, b.Legend, b.Series);
    A.compose(b.Chart, b.Legend, b.Series);
  });
  G(b, "masters/highmaps.src.js", [b["masters/highcharts.src.js"]], function (b) {
    b.product = "Highmaps";
    return b;
  });
  b["masters/highmaps.src.js"]._modules = b;
  return b["masters/highmaps.src.js"];
});
//# sourceMappingURL=highmaps.js.map

/***/ }),

/***/ 16150:
/*!**********************************************!*\
  !*** ./node_modules/highcharts/highstock.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highstock JS v9.3.3 (2022-02-01)

 (c) 2009-2021 Torstein Honsi

 License: www.highcharts.com/license
*/


(function (V, N) {
   true && module.exports ? (N["default"] = N, module.exports = V.document ? N(V) : N) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return N(V);
  }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);
})("undefined" !== typeof window ? window : this, function (V) {
  function N(h, E, A, F) {
    h.hasOwnProperty(E) || (h[E] = F.apply(null, A));
  }
  var h = {};
  N(h, "Core/Globals.js", [], function () {
    var h = "undefined" !== typeof V ? V : "undefined" !== typeof window ? window : {},
      E;
    (function (d) {
      d.SVG_NS = "http://www.w3.org/2000/svg";
      d.product = "Highcharts";
      d.version = "9.3.3";
      d.win = h;
      d.doc = d.win.document;
      d.svg = d.doc && d.doc.createElementNS && !!d.doc.createElementNS(d.SVG_NS, "svg").createSVGRect;
      d.userAgent = d.win.navigator && d.win.navigator.userAgent || "";
      d.isChrome = -1 !== d.userAgent.indexOf("Chrome");
      d.isFirefox = -1 !== d.userAgent.indexOf("Firefox");
      d.isMS = /(edge|msie|trident)/i.test(d.userAgent) && !d.win.opera;
      d.isSafari = !d.isChrome && -1 !== d.userAgent.indexOf("Safari");
      d.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(d.userAgent);
      d.isWebKit = -1 !== d.userAgent.indexOf("AppleWebKit");
      d.deg2rad = 2 * Math.PI / 360;
      d.hasBidiBug = d.isFirefox && 4 > parseInt(d.userAgent.split("Firefox/")[1], 10);
      d.hasTouch = !!d.win.TouchEvent;
      d.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
      d.noop = function () {};
      d.supportsPassiveEvents = function () {
        var h = !1;
        if (!d.isMS) {
          var E = Object.defineProperty({}, "passive", {
            get: function () {
              h = !0;
            }
          });
          d.win.addEventListener && d.win.removeEventListener && (d.win.addEventListener("testPassive", d.noop, E), d.win.removeEventListener("testPassive", d.noop, E));
        }
        return h;
      }();
      d.charts = [];
      d.dateFormats = {};
      d.seriesTypes = {};
      d.symbolSizes = {};
      d.chartCount = 0;
    })(E || (E = {}));
    "";
    return E;
  });
  N(h, "Core/Utilities.js", [h["Core/Globals.js"]], function (d) {
    function h(e, g, b, k) {
      var l = g ? "Highcharts error" : "Highcharts warning";
      32 === e && (e = l + ": Deprecated member");
      var r = p(e),
        B = r ? l + " #" + e + ": www.highcharts.com/errors/" + e + "/" : e.toString();
      if ("undefined" !== typeof k) {
        var M = "";
        r && (B += "?");
        I(k, function (b, e) {
          M += "\n - " + e + ": " + b;
          r && (B += encodeURI(e) + "=" + encodeURI(b));
        });
        B += M;
      }
      K(d, "displayError", {
        chart: b,
        code: e,
        message: B,
        params: k
      }, function () {
        if (g) throw Error(B);
        u.console && -1 === h.messages.indexOf(B) && console.warn(B);
      });
      h.messages.push(B);
    }
    function A(e, g) {
      var b = {};
      I(e, function (k, l) {
        if (H(e[l], !0) && !e.nodeType && g[l]) k = A(e[l], g[l]), Object.keys(k).length && (b[l] = k);else if (H(e[l]) || e[l] !== g[l]) b[l] = e[l];
      });
      return b;
    }
    function F(e, g) {
      return parseInt(e, g || 10);
    }
    function t(e) {
      return "string" === typeof e;
    }
    function G(e) {
      e = Object.prototype.toString.call(e);
      return "[object Array]" === e || "[object Array Iterator]" === e;
    }
    function H(e, g) {
      return !!e && "object" === typeof e && (!g || !G(e));
    }
    function y(e) {
      return H(e) && "number" === typeof e.nodeType;
    }
    function q(e) {
      var g = e && e.constructor;
      return !(!H(e, !0) || y(e) || !g || !g.name || "Object" === g.name);
    }
    function p(e) {
      return "number" === typeof e && !isNaN(e) && Infinity > e && -Infinity < e;
    }
    function f(e) {
      return "undefined" !== typeof e && null !== e;
    }
    function c(e, g, b) {
      var l;
      t(g) ? f(b) ? e.setAttribute(g, b) : e && e.getAttribute && ((l = e.getAttribute(g)) || "class" !== g || (l = e.getAttribute(g + "Name"))) : I(g, function (b, g) {
        f(b) ? e.setAttribute(g, b) : e.removeAttribute(g);
      });
      return l;
    }
    function a(e, g) {
      var b;
      e || (e = {});
      for (b in g) e[b] = g[b];
      return e;
    }
    function n() {
      for (var e = arguments, g = e.length, b = 0; b < g; b++) {
        var l = e[b];
        if ("undefined" !== typeof l && null !== l) return l;
      }
    }
    function m(e, g) {
      d.isMS && !d.svg && g && "undefined" !== typeof g.opacity && (g.filter = "alpha(opacity=" + 100 * g.opacity + ")");
      a(e.style, g);
    }
    function D(e, g) {
      return 1E14 < e ? e : parseFloat(e.toPrecision(g || 14));
    }
    function C(e, g, b) {
      var l = d.getStyle || C;
      if ("width" === g) return g = Math.min(e.offsetWidth, e.scrollWidth), b = e.getBoundingClientRect && e.getBoundingClientRect().width, b < g && b >= g - 1 && (g = Math.floor(b)), Math.max(0, g - (l(e, "padding-left", !0) || 0) - (l(e, "padding-right", !0) || 0));
      if ("height" === g) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (l(e, "padding-top", !0) || 0) - (l(e, "padding-bottom", !0) || 0));
      u.getComputedStyle || h(27, !0);
      if (e = u.getComputedStyle(e, void 0)) {
        var k = e.getPropertyValue(g);
        n(b, "opacity" !== g) && (k = F(k));
      }
      return k;
    }
    function I(e, g, b) {
      for (var l in e) Object.hasOwnProperty.call(e, l) && g.call(b || e[l], e[l], l, e);
    }
    function L(e, g, b) {
      function l(b, g) {
        var l = e.removeEventListener || d.removeEventListenerPolyfill;
        l && l.call(e, b, g, !1);
      }
      function k(b) {
        var k;
        if (e.nodeName) {
          if (g) {
            var P = {};
            P[g] = !0;
          } else P = b;
          I(P, function (e, g) {
            if (b[g]) for (k = b[g].length; k--;) l(g, b[g][k].fn);
          });
        }
      }
      var r = "function" === typeof e && e.prototype || e;
      if (Object.hasOwnProperty.call(r, "hcEvents")) {
        var x = r.hcEvents;
        g ? (r = x[g] || [], b ? (x[g] = r.filter(function (e) {
          return b !== e.fn;
        }), l(g, b)) : (k(x), x[g] = [])) : (k(x), delete r.hcEvents);
      }
    }
    function K(e, g, b, l) {
      b = b || {};
      if (z.createEvent && (e.dispatchEvent || e.fireEvent && e !== d)) {
        var k = z.createEvent("Events");
        k.initEvent(g, !0, !0);
        b = a(k, b);
        e.dispatchEvent ? e.dispatchEvent(b) : e.fireEvent(g, b);
      } else if (e.hcEvents) {
        b.target || a(b, {
          preventDefault: function () {
            b.defaultPrevented = !0;
          },
          target: e,
          type: g
        });
        k = [];
        for (var r = e, B = !1; r.hcEvents;) Object.hasOwnProperty.call(r, "hcEvents") && r.hcEvents[g] && (k.length && (B = !0), k.unshift.apply(k, r.hcEvents[g])), r = Object.getPrototypeOf(r);
        B && k.sort(function (b, e) {
          return b.order - e.order;
        });
        k.forEach(function (g) {
          !1 === g.fn.call(e, b) && b.preventDefault();
        });
      }
      l && !b.defaultPrevented && l.call(e, b);
    }
    var v = d.charts,
      z = d.doc,
      u = d.win;
    (h || (h = {})).messages = [];
    Math.easeInOutSine = function (e) {
      return -.5 * (Math.cos(Math.PI * e) - 1);
    };
    var k = Array.prototype.find ? function (e, g) {
      return e.find(g);
    } : function (e, g) {
      var b,
        l = e.length;
      for (b = 0; b < l; b++) if (g(e[b], b)) return e[b];
    };
    I({
      map: "map",
      each: "forEach",
      grep: "filter",
      reduce: "reduce",
      some: "some"
    }, function (e, g) {
      d[g] = function (b) {
        var l;
        h(32, !1, void 0, (l = {}, l["Highcharts." + g] = "use Array." + e, l));
        return Array.prototype[e].apply(b, [].slice.call(arguments, 1));
      };
    });
    var w,
      l = function () {
        var e = Math.random().toString(36).substring(2, 9) + "-",
          g = 0;
        return function () {
          return "highcharts-" + (w ? "" : e) + g++;
        };
      }();
    u.jQuery && (u.jQuery.fn.highcharts = function () {
      var e = [].slice.call(arguments);
      if (this[0]) return e[0] ? (new d[t(e[0]) ? e.shift() : "Chart"](this[0], e[0], e[1]), this) : v[c(this[0], "data-highcharts-chart")];
    });
    k = {
      addEvent: function (e, g, b, l) {
        void 0 === l && (l = {});
        var k = "function" === typeof e && e.prototype || e;
        Object.hasOwnProperty.call(k, "hcEvents") || (k.hcEvents = {});
        k = k.hcEvents;
        d.Point && e instanceof d.Point && e.series && e.series.chart && (e.series.chart.runTrackerClick = !0);
        var r = e.addEventListener || d.addEventListenerPolyfill;
        r && r.call(e, g, b, d.supportsPassiveEvents ? {
          passive: void 0 === l.passive ? -1 !== g.indexOf("touch") : l.passive,
          capture: !1
        } : !1);
        k[g] || (k[g] = []);
        k[g].push({
          fn: b,
          order: "number" === typeof l.order ? l.order : Infinity
        });
        k[g].sort(function (b, e) {
          return b.order - e.order;
        });
        return function () {
          L(e, g, b);
        };
      },
      arrayMax: function (e) {
        for (var g = e.length, b = e[0]; g--;) e[g] > b && (b = e[g]);
        return b;
      },
      arrayMin: function (e) {
        for (var g = e.length, b = e[0]; g--;) e[g] < b && (b = e[g]);
        return b;
      },
      attr: c,
      clamp: function (e, g, b) {
        return e > g ? e < b ? e : b : g;
      },
      cleanRecursively: A,
      clearTimeout: function (e) {
        f(e) && clearTimeout(e);
      },
      correctFloat: D,
      createElement: function (e, g, b, l, k) {
        e = z.createElement(e);
        g && a(e, g);
        k && m(e, {
          padding: "0",
          border: "none",
          margin: "0"
        });
        b && m(e, b);
        l && l.appendChild(e);
        return e;
      },
      css: m,
      defined: f,
      destroyObjectProperties: function (e, g) {
        I(e, function (b, l) {
          b && b !== g && b.destroy && b.destroy();
          delete e[l];
        });
      },
      discardElement: function (e) {
        e && e.parentElement && e.parentElement.removeChild(e);
      },
      erase: function (e, g) {
        for (var b = e.length; b--;) if (e[b] === g) {
          e.splice(b, 1);
          break;
        }
      },
      error: h,
      extend: a,
      extendClass: function (e, g) {
        var b = function () {};
        b.prototype = new e();
        a(b.prototype, g);
        return b;
      },
      find: k,
      fireEvent: K,
      getMagnitude: function (e) {
        return Math.pow(10, Math.floor(Math.log(e) / Math.LN10));
      },
      getNestedProperty: function (e, g) {
        for (e = e.split("."); e.length && f(g);) {
          var b = e.shift();
          if ("undefined" === typeof b || "__proto__" === b) return;
          g = g[b];
          if (!f(g) || "function" === typeof g || "number" === typeof g.nodeType || g === u) return;
        }
        return g;
      },
      getStyle: C,
      inArray: function (e, g, b) {
        h(32, !1, void 0, {
          "Highcharts.inArray": "use Array.indexOf"
        });
        return g.indexOf(e, b);
      },
      isArray: G,
      isClass: q,
      isDOMElement: y,
      isFunction: function (e) {
        return "function" === typeof e;
      },
      isNumber: p,
      isObject: H,
      isString: t,
      keys: function (e) {
        h(32, !1, void 0, {
          "Highcharts.keys": "use Object.keys"
        });
        return Object.keys(e);
      },
      merge: function () {
        var e,
          g = arguments,
          b = {},
          l = function (b, e) {
            "object" !== typeof b && (b = {});
            I(e, function (g, k) {
              "__proto__" !== k && "constructor" !== k && (!H(g, !0) || q(g) || y(g) ? b[k] = e[k] : b[k] = l(b[k] || {}, g));
            });
            return b;
          };
        !0 === g[0] && (b = g[1], g = Array.prototype.slice.call(g, 2));
        var k = g.length;
        for (e = 0; e < k; e++) b = l(b, g[e]);
        return b;
      },
      normalizeTickInterval: function (e, g, b, l, k) {
        var r = e;
        b = n(b, 1);
        var B = e / b;
        g || (g = k ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === l && (1 === b ? g = g.filter(function (b) {
          return 0 === b % 1;
        }) : .1 >= b && (g = [1 / b])));
        for (l = 0; l < g.length && !(r = g[l], k && r * b >= e || !k && B <= (g[l] + (g[l + 1] || g[l])) / 2); l++);
        return r = D(r * b, -Math.round(Math.log(.001) / Math.LN10));
      },
      objectEach: I,
      offset: function (e) {
        var g = z.documentElement;
        e = e.parentElement || e.parentNode ? e.getBoundingClientRect() : {
          top: 0,
          left: 0,
          width: 0,
          height: 0
        };
        return {
          top: e.top + (u.pageYOffset || g.scrollTop) - (g.clientTop || 0),
          left: e.left + (u.pageXOffset || g.scrollLeft) - (g.clientLeft || 0),
          width: e.width,
          height: e.height
        };
      },
      pad: function (e, g, b) {
        return Array((g || 2) + 1 - String(e).replace("-", "").length).join(b || "0") + e;
      },
      pick: n,
      pInt: F,
      relativeLength: function (e, g, b) {
        return /%$/.test(e) ? g * parseFloat(e) / 100 + (b || 0) : parseFloat(e);
      },
      removeEvent: L,
      splat: function (e) {
        return G(e) ? e : [e];
      },
      stableSort: function (e, g) {
        var b = e.length,
          l,
          k;
        for (k = 0; k < b; k++) e[k].safeI = k;
        e.sort(function (b, e) {
          l = g(b, e);
          return 0 === l ? b.safeI - e.safeI : l;
        });
        for (k = 0; k < b; k++) delete e[k].safeI;
      },
      syncTimeout: function (e, g, b) {
        if (0 < g) return setTimeout(e, g, b);
        e.call(0, b);
        return -1;
      },
      timeUnits: {
        millisecond: 1,
        second: 1E3,
        minute: 6E4,
        hour: 36E5,
        day: 864E5,
        week: 6048E5,
        month: 24192E5,
        year: 314496E5
      },
      uniqueKey: l,
      useSerialIds: function (e) {
        return w = n(e, w);
      },
      wrap: function (e, g, b) {
        var l = e[g];
        e[g] = function () {
          var e = Array.prototype.slice.call(arguments),
            g = arguments,
            k = this;
          k.proceed = function () {
            l.apply(k, arguments.length ? arguments : g);
          };
          e.unshift(l);
          e = b.apply(this, e);
          k.proceed = null;
          return e;
        };
      }
    };
    "";
    return k;
  });
  N(h, "Core/Chart/ChartDefaults.js", [], function () {
    return {
      panning: {
        enabled: !1,
        type: "x"
      },
      styledMode: !1,
      borderRadius: 0,
      colorCount: 10,
      defaultSeriesType: "line",
      ignoreHiddenSeries: !0,
      spacing: [10, 10, 15, 10],
      resetZoomButton: {
        theme: {
          zIndex: 6
        },
        position: {
          align: "right",
          x: -10,
          y: 10
        }
      },
      zoomBySingleTouch: !1,
      width: null,
      height: null,
      borderColor: "#335cad",
      backgroundColor: "#ffffff",
      plotBorderColor: "#cccccc"
    };
  });
  N(h, "Core/Color/Color.js", [h["Core/Globals.js"], h["Core/Utilities.js"]], function (d, h) {
    var E = h.isNumber,
      F = h.merge,
      t = h.pInt;
    h = function () {
      function h(E) {
        this.rgba = [NaN, NaN, NaN, NaN];
        this.input = E;
        var y = d.Color;
        if (y && y !== h) return new y(E);
        if (!(this instanceof h)) return new h(E);
        this.init(E);
      }
      h.parse = function (d) {
        return d ? new h(d) : h.None;
      };
      h.prototype.init = function (d) {
        var y;
        if ("object" === typeof d && "undefined" !== typeof d.stops) this.stops = d.stops.map(function (c) {
          return new h(c[1]);
        });else if ("string" === typeof d) {
          this.input = d = h.names[d.toLowerCase()] || d;
          if ("#" === d.charAt(0)) {
            var q = d.length;
            var p = parseInt(d.substr(1), 16);
            7 === q ? y = [(p & 16711680) >> 16, (p & 65280) >> 8, p & 255, 1] : 4 === q && (y = [(p & 3840) >> 4 | (p & 3840) >> 8, (p & 240) >> 4 | p & 240, (p & 15) << 4 | p & 15, 1]);
          }
          if (!y) for (p = h.parsers.length; p-- && !y;) {
            var f = h.parsers[p];
            (q = f.regex.exec(d)) && (y = f.parse(q));
          }
        }
        y && (this.rgba = y);
      };
      h.prototype.get = function (d) {
        var y = this.input,
          q = this.rgba;
        if ("object" === typeof y && "undefined" !== typeof this.stops) {
          var p = F(y);
          p.stops = [].slice.call(p.stops);
          this.stops.forEach(function (f, c) {
            p.stops[c] = [p.stops[c][0], f.get(d)];
          });
          return p;
        }
        return q && E(q[0]) ? "rgb" === d || !d && 1 === q[3] ? "rgb(" + q[0] + "," + q[1] + "," + q[2] + ")" : "a" === d ? "" + q[3] : "rgba(" + q.join(",") + ")" : y;
      };
      h.prototype.brighten = function (d) {
        var y = this.rgba;
        if (this.stops) this.stops.forEach(function (p) {
          p.brighten(d);
        });else if (E(d) && 0 !== d) for (var q = 0; 3 > q; q++) y[q] += t(255 * d), 0 > y[q] && (y[q] = 0), 255 < y[q] && (y[q] = 255);
        return this;
      };
      h.prototype.setOpacity = function (d) {
        this.rgba[3] = d;
        return this;
      };
      h.prototype.tweenTo = function (d, y) {
        var q = this.rgba,
          p = d.rgba;
        if (!E(q[0]) || !E(p[0])) return d.input || "none";
        d = 1 !== p[3] || 1 !== q[3];
        return (d ? "rgba(" : "rgb(") + Math.round(p[0] + (q[0] - p[0]) * (1 - y)) + "," + Math.round(p[1] + (q[1] - p[1]) * (1 - y)) + "," + Math.round(p[2] + (q[2] - p[2]) * (1 - y)) + (d ? "," + (p[3] + (q[3] - p[3]) * (1 - y)) : "") + ")";
      };
      h.names = {
        white: "#ffffff",
        black: "#000000"
      };
      h.parsers = [{
        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        parse: function (d) {
          return [t(d[1]), t(d[2]), t(d[3]), parseFloat(d[4], 10)];
        }
      }, {
        regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
        parse: function (d) {
          return [t(d[1]), t(d[2]), t(d[3]), 1];
        }
      }];
      h.None = new h("");
      return h;
    }();
    "";
    return h;
  });
  N(h, "Core/Color/Palettes.js", [], function () {
    return {
      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ")
    };
  });
  N(h, "Core/Time.js", [h["Core/Globals.js"], h["Core/Utilities.js"]], function (d, h) {
    var E = d.win,
      F = h.defined,
      t = h.error,
      G = h.extend,
      H = h.isObject,
      y = h.merge,
      q = h.objectEach,
      p = h.pad,
      f = h.pick,
      c = h.splat,
      a = h.timeUnits,
      n = d.isSafari && E.Intl && E.Intl.DateTimeFormat.prototype.formatRange,
      m = d.isSafari && E.Intl && !E.Intl.DateTimeFormat.prototype.formatRange;
    h = function () {
      function D(a) {
        this.options = {};
        this.variableTimezone = this.useUTC = !1;
        this.Date = E.Date;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.update(a);
      }
      D.prototype.get = function (a, c) {
        if (this.variableTimezone || this.timezoneOffset) {
          var C = c.getTime(),
            f = C - this.getTimezoneOffset(c);
          c.setTime(f);
          a = c["getUTC" + a]();
          c.setTime(C);
          return a;
        }
        return this.useUTC ? c["getUTC" + a]() : c["get" + a]();
      };
      D.prototype.set = function (a, c, f) {
        if (this.variableTimezone || this.timezoneOffset) {
          if ("Milliseconds" === a || "Seconds" === a || "Minutes" === a && 0 === this.getTimezoneOffset(c) % 36E5) return c["setUTC" + a](f);
          var C = this.getTimezoneOffset(c);
          C = c.getTime() - C;
          c.setTime(C);
          c["setUTC" + a](f);
          a = this.getTimezoneOffset(c);
          C = c.getTime() + a;
          return c.setTime(C);
        }
        return this.useUTC || n && "FullYear" === a ? c["setUTC" + a](f) : c["set" + a](f);
      };
      D.prototype.update = function (a) {
        var c = f(a && a.useUTC, !0);
        this.options = a = y(!0, this.options || {}, a);
        this.Date = a.Date || E.Date || Date;
        this.timezoneOffset = (this.useUTC = c) && a.timezoneOffset;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.variableTimezone = c && !(!a.getTimezoneOffset && !a.timezone);
      };
      D.prototype.makeTime = function (a, c, n, D, v, z) {
        if (this.useUTC) {
          var u = this.Date.UTC.apply(0, arguments);
          var k = this.getTimezoneOffset(u);
          u += k;
          var w = this.getTimezoneOffset(u);
          k !== w ? u += w - k : k - 36E5 !== this.getTimezoneOffset(u - 36E5) || m || (u -= 36E5);
        } else u = new this.Date(a, c, f(n, 1), f(D, 0), f(v, 0), f(z, 0)).getTime();
        return u;
      };
      D.prototype.timezoneOffsetFunction = function () {
        var a = this,
          c = this.options,
          f = c.getTimezoneOffset,
          n = c.moment || E.moment;
        if (!this.useUTC) return function (a) {
          return 6E4 * new Date(a.toString()).getTimezoneOffset();
        };
        if (c.timezone) {
          if (n) return function (a) {
            return 6E4 * -n.tz(a, c.timezone).utcOffset();
          };
          t(25);
        }
        return this.useUTC && f ? function (a) {
          return 6E4 * f(a.valueOf());
        } : function () {
          return 6E4 * (a.timezoneOffset || 0);
        };
      };
      D.prototype.dateFormat = function (a, c, n) {
        if (!F(c) || isNaN(c)) return d.defaultOptions.lang && d.defaultOptions.lang.invalidDate || "";
        a = f(a, "%Y-%m-%d %H:%M:%S");
        var C = this,
          v = new this.Date(c),
          z = this.get("Hours", v),
          u = this.get("Day", v),
          k = this.get("Date", v),
          w = this.get("Month", v),
          l = this.get("FullYear", v),
          e = d.defaultOptions.lang,
          g = e && e.weekdays,
          b = e && e.shortWeekdays;
        v = G({
          a: b ? b[u] : g[u].substr(0, 3),
          A: g[u],
          d: p(k),
          e: p(k, 2, " "),
          w: u,
          b: e.shortMonths[w],
          B: e.months[w],
          m: p(w + 1),
          o: w + 1,
          y: l.toString().substr(2, 2),
          Y: l,
          H: p(z),
          k: z,
          I: p(z % 12 || 12),
          l: z % 12 || 12,
          M: p(this.get("Minutes", v)),
          p: 12 > z ? "AM" : "PM",
          P: 12 > z ? "am" : "pm",
          S: p(v.getSeconds()),
          L: p(Math.floor(c % 1E3), 3)
        }, d.dateFormats);
        q(v, function (b, e) {
          for (; -1 !== a.indexOf("%" + e);) a = a.replace("%" + e, "function" === typeof b ? b.call(C, c) : b);
        });
        return n ? a.substr(0, 1).toUpperCase() + a.substr(1) : a;
      };
      D.prototype.resolveDTLFormat = function (a) {
        return H(a, !0) ? a : (a = c(a), {
          main: a[0],
          from: a[1],
          to: a[2]
        });
      };
      D.prototype.getTimeTicks = function (c, n, m, D) {
        var v = this,
          z = [],
          u = {},
          k = new v.Date(n),
          w = c.unitRange,
          l = c.count || 1,
          e;
        D = f(D, 1);
        if (F(n)) {
          v.set("Milliseconds", k, w >= a.second ? 0 : l * Math.floor(v.get("Milliseconds", k) / l));
          w >= a.second && v.set("Seconds", k, w >= a.minute ? 0 : l * Math.floor(v.get("Seconds", k) / l));
          w >= a.minute && v.set("Minutes", k, w >= a.hour ? 0 : l * Math.floor(v.get("Minutes", k) / l));
          w >= a.hour && v.set("Hours", k, w >= a.day ? 0 : l * Math.floor(v.get("Hours", k) / l));
          w >= a.day && v.set("Date", k, w >= a.month ? 1 : Math.max(1, l * Math.floor(v.get("Date", k) / l)));
          if (w >= a.month) {
            v.set("Month", k, w >= a.year ? 0 : l * Math.floor(v.get("Month", k) / l));
            var g = v.get("FullYear", k);
          }
          w >= a.year && v.set("FullYear", k, g - g % l);
          w === a.week && (g = v.get("Day", k), v.set("Date", k, v.get("Date", k) - g + D + (g < D ? -7 : 0)));
          g = v.get("FullYear", k);
          D = v.get("Month", k);
          var b = v.get("Date", k),
            B = v.get("Hours", k);
          n = k.getTime();
          !v.variableTimezone && v.useUTC || !F(m) || (e = m - n > 4 * a.month || v.getTimezoneOffset(n) !== v.getTimezoneOffset(m));
          n = k.getTime();
          for (k = 1; n < m;) z.push(n), n = w === a.year ? v.makeTime(g + k * l, 0) : w === a.month ? v.makeTime(g, D + k * l) : !e || w !== a.day && w !== a.week ? e && w === a.hour && 1 < l ? v.makeTime(g, D, b, B + k * l) : n + w * l : v.makeTime(g, D, b + k * l * (w === a.day ? 1 : 7)), k++;
          z.push(n);
          w <= a.hour && 1E4 > z.length && z.forEach(function (b) {
            0 === b % 18E5 && "000000000" === v.dateFormat("%H%M%S%L", b) && (u[b] = "day");
          });
        }
        z.info = G(c, {
          higherRanks: u,
          totalRange: w * l
        });
        return z;
      };
      D.prototype.getDateFormat = function (c, n, f, m) {
        var v = this.dateFormat("%m-%d %H:%M:%S.%L", n),
          z = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          },
          u = "millisecond";
        for (k in a) {
          if (c === a.week && +this.dateFormat("%w", n) === f && "00:00:00.000" === v.substr(6)) {
            var k = "week";
            break;
          }
          if (a[k] > c) {
            k = u;
            break;
          }
          if (z[k] && v.substr(z[k]) !== "01-01 00:00:00.000".substr(z[k])) break;
          "week" !== k && (u = k);
        }
        if (k) var w = this.resolveDTLFormat(m[k]).main;
        return w;
      };
      return D;
    }();
    "";
    return h;
  });
  N(h, "Core/DefaultOptions.js", [h["Core/Chart/ChartDefaults.js"], h["Core/Color/Color.js"], h["Core/Globals.js"], h["Core/Color/Palettes.js"], h["Core/Time.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G) {
    h = h.parse;
    var E = G.merge,
      y = {
        colors: F.colors,
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
          loading: "Loading...",
          months: "January February March April May June July August September October November December".split(" "),
          shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
          weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
          decimalPoint: ".",
          numericSymbols: "kMGTPE".split(""),
          resetZoom: "Reset zoom",
          resetZoomTitle: "Reset zoom level 1:1",
          thousandsSep: " "
        },
        global: {},
        time: {
          Date: void 0,
          getTimezoneOffset: void 0,
          timezone: void 0,
          timezoneOffset: 0,
          useUTC: !0
        },
        chart: d,
        title: {
          text: "Chart title",
          align: "center",
          margin: 15,
          widthAdjust: -44
        },
        subtitle: {
          text: "",
          align: "center",
          widthAdjust: -44
        },
        caption: {
          margin: 15,
          text: "",
          align: "left",
          verticalAlign: "bottom"
        },
        plotOptions: {},
        labels: {
          style: {
            position: "absolute",
            color: "#333333"
          }
        },
        legend: {
          enabled: !0,
          align: "center",
          alignColumns: !0,
          className: "highcharts-no-tooltip",
          layout: "horizontal",
          labelFormatter: function () {
            return this.name;
          },
          borderColor: "#999999",
          borderRadius: 0,
          navigation: {
            activeColor: "#003399",
            inactiveColor: "#cccccc"
          },
          itemStyle: {
            color: "#333333",
            cursor: "pointer",
            fontSize: "12px",
            fontWeight: "bold",
            textOverflow: "ellipsis"
          },
          itemHoverStyle: {
            color: "#000000"
          },
          itemHiddenStyle: {
            color: "#cccccc"
          },
          shadow: !1,
          itemCheckboxStyle: {
            position: "absolute",
            width: "13px",
            height: "13px"
          },
          squareSymbol: !0,
          symbolPadding: 5,
          verticalAlign: "bottom",
          x: 0,
          y: 0,
          title: {
            style: {
              fontWeight: "bold"
            }
          }
        },
        loading: {
          labelStyle: {
            fontWeight: "bold",
            position: "relative",
            top: "45%"
          },
          style: {
            position: "absolute",
            backgroundColor: "#ffffff",
            opacity: .5,
            textAlign: "center"
          }
        },
        tooltip: {
          enabled: !0,
          animation: A.svg,
          borderRadius: 3,
          dateTimeLabelFormats: {
            millisecond: "%A, %b %e, %H:%M:%S.%L",
            second: "%A, %b %e, %H:%M:%S",
            minute: "%A, %b %e, %H:%M",
            hour: "%A, %b %e, %H:%M",
            day: "%A, %b %e, %Y",
            week: "Week from %A, %b %e, %Y",
            month: "%B %Y",
            year: "%Y"
          },
          footerFormat: "",
          headerShape: "callout",
          hideDelay: 500,
          padding: 8,
          shape: "callout",
          shared: !1,
          snap: A.isTouchDevice ? 25 : 10,
          headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
          pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
          backgroundColor: h("#f7f7f7").setOpacity(.85).get(),
          borderWidth: 1,
          shadow: !0,
          stickOnContact: !1,
          style: {
            color: "#333333",
            cursor: "default",
            fontSize: "12px",
            whiteSpace: "nowrap"
          },
          useHTML: !1
        },
        credits: {
          enabled: !0,
          href: "https://www.highcharts.com?credits",
          position: {
            align: "right",
            x: -10,
            verticalAlign: "bottom",
            y: -5
          },
          style: {
            cursor: "pointer",
            color: "#999999",
            fontSize: "9px"
          },
          text: "Highcharts.com"
        }
      };
    y.chart.styledMode = !1;
    "";
    var q = new t(E(y.global, y.time));
    d = {
      defaultOptions: y,
      defaultTime: q,
      getOptions: function () {
        return y;
      },
      setOptions: function (p) {
        E(!0, y, p);
        if (p.time || p.global) A.time ? A.time.update(E(y.global, y.time, p.global, p.time)) : A.time = q;
        return y;
      }
    };
    "";
    return d;
  });
  N(h, "Core/Animation/Fx.js", [h["Core/Color/Color.js"], h["Core/Globals.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = d.parse,
      t = h.win,
      G = A.isNumber,
      H = A.objectEach;
    return function () {
      function d(q, p, f) {
        this.pos = NaN;
        this.options = p;
        this.elem = q;
        this.prop = f;
      }
      d.prototype.dSetter = function () {
        var q = this.paths,
          p = q && q[0];
        q = q && q[1];
        var f = this.now || 0,
          c = [];
        if (1 !== f && p && q) {
          if (p.length === q.length && 1 > f) for (var a = 0; a < q.length; a++) {
            for (var n = p[a], m = q[a], D = [], C = 0; C < m.length; C++) {
              var I = n[C],
                L = m[C];
              G(I) && G(L) && ("A" !== m[0] || 4 !== C && 5 !== C) ? D[C] = I + f * (L - I) : D[C] = L;
            }
            c.push(D);
          } else c = q;
        } else c = this.toD || [];
        this.elem.attr("d", c, void 0, !0);
      };
      d.prototype.update = function () {
        var q = this.elem,
          p = this.prop,
          f = this.now,
          c = this.options.step;
        if (this[p + "Setter"]) this[p + "Setter"]();else q.attr ? q.element && q.attr(p, f, null, !0) : q.style[p] = f + this.unit;
        c && c.call(q, f, this);
      };
      d.prototype.run = function (q, p, f) {
        var c = this,
          a = c.options,
          n = function (a) {
            return n.stopped ? !1 : c.step(a);
          },
          m = t.requestAnimationFrame || function (a) {
            setTimeout(a, 13);
          },
          D = function () {
            for (var a = 0; a < d.timers.length; a++) d.timers[a]() || d.timers.splice(a--, 1);
            d.timers.length && m(D);
          };
        q !== p || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = q, this.end = p, this.unit = f, this.now = this.start, this.pos = 0, n.elem = this.elem, n.prop = this.prop, n() && 1 === d.timers.push(n) && m(D)) : (delete a.curAnim[this.prop], a.complete && 0 === Object.keys(a.curAnim).length && a.complete.call(this.elem));
      };
      d.prototype.step = function (q) {
        var p = +new Date(),
          f = this.options,
          c = this.elem,
          a = f.complete,
          n = f.duration,
          m = f.curAnim;
        if (c.attr && !c.element) q = !1;else if (q || p >= n + this.startTime) {
          this.now = this.end;
          this.pos = 1;
          this.update();
          var D = m[this.prop] = !0;
          H(m, function (a) {
            !0 !== a && (D = !1);
          });
          D && a && a.call(c);
          q = !1;
        } else this.pos = f.easing((p - this.startTime) / n), this.now = this.start + (this.end - this.start) * this.pos, this.update(), q = !0;
        return q;
      };
      d.prototype.initPath = function (q, p, f) {
        function c(a, c) {
          for (; a.length < K;) {
            var u = a[0],
              k = c[K - a.length];
            k && "M" === u[0] && (a[0] = "C" === k[0] ? ["C", u[1], u[2], u[1], u[2], u[1], u[2]] : ["L", u[1], u[2]]);
            a.unshift(u);
            D && (u = a.pop(), a.push(a[a.length - 1], u));
          }
        }
        function a(a, c) {
          for (; a.length < K;) if (c = a[Math.floor(a.length / C) - 1].slice(), "C" === c[0] && (c[1] = c[5], c[2] = c[6]), D) {
            var u = a[Math.floor(a.length / C)].slice();
            a.splice(a.length / 2, 0, c, u);
          } else a.push(c);
        }
        var n = q.startX,
          m = q.endX;
        f = f.slice();
        var D = q.isArea,
          C = D ? 2 : 1;
        p = p && p.slice();
        if (!p) return [f, f];
        if (n && m && m.length) {
          for (q = 0; q < n.length; q++) if (n[q] === m[0]) {
            var I = q;
            break;
          } else if (n[0] === m[m.length - n.length + q]) {
            I = q;
            var L = !0;
            break;
          } else if (n[n.length - 1] === m[m.length - n.length + q]) {
            I = n.length - q;
            break;
          }
          "undefined" === typeof I && (p = []);
        }
        if (p.length && G(I)) {
          var K = f.length + I * C;
          L ? (c(p, f), a(f, p)) : (c(f, p), a(p, f));
        }
        return [p, f];
      };
      d.prototype.fillSetter = function () {
        d.prototype.strokeSetter.apply(this, arguments);
      };
      d.prototype.strokeSetter = function () {
        this.elem.attr(this.prop, E(this.start).tweenTo(E(this.end), this.pos), void 0, !0);
      };
      d.timers = [];
      return d;
    }();
  });
  N(h, "Core/Animation/AnimationUtilities.js", [h["Core/Animation/Fx.js"], h["Core/Utilities.js"]], function (d, h) {
    function E(a) {
      return q(a) ? p({
        duration: 500,
        defer: 0
      }, a) : {
        duration: a ? 500 : 0,
        defer: 0
      };
    }
    function F(a, c) {
      for (var n = d.timers.length; n--;) d.timers[n].elem !== a || c && c !== d.timers[n].prop || (d.timers[n].stopped = !0);
    }
    var t = h.defined,
      G = h.getStyle,
      H = h.isArray,
      y = h.isNumber,
      q = h.isObject,
      p = h.merge,
      f = h.objectEach,
      c = h.pick;
    return {
      animate: function (a, c, m) {
        var n,
          C = "",
          I,
          L;
        if (!q(m)) {
          var K = arguments;
          m = {
            duration: K[2],
            easing: K[3],
            complete: K[4]
          };
        }
        y(m.duration) || (m.duration = 400);
        m.easing = "function" === typeof m.easing ? m.easing : Math[m.easing] || Math.easeInOutSine;
        m.curAnim = p(c);
        f(c, function (f, z) {
          F(a, z);
          L = new d(a, m, z);
          I = void 0;
          "d" === z && H(c.d) ? (L.paths = L.initPath(a, a.pathArray, c.d), L.toD = c.d, n = 0, I = 1) : a.attr ? n = a.attr(z) : (n = parseFloat(G(a, z)) || 0, "opacity" !== z && (C = "px"));
          I || (I = f);
          "string" === typeof I && I.match("px") && (I = I.replace(/px/g, ""));
          L.run(n, I, C);
        });
      },
      animObject: E,
      getDeferredAnimation: function (a, c, f) {
        var n = E(c),
          m = 0,
          p = 0;
        (f ? [f] : a.series).forEach(function (a) {
          a = E(a.options.animation);
          m = c && t(c.defer) ? n.defer : Math.max(m, a.duration + a.defer);
          p = Math.min(n.duration, a.duration);
        });
        a.renderer.forExport && (m = 0);
        return {
          defer: Math.max(0, m - p),
          duration: Math.min(m, p)
        };
      },
      setAnimation: function (a, n) {
        n.renderer.globalAnimation = c(a, n.options.chart.animation, !0);
      },
      stop: F
    };
  });
  N(h, "Core/Renderer/HTML/AST.js", [h["Core/Globals.js"], h["Core/Utilities.js"]], function (d, h) {
    var E = d.SVG_NS,
      F = h.attr,
      t = h.createElement,
      G = h.error,
      H = h.isFunction,
      y = h.isString,
      q = h.objectEach,
      p = h.splat,
      f = (h = d.win.trustedTypes) && H(h.createPolicy) && h.createPolicy("highcharts", {
        createHTML: function (a) {
          return a;
        }
      }),
      c = f ? f.createHTML("") : "";
    try {
      var a = !!new DOMParser().parseFromString(c, "text/html");
    } catch (n) {
      a = !1;
    }
    H = function () {
      function n(a) {
        this.nodes = "string" === typeof a ? this.parseMarkup(a) : a;
      }
      n.filterUserAttributes = function (a) {
        q(a, function (c, f) {
          var m = !0;
          -1 === n.allowedAttributes.indexOf(f) && (m = !1);
          -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(f) && (m = y(c) && n.allowedReferences.some(function (a) {
            return 0 === c.indexOf(a);
          }));
          m || (G("Highcharts warning: Invalid attribute '" + f + "' in config"), delete a[f]);
        });
        return a;
      };
      n.setElementHTML = function (a, c) {
        a.innerHTML = n.emptyHTML;
        c && new n(c).addToDOM(a);
      };
      n.prototype.addToDOM = function (a) {
        function c(a, f) {
          var m;
          p(a).forEach(function (a) {
            var v = a.tagName,
              z = a.textContent ? d.doc.createTextNode(a.textContent) : void 0;
            if (v) if ("#text" === v) var u = z;else if (-1 !== n.allowedTags.indexOf(v)) {
              v = d.doc.createElementNS("svg" === v ? E : f.namespaceURI || E, v);
              var k = a.attributes || {};
              q(a, function (a, l) {
                "tagName" !== l && "attributes" !== l && "children" !== l && "textContent" !== l && (k[l] = a);
              });
              F(v, n.filterUserAttributes(k));
              z && v.appendChild(z);
              c(a.children || [], v);
              u = v;
            } else G("Highcharts warning: Invalid tagName " + v + " in config");
            u && f.appendChild(u);
            m = u;
          });
          return m;
        }
        return c(this.nodes, a);
      };
      n.prototype.parseMarkup = function (c) {
        var n = [];
        c = c.trim();
        if (a) c = new DOMParser().parseFromString(f ? f.createHTML(c) : c, "text/html");else {
          var m = t("div");
          m.innerHTML = c;
          c = {
            body: m
          };
        }
        var p = function (a, c) {
          var f = a.nodeName.toLowerCase(),
            z = {
              tagName: f
            };
          "#text" === f && (z.textContent = a.textContent || "");
          if (f = a.attributes) {
            var u = {};
            [].forEach.call(f, function (k) {
              u[k.name] = k.value;
            });
            z.attributes = u;
          }
          if (a.childNodes.length) {
            var k = [];
            [].forEach.call(a.childNodes, function (a) {
              p(a, k);
            });
            k.length && (z.children = k);
          }
          c.push(z);
        };
        [].forEach.call(c.body.childNodes, function (a) {
          return p(a, n);
        });
        return n;
      };
      n.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex".split(" ");
      n.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
      n.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
      n.emptyHTML = c;
      return n;
    }();
    "";
    return H;
  });
  N(h, "Core/FormatUtilities.js", [h["Core/DefaultOptions.js"], h["Core/Utilities.js"]], function (d, h) {
    function E(p, f, c, a) {
      p = +p || 0;
      f = +f;
      var n = F.lang,
        m = (p.toString().split(".")[1] || "").split("e")[0].length,
        D = p.toString().split("e"),
        C = f;
      if (-1 === f) f = Math.min(m, 20);else if (!H(f)) f = 2;else if (f && D[1] && 0 > D[1]) {
        var I = f + +D[1];
        0 <= I ? (D[0] = (+D[0]).toExponential(I).split("e")[0], f = I) : (D[0] = D[0].split(".")[0] || 0, p = 20 > f ? (D[0] * Math.pow(10, D[1])).toFixed(f) : 0, D[1] = 0);
      }
      I = (Math.abs(D[1] ? D[0] : p) + Math.pow(10, -Math.max(f, m) - 1)).toFixed(f);
      m = String(q(I));
      var L = 3 < m.length ? m.length % 3 : 0;
      c = y(c, n.decimalPoint);
      a = y(a, n.thousandsSep);
      p = (0 > p ? "-" : "") + (L ? m.substr(0, L) + a : "");
      p = 0 > +D[1] && !C ? "0" : p + m.substr(L).replace(/(\d{3})(?=\d)/g, "$1" + a);
      f && (p += c + I.slice(-f));
      D[1] && 0 !== +p && (p += "e" + D[1]);
      return p;
    }
    var F = d.defaultOptions,
      t = d.defaultTime,
      G = h.getNestedProperty,
      H = h.isNumber,
      y = h.pick,
      q = h.pInt;
    return {
      dateFormat: function (p, f, c) {
        return t.dateFormat(p, f, c);
      },
      format: function (p, f, c) {
        var a = "{",
          n = !1,
          m = /f$/,
          D = /\.([0-9])/,
          C = F.lang,
          I = c && c.time || t;
        c = c && c.numberFormatter || E;
        for (var L = []; p;) {
          var q = p.indexOf(a);
          if (-1 === q) break;
          var v = p.slice(0, q);
          if (n) {
            v = v.split(":");
            a = G(v.shift() || "", f);
            if (v.length && "number" === typeof a) if (v = v.join(":"), m.test(v)) {
              var z = parseInt((v.match(D) || ["", "-1"])[1], 10);
              null !== a && (a = c(a, z, C.decimalPoint, -1 < v.indexOf(",") ? C.thousandsSep : ""));
            } else a = I.dateFormat(v, a);
            L.push(a);
          } else L.push(v);
          p = p.slice(q + 1);
          a = (n = !n) ? "}" : "{";
        }
        L.push(p);
        return L.join("");
      },
      numberFormat: E
    };
  });
  N(h, "Core/Renderer/RendererUtilities.js", [h["Core/Utilities.js"]], function (d) {
    var h = d.clamp,
      A = d.pick,
      F = d.stableSort,
      t;
    (function (d) {
      function t(d, q, p) {
        var f = d,
          c = f.reducedLen || q,
          a = function (a, c) {
            return (c.rank || 0) - (a.rank || 0);
          },
          n = function (a, c) {
            return a.target - c.target;
          },
          m,
          D = !0,
          C = [],
          I = 0;
        for (m = d.length; m--;) I += d[m].size;
        if (I > c) {
          F(d, a);
          for (I = m = 0; I <= c;) I += d[m].size, m++;
          C = d.splice(m - 1, d.length);
        }
        F(d, n);
        for (d = d.map(function (a) {
          return {
            size: a.size,
            targets: [a.target],
            align: A(a.align, .5)
          };
        }); D;) {
          for (m = d.length; m--;) c = d[m], a = (Math.min.apply(0, c.targets) + Math.max.apply(0, c.targets)) / 2, c.pos = h(a - c.size * c.align, 0, q - c.size);
          m = d.length;
          for (D = !1; m--;) 0 < m && d[m - 1].pos + d[m - 1].size > d[m].pos && (d[m - 1].size += d[m].size, d[m - 1].targets = d[m - 1].targets.concat(d[m].targets), d[m - 1].align = .5, d[m - 1].pos + d[m - 1].size > q && (d[m - 1].pos = q - d[m - 1].size), d.splice(m, 1), D = !0);
        }
        f.push.apply(f, C);
        m = 0;
        d.some(function (a) {
          var c = 0;
          return (a.targets || []).some(function () {
            f[m].pos = a.pos + c;
            if ("undefined" !== typeof p && Math.abs(f[m].pos - f[m].target) > p) return f.slice(0, m + 1).forEach(function (a) {
              return delete a.pos;
            }), f.reducedLen = (f.reducedLen || q) - .1 * q, f.reducedLen > .1 * q && t(f, q, p), !0;
            c += f[m].size;
            m++;
            return !1;
          });
        });
        F(f, n);
        return f;
      }
      d.distribute = t;
    })(t || (t = {}));
    return t;
  });
  N(h, "Core/Renderer/SVG/SVGElement.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/Renderer/HTML/AST.js"], h["Core/Color/Color.js"], h["Core/Globals.js"], h["Core/Utilities.js"]], function (d, h, A, F, t) {
    var E = d.animate,
      H = d.animObject,
      y = d.stop,
      q = F.deg2rad,
      p = F.doc,
      f = F.noop,
      c = F.svg,
      a = F.SVG_NS,
      n = F.win,
      m = t.addEvent,
      D = t.attr,
      C = t.createElement,
      I = t.css,
      L = t.defined,
      K = t.erase,
      v = t.extend,
      z = t.fireEvent,
      u = t.isArray,
      k = t.isFunction,
      w = t.isNumber,
      l = t.isString,
      e = t.merge,
      g = t.objectEach,
      b = t.pick,
      B = t.pInt,
      J = t.syncTimeout,
      r = t.uniqueKey;
    d = function () {
      function x() {
        this.element = void 0;
        this.onEvents = {};
        this.opacity = 1;
        this.renderer = void 0;
        this.SVG_NS = a;
        this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
      }
      x.prototype._defaultGetter = function (e) {
        e = b(this[e + "Value"], this[e], this.element ? this.element.getAttribute(e) : null, 0);
        /^[\-0-9\.]+$/.test(e) && (e = parseFloat(e));
        return e;
      };
      x.prototype._defaultSetter = function (b, e, g) {
        g.setAttribute(e, b);
      };
      x.prototype.add = function (b) {
        var e = this.renderer,
          g = this.element;
        b && (this.parentGroup = b);
        this.parentInverted = b && b.inverted;
        "undefined" !== typeof this.textStr && "text" === this.element.nodeName && e.buildText(this);
        this.added = !0;
        if (!b || b.handleZ || this.zIndex) var l = this.zIndexSetter();
        l || (b ? b.element : e.box).appendChild(g);
        if (this.onAdd) this.onAdd();
        return this;
      };
      x.prototype.addClass = function (b, e) {
        var g = e ? "" : this.attr("class") || "";
        b = (b || "").split(/ /g).reduce(function (b, e) {
          -1 === g.indexOf(e) && b.push(e);
          return b;
        }, g ? [g] : []).join(" ");
        b !== g && this.attr("class", b);
        return this;
      };
      x.prototype.afterSetters = function () {
        this.doTransform && (this.updateTransform(), this.doTransform = !1);
      };
      x.prototype.align = function (e, g, k) {
        var r = {},
          P = this.renderer,
          a = P.alignedObjects,
          M,
          c,
          B;
        if (e) {
          if (this.alignOptions = e, this.alignByTranslate = g, !k || l(k)) this.alignTo = M = k || "renderer", K(a, this), a.push(this), k = void 0;
        } else e = this.alignOptions, g = this.alignByTranslate, M = this.alignTo;
        k = b(k, P[M], "scrollablePlotBox" === M ? P.plotBox : void 0, P);
        M = e.align;
        var x = e.verticalAlign;
        P = (k.x || 0) + (e.x || 0);
        a = (k.y || 0) + (e.y || 0);
        "right" === M ? c = 1 : "center" === M && (c = 2);
        c && (P += (k.width - (e.width || 0)) / c);
        r[g ? "translateX" : "x"] = Math.round(P);
        "bottom" === x ? B = 1 : "middle" === x && (B = 2);
        B && (a += (k.height - (e.height || 0)) / B);
        r[g ? "translateY" : "y"] = Math.round(a);
        this[this.placed ? "animate" : "attr"](r);
        this.placed = !0;
        this.alignAttr = r;
        return this;
      };
      x.prototype.alignSetter = function (b) {
        var e = {
          left: "start",
          center: "middle",
          right: "end"
        };
        e[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", e[b]));
      };
      x.prototype.animate = function (e, k, l) {
        var r = this,
          a = H(b(k, this.renderer.globalAnimation, !0));
        k = a.defer;
        b(p.hidden, p.msHidden, p.webkitHidden, !1) && (a.duration = 0);
        0 !== a.duration ? (l && (a.complete = l), J(function () {
          r.element && E(r, e, a);
        }, k)) : (this.attr(e, void 0, l), g(e, function (b, e) {
          a.step && a.step.call(this, b, {
            prop: e,
            pos: 1,
            elem: this
          });
        }, this));
        return this;
      };
      x.prototype.applyTextOutline = function (b) {
        var e = this.element;
        -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));
        var g = b.split(" ");
        b = g[g.length - 1];
        if ((g = g[0]) && "none" !== g && F.svg) {
          this.fakeTS = !0;
          this.ySetter = this.xSetter;
          g = g.replace(/(^[\d\.]+)(.*?)$/g, function (b, e, g) {
            return 2 * Number(e) + g;
          });
          this.removeTextOutline();
          var k = p.createElementNS(a, "tspan");
          D(k, {
            "class": "highcharts-text-outline",
            fill: b,
            stroke: b,
            "stroke-width": g,
            "stroke-linejoin": "round"
          });
          [].forEach.call(e.childNodes, function (b) {
            var e = b.cloneNode(!0);
            e.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (b) {
              return e.removeAttribute(b);
            });
            k.appendChild(e);
          });
          var l = p.createElementNS(a, "tspan");
          l.textContent = "\u200b";
          ["x", "y"].forEach(function (b) {
            var g = e.getAttribute(b);
            g && l.setAttribute(b, g);
          });
          k.appendChild(l);
          e.insertBefore(k, e.firstChild);
        }
      };
      x.prototype.attr = function (b, e, k, l) {
        var a = this.element,
          r = this.symbolCustomAttribs,
          P,
          O = this,
          M,
          c;
        if ("string" === typeof b && "undefined" !== typeof e) {
          var B = b;
          b = {};
          b[B] = e;
        }
        "string" === typeof b ? O = (this[b + "Getter"] || this._defaultGetter).call(this, b, a) : (g(b, function (e, g) {
          M = !1;
          l || y(this, g);
          this.symbolName && -1 !== r.indexOf(g) && (P || (this.symbolAttr(b), P = !0), M = !0);
          !this.rotation || "x" !== g && "y" !== g || (this.doTransform = !0);
          M || (c = this[g + "Setter"] || this._defaultSetter, c.call(this, e, g, a), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(g) && this.updateShadows(g, e, c));
        }, this), this.afterSetters());
        k && k.call(this);
        return O;
      };
      x.prototype.clip = function (b) {
        return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
      };
      x.prototype.crisp = function (b, e) {
        e = e || b.strokeWidth || 0;
        var g = Math.round(e) % 2 / 2;
        b.x = Math.floor(b.x || this.x || 0) + g;
        b.y = Math.floor(b.y || this.y || 0) + g;
        b.width = Math.floor((b.width || this.width || 0) - 2 * g);
        b.height = Math.floor((b.height || this.height || 0) - 2 * g);
        L(b.strokeWidth) && (b.strokeWidth = e);
        return b;
      };
      x.prototype.complexColor = function (b, k, l) {
        var a = this.renderer,
          P,
          c,
          B,
          x,
          w,
          M,
          J,
          f,
          n,
          m,
          v = [],
          C;
        z(this.renderer, "complexColor", {
          args: arguments
        }, function () {
          b.radialGradient ? c = "radialGradient" : b.linearGradient && (c = "linearGradient");
          if (c) {
            B = b[c];
            w = a.gradients;
            M = b.stops;
            n = l.radialReference;
            u(B) && (b[c] = B = {
              x1: B[0],
              y1: B[1],
              x2: B[2],
              y2: B[3],
              gradientUnits: "userSpaceOnUse"
            });
            "radialGradient" === c && n && !L(B.gradientUnits) && (x = B, B = e(B, a.getRadialAttr(n, x), {
              gradientUnits: "userSpaceOnUse"
            }));
            g(B, function (b, e) {
              "id" !== e && v.push(e, b);
            });
            g(M, function (b) {
              v.push(b);
            });
            v = v.join(",");
            if (w[v]) m = w[v].attr("id");else {
              B.id = m = r();
              var O = w[v] = a.createElement(c).attr(B).add(a.defs);
              O.radAttr = x;
              O.stops = [];
              M.forEach(function (b) {
                0 === b[1].indexOf("rgba") ? (P = A.parse(b[1]), J = P.get("rgb"), f = P.get("a")) : (J = b[1], f = 1);
                b = a.createElement("stop").attr({
                  offset: b[0],
                  "stop-color": J,
                  "stop-opacity": f
                }).add(O);
                O.stops.push(b);
              });
            }
            C = "url(" + a.url + "#" + m + ")";
            l.setAttribute(k, C);
            l.gradient = v;
            b.toString = function () {
              return C;
            };
          }
        });
      };
      x.prototype.css = function (b) {
        var e = this.styles,
          k = {},
          l = this.element,
          a = ["textOutline", "textOverflow", "width"],
          r = "",
          x = !e;
        b && b.color && (b.fill = b.color);
        e && g(b, function (b, g) {
          e && e[g] !== b && (k[g] = b, x = !0);
        });
        if (x) {
          e && (b = v(e, k));
          if (b) if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === l.nodeName.toLowerCase() && b.width) var w = this.textWidth = B(b.width);
          this.styles = b;
          w && !c && this.renderer.forExport && delete b.width;
          if (l.namespaceURI === this.SVG_NS) {
            var u = function (b, e) {
              return "-" + e.toLowerCase();
            };
            g(b, function (b, e) {
              -1 === a.indexOf(e) && (r += e.replace(/([A-Z])/g, u) + ":" + b + ";");
            });
            r && D(l, "style", r);
          } else I(l, b);
          this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));
        }
        return this;
      };
      x.prototype.dashstyleSetter = function (e) {
        var g = this["stroke-width"];
        "inherit" === g && (g = 1);
        if (e = e && e.toLowerCase()) {
          var k = e.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
          for (e = k.length; e--;) k[e] = "" + B(k[e]) * b(g, NaN);
          e = k.join(",").replace(/NaN/g, "none");
          this.element.setAttribute("stroke-dasharray", e);
        }
      };
      x.prototype.destroy = function () {
        var b = this,
          e = b.element || {},
          k = b.renderer,
          l = e.ownerSVGElement,
          a = k.isSVG && "SPAN" === e.nodeName && b.parentGroup || void 0;
        e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null;
        y(b);
        if (b.clipPath && l) {
          var r = b.clipPath;
          [].forEach.call(l.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
            -1 < b.getAttribute("clip-path").indexOf(r.element.id) && b.removeAttribute("clip-path");
          });
          b.clipPath = r.destroy();
        }
        if (b.stops) {
          for (l = 0; l < b.stops.length; l++) b.stops[l].destroy();
          b.stops.length = 0;
          b.stops = void 0;
        }
        b.safeRemoveChild(e);
        for (k.styledMode || b.destroyShadows(); a && a.div && 0 === a.div.childNodes.length;) e = a.parentGroup, b.safeRemoveChild(a.div), delete a.div, a = e;
        b.alignTo && K(k.alignedObjects, b);
        g(b, function (e, g) {
          b[g] && b[g].parentGroup === b && b[g].destroy && b[g].destroy();
          delete b[g];
        });
      };
      x.prototype.destroyShadows = function () {
        (this.shadows || []).forEach(function (b) {
          this.safeRemoveChild(b);
        }, this);
        this.shadows = void 0;
      };
      x.prototype.destroyTextPath = function (b, e) {
        var g = b.getElementsByTagName("text")[0];
        if (g) {
          if (g.removeAttribute("dx"), g.removeAttribute("dy"), e.element.setAttribute("id", ""), this.textPathWrapper && g.getElementsByTagName("textPath").length) {
            for (b = this.textPathWrapper.element.childNodes; b.length;) g.appendChild(b[0]);
            g.removeChild(this.textPathWrapper.element);
          }
        } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");
        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
      };
      x.prototype.dSetter = function (b, e, g) {
        u(b) && ("string" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, e, g) {
          return e && e.join ? (g ? b + " " : "") + e.join(" ") : (e || "").toString();
        }, ""));
        /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
        this[e] !== b && (g.setAttribute(e, b), this[e] = b);
      };
      x.prototype.fadeOut = function (e) {
        var g = this;
        g.animate({
          opacity: 0
        }, {
          duration: b(e, 150),
          complete: function () {
            g.attr({
              y: -9999
            }).hide();
          }
        });
      };
      x.prototype.fillSetter = function (b, e, g) {
        "string" === typeof b ? g.setAttribute(e, b) : b && this.complexColor(b, e, g);
      };
      x.prototype.getBBox = function (e, g) {
        var l = this.renderer,
          a = this.element,
          r = this.styles,
          B = this.textStr,
          c = l.cache,
          w = l.cacheKeys,
          u = a.namespaceURI === this.SVG_NS;
        g = b(g, this.rotation, 0);
        var J = l.styledMode ? a && x.prototype.getStyle.call(a, "font-size") : r && r.fontSize,
          z;
        if (L(B)) {
          var M = B.toString();
          -1 === M.indexOf("<") && (M = M.replace(/[0-9]/g, "0"));
          M += ["", g, J, this.textWidth, r && r.textOverflow, r && r.fontWeight].join();
        }
        M && !e && (z = c[M]);
        if (!z) {
          if (u || l.forExport) {
            try {
              var f = this.fakeTS && function (b) {
                var e = a.querySelector(".highcharts-text-outline");
                e && I(e, {
                  display: b
                });
              };
              k(f) && f("none");
              z = a.getBBox ? v({}, a.getBBox()) : {
                width: a.offsetWidth,
                height: a.offsetHeight
              };
              k(f) && f("");
            } catch (U) {
              "";
            }
            if (!z || 0 > z.width) z = {
              width: 0,
              height: 0
            };
          } else z = this.htmlGetBBox();
          l.isSVG && (e = z.width, l = z.height, u && (z.height = l = {
            "11px,17": 14,
            "13px,20": 16
          }[(J || "") + "," + Math.round(l)] || l), g && (u = g * q, z.width = Math.abs(l * Math.sin(u)) + Math.abs(e * Math.cos(u)), z.height = Math.abs(l * Math.cos(u)) + Math.abs(e * Math.sin(u))));
          if (M && ("" === B || 0 < z.height)) {
            for (; 250 < w.length;) delete c[w.shift()];
            c[M] || w.push(M);
            c[M] = z;
          }
        }
        return z;
      };
      x.prototype.getStyle = function (b) {
        return n.getComputedStyle(this.element || this, "").getPropertyValue(b);
      };
      x.prototype.hasClass = function (b) {
        return -1 !== ("" + this.attr("class")).split(" ").indexOf(b);
      };
      x.prototype.hide = function (b) {
        b ? this.attr({
          y: -9999
        }) : this.attr({
          visibility: "hidden"
        });
        return this;
      };
      x.prototype.htmlGetBBox = function () {
        return {
          height: 0,
          width: 0,
          x: 0,
          y: 0
        };
      };
      x.prototype.init = function (b, e) {
        this.element = "span" === e ? C(e) : p.createElementNS(this.SVG_NS, e);
        this.renderer = b;
        z(this, "afterInit");
      };
      x.prototype.invert = function (b) {
        this.inverted = b;
        this.updateTransform();
        return this;
      };
      x.prototype.on = function (b, e) {
        var g = this.onEvents;
        if (g[b]) g[b]();
        g[b] = m(this.element, b, e);
        return this;
      };
      x.prototype.opacitySetter = function (b, e, g) {
        this.opacity = b = Number(Number(b).toFixed(3));
        g.setAttribute(e, b);
      };
      x.prototype.removeClass = function (b) {
        return this.attr("class", ("" + this.attr("class")).replace(l(b) ? new RegExp("(^| )" + b + "( |$)") : b, " ").replace(/ +/g, " ").trim());
      };
      x.prototype.removeTextOutline = function () {
        var b = this.element.querySelector("tspan.highcharts-text-outline");
        b && this.safeRemoveChild(b);
      };
      x.prototype.safeRemoveChild = function (b) {
        var e = b.parentNode;
        e && e.removeChild(b);
      };
      x.prototype.setRadialReference = function (b) {
        var e = this.element.gradient && this.renderer.gradients[this.element.gradient];
        this.element.radialReference = b;
        e && e.radAttr && e.animate(this.renderer.getRadialAttr(b, e.radAttr));
        return this;
      };
      x.prototype.setTextPath = function (b, l) {
        var k = this.element,
          a = this.text ? this.text.element : k,
          B = {
            textAnchor: "text-anchor"
          },
          c = !1,
          x = this.textPathWrapper,
          u = !x;
        l = e(!0, {
          enabled: !0,
          attributes: {
            dy: -5,
            startOffset: "50%",
            textAnchor: "middle"
          }
        }, l);
        var Q = h.filterUserAttributes(l.attributes);
        if (b && l && l.enabled) {
          x && null === x.element.parentNode ? (u = !0, x = x.destroy()) : x && this.removeTextOutline.call(x.parentGroup);
          this.options && this.options.padding && (Q.dx = -this.options.padding);
          x || (this.textPathWrapper = x = this.renderer.createElement("textPath"), c = !0);
          var J = x.element;
          (l = b.element.getAttribute("id")) || b.element.setAttribute("id", l = r());
          if (u) for (a.setAttribute("y", 0), w(Q.dx) && a.setAttribute("x", -Q.dx), b = [].slice.call(a.childNodes), u = 0; u < b.length; u++) {
            var z = b[u];
            z.nodeType !== n.Node.TEXT_NODE && "tspan" !== z.nodeName || J.appendChild(z);
          }
          c && x && x.add({
            element: a
          });
          J.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + l);
          L(Q.dy) && (J.parentNode.setAttribute("dy", Q.dy), delete Q.dy);
          L(Q.dx) && (J.parentNode.setAttribute("dx", Q.dx), delete Q.dx);
          g(Q, function (b, e) {
            J.setAttribute(B[e] || e, b);
          });
          k.removeAttribute("transform");
          this.removeTextOutline.call(x);
          this.text && !this.renderer.styledMode && this.attr({
            fill: "none",
            "stroke-width": 0
          });
          this.applyTextOutline = this.updateTransform = f;
        } else x && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(k, b), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));
        return this;
      };
      x.prototype.shadow = function (b, e, l) {
        var k = [],
          a = this.element,
          r = this.oldShadowOptions,
          P = {
            color: "#000000",
            offsetX: this.parentInverted ? -1 : 1,
            offsetY: this.parentInverted ? -1 : 1,
            opacity: .15,
            width: 3
          },
          B = !1,
          c;
        !0 === b ? c = P : "object" === typeof b && (c = v(P, b));
        c && (c && r && g(c, function (b, e) {
          b !== r[e] && (B = !0);
        }), B && this.destroyShadows(), this.oldShadowOptions = c);
        if (!c) this.destroyShadows();else if (!this.shadows) {
          var x = c.opacity / c.width;
          var w = this.parentInverted ? "translate(" + c.offsetY + ", " + c.offsetX + ")" : "translate(" + c.offsetX + ", " + c.offsetY + ")";
          for (P = 1; P <= c.width; P++) {
            var u = a.cloneNode(!1);
            var J = 2 * c.width + 1 - 2 * P;
            D(u, {
              stroke: b.color || "#000000",
              "stroke-opacity": x * P,
              "stroke-width": J,
              transform: w,
              fill: "none"
            });
            u.setAttribute("class", (u.getAttribute("class") || "") + " highcharts-shadow");
            l && (D(u, "height", Math.max(D(u, "height") - J, 0)), u.cutHeight = J);
            e ? e.element.appendChild(u) : a.parentNode && a.parentNode.insertBefore(u, a);
            k.push(u);
          }
          this.shadows = k;
        }
        return this;
      };
      x.prototype.show = function (b) {
        return this.attr({
          visibility: b ? "inherit" : "visible"
        });
      };
      x.prototype.strokeSetter = function (b, e, g) {
        this[e] = b;
        this.stroke && this["stroke-width"] ? (x.prototype.fillSetter.call(this, this.stroke, "stroke", g), g.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === e && 0 === b && this.hasStroke ? (g.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (g.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
      };
      x.prototype.strokeWidth = function () {
        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
        var b = this.getStyle("stroke-width"),
          e = 0;
        if (b.indexOf("px") === b.length - 2) e = B(b);else if ("" !== b) {
          var g = p.createElementNS(a, "rect");
          D(g, {
            width: b,
            "stroke-width": 0
          });
          this.element.parentNode.appendChild(g);
          e = g.getBBox().width;
          g.parentNode.removeChild(g);
        }
        return e;
      };
      x.prototype.symbolAttr = function (e) {
        var g = this;
        "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (l) {
          g[l] = b(e[l], g[l]);
        });
        g.attr({
          d: g.renderer.symbols[g.symbolName](g.x, g.y, g.width, g.height, g)
        });
      };
      x.prototype.textSetter = function (b) {
        b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
      };
      x.prototype.titleSetter = function (e) {
        var g = this.element,
          l = g.getElementsByTagName("title")[0] || p.createElementNS(this.SVG_NS, "title");
        g.insertBefore ? g.insertBefore(l, g.firstChild) : g.appendChild(l);
        l.textContent = String(b(e, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
      };
      x.prototype.toFront = function () {
        var b = this.element;
        b.parentNode.appendChild(b);
        return this;
      };
      x.prototype.translate = function (b, e) {
        return this.attr({
          translateX: b,
          translateY: e
        });
      };
      x.prototype.updateShadows = function (b, e, g) {
        var l = this.shadows;
        if (l) for (var k = l.length; k--;) g.call(l[k], "height" === b ? Math.max(e - (l[k].cutHeight || 0), 0) : "d" === b ? this.d : e, b, l[k]);
      };
      x.prototype.updateTransform = function () {
        var e = this.scaleX,
          g = this.scaleY,
          l = this.inverted,
          k = this.rotation,
          a = this.matrix,
          r = this.element,
          c = this.translateX || 0,
          B = this.translateY || 0;
        l && (c += this.width, B += this.height);
        c = ["translate(" + c + "," + B + ")"];
        L(a) && c.push("matrix(" + a.join(",") + ")");
        l ? c.push("rotate(90) scale(-1,1)") : k && c.push("rotate(" + k + " " + b(this.rotationOriginX, r.getAttribute("x"), 0) + " " + b(this.rotationOriginY, r.getAttribute("y") || 0) + ")");
        (L(e) || L(g)) && c.push("scale(" + b(e, 1) + " " + b(g, 1) + ")");
        c.length && r.setAttribute("transform", c.join(" "));
      };
      x.prototype.visibilitySetter = function (b, e, g) {
        "inherit" === b ? g.removeAttribute(e) : this[e] !== b && g.setAttribute(e, b);
        this[e] = b;
      };
      x.prototype.xGetter = function (b) {
        "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
        return this._defaultGetter(b);
      };
      x.prototype.zIndexSetter = function (b, e) {
        var g = this.renderer,
          l = this.parentGroup,
          k = (l || g).element || g.box,
          a = this.element;
        g = k === g.box;
        var r = !1;
        var c = this.added;
        var x;
        L(b) ? (a.setAttribute("data-z-index", b), b = +b, this[e] === b && (c = !1)) : L(this[e]) && a.removeAttribute("data-z-index");
        this[e] = b;
        if (c) {
          (b = this.zIndex) && l && (l.handleZ = !0);
          e = k.childNodes;
          for (x = e.length - 1; 0 <= x && !r; x--) {
            l = e[x];
            c = l.getAttribute("data-z-index");
            var u = !L(c);
            if (l !== a) if (0 > b && u && !g && !x) k.insertBefore(a, e[x]), r = !0;else if (B(c) <= b || u && (!L(b) || 0 <= b)) k.insertBefore(a, e[x + 1] || null), r = !0;
          }
          r || (k.insertBefore(a, e[g ? 3 : 0] || null), r = !0);
        }
        return r;
      };
      return x;
    }();
    d.prototype["stroke-widthSetter"] = d.prototype.strokeSetter;
    d.prototype.yGetter = d.prototype.xGetter;
    d.prototype.matrixSetter = d.prototype.rotationOriginXSetter = d.prototype.rotationOriginYSetter = d.prototype.rotationSetter = d.prototype.scaleXSetter = d.prototype.scaleYSetter = d.prototype.translateXSetter = d.prototype.translateYSetter = d.prototype.verticalAlignSetter = function (b, e) {
      this[e] = b;
      this.doTransform = !0;
    };
    "";
    return d;
  });
  N(h, "Core/Renderer/RendererRegistry.js", [h["Core/Globals.js"]], function (d) {
    var h;
    (function (h) {
      h.rendererTypes = {};
      var E;
      h.getRendererType = function (d) {
        void 0 === d && (d = E);
        return h.rendererTypes[d] || h.rendererTypes[E];
      };
      h.registerRendererType = function (t, A, H) {
        h.rendererTypes[t] = A;
        if (!E || H) E = t, d.Renderer = A;
      };
    })(h || (h = {}));
    return h;
  });
  N(h, "Core/Renderer/SVG/SVGLabel.js", [h["Core/Renderer/SVG/SVGElement.js"], h["Core/Utilities.js"]], function (d, h) {
    var E = this && this.__extends || function () {
        var p = function (f, c) {
          p = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);
          };
          return p(f, c);
        };
        return function (f, c) {
          function a() {
            this.constructor = f;
          }
          p(f, c);
          f.prototype = null === c ? Object.create(c) : (a.prototype = c.prototype, new a());
        };
      }(),
      F = h.defined,
      t = h.extend,
      G = h.isNumber,
      H = h.merge,
      y = h.pick,
      q = h.removeEvent;
    return function (p) {
      function f(c, a, n, m, D, C, I, L, d, v) {
        var z = p.call(this) || this;
        z.paddingLeftSetter = z.paddingSetter;
        z.paddingRightSetter = z.paddingSetter;
        z.init(c, "g");
        z.textStr = a;
        z.x = n;
        z.y = m;
        z.anchorX = C;
        z.anchorY = I;
        z.baseline = d;
        z.className = v;
        z.addClass("button" === v ? "highcharts-no-tooltip" : "highcharts-label");
        v && z.addClass("highcharts-" + v);
        z.text = c.text(void 0, 0, 0, L).attr({
          zIndex: 1
        });
        var u;
        "string" === typeof D && ((u = /^url\((.*?)\)$/.test(D)) || z.renderer.symbols[D]) && (z.symbolKey = D);
        z.bBox = f.emptyBBox;
        z.padding = 3;
        z.baselineOffset = 0;
        z.needsBox = c.styledMode || u;
        z.deferredAttr = {};
        z.alignFactor = 0;
        return z;
      }
      E(f, p);
      f.prototype.alignSetter = function (c) {
        c = {
          left: 0,
          center: .5,
          right: 1
        }[c];
        c !== this.alignFactor && (this.alignFactor = c, this.bBox && G(this.xSetting) && this.attr({
          x: this.xSetting
        }));
      };
      f.prototype.anchorXSetter = function (c, a) {
        this.anchorX = c;
        this.boxAttr(a, Math.round(c) - this.getCrispAdjust() - this.xSetting);
      };
      f.prototype.anchorYSetter = function (c, a) {
        this.anchorY = c;
        this.boxAttr(a, c - this.ySetting);
      };
      f.prototype.boxAttr = function (c, a) {
        this.box ? this.box.attr(c, a) : this.deferredAttr[c] = a;
      };
      f.prototype.css = function (c) {
        if (c) {
          var a = {};
          c = H(c);
          f.textProps.forEach(function (f) {
            "undefined" !== typeof c[f] && (a[f] = c[f], delete c[f]);
          });
          this.text.css(a);
          var n = ("width" in a);
          "fontSize" in a || "fontWeight" in a ? this.updateTextPadding() : n && this.updateBoxSize();
        }
        return d.prototype.css.call(this, c);
      };
      f.prototype.destroy = function () {
        q(this.element, "mouseenter");
        q(this.element, "mouseleave");
        this.text && this.text.destroy();
        this.box && (this.box = this.box.destroy());
        d.prototype.destroy.call(this);
      };
      f.prototype.fillSetter = function (c, a) {
        c && (this.needsBox = !0);
        this.fill = c;
        this.boxAttr(a, c);
      };
      f.prototype.getBBox = function () {
        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
        var c = this.padding,
          a = y(this.paddingLeft, c);
        return {
          width: this.width,
          height: this.height,
          x: this.bBox.x - a,
          y: this.bBox.y - c
        };
      };
      f.prototype.getCrispAdjust = function () {
        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
      };
      f.prototype.heightSetter = function (c) {
        this.heightSetting = c;
      };
      f.prototype.onAdd = function () {
        var c = this.textStr;
        this.text.add(this);
        this.attr({
          text: F(c) ? c : "",
          x: this.x,
          y: this.y
        });
        this.box && F(this.anchorX) && this.attr({
          anchorX: this.anchorX,
          anchorY: this.anchorY
        });
      };
      f.prototype.paddingSetter = function (c, a) {
        G(c) ? c !== this[a] && (this[a] = c, this.updateTextPadding()) : this[a] = void 0;
      };
      f.prototype.rSetter = function (c, a) {
        this.boxAttr(a, c);
      };
      f.prototype.shadow = function (c) {
        c && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(c));
        return this;
      };
      f.prototype.strokeSetter = function (c, a) {
        this.stroke = c;
        this.boxAttr(a, c);
      };
      f.prototype["stroke-widthSetter"] = function (c, a) {
        c && (this.needsBox = !0);
        this["stroke-width"] = c;
        this.boxAttr(a, c);
      };
      f.prototype["text-alignSetter"] = function (c) {
        this.textAlign = c;
      };
      f.prototype.textSetter = function (c) {
        "undefined" !== typeof c && this.text.attr({
          text: c
        });
        this.updateTextPadding();
      };
      f.prototype.updateBoxSize = function () {
        var c = this.text.element.style,
          a = {},
          n = this.padding,
          m = this.bBox = G(this.widthSetting) && G(this.heightSetting) && !this.textAlign || !F(this.text.textStr) ? f.emptyBBox : this.text.getBBox();
        this.width = this.getPaddedWidth();
        this.height = (this.heightSetting || m.height || 0) + 2 * n;
        c = this.renderer.fontMetrics(c && c.fontSize, this.text);
        this.baselineOffset = n + Math.min((this.text.firstLineMetrics || c).b, m.height || Infinity);
        this.heightSetting && (this.baselineOffset += (this.heightSetting - c.h) / 2);
        this.needsBox && (this.box || (n = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), n.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), n.add(this)), n = this.getCrispAdjust(), a.x = n, a.y = (this.baseline ? -this.baselineOffset : 0) + n, a.width = Math.round(this.width), a.height = Math.round(this.height), this.box.attr(t(a, this.deferredAttr)), this.deferredAttr = {});
      };
      f.prototype.updateTextPadding = function () {
        var c = this.text;
        this.updateBoxSize();
        var a = this.baseline ? 0 : this.baselineOffset,
          f = y(this.paddingLeft, this.padding);
        F(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (f += {
          center: .5,
          right: 1
        }[this.textAlign] * (this.widthSetting - this.bBox.width));
        if (f !== c.x || a !== c.y) c.attr("x", f), c.hasBoxWidthChanged && (this.bBox = c.getBBox(!0)), "undefined" !== typeof a && c.attr("y", a);
        c.x = f;
        c.y = a;
      };
      f.prototype.widthSetter = function (c) {
        this.widthSetting = G(c) ? c : void 0;
      };
      f.prototype.getPaddedWidth = function () {
        var c = this.padding,
          a = y(this.paddingLeft, c);
        c = y(this.paddingRight, c);
        return (this.widthSetting || this.bBox.width || 0) + a + c;
      };
      f.prototype.xSetter = function (c) {
        this.x = c;
        this.alignFactor && (c -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
        this.xSetting = Math.round(c);
        this.attr("translateX", this.xSetting);
      };
      f.prototype.ySetter = function (c) {
        this.ySetting = this.y = Math.round(c);
        this.attr("translateY", this.ySetting);
      };
      f.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      };
      f.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
      return f;
    }(d);
  });
  N(h, "Core/Renderer/SVG/Symbols.js", [h["Core/Utilities.js"]], function (d) {
    function h(d, q, p, f, c) {
      var a = [];
      if (c) {
        var n = c.start || 0,
          m = H(c.r, p);
        p = H(c.r, f || p);
        var D = (c.end || 0) - .001;
        f = c.innerR;
        var C = H(c.open, .001 > Math.abs((c.end || 0) - n - 2 * Math.PI)),
          I = Math.cos(n),
          L = Math.sin(n),
          h = Math.cos(D),
          v = Math.sin(D);
        n = H(c.longArc, .001 > D - n - Math.PI ? 0 : 1);
        a.push(["M", d + m * I, q + p * L], ["A", m, p, 0, n, H(c.clockwise, 1), d + m * h, q + p * v]);
        t(f) && a.push(C ? ["M", d + f * h, q + f * v] : ["L", d + f * h, q + f * v], ["A", f, f, 0, n, t(c.clockwise) ? 1 - c.clockwise : 0, d + f * I, q + f * L]);
        C || a.push(["Z"]);
      }
      return a;
    }
    function A(d, q, p, f, c) {
      return c && c.r ? F(d, q, p, f, c) : [["M", d, q], ["L", d + p, q], ["L", d + p, q + f], ["L", d, q + f], ["Z"]];
    }
    function F(d, q, p, f, c) {
      c = c && c.r || 0;
      return [["M", d + c, q], ["L", d + p - c, q], ["C", d + p, q, d + p, q, d + p, q + c], ["L", d + p, q + f - c], ["C", d + p, q + f, d + p, q + f, d + p - c, q + f], ["L", d + c, q + f], ["C", d, q + f, d, q + f, d, q + f - c], ["L", d, q + c], ["C", d, q, d, q, d + c, q]];
    }
    var t = d.defined,
      G = d.isNumber,
      H = d.pick;
    return {
      arc: h,
      callout: function (d, q, p, f, c) {
        var a = Math.min(c && c.r || 0, p, f),
          n = a + 6,
          m = c && c.anchorX;
        c = c && c.anchorY || 0;
        var D = F(d, q, p, f, {
          r: a
        });
        if (!G(m)) return D;
        d + m >= p ? c > q + n && c < q + f - n ? D.splice(3, 1, ["L", d + p, c - 6], ["L", d + p + 6, c], ["L", d + p, c + 6], ["L", d + p, q + f - a]) : D.splice(3, 1, ["L", d + p, f / 2], ["L", m, c], ["L", d + p, f / 2], ["L", d + p, q + f - a]) : 0 >= d + m ? c > q + n && c < q + f - n ? D.splice(7, 1, ["L", d, c + 6], ["L", d - 6, c], ["L", d, c - 6], ["L", d, q + a]) : D.splice(7, 1, ["L", d, f / 2], ["L", m, c], ["L", d, f / 2], ["L", d, q + a]) : c && c > f && m > d + n && m < d + p - n ? D.splice(5, 1, ["L", m + 6, q + f], ["L", m, q + f + 6], ["L", m - 6, q + f], ["L", d + a, q + f]) : c && 0 > c && m > d + n && m < d + p - n && D.splice(1, 1, ["L", m - 6, q], ["L", m, q - 6], ["L", m + 6, q], ["L", p - a, q]);
        return D;
      },
      circle: function (d, q, p, f) {
        return h(d + p / 2, q + f / 2, p / 2, f / 2, {
          start: .5 * Math.PI,
          end: 2.5 * Math.PI,
          open: !1
        });
      },
      diamond: function (d, q, p, f) {
        return [["M", d + p / 2, q], ["L", d + p, q + f / 2], ["L", d + p / 2, q + f], ["L", d, q + f / 2], ["Z"]];
      },
      rect: A,
      roundedRect: F,
      square: A,
      triangle: function (d, q, p, f) {
        return [["M", d + p / 2, q], ["L", d + p, q + f], ["L", d, q + f], ["Z"]];
      },
      "triangle-down": function (d, q, p, f) {
        return [["M", d, q], ["L", d + p, q], ["L", d + p / 2, q + f], ["Z"]];
      }
    };
  });
  N(h, "Core/Renderer/SVG/TextBuilder.js", [h["Core/Renderer/HTML/AST.js"], h["Core/Globals.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = h.doc,
      t = h.SVG_NS,
      G = h.win,
      H = A.attr,
      y = A.isString,
      q = A.objectEach,
      p = A.pick;
    return function () {
      function f(c) {
        var a = c.styles;
        this.renderer = c.renderer;
        this.svgElement = c;
        this.width = c.textWidth;
        this.textLineHeight = a && a.lineHeight;
        this.textOutline = a && a.textOutline;
        this.ellipsis = !(!a || "ellipsis" !== a.textOverflow);
        this.noWrap = !(!a || "nowrap" !== a.whiteSpace);
        this.fontSize = a && a.fontSize;
      }
      f.prototype.buildSVG = function () {
        var c = this.svgElement,
          a = c.element,
          f = c.renderer,
          m = p(c.textStr, "").toString(),
          D = -1 !== m.indexOf("<"),
          C = a.childNodes;
        f = this.width && !c.added && f.box;
        var I = /<br.*?>/g,
          L = [m, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();
        if (L !== c.textCache) {
          c.textCache = L;
          delete c.actualWidth;
          for (L = C.length; L--;) a.removeChild(C[L]);
          D || this.ellipsis || this.width || -1 !== m.indexOf(" ") && (!this.noWrap || I.test(m)) ? "" !== m && (f && f.appendChild(a), m = new d(m), this.modifyTree(m.nodes), m.addToDOM(c.element), this.modifyDOM(), this.ellipsis && -1 !== (a.textContent || "").indexOf("\u2026") && c.attr("title", this.unescapeEntities(c.textStr || "", ["&lt;", "&gt;"])), f && f.removeChild(a)) : a.appendChild(E.createTextNode(this.unescapeEntities(m)));
          y(this.textOutline) && c.applyTextOutline && c.applyTextOutline(this.textOutline);
        }
      };
      f.prototype.modifyDOM = function () {
        var c = this,
          a = this.svgElement,
          f = H(a.element, "x");
        a.firstLineMetrics = void 0;
        for (var m; m = a.element.firstChild;) if (/^[\s\u200B]*$/.test(m.textContent || " ")) a.element.removeChild(m);else break;
        [].forEach.call(a.element.querySelectorAll("tspan.highcharts-br"), function (n, m) {
          n.nextSibling && n.previousSibling && (0 === m && 1 === n.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(void 0, n.previousSibling)), H(n, {
            dy: c.getLineHeight(n.nextSibling),
            x: f
          }));
        });
        var d = this.width || 0;
        if (d) {
          var C = function (n, m) {
              var v = n.textContent || "",
                z = v.replace(/([^\^])-/g, "$1- ").split(" "),
                u = !c.noWrap && (1 < z.length || 1 < a.element.childNodes.length),
                k = c.getLineHeight(m),
                w = 0,
                l = a.actualWidth;
              if (c.ellipsis) v && c.truncate(n, v, void 0, 0, Math.max(0, d - parseInt(c.fontSize || 12, 10)), function (e, g) {
                return e.substring(0, g) + "\u2026";
              });else if (u) {
                v = [];
                for (u = []; m.firstChild && m.firstChild !== n;) u.push(m.firstChild), m.removeChild(m.firstChild);
                for (; z.length;) z.length && !c.noWrap && 0 < w && (v.push(n.textContent || ""), n.textContent = z.join(" ").replace(/- /g, "-")), c.truncate(n, void 0, z, 0 === w ? l || 0 : 0, d, function (e, g) {
                  return z.slice(0, g).join(" ").replace(/- /g, "-");
                }), l = a.actualWidth, w++;
                u.forEach(function (e) {
                  m.insertBefore(e, n);
                });
                v.forEach(function (e) {
                  m.insertBefore(E.createTextNode(e), n);
                  e = E.createElementNS(t, "tspan");
                  e.textContent = "\u200b";
                  H(e, {
                    dy: k,
                    x: f
                  });
                  m.insertBefore(e, n);
                });
              }
            },
            p = function (c) {
              [].slice.call(c.childNodes).forEach(function (f) {
                f.nodeType === G.Node.TEXT_NODE ? C(f, c) : (-1 !== f.className.baseVal.indexOf("highcharts-br") && (a.actualWidth = 0), p(f));
              });
            };
          p(a.element);
        }
      };
      f.prototype.getLineHeight = function (c) {
        var a;
        c = c.nodeType === G.Node.TEXT_NODE ? c.parentElement : c;
        this.renderer.styledMode || (a = c && /(px|em)$/.test(c.style.fontSize) ? c.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a, c || this.svgElement.element).h;
      };
      f.prototype.modifyTree = function (c) {
        var a = this,
          f = function (n, d) {
            var m = n.attributes;
            m = void 0 === m ? {} : m;
            var p = n.children,
              D = n.tagName,
              q = a.renderer.styledMode;
            if ("b" === D || "strong" === D) q ? m["class"] = "highcharts-strong" : m.style = "font-weight:bold;" + (m.style || "");else if ("i" === D || "em" === D) q ? m["class"] = "highcharts-emphasized" : m.style = "font-style:italic;" + (m.style || "");
            y(m.style) && (m.style = m.style.replace(/(;| |^)color([ :])/, "$1fill$2"));
            "br" === D ? (m["class"] = "highcharts-br", n.textContent = "\u200b", (d = c[d + 1]) && d.textContent && (d.textContent = d.textContent.replace(/^ +/gm, ""))) : "a" === D && p && p.some(function (a) {
              return "#text" === a.tagName;
            }) && (n.children = [{
              children: p,
              tagName: "tspan"
            }]);
            "#text" !== D && "a" !== D && (n.tagName = "tspan");
            n.attributes = m;
            p && p.filter(function (a) {
              return "#text" !== a.tagName;
            }).forEach(f);
          };
        c.forEach(f);
      };
      f.prototype.truncate = function (c, a, f, m, d, p) {
        var n = this.svgElement,
          C = n.renderer,
          D = n.rotation,
          v = [],
          z = f ? 1 : 0,
          u = (a || f || "").length,
          k = u,
          w,
          l = function (e, b) {
            b = b || e;
            var g = c.parentNode;
            if (g && "undefined" === typeof v[b]) if (g.getSubStringLength) try {
              v[b] = m + g.getSubStringLength(0, f ? b + 1 : b);
            } catch (J) {
              "";
            } else C.getSpanWidth && (c.textContent = p(a || f, e), v[b] = m + C.getSpanWidth(n, c));
            return v[b];
          };
        n.rotation = 0;
        var e = l(c.textContent.length);
        if (m + e > d) {
          for (; z <= u;) k = Math.ceil((z + u) / 2), f && (w = p(f, k)), e = l(k, w && w.length - 1), z === u ? z = u + 1 : e > d ? u = k - 1 : z = k;
          0 === u ? c.textContent = "" : a && u === a.length - 1 || (c.textContent = w || p(a || f, k));
        }
        f && f.splice(0, k);
        n.actualWidth = e;
        n.rotation = D;
      };
      f.prototype.unescapeEntities = function (c, a) {
        q(this.renderer.escapes, function (f, m) {
          a && -1 !== a.indexOf(f) || (c = c.toString().replace(new RegExp(f, "g"), m));
        });
        return c;
      };
      return f;
    }();
  });
  N(h, "Core/Renderer/SVG/SVGRenderer.js", [h["Core/Renderer/HTML/AST.js"], h["Core/Color/Color.js"], h["Core/Globals.js"], h["Core/Renderer/RendererRegistry.js"], h["Core/Renderer/SVG/SVGElement.js"], h["Core/Renderer/SVG/SVGLabel.js"], h["Core/Renderer/SVG/Symbols.js"], h["Core/Renderer/SVG/TextBuilder.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G, H, y, q) {
    var p = A.charts,
      f = A.deg2rad,
      c = A.doc,
      a = A.isFirefox,
      n = A.isMS,
      m = A.isWebKit,
      D = A.noop,
      C = A.SVG_NS,
      I = A.symbolSizes,
      L = A.win,
      K = q.addEvent,
      v = q.attr,
      z = q.createElement,
      u = q.css,
      k = q.defined,
      w = q.destroyObjectProperties,
      l = q.extend,
      e = q.isArray,
      g = q.isNumber,
      b = q.isObject,
      B = q.isString,
      J = q.merge,
      r = q.pick,
      x = q.pInt,
      M = q.uniqueKey,
      X;
    A = function () {
      function P(b, e, g, l, k, a, r) {
        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
        this.init(b, e, g, l, k, a, r);
      }
      P.prototype.init = function (b, e, g, l, k, r, B) {
        var x = this.createElement("svg").attr({
            version: "1.1",
            "class": "highcharts-root"
          }),
          O = x.element;
        B || x.css(this.getStyle(l));
        b.appendChild(O);
        v(b, "dir", "ltr");
        -1 === b.innerHTML.indexOf("xmlns") && v(O, "xmlns", this.SVG_NS);
        this.isSVG = !0;
        this.box = O;
        this.boxWrapper = x;
        this.alignedObjects = [];
        this.url = this.getReferenceURL();
        this.createElement("desc").add().element.appendChild(c.createTextNode("Created with Highcharts 9.3.3"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = r;
        this.forExport = k;
        this.styledMode = B;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(e, g, !1);
        var P;
        a && b.getBoundingClientRect && (e = function () {
          u(b, {
            left: 0,
            top: 0
          });
          P = b.getBoundingClientRect();
          u(b, {
            left: Math.ceil(P.left) - P.left + "px",
            top: Math.ceil(P.top) - P.top + "px"
          });
        }, e(), this.unSubPixelFix = K(L, "resize", e));
      };
      P.prototype.definition = function (b) {
        return new d([b]).addToDOM(this.defs.element);
      };
      P.prototype.getReferenceURL = function () {
        if ((a || m) && c.getElementsByTagName("base").length) {
          if (!k(X)) {
            var b = M();
            b = new d([{
              tagName: "svg",
              attributes: {
                width: 8,
                height: 8
              },
              children: [{
                tagName: "defs",
                children: [{
                  tagName: "clipPath",
                  attributes: {
                    id: b
                  },
                  children: [{
                    tagName: "rect",
                    attributes: {
                      width: 4,
                      height: 4
                    }
                  }]
                }]
              }, {
                tagName: "rect",
                attributes: {
                  id: "hitme",
                  width: 8,
                  height: 8,
                  "clip-path": "url(#" + b + ")",
                  fill: "rgba(0,0,0,0.001)"
                }
              }]
            }]).addToDOM(c.body);
            u(b, {
              position: "fixed",
              top: 0,
              left: 0,
              zIndex: 9E5
            });
            var e = c.elementFromPoint(6, 6);
            X = "hitme" === (e && e.id);
            c.body.removeChild(b);
          }
          if (X) return L.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
        }
        return "";
      };
      P.prototype.getStyle = function (b) {
        return this.style = l({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: "12px"
        }, b);
      };
      P.prototype.setStyle = function (b) {
        this.boxWrapper.css(this.getStyle(b));
      };
      P.prototype.isHidden = function () {
        return !this.boxWrapper.getBBox().width;
      };
      P.prototype.destroy = function () {
        var b = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        w(this.gradients || {});
        this.gradients = null;
        b && (this.defs = b.destroy());
        this.unSubPixelFix && this.unSubPixelFix();
        return this.alignedObjects = null;
      };
      P.prototype.createElement = function (b) {
        var e = new this.Element();
        e.init(this, b);
        return e;
      };
      P.prototype.getRadialAttr = function (b, e) {
        return {
          cx: b[0] - b[2] / 2 + (e.cx || 0) * b[2],
          cy: b[1] - b[2] / 2 + (e.cy || 0) * b[2],
          r: (e.r || 0) * b[2]
        };
      };
      P.prototype.buildText = function (b) {
        new y(b).buildSVG();
      };
      P.prototype.getContrast = function (b) {
        b = h.parse(b).rgba;
        b[0] *= 1;
        b[1] *= 1.2;
        b[2] *= .5;
        return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
      };
      P.prototype.button = function (b, e, g, k, a, r, c, B, x, P) {
        var u = this.label(b, e, g, x, void 0, void 0, P, void 0, "button"),
          w = this.styledMode,
          O = 0,
          f = a ? J(a) : {};
        b = f && f.style || {};
        f = d.filterUserAttributes(f);
        u.attr(J({
          padding: 8,
          r: 2
        }, f));
        if (!w) {
          f = J({
            fill: "#f7f7f7",
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontWeight: "normal"
            }
          }, {
            style: b
          }, f);
          var Q = f.style;
          delete f.style;
          r = J(f, {
            fill: "#e6e6e6"
          }, d.filterUserAttributes(r || {}));
          var z = r.style;
          delete r.style;
          c = J(f, {
            fill: "#e6ebf5",
            style: {
              color: "#000000",
              fontWeight: "bold"
            }
          }, d.filterUserAttributes(c || {}));
          var m = c.style;
          delete c.style;
          B = J(f, {
            style: {
              color: "#cccccc"
            }
          }, d.filterUserAttributes(B || {}));
          var W = B.style;
          delete B.style;
        }
        K(u.element, n ? "mouseover" : "mouseenter", function () {
          3 !== O && u.setState(1);
        });
        K(u.element, n ? "mouseout" : "mouseleave", function () {
          3 !== O && u.setState(O);
        });
        u.setState = function (b) {
          1 !== b && (u.state = O = b);
          u.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
          w || u.attr([f, r, c, B][b || 0]).css([Q, z, m, W][b || 0]);
        };
        w || u.attr(f).css(l({
          cursor: "default"
        }, Q));
        return u.on("touchstart", function (b) {
          return b.stopPropagation();
        }).on("click", function (b) {
          3 !== O && k.call(u, b);
        });
      };
      P.prototype.crispLine = function (b, e, g) {
        void 0 === g && (g = "round");
        var l = b[0],
          a = b[1];
        k(l[1]) && l[1] === a[1] && (l[1] = a[1] = Math[g](l[1]) - e % 2 / 2);
        k(l[2]) && l[2] === a[2] && (l[2] = a[2] = Math[g](l[2]) + e % 2 / 2);
        return b;
      };
      P.prototype.path = function (g) {
        var k = this.styledMode ? {} : {
          fill: "none"
        };
        e(g) ? k.d = g : b(g) && l(k, g);
        return this.createElement("path").attr(k);
      };
      P.prototype.circle = function (e, g, l) {
        e = b(e) ? e : "undefined" === typeof e ? {} : {
          x: e,
          y: g,
          r: l
        };
        g = this.createElement("circle");
        g.xSetter = g.ySetter = function (b, e, g) {
          g.setAttribute("c" + e, b);
        };
        return g.attr(e);
      };
      P.prototype.arc = function (e, g, l, k, a, r) {
        b(e) ? (k = e, g = k.y, l = k.r, e = k.x) : k = {
          innerR: k,
          start: a,
          end: r
        };
        e = this.symbol("arc", e, g, l, l, k);
        e.r = l;
        return e;
      };
      P.prototype.rect = function (e, g, l, k, a, r) {
        a = b(e) ? e.r : a;
        var c = this.createElement("rect");
        e = b(e) ? e : "undefined" === typeof e ? {} : {
          x: e,
          y: g,
          width: Math.max(l, 0),
          height: Math.max(k, 0)
        };
        this.styledMode || ("undefined" !== typeof r && (e["stroke-width"] = r, e = c.crisp(e)), e.fill = "none");
        a && (e.r = a);
        c.rSetter = function (b, e, g) {
          c.r = b;
          v(g, {
            rx: b,
            ry: b
          });
        };
        c.rGetter = function () {
          return c.r || 0;
        };
        return c.attr(e);
      };
      P.prototype.setSize = function (b, e, g) {
        this.width = b;
        this.height = e;
        this.boxWrapper.animate({
          width: b,
          height: e
        }, {
          step: function () {
            this.attr({
              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
            });
          },
          duration: r(g, !0) ? void 0 : 0
        });
        this.alignElements();
      };
      P.prototype.g = function (b) {
        var e = this.createElement("g");
        return b ? e.attr({
          "class": "highcharts-" + b
        }) : e;
      };
      P.prototype.image = function (b, e, l, k, a, r) {
        var c = {
            preserveAspectRatio: "none"
          },
          B = function (b, e) {
            b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", e) : b.setAttribute("hc-svg-href", e);
          };
        g(e) && (c.x = e);
        g(l) && (c.y = l);
        g(k) && (c.width = k);
        g(a) && (c.height = a);
        var x = this.createElement("image").attr(c);
        e = function (e) {
          B(x.element, b);
          r.call(x, e);
        };
        r ? (B(x.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), l = new L.Image(), K(l, "load", e), l.src = b, l.complete && e({})) : B(x.element, b);
        return x;
      };
      P.prototype.symbol = function (b, e, g, a, B, x) {
        var P = this,
          w = /^url\((.*?)\)$/,
          f = w.test(b),
          J = !f && (this.symbols[b] ? b : "circle"),
          O = J && this.symbols[J],
          Q;
        if (O) {
          "number" === typeof e && (Q = O.call(this.symbols, Math.round(e || 0), Math.round(g || 0), a || 0, B || 0, x));
          var n = this.path(Q);
          P.styledMode || n.attr("fill", "none");
          l(n, {
            symbolName: J || void 0,
            x: e,
            y: g,
            width: a,
            height: B
          });
          x && l(n, x);
        } else if (f) {
          var m = b.match(w)[1];
          var v = n = this.image(m);
          v.imgwidth = r(I[m] && I[m].width, x && x.width);
          v.imgheight = r(I[m] && I[m].height, x && x.height);
          var d = function (b) {
            return b.attr({
              width: b.width,
              height: b.height
            });
          };
          ["width", "height"].forEach(function (b) {
            v[b + "Setter"] = function (b, e) {
              var g = this["img" + e];
              this[e] = b;
              k(g) && (x && "within" === x.backgroundSize && this.width && this.height && (g = Math.round(g * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(e, g), this.alignByTranslate || (b = ((this[e] || 0) - g) / 2, this.attr("width" === e ? {
                translateX: b
              } : {
                translateY: b
              })));
            };
          });
          k(e) && v.attr({
            x: e,
            y: g
          });
          v.isImg = !0;
          k(v.imgwidth) && k(v.imgheight) ? d(v) : (v.attr({
            width: 0,
            height: 0
          }), z("img", {
            onload: function () {
              var b = p[P.chartIndex];
              0 === this.width && (u(this, {
                position: "absolute",
                top: "-999em"
              }), c.body.appendChild(this));
              I[m] = {
                width: this.width,
                height: this.height
              };
              v.imgwidth = this.width;
              v.imgheight = this.height;
              v.element && d(v);
              this.parentNode && this.parentNode.removeChild(this);
              P.imgCount--;
              if (!P.imgCount && b && !b.hasLoaded) b.onload();
            },
            src: m
          }), this.imgCount++);
        }
        return n;
      };
      P.prototype.clipRect = function (b, e, g, l) {
        var k = M() + "-",
          a = this.createElement("clipPath").attr({
            id: k
          }).add(this.defs);
        b = this.rect(b, e, g, l, 0).add(a);
        b.id = k;
        b.clipPath = a;
        b.count = 0;
        return b;
      };
      P.prototype.text = function (b, e, g, l) {
        var a = {};
        if (l && (this.allowHTML || !this.forExport)) return this.html(b, e, g);
        a.x = Math.round(e || 0);
        g && (a.y = Math.round(g));
        k(b) && (a.text = b);
        b = this.createElement("text").attr(a);
        if (!l || this.forExport && !this.allowHTML) b.xSetter = function (b, e, g) {
          for (var l = g.getElementsByTagName("tspan"), k = g.getAttribute(e), a = 0, r; a < l.length; a++) r = l[a], r.getAttribute(e) === k && r.setAttribute(e, b);
          g.setAttribute(e, b);
        };
        return b;
      };
      P.prototype.fontMetrics = function (b, e) {
        b = !this.styledMode && /px/.test(b) || !L.getComputedStyle ? b || e && e.style && e.style.fontSize || this.style && this.style.fontSize : e && t.prototype.getStyle.call(e, "font-size");
        b = /px/.test(b) ? x(b) : 12;
        e = 24 > b ? b + 3 : Math.round(1.2 * b);
        return {
          h: e,
          b: Math.round(.8 * e),
          f: b
        };
      };
      P.prototype.rotCorr = function (b, e, g) {
        var l = b;
        e && g && (l = Math.max(l * Math.cos(e * f), 4));
        return {
          x: -b / 3 * Math.sin(e * f),
          y: l
        };
      };
      P.prototype.pathToSegments = function (b) {
        for (var e = [], l = [], k = {
            A: 8,
            C: 7,
            H: 2,
            L: 3,
            M: 3,
            Q: 5,
            S: 5,
            T: 3,
            V: 2
          }, a = 0; a < b.length; a++) B(l[0]) && g(b[a]) && l.length === k[l[0].toUpperCase()] && b.splice(a, 0, l[0].replace("M", "L").replace("m", "l")), "string" === typeof b[a] && (l.length && e.push(l.slice(0)), l.length = 0), l.push(b[a]);
        e.push(l.slice(0));
        return e;
      };
      P.prototype.label = function (b, e, g, l, k, a, r, c, x) {
        return new G(this, b, e, g, l, k, a, r, c, x);
      };
      P.prototype.alignElements = function () {
        this.alignedObjects.forEach(function (b) {
          return b.align();
        });
      };
      return P;
    }();
    l(A.prototype, {
      Element: t,
      SVG_NS: C,
      escapes: {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      },
      symbols: H,
      draw: D
    });
    F.registerRendererType("svg", A, !0);
    "";
    return A;
  });
  N(h, "Core/Renderer/HTML/HTMLElement.js", [h["Core/Globals.js"], h["Core/Renderer/SVG/SVGElement.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = this && this.__extends || function () {
        var a = function (c, f) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);
          };
          return a(c, f);
        };
        return function (c, f) {
          function n() {
            this.constructor = c;
          }
          a(c, f);
          c.prototype = null === f ? Object.create(f) : (n.prototype = f.prototype, new n());
        };
      }(),
      t = d.isFirefox,
      G = d.isMS,
      H = d.isWebKit,
      y = d.win,
      q = A.css,
      p = A.defined,
      f = A.extend,
      c = A.pick,
      a = A.pInt;
    return function (n) {
      function m() {
        return null !== n && n.apply(this, arguments) || this;
      }
      E(m, n);
      m.compose = function (a) {
        if (-1 === m.composedClasses.indexOf(a)) {
          m.composedClasses.push(a);
          var c = m.prototype,
            f = a.prototype;
          f.getSpanCorrection = c.getSpanCorrection;
          f.htmlCss = c.htmlCss;
          f.htmlGetBBox = c.htmlGetBBox;
          f.htmlUpdateTransform = c.htmlUpdateTransform;
          f.setSpanRotation = c.setSpanRotation;
        }
        return a;
      };
      m.prototype.getSpanCorrection = function (a, c, f) {
        this.xCorr = -a * f;
        this.yCorr = -c;
      };
      m.prototype.htmlCss = function (a) {
        var n = "SPAN" === this.element.tagName && a && "width" in a,
          m = c(n && a.width, void 0);
        if (n) {
          delete a.width;
          this.textWidth = m;
          var d = !0;
        }
        a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
        this.styles = f(this.styles, a);
        q(this.element, a);
        d && this.htmlUpdateTransform();
        return this;
      };
      m.prototype.htmlGetBBox = function () {
        var a = this.element;
        return {
          x: a.offsetLeft,
          y: a.offsetTop,
          width: a.offsetWidth,
          height: a.offsetHeight
        };
      };
      m.prototype.htmlUpdateTransform = function () {
        if (this.added) {
          var c = this.renderer,
            f = this.element,
            n = this.translateX || 0,
            m = this.translateY || 0,
            d = this.x || 0,
            v = this.y || 0,
            z = this.textAlign || "left",
            u = {
              left: 0,
              center: .5,
              right: 1
            }[z],
            k = this.styles;
          k = k && k.whiteSpace;
          q(f, {
            marginLeft: n,
            marginTop: m
          });
          !c.styledMode && this.shadows && this.shadows.forEach(function (b) {
            q(b, {
              marginLeft: n + 1,
              marginTop: m + 1
            });
          });
          this.inverted && [].forEach.call(f.childNodes, function (b) {
            c.invertChild(b, f);
          });
          if ("SPAN" === f.tagName) {
            var w = this.rotation,
              l = this.textWidth && a(this.textWidth),
              e = [w, z, f.innerHTML, this.textWidth, this.textAlign].join(),
              g = void 0;
            g = !1;
            if (l !== this.oldTextWidth) {
              if (this.textPxLength) var b = this.textPxLength;else q(f, {
                width: "",
                whiteSpace: k || "nowrap"
              }), b = f.offsetWidth;
              (l > this.oldTextWidth || b > l) && (/[ \-]/.test(f.textContent || f.innerText) || "ellipsis" === f.style.textOverflow) && (q(f, {
                width: b > l || w ? l + "px" : "auto",
                display: "block",
                whiteSpace: k || "normal"
              }), this.oldTextWidth = l, g = !0);
            }
            this.hasBoxWidthChanged = g;
            e !== this.cTT && (g = c.fontMetrics(f.style.fontSize, f).b, !p(w) || w === (this.oldRotation || 0) && z === this.oldAlign || this.setSpanRotation(w, u, g), this.getSpanCorrection(!p(w) && this.textPxLength || f.offsetWidth, g, u, w, z));
            q(f, {
              left: d + (this.xCorr || 0) + "px",
              top: v + (this.yCorr || 0) + "px"
            });
            this.cTT = e;
            this.oldRotation = w;
            this.oldAlign = z;
          }
        } else this.alignOnAdd = !0;
      };
      m.prototype.setSpanRotation = function (a, c, f) {
        var n = {},
          m = G && !/Edge/.test(y.navigator.userAgent) ? "-ms-transform" : H ? "-webkit-transform" : t ? "MozTransform" : y.opera ? "-o-transform" : void 0;
        m && (n[m] = n.transform = "rotate(" + a + "deg)", n[m + (t ? "Origin" : "-origin")] = n.transformOrigin = 100 * c + "% " + f + "px", q(this.element, n));
      };
      m.composedClasses = [];
      return m;
    }(h);
  });
  N(h, "Core/Renderer/HTML/HTMLRenderer.js", [h["Core/Renderer/HTML/AST.js"], h["Core/Renderer/SVG/SVGElement.js"], h["Core/Renderer/SVG/SVGRenderer.js"], h["Core/Utilities.js"]], function (d, h, A, F) {
    var t = this && this.__extends || function () {
        var d = function (f, c) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);
          };
          return d(f, c);
        };
        return function (f, c) {
          function a() {
            this.constructor = f;
          }
          d(f, c);
          f.prototype = null === c ? Object.create(c) : (a.prototype = c.prototype, new a());
        };
      }(),
      E = F.attr,
      H = F.createElement,
      y = F.extend,
      q = F.pick;
    return function (p) {
      function f() {
        return null !== p && p.apply(this, arguments) || this;
      }
      t(f, p);
      f.compose = function (c) {
        -1 === f.composedClasses.indexOf(c) && (f.composedClasses.push(c), c.prototype.html = f.prototype.html);
        return c;
      };
      f.prototype.html = function (c, a, f) {
        var n = this.createElement("span"),
          p = n.element,
          C = n.renderer,
          I = C.isSVG,
          L = function (a, c) {
            ["opacity", "visibility"].forEach(function (f) {
              a[f + "Setter"] = function (u, k, w) {
                var l = a.div ? a.div.style : c;
                h.prototype[f + "Setter"].call(this, u, k, w);
                l && (l[k] = u);
              };
            });
            a.addedSetters = !0;
          };
        n.textSetter = function (a) {
          a !== this.textStr && (delete this.bBox, delete this.oldTextWidth, d.setElementHTML(this.element, q(a, "")), this.textStr = a, n.doTransform = !0);
        };
        I && L(n, n.element.style);
        n.xSetter = n.ySetter = n.alignSetter = n.rotationSetter = function (a, c) {
          "align" === c ? n.alignValue = n.textAlign = a : n[c] = a;
          n.doTransform = !0;
        };
        n.afterSetters = function () {
          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
        };
        n.attr({
          text: c,
          x: Math.round(a),
          y: Math.round(f)
        }).css({
          position: "absolute"
        });
        C.styledMode || n.css({
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize
        });
        p.style.whiteSpace = "nowrap";
        n.css = n.htmlCss;
        I && (n.add = function (a) {
          var c = C.box.parentNode,
            f = [];
          if (this.parentGroup = a) {
            var u = a.div;
            if (!u) {
              for (; a;) f.push(a), a = a.parentGroup;
              f.reverse().forEach(function (k) {
                function a(b, e) {
                  k[e] = b;
                  "translateX" === e ? g.left = b + "px" : g.top = b + "px";
                  k.doTransform = !0;
                }
                var l = E(k.element, "class"),
                  e = k.styles || {};
                u = k.div = k.div || H("div", l ? {
                  className: l
                } : void 0, {
                  position: "absolute",
                  left: (k.translateX || 0) + "px",
                  top: (k.translateY || 0) + "px",
                  display: k.display,
                  opacity: k.opacity,
                  cursor: e.cursor,
                  pointerEvents: e.pointerEvents,
                  visibility: k.visibility
                }, u || c);
                var g = u.style;
                y(k, {
                  classSetter: function (b) {
                    return function (e) {
                      this.element.setAttribute("class", e);
                      b.className = e;
                    };
                  }(u),
                  on: function () {
                    f[0].div && n.on.apply({
                      element: f[0].div,
                      onEvents: k.onEvents
                    }, arguments);
                    return k;
                  },
                  translateXSetter: a,
                  translateYSetter: a
                });
                k.addedSetters || L(k);
              });
            }
          } else u = c;
          u.appendChild(p);
          n.added = !0;
          n.alignOnAdd && n.htmlUpdateTransform();
          return n;
        });
        return n;
      };
      f.composedClasses = [];
      return f;
    }(A);
  });
  N(h, "Core/Axis/AxisDefaults.js", [], function () {
    var d;
    (function (d) {
      d.defaultXAxisOptions = {
        alignTicks: !0,
        allowDecimals: void 0,
        panningEnabled: !0,
        zIndex: 2,
        zoomEnabled: !0,
        dateTimeLabelFormats: {
          millisecond: {
            main: "%H:%M:%S.%L",
            range: !1
          },
          second: {
            main: "%H:%M:%S",
            range: !1
          },
          minute: {
            main: "%H:%M",
            range: !1
          },
          hour: {
            main: "%H:%M",
            range: !1
          },
          day: {
            main: "%e. %b"
          },
          week: {
            main: "%e. %b"
          },
          month: {
            main: "%b '%y"
          },
          year: {
            main: "%Y"
          }
        },
        endOnTick: !1,
        gridLineDashStyle: "Solid",
        gridZIndex: 1,
        labels: {
          autoRotation: void 0,
          autoRotationLimit: 80,
          distance: void 0,
          enabled: !0,
          indentation: 10,
          overflow: "justify",
          padding: 5,
          reserveSpace: void 0,
          rotation: void 0,
          staggerLines: 0,
          step: 0,
          useHTML: !1,
          x: 0,
          zIndex: 7,
          style: {
            color: "#666666",
            cursor: "default",
            fontSize: "11px"
          }
        },
        maxPadding: .01,
        minorGridLineDashStyle: "Solid",
        minorTickLength: 2,
        minorTickPosition: "outside",
        minPadding: .01,
        offset: void 0,
        opposite: !1,
        reversed: void 0,
        reversedStacks: !1,
        showEmpty: !0,
        showFirstLabel: !0,
        showLastLabel: !0,
        startOfWeek: 1,
        startOnTick: !1,
        tickLength: 10,
        tickPixelInterval: 100,
        tickmarkPlacement: "between",
        tickPosition: "outside",
        title: {
          align: "middle",
          rotation: 0,
          useHTML: !1,
          x: 0,
          y: 0,
          style: {
            color: "#666666"
          }
        },
        type: "linear",
        uniqueNames: !0,
        visible: !0,
        minorGridLineColor: "#f2f2f2",
        minorGridLineWidth: 1,
        minorTickColor: "#999999",
        lineColor: "#ccd6eb",
        lineWidth: 1,
        gridLineColor: "#e6e6e6",
        gridLineWidth: void 0,
        tickColor: "#ccd6eb"
      };
      d.defaultYAxisOptions = {
        reversedStacks: !0,
        endOnTick: !0,
        maxPadding: .05,
        minPadding: .05,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {
          x: -8
        },
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          animation: {},
          allowOverlap: !1,
          enabled: !1,
          crop: !0,
          overflow: "justify",
          formatter: function () {
            var d = this.axis.chart.numberFormatter;
            return d(this.total, -1);
          },
          style: {
            color: "#000000",
            fontSize: "11px",
            fontWeight: "bold",
            textOutline: "1px contrast"
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
      };
      d.defaultLeftAxisOptions = {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      };
      d.defaultRightAxisOptions = {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      };
      d.defaultBottomAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
      d.defaultTopAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
    })(d || (d = {}));
    return d;
  });
  N(h, "Core/Foundation.js", [h["Core/Utilities.js"]], function (d) {
    var h = d.addEvent,
      A = d.isFunction,
      F = d.objectEach,
      t = d.removeEvent,
      G;
    (function (d) {
      d.registerEventOptions = function (d, q) {
        d.eventOptions = d.eventOptions || {};
        F(q.events, function (p, f) {
          d.eventOptions[f] !== p && (d.eventOptions[f] && (t(d, f, d.eventOptions[f]), delete d.eventOptions[f]), A(p) && (d.eventOptions[f] = p, h(d, f, p)));
        });
      };
    })(G || (G = {}));
    return G;
  });
  N(h, "Core/Axis/Tick.js", [h["Core/FormatUtilities.js"], h["Core/Globals.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = h.deg2rad,
      t = A.clamp,
      G = A.correctFloat,
      H = A.defined,
      y = A.destroyObjectProperties,
      q = A.extend,
      p = A.fireEvent,
      f = A.isNumber,
      c = A.merge,
      a = A.objectEach,
      n = A.pick;
    h = function () {
      function m(a, c, f, n, d) {
        this.isNewLabel = this.isNew = !0;
        this.axis = a;
        this.pos = c;
        this.type = f || "";
        this.parameters = d || {};
        this.tickmarkOffset = this.parameters.tickmarkOffset;
        this.options = this.parameters.options;
        p(this, "init");
        f || n || this.addLabel();
      }
      m.prototype.addLabel = function () {
        var a = this,
          c = a.axis,
          m = c.options,
          h = c.chart,
          K = c.categories,
          v = c.logarithmic,
          z = c.names,
          u = a.pos,
          k = n(a.options && a.options.labels, m.labels),
          w = c.tickPositions,
          l = u === w[0],
          e = u === w[w.length - 1],
          g = (!k.step || 1 === k.step) && 1 === c.tickInterval;
        w = w.info;
        var b = a.label,
          B;
        K = this.parameters.category || (K ? n(K[u], z[u], u) : u);
        v && f(K) && (K = G(v.lin2log(K)));
        if (c.dateTime) if (w) {
          var J = h.time.resolveDTLFormat(m.dateTimeLabelFormats[!m.grid && w.higherRanks[u] || w.unitName]);
          var r = J.main;
        } else f(K) && (r = c.dateTime.getXDateFormat(K, m.dateTimeLabelFormats || {}));
        a.isFirst = l;
        a.isLast = e;
        var x = {
          axis: c,
          chart: h,
          dateTimeLabelFormat: r,
          isFirst: l,
          isLast: e,
          pos: u,
          tick: a,
          tickPositionInfo: w,
          value: K
        };
        p(this, "labelFormat", x);
        var M = function (b) {
          return k.formatter ? k.formatter.call(b, b) : k.format ? (b.text = c.defaultLabelFormatter.call(b), d.format(k.format, b, h)) : c.defaultLabelFormatter.call(b, b);
        };
        m = M.call(x, x);
        var X = J && J.list;
        a.shortenLabel = X ? function () {
          for (B = 0; B < X.length; B++) if (q(x, {
            dateTimeLabelFormat: X[B]
          }), b.attr({
            text: M.call(x, x)
          }), b.getBBox().width < c.getSlotWidth(a) - 2 * k.padding) return;
          b.attr({
            text: ""
          });
        } : void 0;
        g && c._addedPlotLB && a.moveLabel(m, k);
        H(b) || a.movedLabel ? b && b.textStr !== m && !g && (!b.textWidth || k.style.width || b.styles.width || b.css({
          width: null
        }), b.attr({
          text: m
        }), b.textPxLength = b.getBBox().width) : (a.label = b = a.createLabel({
          x: 0,
          y: 0
        }, m, k), a.rotation = 0);
      };
      m.prototype.createLabel = function (a, f, n) {
        var d = this.axis,
          m = d.chart;
        if (a = H(f) && n.enabled ? m.renderer.text(f, a.x, a.y, n.useHTML).add(d.labelGroup) : null) m.styledMode || a.css(c(n.style)), a.textPxLength = a.getBBox().width;
        return a;
      };
      m.prototype.destroy = function () {
        y(this, this.axis);
      };
      m.prototype.getPosition = function (a, c, f, n) {
        var d = this.axis,
          m = d.chart,
          z = n && m.oldChartHeight || m.chartHeight;
        a = {
          x: a ? G(d.translate(c + f, null, null, n) + d.transB) : d.left + d.offset + (d.opposite ? (n && m.oldChartWidth || m.chartWidth) - d.right - d.left : 0),
          y: a ? z - d.bottom + d.offset - (d.opposite ? d.height : 0) : G(z - d.translate(c + f, null, null, n) - d.transB)
        };
        a.y = t(a.y, -1E5, 1E5);
        p(this, "afterGetPosition", {
          pos: a
        });
        return a;
      };
      m.prototype.getLabelPosition = function (a, c, f, n, d, m, z, u) {
        var k = this.axis,
          w = k.transA,
          l = k.isLinked && k.linkedParent ? k.linkedParent.reversed : k.reversed,
          e = k.staggerLines,
          g = k.tickRotCorr || {
            x: 0,
            y: 0
          },
          b = n || k.reserveSpaceDefault ? 0 : -k.labelOffset * ("center" === k.labelAlign ? .5 : 1),
          B = {},
          J = d.y;
        H(J) || (J = 0 === k.side ? f.rotation ? -8 : -f.getBBox().height : 2 === k.side ? g.y + 8 : Math.cos(f.rotation * E) * (g.y - f.getBBox(!1, 0).height / 2));
        a = a + d.x + b + g.x - (m && n ? m * w * (l ? -1 : 1) : 0);
        c = c + J - (m && !n ? m * w * (l ? 1 : -1) : 0);
        e && (f = z / (u || 1) % e, k.opposite && (f = e - f - 1), c += k.labelOffset / e * f);
        B.x = a;
        B.y = Math.round(c);
        p(this, "afterGetLabelPosition", {
          pos: B,
          tickmarkOffset: m,
          index: z
        });
        return B;
      };
      m.prototype.getLabelSize = function () {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
      };
      m.prototype.getMarkPath = function (a, c, f, n, d, m) {
        return m.crispLine([["M", a, c], ["L", a + (d ? 0 : -f), c + (d ? f : 0)]], n);
      };
      m.prototype.handleOverflow = function (a) {
        var c = this.axis,
          f = c.options.labels,
          d = a.x,
          m = c.chart.chartWidth,
          v = c.chart.spacing,
          z = n(c.labelLeft, Math.min(c.pos, v[3]));
        v = n(c.labelRight, Math.max(c.isRadial ? 0 : c.pos + c.len, m - v[1]));
        var u = this.label,
          k = this.rotation,
          w = {
            left: 0,
            center: .5,
            right: 1
          }[c.labelAlign || u.attr("align")],
          l = u.getBBox().width,
          e = c.getSlotWidth(this),
          g = {},
          b = e,
          B = 1,
          J;
        if (k || "justify" !== f.overflow) 0 > k && d - w * l < z ? J = Math.round(d / Math.cos(k * E) - z) : 0 < k && d + w * l > v && (J = Math.round((m - d) / Math.cos(k * E)));else if (m = d + (1 - w) * l, d - w * l < z ? b = a.x + b * (1 - w) - z : m > v && (b = v - a.x + b * w, B = -1), b = Math.min(e, b), b < e && "center" === c.labelAlign && (a.x += B * (e - b - w * (e - Math.min(l, b)))), l > b || c.autoRotation && (u.styles || {}).width) J = b;
        J && (this.shortenLabel ? this.shortenLabel() : (g.width = Math.floor(J) + "px", (f.style || {}).textOverflow || (g.textOverflow = "ellipsis"), u.css(g)));
      };
      m.prototype.moveLabel = function (c, f) {
        var n = this,
          d = n.label,
          m = n.axis,
          v = m.reversed,
          z = !1;
        d && d.textStr === c ? (n.movedLabel = d, z = !0, delete n.label) : a(m.ticks, function (a) {
          z || a.isNew || a === n || !a.label || a.label.textStr !== c || (n.movedLabel = a.label, z = !0, a.labelPos = n.movedLabel.xy, delete a.label);
        });
        if (!z && (n.labelPos || d)) {
          var u = n.labelPos || d.xy;
          d = m.horiz ? v ? 0 : m.width + m.left : u.x;
          m = m.horiz ? u.y : v ? m.width + m.left : 0;
          n.movedLabel = n.createLabel({
            x: d,
            y: m
          }, c, f);
          n.movedLabel && n.movedLabel.attr({
            opacity: 0
          });
        }
      };
      m.prototype.render = function (a, c, f) {
        var d = this.axis,
          m = d.horiz,
          v = this.pos,
          z = n(this.tickmarkOffset, d.tickmarkOffset);
        v = this.getPosition(m, v, z, c);
        z = v.x;
        var u = v.y;
        d = m && z === d.pos + d.len || !m && u === d.pos ? -1 : 1;
        m = n(f, this.label && this.label.newOpacity, 1);
        f = n(f, 1);
        this.isActive = !0;
        this.renderGridLine(c, f, d);
        this.renderMark(v, f, d);
        this.renderLabel(v, c, m, a);
        this.isNew = !1;
        p(this, "afterRender");
      };
      m.prototype.renderGridLine = function (a, c, f) {
        var d = this.axis,
          m = d.options,
          v = {},
          z = this.pos,
          u = this.type,
          k = n(this.tickmarkOffset, d.tickmarkOffset),
          w = d.chart.renderer,
          l = this.gridLine,
          e = m.gridLineWidth,
          g = m.gridLineColor,
          b = m.gridLineDashStyle;
        "minor" === this.type && (e = m.minorGridLineWidth, g = m.minorGridLineColor, b = m.minorGridLineDashStyle);
        l || (d.chart.styledMode || (v.stroke = g, v["stroke-width"] = e || 0, v.dashstyle = b), u || (v.zIndex = 1), a && (c = 0), this.gridLine = l = w.path().attr(v).addClass("highcharts-" + (u ? u + "-" : "") + "grid-line").add(d.gridGroup));
        if (l && (f = d.getPlotLinePath({
          value: z + k,
          lineWidth: l.strokeWidth() * f,
          force: "pass",
          old: a
        }))) l[a || this.isNew ? "attr" : "animate"]({
          d: f,
          opacity: c
        });
      };
      m.prototype.renderMark = function (a, c, f) {
        var d = this.axis,
          m = d.options,
          v = d.chart.renderer,
          z = this.type,
          u = d.tickSize(z ? z + "Tick" : "tick"),
          k = a.x;
        a = a.y;
        var w = n(m["minor" !== z ? "tickWidth" : "minorTickWidth"], !z && d.isXAxis ? 1 : 0);
        m = m["minor" !== z ? "tickColor" : "minorTickColor"];
        var l = this.mark,
          e = !l;
        u && (d.opposite && (u[0] = -u[0]), l || (this.mark = l = v.path().addClass("highcharts-" + (z ? z + "-" : "") + "tick").add(d.axisGroup), d.chart.styledMode || l.attr({
          stroke: m,
          "stroke-width": w
        })), l[e ? "attr" : "animate"]({
          d: this.getMarkPath(k, a, u[0], l.strokeWidth() * f, d.horiz, v),
          opacity: c
        }));
      };
      m.prototype.renderLabel = function (a, c, d, m) {
        var p = this.axis,
          v = p.horiz,
          z = p.options,
          u = this.label,
          k = z.labels,
          w = k.step;
        p = n(this.tickmarkOffset, p.tickmarkOffset);
        var l = a.x;
        a = a.y;
        var e = !0;
        u && f(l) && (u.xy = a = this.getLabelPosition(l, a, u, v, k, p, m, w), this.isFirst && !this.isLast && !z.showFirstLabel || this.isLast && !this.isFirst && !z.showLastLabel ? e = !1 : !v || k.step || k.rotation || c || 0 === d || this.handleOverflow(a), w && m % w && (e = !1), e && f(a.y) ? (a.opacity = d, u[this.isNewLabel ? "attr" : "animate"](a), this.isNewLabel = !1) : (u.attr("y", -9999), this.isNewLabel = !0));
      };
      m.prototype.replaceMovedLabel = function () {
        var a = this.label,
          c = this.axis,
          f = c.reversed;
        if (a && !this.isNew) {
          var n = c.horiz ? f ? c.left : c.width + c.left : a.xy.x;
          f = c.horiz ? a.xy.y : f ? c.width + c.top : c.top;
          a.animate({
            x: n,
            y: f,
            opacity: 0
          }, void 0, a.destroy);
          delete this.label;
        }
        c.isDirty = !0;
        this.label = this.movedLabel;
        delete this.movedLabel;
      };
      return m;
    }();
    "";
    return h;
  });
  N(h, "Core/Axis/Axis.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/Axis/AxisDefaults.js"], h["Core/Color/Color.js"], h["Core/DefaultOptions.js"], h["Core/Foundation.js"], h["Core/Globals.js"], h["Core/Axis/Tick.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G, H, y) {
    var q = d.animObject,
      p = F.defaultOptions,
      f = t.registerEventOptions,
      c = G.deg2rad,
      a = y.arrayMax,
      n = y.arrayMin,
      m = y.clamp,
      D = y.correctFloat,
      C = y.defined,
      I = y.destroyObjectProperties,
      L = y.erase,
      K = y.error,
      v = y.extend,
      z = y.fireEvent,
      u = y.getMagnitude,
      k = y.isArray,
      w = y.isNumber,
      l = y.isString,
      e = y.merge,
      g = y.normalizeTickInterval,
      b = y.objectEach,
      B = y.pick,
      J = y.relativeLength,
      r = y.removeEvent,
      x = y.splat,
      M = y.syncTimeout;
    d = function () {
      function d(b, e) {
        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;
        this.init(b, e);
      }
      d.prototype.init = function (b, e) {
        var g = e.isX;
        this.chart = b;
        this.horiz = b.inverted && !this.isZAxis ? !g : g;
        this.isXAxis = g;
        this.coll = this.coll || (g ? "xAxis" : "yAxis");
        z(this, "init", {
          userOptions: e
        });
        this.opposite = B(e.opposite, this.opposite);
        this.side = B(e.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
        this.setOptions(e);
        var a = this.options,
          l = a.labels,
          k = a.type;
        this.userOptions = e;
        this.minPixelPadding = 0;
        this.reversed = B(a.reversed, this.reversed);
        this.visible = a.visible;
        this.zoomEnabled = a.zoomEnabled;
        this.hasNames = "category" === k || !0 === a.categories;
        this.categories = a.categories || this.hasNames;
        this.names || (this.names = [], this.names.keys = {});
        this.plotLinesAndBandsGroups = {};
        this.positiveValuesOnly = !!this.logarithmic;
        this.isLinked = C(a.linkedTo);
        this.ticks = {};
        this.labelEdge = [];
        this.minorTicks = {};
        this.plotLinesAndBands = [];
        this.alternateBands = {};
        this.len = 0;
        this.minRange = this.userMinRange = a.minRange || a.maxZoom;
        this.range = a.range;
        this.offset = a.offset || 0;
        this.min = this.max = null;
        e = B(a.crosshair, x(b.options.tooltip.crosshairs)[g ? 0 : 1]);
        this.crosshair = !0 === e ? {} : e;
        -1 === b.axes.indexOf(this) && (g ? b.axes.splice(b.xAxis.length, 0, this) : b.axes.push(this), b[this.coll].push(this));
        this.series = this.series || [];
        b.inverted && !this.isZAxis && g && "undefined" === typeof this.reversed && (this.reversed = !0);
        this.labelRotation = w(l.rotation) ? l.rotation : void 0;
        f(this, a);
        z(this, "afterInit");
      };
      d.prototype.setOptions = function (b) {
        this.options = e(h.defaultXAxisOptions, "yAxis" === this.coll && h.defaultYAxisOptions, [h.defaultTopAxisOptions, h.defaultRightAxisOptions, h.defaultBottomAxisOptions, h.defaultLeftAxisOptions][this.side], e(p[this.coll], b));
        z(this, "afterSetOptions", {
          userOptions: b
        });
      };
      d.prototype.defaultLabelFormatter = function (b) {
        var e = this.axis;
        b = this.chart.numberFormatter;
        var g = w(this.value) ? this.value : NaN,
          a = e.chart.time,
          l = this.dateTimeLabelFormat,
          k = p.lang,
          c = k.numericSymbols;
        k = k.numericSymbolMagnitude || 1E3;
        var r = e.logarithmic ? Math.abs(g) : e.tickInterval,
          f = c && c.length;
        if (e.categories) var x = "" + this.value;else if (l) x = a.dateFormat(l, g);else if (f && 1E3 <= r) for (; f-- && "undefined" === typeof x;) e = Math.pow(k, f + 1), r >= e && 0 === 10 * g % e && null !== c[f] && 0 !== g && (x = b(g / e, -1) + c[f]);
        "undefined" === typeof x && (x = 1E4 <= Math.abs(g) ? b(g, -1) : b(g, -1, void 0, ""));
        return x;
      };
      d.prototype.getSeriesExtremes = function () {
        var b = this,
          e = b.chart,
          g;
        z(this, "getSeriesExtremes", null, function () {
          b.hasVisibleSeries = !1;
          b.dataMin = b.dataMax = b.threshold = null;
          b.softThreshold = !b.isXAxis;
          b.stacking && b.stacking.buildStacks();
          b.series.forEach(function (a) {
            if (a.visible || !e.options.chart.ignoreHiddenSeries) {
              var l = a.options,
                k = l.threshold;
              b.hasVisibleSeries = !0;
              b.positiveValuesOnly && 0 >= k && (k = null);
              if (b.isXAxis) {
                if (l = a.xData, l.length) {
                  l = b.logarithmic ? l.filter(b.validatePositiveValue) : l;
                  g = a.getXExtremes(l);
                  var c = g.min;
                  var r = g.max;
                  w(c) || c instanceof Date || (l = l.filter(w), g = a.getXExtremes(l), c = g.min, r = g.max);
                  l.length && (b.dataMin = Math.min(B(b.dataMin, c), c), b.dataMax = Math.max(B(b.dataMax, r), r));
                }
              } else if (a = a.applyExtremes(), w(a.dataMin) && (c = a.dataMin, b.dataMin = Math.min(B(b.dataMin, c), c)), w(a.dataMax) && (r = a.dataMax, b.dataMax = Math.max(B(b.dataMax, r), r)), C(k) && (b.threshold = k), !l.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;
            }
          });
        });
        z(this, "afterGetSeriesExtremes");
      };
      d.prototype.translate = function (b, e, g, a, l, k) {
        var c = this.linkedParent || this,
          r = a && c.old ? c.old.min : c.min,
          f = c.minPixelPadding;
        l = (c.isOrdinal || c.brokenAxis && c.brokenAxis.hasBreaks || c.logarithmic && l) && c.lin2val;
        var x = 1,
          B = 0;
        a = a && c.old ? c.old.transA : c.transA;
        a || (a = c.transA);
        g && (x *= -1, B = c.len);
        c.reversed && (x *= -1, B -= x * (c.sector || c.len));
        e ? (b = (b * x + B - f) / a + r, l && (b = c.lin2val(b))) : (l && (b = c.val2lin(b)), b = w(r) ? x * (b - r) * a + B + x * f + (w(k) ? a * k : 0) : void 0);
        return b;
      };
      d.prototype.toPixels = function (b, e) {
        return this.translate(b, !1, !this.horiz, null, !0) + (e ? 0 : this.pos);
      };
      d.prototype.toValue = function (b, e) {
        return this.translate(b - (e ? 0 : this.pos), !0, !this.horiz, null, !0);
      };
      d.prototype.getPlotLinePath = function (b) {
        function e(b, e, g) {
          if ("pass" !== n && b < e || b > g) n ? b = m(b, e, g) : h = !0;
          return b;
        }
        var g = this,
          a = g.chart,
          l = g.left,
          k = g.top,
          c = b.old,
          r = b.value,
          f = b.lineWidth,
          x = c && a.oldChartHeight || a.chartHeight,
          u = c && a.oldChartWidth || a.chartWidth,
          d = g.transB,
          J = b.translatedValue,
          n = b.force,
          P,
          v,
          p,
          M,
          h;
        b = {
          value: r,
          lineWidth: f,
          old: c,
          force: n,
          acrossPanes: b.acrossPanes,
          translatedValue: J
        };
        z(this, "getPlotLinePath", b, function (b) {
          J = B(J, g.translate(r, null, null, c));
          J = m(J, -1E5, 1E5);
          P = p = Math.round(J + d);
          v = M = Math.round(x - J - d);
          w(J) ? g.horiz ? (v = k, M = x - g.bottom, P = p = e(P, l, l + g.width)) : (P = l, p = u - g.right, v = M = e(v, k, k + g.height)) : (h = !0, n = !1);
          b.path = h && !n ? null : a.renderer.crispLine([["M", P, v], ["L", p, M]], f || 1);
        });
        return b.path;
      };
      d.prototype.getLinearTickPositions = function (b, e, g) {
        var a = D(Math.floor(e / b) * b);
        g = D(Math.ceil(g / b) * b);
        var l = [],
          k;
        D(a + b) === a && (k = 20);
        if (this.single) return [e];
        for (e = a; e <= g;) {
          l.push(e);
          e = D(e + b, k);
          if (e === c) break;
          var c = e;
        }
        return l;
      };
      d.prototype.getMinorTickInterval = function () {
        var b = this.options;
        return !0 === b.minorTicks ? B(b.minorTickInterval, "auto") : !1 === b.minorTicks ? null : b.minorTickInterval;
      };
      d.prototype.getMinorTickPositions = function () {
        var b = this.options,
          e = this.tickPositions,
          g = this.minorTickInterval,
          a = this.pointRangePadding || 0,
          l = this.min - a;
        a = this.max + a;
        var k = a - l,
          c = [];
        if (k && k / g < this.len / 3) {
          var r = this.logarithmic;
          if (r) this.paddedTicks.forEach(function (b, e, a) {
            e && c.push.apply(c, r.getLogTickPositions(g, a[e - 1], a[e], !0));
          });else if (this.dateTime && "auto" === this.getMinorTickInterval()) c = c.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(g), l, a, b.startOfWeek));else for (b = l + (e[0] - l) % g; b <= a && b !== c[0]; b += g) c.push(b);
        }
        0 !== c.length && this.trimTicks(c);
        return c;
      };
      d.prototype.adjustForMinRange = function () {
        var b = this.options,
          e = this.logarithmic,
          g = this.min,
          l = this.max,
          k = 0,
          c,
          r,
          f,
          x;
        this.isXAxis && "undefined" === typeof this.minRange && !e && (C(b.min) || C(b.max) || C(b.floor) || C(b.ceiling) ? this.minRange = null : (this.series.forEach(function (b) {
          f = b.xData;
          x = b.xIncrement ? 1 : f.length - 1;
          if (1 < f.length) for (c = x; 0 < c; c--) if (r = f[c] - f[c - 1], !k || r < k) k = r;
        }), this.minRange = Math.min(5 * k, this.dataMax - this.dataMin)));
        if (l - g < this.minRange) {
          var u = this.dataMax - this.dataMin >= this.minRange;
          var d = this.minRange;
          var w = (d - l + g) / 2;
          w = [g - w, B(b.min, g - w)];
          u && (w[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
          g = a(w);
          l = [g + d, B(b.max, g + d)];
          u && (l[2] = e ? e.log2lin(this.dataMax) : this.dataMax);
          l = n(l);
          l - g < d && (w[0] = l - d, w[1] = B(b.min, l - d), g = a(w));
        }
        this.min = g;
        this.max = l;
      };
      d.prototype.getClosest = function () {
        var b;
        this.categories ? b = 1 : this.series.forEach(function (e) {
          var g = e.closestPointRange,
            a = e.visible || !e.chart.options.chart.ignoreHiddenSeries;
          !e.noSharedTooltip && C(g) && a && (b = C(b) ? Math.min(b, g) : g);
        });
        return b;
      };
      d.prototype.nameToX = function (b) {
        var e = k(this.categories),
          g = e ? this.categories : this.names,
          a = b.options.x;
        b.series.requireSorting = !1;
        C(a) || (a = this.options.uniqueNames ? e ? g.indexOf(b.name) : B(g.keys[b.name], -1) : b.series.autoIncrement());
        if (-1 === a) {
          if (!e) var l = g.length;
        } else l = a;
        "undefined" !== typeof l && (this.names[l] = b.name, this.names.keys[b.name] = l);
        return l;
      };
      d.prototype.updateNames = function () {
        var b = this,
          e = this.names;
        0 < e.length && (Object.keys(e.keys).forEach(function (b) {
          delete e.keys[b];
        }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (e) {
          e.xIncrement = null;
          if (!e.points || e.isDirtyData) b.max = Math.max(b.max, e.xData.length - 1), e.processData(), e.generatePoints();
          e.data.forEach(function (g, a) {
            if (g && g.options && "undefined" !== typeof g.name) {
              var l = b.nameToX(g);
              "undefined" !== typeof l && l !== g.x && (g.x = l, e.xData[a] = l);
            }
          });
        }));
      };
      d.prototype.setAxisTranslation = function () {
        var b = this,
          e = b.max - b.min,
          g = b.linkedParent,
          a = !!b.categories,
          k = b.isXAxis,
          c = b.axisPointRange || 0,
          r = 0,
          f = 0,
          x = b.transA;
        if (k || a || c) {
          var u = b.getClosest();
          g ? (r = g.minPointOffset, f = g.pointRangePadding) : b.series.forEach(function (e) {
            var g = a ? 1 : k ? B(e.options.pointRange, u, 0) : b.axisPointRange || 0,
              x = e.options.pointPlacement;
            c = Math.max(c, g);
            if (!b.single || a) e = e.is("xrange") ? !k : k, r = Math.max(r, e && l(x) ? 0 : g / 2), f = Math.max(f, e && "on" === x ? 0 : g);
          });
          g = b.ordinal && b.ordinal.slope && u ? b.ordinal.slope / u : 1;
          b.minPointOffset = r *= g;
          b.pointRangePadding = f *= g;
          b.pointRange = Math.min(c, b.single && a ? 1 : e);
          k && (b.closestPointRange = u);
        }
        b.translationSlope = b.transA = x = b.staticScale || b.len / (e + f || 1);
        b.transB = b.horiz ? b.left : b.bottom;
        b.minPixelPadding = x * r;
        z(this, "afterSetAxisTranslation");
      };
      d.prototype.minFromRange = function () {
        return this.max - this.range;
      };
      d.prototype.setTickInterval = function (b) {
        var e = this.chart,
          a = this.logarithmic,
          l = this.options,
          k = this.isXAxis,
          c = this.isLinked,
          r = l.tickPixelInterval,
          f = this.categories,
          x = this.softThreshold,
          d = l.maxPadding,
          J = l.minPadding,
          n = w(l.tickInterval) && 0 <= l.tickInterval ? l.tickInterval : void 0,
          m = w(this.threshold) ? this.threshold : null;
        this.dateTime || f || c || this.getTickAmount();
        var P = B(this.userMin, l.min);
        var v = B(this.userMax, l.max);
        if (c) {
          this.linkedParent = e[this.coll][l.linkedTo];
          var p = this.linkedParent.getExtremes();
          this.min = B(p.min, p.dataMin);
          this.max = B(p.max, p.dataMax);
          l.type !== this.linkedParent.options.type && K(11, 1, e);
        } else {
          if (x && C(m)) if (this.dataMin >= m) p = m, J = 0;else if (this.dataMax <= m) {
            var M = m;
            d = 0;
          }
          this.min = B(P, p, this.dataMin);
          this.max = B(v, M, this.dataMax);
        }
        a && (this.positiveValuesOnly && !b && 0 >= Math.min(this.min, B(this.dataMin, this.min)) && K(10, 1, e), this.min = D(a.log2lin(this.min), 16), this.max = D(a.log2lin(this.max), 16));
        this.range && C(this.max) && (this.userMin = this.min = P = Math.max(this.dataMin, this.minFromRange()), this.userMax = v = this.max, this.range = null);
        z(this, "foundExtremes");
        this.beforePadding && this.beforePadding();
        this.adjustForMinRange();
        !(f || this.axisPointRange || this.stacking && this.stacking.usePercentage || c) && C(this.min) && C(this.max) && (e = this.max - this.min) && (!C(P) && J && (this.min -= e * J), !C(v) && d && (this.max += e * d));
        w(this.userMin) || (w(l.softMin) && l.softMin < this.min && (this.min = P = l.softMin), w(l.floor) && (this.min = Math.max(this.min, l.floor)));
        w(this.userMax) || (w(l.softMax) && l.softMax > this.max && (this.max = v = l.softMax), w(l.ceiling) && (this.max = Math.min(this.max, l.ceiling)));
        x && C(this.dataMin) && (m = m || 0, !C(P) && this.min < m && this.dataMin >= m ? this.min = this.options.minRange ? Math.min(m, this.max - this.minRange) : m : !C(v) && this.max > m && this.dataMax <= m && (this.max = this.options.minRange ? Math.max(m, this.min + this.minRange) : m));
        w(this.min) && w(this.max) && !this.chart.polar && this.min > this.max && (C(this.options.min) ? this.max = this.min : C(this.options.max) && (this.min = this.max));
        this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : c && this.linkedParent && !n && r === this.linkedParent.options.tickPixelInterval ? n = this.linkedParent.tickInterval : B(n, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, f ? 1 : (this.max - this.min) * r / Math.max(this.len, r));
        if (k && !b) {
          var h = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
          this.series.forEach(function (b) {
            b.forceCrop = b.forceCropping && b.forceCropping();
            b.processData(h);
          });
          z(this, "postProcessData", {
            hasExtemesChanged: h
          });
        }
        this.setAxisTranslation();
        z(this, "initialAxisTranslation");
        this.pointRange && !n && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
        b = B(l.minTickInterval, this.dateTime && !this.series.some(function (b) {
          return b.noSharedTooltip;
        }) ? this.closestPointRange : 0);
        !n && this.tickInterval < b && (this.tickInterval = b);
        this.dateTime || this.logarithmic || n || (this.tickInterval = g(this.tickInterval, void 0, u(this.tickInterval), B(l.allowDecimals, .5 > this.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));
        this.tickAmount || (this.tickInterval = this.unsquish());
        this.setTickPositions();
      };
      d.prototype.setTickPositions = function () {
        var b = this.options,
          e = b.tickPositions,
          g = this.getMinorTickInterval(),
          a = this.hasVerticalPanning(),
          l = "colorAxis" === this.coll,
          k = (l || !a) && b.startOnTick;
        a = (l || !a) && b.endOnTick;
        l = b.tickPositioner;
        this.tickmarkOffset = this.categories && "between" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
        this.minorTickInterval = "auto" === g && this.tickInterval ? this.tickInterval / 5 : g;
        this.single = this.min === this.max && C(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);
        this.tickPositions = g = e && e.slice();
        !g && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? g = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (g = [this.min, this.max], K(19, !1, this.chart)), g.length > this.len && (g = [g[0], g.pop()], g[0] === g[1] && (g.length = 1)), this.tickPositions = g, l && (l = l.apply(this, [this.min, this.max]))) && (this.tickPositions = g = l);
        this.paddedTicks = g.slice(0);
        this.trimTicks(g, k, a);
        this.isLinked || (this.single && 2 > g.length && !this.categories && !this.series.some(function (b) {
          return b.is("heatmap") && "between" === b.options.pointPlacement;
        }) && (this.min -= .5, this.max += .5), e || l || this.adjustTickAmount());
        z(this, "afterSetTickPositions");
      };
      d.prototype.trimTicks = function (b, e, g) {
        var a = b[0],
          l = b[b.length - 1],
          k = !this.isOrdinal && this.minPointOffset || 0;
        z(this, "trimTicks");
        if (!this.isLinked) {
          if (e && -Infinity !== a) this.min = a;else for (; this.min - k > b[0];) b.shift();
          if (g) this.max = l;else for (; this.max + k < b[b.length - 1];) b.pop();
          0 === b.length && C(a) && !this.options.tickPositions && b.push((l + a) / 2);
        }
      };
      d.prototype.alignToOthers = function () {
        var b = {},
          e = this.options,
          g;
        !1 !== this.chart.options.chart.alignTicks && e.alignTicks && !1 !== e.startOnTick && !1 !== e.endOnTick && !this.logarithmic && this.chart[this.coll].forEach(function (e) {
          var a = e.options;
          a = [e.horiz ? a.left : a.top, a.width, a.height, a.pane].join();
          e.series.length && (b[a] ? g = !0 : b[a] = 1);
        });
        return g;
      };
      d.prototype.getTickAmount = function () {
        var b = this.options,
          e = b.tickPixelInterval,
          g = b.tickAmount;
        !C(b.tickInterval) && !g && this.len < e && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (g = 2);
        !g && this.alignToOthers() && (g = Math.ceil(this.len / e) + 1);
        4 > g && (this.finalTickAmt = g, g = 5);
        this.tickAmount = g;
      };
      d.prototype.adjustTickAmount = function () {
        var b = this.options,
          e = this.tickInterval,
          g = this.tickPositions,
          a = this.tickAmount,
          l = this.finalTickAmt,
          k = g && g.length,
          c = B(this.threshold, this.softThreshold ? 0 : null);
        if (this.hasData() && w(this.min) && w(this.max)) {
          if (k < a) {
            for (; g.length < a;) g.length % 2 || this.min === c ? g.push(D(g[g.length - 1] + e)) : g.unshift(D(g[0] - e));
            this.transA *= (k - 1) / (a - 1);
            this.min = b.startOnTick ? g[0] : Math.min(this.min, g[0]);
            this.max = b.endOnTick ? g[g.length - 1] : Math.max(this.max, g[g.length - 1]);
          } else k > a && (this.tickInterval *= 2, this.setTickPositions());
          if (C(l)) {
            for (e = b = g.length; e--;) (3 === l && 1 === e % 2 || 2 >= l && 0 < e && e < b - 1) && g.splice(e, 1);
            this.finalTickAmt = void 0;
          }
        }
      };
      d.prototype.setScale = function () {
        var b = !1,
          e = !1;
        this.series.forEach(function (g) {
          b = b || g.isDirtyData || g.isDirty;
          e = e || g.xAxis && g.xAxis.isDirty || !1;
        });
        this.setAxisSize();
        var g = this.len !== (this.old && this.old.len);
        g || b || e || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = g || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
        b && this.panningState && (this.panningState.isDirty = !0);
        z(this, "afterSetScale");
      };
      d.prototype.setExtremes = function (b, e, g, a, l) {
        var k = this,
          c = k.chart;
        g = B(g, !0);
        k.series.forEach(function (b) {
          delete b.kdTree;
        });
        l = v(l, {
          min: b,
          max: e
        });
        z(k, "setExtremes", l, function () {
          k.userMin = b;
          k.userMax = e;
          k.eventArgs = l;
          g && c.redraw(a);
        });
      };
      d.prototype.zoom = function (b, e) {
        var g = this,
          a = this.dataMin,
          l = this.dataMax,
          k = this.options,
          c = Math.min(a, B(k.min, a)),
          r = Math.max(l, B(k.max, l));
        b = {
          newMin: b,
          newMax: e
        };
        z(this, "zoom", b, function (b) {
          var e = b.newMin,
            k = b.newMax;
          if (e !== g.min || k !== g.max) g.allowZoomOutside || (C(a) && (e < c && (e = c), e > r && (e = r)), C(l) && (k < c && (k = c), k > r && (k = r))), g.displayBtn = "undefined" !== typeof e || "undefined" !== typeof k, g.setExtremes(e, k, !1, void 0, {
            trigger: "zoom"
          });
          b.zoomed = !0;
        });
        return b.zoomed;
      };
      d.prototype.setAxisSize = function () {
        var b = this.chart,
          e = this.options,
          g = e.offsets || [0, 0, 0, 0],
          a = this.horiz,
          l = this.width = Math.round(J(B(e.width, b.plotWidth - g[3] + g[1]), b.plotWidth)),
          k = this.height = Math.round(J(B(e.height, b.plotHeight - g[0] + g[2]), b.plotHeight)),
          c = this.top = Math.round(J(B(e.top, b.plotTop + g[0]), b.plotHeight, b.plotTop));
        e = this.left = Math.round(J(B(e.left, b.plotLeft + g[3]), b.plotWidth, b.plotLeft));
        this.bottom = b.chartHeight - k - c;
        this.right = b.chartWidth - l - e;
        this.len = Math.max(a ? l : k, 0);
        this.pos = a ? e : c;
      };
      d.prototype.getExtremes = function () {
        var b = this.logarithmic;
        return {
          min: b ? D(b.lin2log(this.min)) : this.min,
          max: b ? D(b.lin2log(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        };
      };
      d.prototype.getThreshold = function (b) {
        var e = this.logarithmic,
          g = e ? e.lin2log(this.min) : this.min;
        e = e ? e.lin2log(this.max) : this.max;
        null === b || -Infinity === b ? b = g : Infinity === b ? b = e : g > b ? b = g : e < b && (b = e);
        return this.translate(b, 0, 1, 0, 1);
      };
      d.prototype.autoLabelAlign = function (b) {
        var e = (B(b, 0) - 90 * this.side + 720) % 360;
        b = {
          align: "center"
        };
        z(this, "autoLabelAlign", b, function (b) {
          15 < e && 165 > e ? b.align = "right" : 195 < e && 345 > e && (b.align = "left");
        });
        return b.align;
      };
      d.prototype.tickSize = function (b) {
        var e = this.options,
          g = B(e["tick" === b ? "tickWidth" : "minorTickWidth"], "tick" === b && this.isXAxis && !this.categories ? 1 : 0),
          a = e["tick" === b ? "tickLength" : "minorTickLength"];
        if (g && a) {
          "inside" === e[b + "Position"] && (a = -a);
          var l = [a, g];
        }
        b = {
          tickSize: l
        };
        z(this, "afterTickSize", b);
        return b.tickSize;
      };
      d.prototype.labelMetrics = function () {
        var b = this.tickPositions && this.tickPositions[0] || 0;
        return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);
      };
      d.prototype.unsquish = function () {
        var b = this.options.labels,
          e = this.horiz,
          g = this.tickInterval,
          a = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / g),
          l = b.rotation,
          k = this.labelMetrics(),
          r = Math.max(this.max - this.min, 0),
          f = function (b) {
            var e = b / (a || 1);
            e = 1 < e ? Math.ceil(e) : 1;
            e * g > r && Infinity !== b && Infinity !== a && r && (e = Math.ceil(r / g));
            return D(e * g);
          },
          x = g,
          u,
          d,
          J = Number.MAX_VALUE;
        if (e) {
          if (!b.staggerLines && !b.step) if (w(l)) var n = [l];else a < b.autoRotationLimit && (n = b.autoRotation);
          n && n.forEach(function (b) {
            if (b === l || b && -90 <= b && 90 >= b) {
              d = f(Math.abs(k.h / Math.sin(c * b)));
              var e = d + Math.abs(b / 360);
              e < J && (J = e, u = b, x = d);
            }
          });
        } else b.step || (x = f(k.h));
        this.autoRotation = n;
        this.labelRotation = B(u, w(l) ? l : 0);
        return x;
      };
      d.prototype.getSlotWidth = function (b) {
        var e = this.chart,
          g = this.horiz,
          a = this.options.labels,
          l = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
          k = e.margin[3];
        if (b && w(b.slotWidth)) return b.slotWidth;
        if (g && 2 > a.step) return a.rotation ? 0 : (this.staggerLines || 1) * this.len / l;
        if (!g) {
          b = a.style.width;
          if (void 0 !== b) return parseInt(String(b), 10);
          if (k) return k - e.spacing[3];
        }
        return .33 * e.chartWidth;
      };
      d.prototype.renderUnsquish = function () {
        var b = this.chart,
          e = b.renderer,
          g = this.tickPositions,
          a = this.ticks,
          k = this.options.labels,
          c = k.style,
          r = this.horiz,
          f = this.getSlotWidth(),
          x = Math.max(1, Math.round(f - 2 * k.padding)),
          B = {},
          u = this.labelMetrics(),
          d = c.textOverflow,
          w = 0;
        l(k.rotation) || (B.rotation = k.rotation || 0);
        g.forEach(function (b) {
          b = a[b];
          b.movedLabel && b.replaceMovedLabel();
          b && b.label && b.label.textPxLength > w && (w = b.label.textPxLength);
        });
        this.maxLabelLength = w;
        if (this.autoRotation) w > x && w > u.h ? B.rotation = this.labelRotation : this.labelRotation = 0;else if (f) {
          var J = x;
          if (!d) {
            var n = "clip";
            for (x = g.length; !r && x--;) {
              var m = g[x];
              if (m = a[m].label) m.styles && "ellipsis" === m.styles.textOverflow ? m.css({
                textOverflow: "clip"
              }) : m.textPxLength > f && m.css({
                width: f + "px"
              }), m.getBBox().height > this.len / g.length - (u.h - u.f) && (m.specificTextOverflow = "ellipsis");
            }
          }
        }
        B.rotation && (J = w > .5 * b.chartHeight ? .33 * b.chartHeight : w, d || (n = "ellipsis"));
        if (this.labelAlign = k.align || this.autoLabelAlign(this.labelRotation)) B.align = this.labelAlign;
        g.forEach(function (b) {
          var e = (b = a[b]) && b.label,
            g = c.width,
            l = {};
          e && (e.attr(B), b.shortenLabel ? b.shortenLabel() : J && !g && "nowrap" !== c.whiteSpace && (J < e.textPxLength || "SPAN" === e.element.tagName) ? (l.width = J + "px", d || (l.textOverflow = e.specificTextOverflow || n), e.css(l)) : e.styles && e.styles.width && !l.width && !g && e.css({
            width: null
          }), delete e.specificTextOverflow, b.rotation = B.rotation);
        }, this);
        this.tickRotCorr = e.rotCorr(u.b, this.labelRotation || 0, 0 !== this.side);
      };
      d.prototype.hasData = function () {
        return this.series.some(function (b) {
          return b.hasData();
        }) || this.options.showEmpty && C(this.min) && C(this.max);
      };
      d.prototype.addTitle = function (b) {
        var g = this.chart.renderer,
          a = this.horiz,
          l = this.opposite,
          k = this.options.title,
          c = this.chart.styledMode,
          r;
        this.axisTitle || ((r = k.textAlign) || (r = (a ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: l ? "right" : "left",
          middle: "center",
          high: l ? "left" : "right"
        })[k.align]), this.axisTitle = g.text(k.text || "", 0, 0, k.useHTML).attr({
          zIndex: 7,
          rotation: k.rotation,
          align: r
        }).addClass("highcharts-axis-title"), c || this.axisTitle.css(e(k.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
        c || k.style.width || this.isRadial || this.axisTitle.css({
          width: this.len + "px"
        });
        this.axisTitle[b ? "show" : "hide"](b);
      };
      d.prototype.generateTick = function (b) {
        var e = this.ticks;
        e[b] ? e[b].addLabel() : e[b] = new H(this, b);
      };
      d.prototype.getOffset = function () {
        var e = this,
          g = this,
          a = g.chart,
          l = g.horiz,
          k = g.options,
          c = g.side,
          r = g.ticks,
          f = g.tickPositions,
          x = g.coll,
          u = g.axisParent,
          d = a.renderer,
          w = a.inverted && !g.isZAxis ? [1, 0, 3, 2][c] : c,
          J = g.hasData(),
          n = k.title,
          m = k.labels,
          v = a.axisOffset;
        a = a.clipOffset;
        var p = [-1, 1, 1, -1][c],
          M = k.className,
          h,
          q = 0,
          I = 0,
          D = 0;
        g.showAxis = h = J || k.showEmpty;
        g.staggerLines = g.horiz && m.staggerLines || void 0;
        if (!g.axisGroup) {
          var L = function (b, g, a) {
            return d.g(b).attr({
              zIndex: a
            }).addClass("highcharts-" + x.toLowerCase() + g + " " + (e.isRadial ? "highcharts-radial-axis" + g + " " : "") + (M || "")).add(u);
          };
          g.gridGroup = L("grid", "-grid", k.gridZIndex);
          g.axisGroup = L("axis", "", k.zIndex);
          g.labelGroup = L("axis-labels", "-labels", m.zIndex);
        }
        J || g.isLinked ? (f.forEach(function (b) {
          g.generateTick(b);
        }), g.renderUnsquish(), g.reserveSpaceDefault = 0 === c || 2 === c || {
          1: "left",
          3: "right"
        }[c] === g.labelAlign, B(m.reserveSpace, "center" === g.labelAlign ? !0 : null, g.reserveSpaceDefault) && f.forEach(function (b) {
          D = Math.max(r[b].getLabelSize(), D);
        }), g.staggerLines && (D *= g.staggerLines), g.labelOffset = D * (g.opposite ? -1 : 1)) : b(r, function (b, e) {
          b.destroy();
          delete r[e];
        });
        if (n && n.text && !1 !== n.enabled && (g.addTitle(h), h && !1 !== n.reserveSpace)) {
          g.titleOffset = q = g.axisTitle.getBBox()[l ? "height" : "width"];
          var K = n.offset;
          I = C(K) ? 0 : B(n.margin, l ? 5 : 10);
        }
        g.renderLine();
        g.offset = p * B(k.offset, v[c] ? v[c] + (k.margin || 0) : 0);
        g.tickRotCorr = g.tickRotCorr || {
          x: 0,
          y: 0
        };
        n = 0 === c ? -g.labelMetrics().h : 2 === c ? g.tickRotCorr.y : 0;
        J = Math.abs(D) + I;
        D && (J = J - n + p * (l ? B(m.y, g.tickRotCorr.y + 8 * p) : m.x));
        g.axisTitleMargin = B(K, J);
        g.getMaxLabelDimensions && (g.maxLabelDimensions = g.getMaxLabelDimensions(r, f));
        "colorAxis" !== x && (l = this.tickSize("tick"), v[c] = Math.max(v[c], (g.axisTitleMargin || 0) + q + p * g.offset, J, f && f.length && l ? l[0] + p * g.offset : 0), k = !g.axisLine || k.offset ? 0 : 2 * Math.floor(g.axisLine.strokeWidth() / 2), a[w] = Math.max(a[w], k));
        z(this, "afterGetOffset");
      };
      d.prototype.getLinePath = function (b) {
        var e = this.chart,
          g = this.opposite,
          a = this.offset,
          l = this.horiz,
          k = this.left + (g ? this.width : 0) + a;
        a = e.chartHeight - this.bottom - (g ? this.height : 0) + a;
        g && (b *= -1);
        return e.renderer.crispLine([["M", l ? this.left : k, l ? a : this.top], ["L", l ? e.chartWidth - this.right : k, l ? a : e.chartHeight - this.bottom]], b);
      };
      d.prototype.renderLine = function () {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        }));
      };
      d.prototype.getTitlePosition = function () {
        var b = this.horiz,
          e = this.left,
          g = this.top,
          a = this.len,
          l = this.options.title,
          k = b ? e : g,
          c = this.opposite,
          r = this.offset,
          f = l.x,
          x = l.y,
          B = this.axisTitle,
          u = this.chart.renderer.fontMetrics(l.style.fontSize, B);
        B = Math.max(B.getBBox(null, 0).height - u.h - 1, 0);
        a = {
          low: k + (b ? 0 : a),
          middle: k + a / 2,
          high: k + (b ? a : 0)
        }[l.align];
        e = (b ? g + this.height : e) + (b ? 1 : -1) * (c ? -1 : 1) * this.axisTitleMargin + [-B, B, u.f, -B][this.side];
        b = {
          x: b ? a + f : e + (c ? this.width : 0) + r + f,
          y: b ? e + x - (c ? this.height : 0) + r : a + x
        };
        z(this, "afterGetTitlePosition", {
          titlePosition: b
        });
        return b;
      };
      d.prototype.renderMinorTick = function (b, e) {
        var g = this.minorTicks;
        g[b] || (g[b] = new H(this, b, "minor"));
        e && g[b].isNew && g[b].render(null, !0);
        g[b].render(null, !1, 1);
      };
      d.prototype.renderTick = function (b, e, g) {
        var a = this.ticks;
        if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) a[b] || (a[b] = new H(this, b)), g && a[b].isNew && a[b].render(e, !0, -1), a[b].render(e);
      };
      d.prototype.render = function () {
        var e = this,
          g = e.chart,
          a = e.logarithmic,
          l = e.options,
          k = e.isLinked,
          c = e.tickPositions,
          r = e.axisTitle,
          f = e.ticks,
          x = e.minorTicks,
          B = e.alternateBands,
          u = l.stackLabels,
          d = l.alternateGridColor,
          J = e.tickmarkOffset,
          n = e.axisLine,
          m = e.showAxis,
          v = q(g.renderer.globalAnimation),
          p,
          h;
        e.labelEdge.length = 0;
        e.overlap = !1;
        [f, x, B].forEach(function (e) {
          b(e, function (b) {
            b.isActive = !1;
          });
        });
        if (e.hasData() || k) {
          var C = e.chart.hasRendered && e.old && w(e.old.min);
          e.minorTickInterval && !e.categories && e.getMinorTickPositions().forEach(function (b) {
            e.renderMinorTick(b, C);
          });
          c.length && (c.forEach(function (b, g) {
            e.renderTick(b, g, C);
          }), J && (0 === e.min || e.single) && (f[-1] || (f[-1] = new H(e, -1, null, !0)), f[-1].render(-1)));
          d && c.forEach(function (b, l) {
            h = "undefined" !== typeof c[l + 1] ? c[l + 1] + J : e.max - J;
            0 === l % 2 && b < e.max && h <= e.max + (g.polar ? -J : J) && (B[b] || (B[b] = new G.PlotLineOrBand(e)), p = b + J, B[b].options = {
              from: a ? a.lin2log(p) : p,
              to: a ? a.lin2log(h) : h,
              color: d,
              className: "highcharts-alternate-grid"
            }, B[b].render(), B[b].isActive = !0);
          });
          e._addedPlotLB || (e._addedPlotLB = !0, (l.plotLines || []).concat(l.plotBands || []).forEach(function (b) {
            e.addPlotBandOrLine(b);
          }));
        }
        [f, x, B].forEach(function (e) {
          var a = [],
            l = v.duration;
          b(e, function (b, e) {
            b.isActive || (b.render(e, !1, 0), b.isActive = !1, a.push(e));
          });
          M(function () {
            for (var b = a.length; b--;) e[a[b]] && !e[a[b]].isActive && (e[a[b]].destroy(), delete e[a[b]]);
          }, e !== B && g.hasRendered && l ? l : 0);
        });
        n && (n[n.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(n.strokeWidth())
        }), n.isPlaced = !0, n[m ? "show" : "hide"](m));
        r && m && (l = e.getTitlePosition(), w(l.y) ? (r[r.isNew ? "attr" : "animate"](l), r.isNew = !1) : (r.attr("y", -9999), r.isNew = !0));
        u && u.enabled && e.stacking && e.stacking.renderStackTotals();
        e.old = {
          len: e.len,
          max: e.max,
          min: e.min,
          transA: e.transA,
          userMax: e.userMax,
          userMin: e.userMin
        };
        e.isDirty = !1;
        z(this, "afterRender");
      };
      d.prototype.redraw = function () {
        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {
          b.render();
        }));
        this.series.forEach(function (b) {
          b.isDirty = !0;
        });
      };
      d.prototype.getKeepProps = function () {
        return this.keepProps || d.keepProps;
      };
      d.prototype.destroy = function (e) {
        var g = this,
          a = g.plotLinesAndBands,
          l = this.eventOptions;
        z(this, "destroy", {
          keepEvents: e
        });
        e || r(g);
        [g.ticks, g.minorTicks, g.alternateBands].forEach(function (b) {
          I(b);
        });
        if (a) for (e = a.length; e--;) a[e].destroy();
        "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (b) {
          g[b] && (g[b] = g[b].destroy());
        });
        for (var k in g.plotLinesAndBandsGroups) g.plotLinesAndBandsGroups[k] = g.plotLinesAndBandsGroups[k].destroy();
        b(g, function (b, e) {
          -1 === g.getKeepProps().indexOf(e) && delete g[e];
        });
        this.eventOptions = l;
      };
      d.prototype.drawCrosshair = function (b, e) {
        var g = this.crosshair,
          a = B(g && g.snap, !0),
          l = this.chart,
          k,
          c = this.cross;
        z(this, "drawCrosshair", {
          e: b,
          point: e
        });
        b || (b = this.cross && this.cross.e);
        if (g && !1 !== (C(e) || !a)) {
          a ? C(e) && (k = B("colorAxis" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : k = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);
          if (C(k)) {
            var r = {
              value: e && (this.isXAxis ? e.x : B(e.stackY, e.y)),
              translatedValue: k
            };
            l.polar && v(r, {
              isCrosshair: !0,
              chartX: b && b.chartX,
              chartY: b && b.chartY,
              point: e
            });
            r = this.getPlotLinePath(r) || null;
          }
          if (!C(r)) {
            this.hideCrosshair();
            return;
          }
          a = this.categories && !this.isRadial;
          c || (this.cross = c = l.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (a ? "category " : "thin ") + (g.className || "")).attr({
            zIndex: B(g.zIndex, 2)
          }).add(), l.styledMode || (c.attr({
            stroke: g.color || (a ? A.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
            "stroke-width": B(g.width, 1)
          }).css({
            "pointer-events": "none"
          }), g.dashStyle && c.attr({
            dashstyle: g.dashStyle
          })));
          c.show().attr({
            d: r
          });
          a && !g.width && c.attr({
            "stroke-width": this.transA
          });
          this.cross.e = b;
        } else this.hideCrosshair();
        z(this, "afterDrawCrosshair", {
          e: b,
          point: e
        });
      };
      d.prototype.hideCrosshair = function () {
        this.cross && this.cross.hide();
        z(this, "afterHideCrosshair");
      };
      d.prototype.hasVerticalPanning = function () {
        var b = this.chart.options.chart.panning;
        return !!(b && b.enabled && /y/.test(b.type));
      };
      d.prototype.validatePositiveValue = function (b) {
        return w(b) && 0 < b;
      };
      d.prototype.update = function (b, g) {
        var a = this.chart;
        b = e(this.userOptions, b);
        this.destroy(!0);
        this.init(a, b);
        a.isDirtyBox = !0;
        B(g, !0) && a.redraw();
      };
      d.prototype.remove = function (b) {
        for (var e = this.chart, g = this.coll, a = this.series, l = a.length; l--;) a[l] && a[l].remove(!1);
        L(e.axes, this);
        L(e[g], this);
        e[g].forEach(function (b, e) {
          b.options.index = b.userOptions.index = e;
        });
        this.destroy();
        e.isDirtyBox = !0;
        B(b, !0) && e.redraw();
      };
      d.prototype.setTitle = function (b, e) {
        this.update({
          title: b
        }, e);
      };
      d.prototype.setCategories = function (b, e) {
        this.update({
          categories: b
        }, e);
      };
      d.defaultOptions = h.defaultXAxisOptions;
      d.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
      return d;
    }();
    "";
    return d;
  });
  N(h, "Core/Axis/DateTimeAxis.js", [h["Core/Utilities.js"]], function (d) {
    var h = d.addEvent,
      A = d.getMagnitude,
      F = d.normalizeTickInterval,
      t = d.timeUnits,
      G;
    (function (d) {
      function y() {
        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
      }
      function q(c) {
        "datetime" !== c.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new f(this));
      }
      var p = [];
      d.compose = function (c) {
        -1 === p.indexOf(c) && (p.push(c), c.keepProps.push("dateTime"), c.prototype.getTimeTicks = y, h(c, "init", q));
        return c;
      };
      var f = function () {
        function c(a) {
          this.axis = a;
        }
        c.prototype.normalizeTimeTickInterval = function (a, c) {
          var f = c || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
          c = f[f.length - 1];
          var d = t[c[0]],
            n = c[1],
            p;
          for (p = 0; p < f.length && !(c = f[p], d = t[c[0]], n = c[1], f[p + 1] && a <= (d * n[n.length - 1] + t[f[p + 1][0]]) / 2); p++);
          d === t.year && a < 5 * d && (n = [1, 2, 5]);
          a = F(a / d, n, "year" === c[0] ? Math.max(A(a / d), 1) : 1);
          return {
            unitRange: d,
            count: a,
            unitName: c[0]
          };
        };
        c.prototype.getXDateFormat = function (a, c) {
          var f = this.axis;
          return f.closestPointRange ? f.chart.time.getDateFormat(f.closestPointRange, a, f.options.startOfWeek, c) || c.year : c.day;
        };
        return c;
      }();
      d.Additions = f;
    })(G || (G = {}));
    return G;
  });
  N(h, "Core/Axis/LogarithmicAxis.js", [h["Core/Utilities.js"]], function (d) {
    var h = d.addEvent,
      A = d.getMagnitude,
      F = d.normalizeTickInterval,
      t = d.pick,
      G;
    (function (d) {
      function y(c) {
        var a = this.logarithmic;
        "logarithmic" !== c.userOptions.type ? this.logarithmic = void 0 : a || (this.logarithmic = new f(this));
      }
      function q() {
        var c = this.logarithmic;
        c && (this.lin2val = function (a) {
          return c.lin2log(a);
        }, this.val2lin = function (a) {
          return c.log2lin(a);
        });
      }
      var p = [];
      d.compose = function (c) {
        -1 === p.indexOf(c) && (p.push(c), c.keepProps.push("logarithmic"), h(c, "init", y), h(c, "afterInit", q));
        return c;
      };
      var f = function () {
        function c(a) {
          this.axis = a;
        }
        c.prototype.getLogTickPositions = function (a, c, f, d) {
          var n = this.axis,
            m = n.len,
            p = n.options,
            h = [];
          d || (this.minorAutoInterval = void 0);
          if (.5 <= a) a = Math.round(a), h = n.getLinearTickPositions(a, c, f);else if (.08 <= a) {
            var v = Math.floor(c),
              z,
              u = p = void 0;
            for (m = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; v < f + 1 && !u; v++) {
              var k = m.length;
              for (z = 0; z < k && !u; z++) {
                var w = this.log2lin(this.lin2log(v) * m[z]);
                w > c && (!d || p <= f) && "undefined" !== typeof p && h.push(p);
                p > f && (u = !0);
                p = w;
              }
            }
          } else c = this.lin2log(c), f = this.lin2log(f), a = d ? n.getMinorTickInterval() : p.tickInterval, a = t("auto" === a ? null : a, this.minorAutoInterval, p.tickPixelInterval / (d ? 5 : 1) * (f - c) / ((d ? m / n.tickPositions.length : m) || 1)), a = F(a, void 0, A(a)), h = n.getLinearTickPositions(a, c, f).map(this.log2lin), d || (this.minorAutoInterval = a / 5);
          d || (n.tickInterval = a);
          return h;
        };
        c.prototype.lin2log = function (a) {
          return Math.pow(10, a);
        };
        c.prototype.log2lin = function (a) {
          return Math.log(a) / Math.LN10;
        };
        return c;
      }();
      d.Additions = f;
    })(G || (G = {}));
    return G;
  });
  N(h, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [h["Core/Utilities.js"]], function (d) {
    var h = d.erase,
      A = d.extend,
      F = d.isNumber,
      t;
    (function (d) {
      var t = [],
        y;
      d.compose = function (d, f) {
        y || (y = d);
        -1 === t.indexOf(f) && (t.push(f), A(f.prototype, q.prototype));
        return f;
      };
      var q = function () {
        function d() {}
        d.prototype.getPlotBandPath = function (f, c, a) {
          void 0 === a && (a = this.options);
          var d = this.getPlotLinePath({
              value: c,
              force: !0,
              acrossPanes: a.acrossPanes
            }),
            m = [],
            p = this.horiz;
          c = !F(this.min) || !F(this.max) || f < this.min && c < this.min || f > this.max && c > this.max;
          f = this.getPlotLinePath({
            value: f,
            force: !0,
            acrossPanes: a.acrossPanes
          });
          a = 1;
          if (f && d) {
            if (c) {
              var h = f.toString() === d.toString();
              a = 0;
            }
            for (c = 0; c < f.length; c += 2) {
              var q = f[c],
                L = f[c + 1],
                K = d[c],
                v = d[c + 1];
              "M" !== q[0] && "L" !== q[0] || "M" !== L[0] && "L" !== L[0] || "M" !== K[0] && "L" !== K[0] || "M" !== v[0] && "L" !== v[0] || (p && K[1] === q[1] ? (K[1] += a, v[1] += a) : p || K[2] !== q[2] || (K[2] += a, v[2] += a), m.push(["M", q[1], q[2]], ["L", L[1], L[2]], ["L", v[1], v[2]], ["L", K[1], K[2]], ["Z"]));
              m.isFlat = h;
            }
          }
          return m;
        };
        d.prototype.addPlotBand = function (f) {
          return this.addPlotBandOrLine(f, "plotBands");
        };
        d.prototype.addPlotLine = function (f) {
          return this.addPlotBandOrLine(f, "plotLines");
        };
        d.prototype.addPlotBandOrLine = function (f, c) {
          var a = this,
            d = this.userOptions,
            m = new y(this, f);
          this.visible && (m = m.render());
          if (m) {
            this._addedPlotLB || (this._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (c) {
              a.addPlotBandOrLine(c);
            }));
            if (c) {
              var p = d[c] || [];
              p.push(f);
              d[c] = p;
            }
            this.plotLinesAndBands.push(m);
          }
          return m;
        };
        d.prototype.removePlotBandOrLine = function (f) {
          var c = this.plotLinesAndBands,
            a = this.options,
            d = this.userOptions;
          if (c) {
            for (var m = c.length; m--;) c[m].id === f && c[m].destroy();
            [a.plotLines || [], d.plotLines || [], a.plotBands || [], d.plotBands || []].forEach(function (a) {
              for (m = a.length; m--;) (a[m] || {}).id === f && h(a, a[m]);
            });
          }
        };
        d.prototype.removePlotBand = function (f) {
          this.removePlotBandOrLine(f);
        };
        d.prototype.removePlotLine = function (f) {
          this.removePlotBandOrLine(f);
        };
        return d;
      }();
    })(t || (t = {}));
    return t;
  });
  N(h, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [h["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], h["Core/Utilities.js"]], function (d, h) {
    var A = h.arrayMax,
      E = h.arrayMin,
      t = h.defined,
      G = h.destroyObjectProperties,
      H = h.erase,
      y = h.fireEvent,
      q = h.merge,
      p = h.objectEach,
      f = h.pick;
    h = function () {
      function c(a, c) {
        this.axis = a;
        c && (this.options = c, this.id = c.id);
      }
      c.compose = function (a) {
        return d.compose(c, a);
      };
      c.prototype.render = function () {
        y(this, "render");
        var a = this,
          c = a.axis,
          d = c.horiz,
          h = c.logarithmic,
          C = a.options,
          I = C.color,
          L = f(C.zIndex, 0),
          K = C.events,
          v = {},
          z = c.chart.renderer,
          u = C.label,
          k = a.label,
          w = C.to,
          l = C.from,
          e = C.value,
          g = a.svgElem,
          b = [],
          B = t(l) && t(w);
        b = t(e);
        var J = !g,
          r = {
            "class": "highcharts-plot-" + (B ? "band " : "line ") + (C.className || "")
          },
          x = B ? "bands" : "lines";
        h && (l = h.log2lin(l), w = h.log2lin(w), e = h.log2lin(e));
        c.chart.styledMode || (b ? (r.stroke = I || "#999999", r["stroke-width"] = f(C.width, 1), C.dashStyle && (r.dashstyle = C.dashStyle)) : B && (r.fill = I || "#e6ebf5", C.borderWidth && (r.stroke = C.borderColor, r["stroke-width"] = C.borderWidth)));
        v.zIndex = L;
        x += "-" + L;
        (h = c.plotLinesAndBandsGroups[x]) || (c.plotLinesAndBandsGroups[x] = h = z.g("plot-" + x).attr(v).add());
        J && (a.svgElem = g = z.path().attr(r).add(h));
        if (b) b = c.getPlotLinePath({
          value: e,
          lineWidth: g.strokeWidth(),
          acrossPanes: C.acrossPanes
        });else if (B) b = c.getPlotBandPath(l, w, C);else return;
        !a.eventsAdded && K && (p(K, function (b, e) {
          g.on(e, function (b) {
            K[e].apply(a, [b]);
          });
        }), a.eventsAdded = !0);
        (J || !g.d) && b && b.length ? g.attr({
          d: b
        }) : g && (b ? (g.show(!0), g.animate({
          d: b
        })) : g.d && (g.hide(), k && (a.label = k = k.destroy())));
        u && (t(u.text) || t(u.formatter)) && b && b.length && 0 < c.width && 0 < c.height && !b.isFlat ? (u = q({
          align: d && B && "center",
          x: d ? !B && 4 : 10,
          verticalAlign: !d && B && "middle",
          y: d ? B ? 16 : 10 : B ? 6 : -4,
          rotation: d && !B && 90
        }, u), this.renderLabel(u, b, B, L)) : k && k.hide();
        return a;
      };
      c.prototype.renderLabel = function (a, c, f, d) {
        var n = this.axis,
          m = n.chart.renderer,
          p = this.label;
        p || (this.label = p = m.text(this.getLabelText(a), 0, 0, a.useHTML).attr({
          align: a.textAlign || a.align,
          rotation: a.rotation,
          "class": "highcharts-plot-" + (f ? "band" : "line") + "-label " + (a.className || ""),
          zIndex: d
        }).add(), n.chart.styledMode || p.css(q({
          textOverflow: "ellipsis"
        }, a.style)));
        d = c.xBounds || [c[0][1], c[1][1], f ? c[2][1] : c[0][1]];
        c = c.yBounds || [c[0][2], c[1][2], f ? c[2][2] : c[0][2]];
        f = E(d);
        m = E(c);
        p.align(a, !1, {
          x: f,
          y: m,
          width: A(d) - f,
          height: A(c) - m
        });
        p.alignValue && "left" !== p.alignValue || p.css({
          width: (90 === p.rotation ? n.height - (p.alignAttr.y - n.top) : n.width - (p.alignAttr.x - n.left)) + "px"
        });
        p.show(!0);
      };
      c.prototype.getLabelText = function (a) {
        return t(a.formatter) ? a.formatter.call(this) : a.text;
      };
      c.prototype.destroy = function () {
        H(this.axis.plotLinesAndBands, this);
        delete this.axis;
        G(this);
      };
      return c;
    }();
    "";
    "";
    return h;
  });
  N(h, "Core/Tooltip.js", [h["Core/FormatUtilities.js"], h["Core/Globals.js"], h["Core/Renderer/RendererUtilities.js"], h["Core/Renderer/RendererRegistry.js"], h["Core/Utilities.js"]], function (d, h, A, F, t) {
    var E = d.format,
      H = h.doc,
      y = A.distribute,
      q = t.addEvent,
      p = t.clamp,
      f = t.css,
      c = t.defined,
      a = t.discardElement,
      n = t.extend,
      m = t.fireEvent,
      D = t.isArray,
      C = t.isNumber,
      I = t.isString,
      L = t.merge,
      K = t.pick,
      v = t.splat,
      z = t.syncTimeout;
    d = function () {
      function d(a, c) {
        this.allowShared = !0;
        this.container = void 0;
        this.crosshairs = [];
        this.distance = 0;
        this.isHidden = !0;
        this.isSticky = !1;
        this.now = {};
        this.options = {};
        this.outside = !1;
        this.chart = a;
        this.init(a, c);
      }
      d.prototype.applyFilter = function () {
        var a = this.chart;
        a.renderer.definition({
          tagName: "filter",
          attributes: {
            id: "drop-shadow-" + a.index,
            opacity: .5
          },
          children: [{
            tagName: "feGaussianBlur",
            attributes: {
              "in": "SourceAlpha",
              stdDeviation: 1
            }
          }, {
            tagName: "feOffset",
            attributes: {
              dx: 1,
              dy: 1
            }
          }, {
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncA",
              attributes: {
                type: "linear",
                slope: .3
              }
            }]
          }, {
            tagName: "feMerge",
            children: [{
              tagName: "feMergeNode"
            }, {
              tagName: "feMergeNode",
              attributes: {
                "in": "SourceGraphic"
              }
            }]
          }]
        });
      };
      d.prototype.bodyFormatter = function (a) {
        return a.map(function (a) {
          var l = a.series.tooltipOptions;
          return (l[(a.point.formatPrefix || "point") + "Formatter"] || a.point.tooltipFormatter).call(a.point, l[(a.point.formatPrefix || "point") + "Format"] || "");
        });
      };
      d.prototype.cleanSplit = function (a) {
        this.chart.series.forEach(function (c) {
          var l = c && c.tt;
          l && (!l.isActive || a ? c.tt = l.destroy() : l.isActive = !1);
        });
      };
      d.prototype.defaultFormatter = function (a) {
        var c = this.points || v(this);
        var l = [a.tooltipFooterHeaderFormatter(c[0])];
        l = l.concat(a.bodyFormatter(c));
        l.push(a.tooltipFooterHeaderFormatter(c[0], !0));
        return l;
      };
      d.prototype.destroy = function () {
        this.label && (this.label = this.label.destroy());
        this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());
        this.renderer && (this.renderer = this.renderer.destroy(), a(this.container));
        t.clearTimeout(this.hideTimer);
        t.clearTimeout(this.tooltipTimeout);
      };
      d.prototype.getAnchor = function (a, c) {
        var l = this.chart,
          e = l.pointer,
          g = l.inverted,
          b = l.plotTop,
          k = l.plotLeft,
          f,
          r,
          d = 0,
          u = 0;
        a = v(a);
        this.followPointer && c ? ("undefined" === typeof c.chartX && (c = e.normalize(c)), e = [c.chartX - k, c.chartY - b]) : a[0].tooltipPos ? e = a[0].tooltipPos : (a.forEach(function (e) {
          f = e.series.yAxis;
          r = e.series.xAxis;
          d += e.plotX || 0;
          u += e.plotLow ? (e.plotLow + (e.plotHigh || 0)) / 2 : e.plotY || 0;
          r && f && (g ? (d += b + l.plotHeight - r.len - r.pos, u += k + l.plotWidth - f.len - f.pos) : (d += r.pos - k, u += f.pos - b));
        }), d /= a.length, u /= a.length, e = [g ? l.plotWidth - u : d, g ? l.plotHeight - d : u], this.shared && 1 < a.length && c && (g ? e[0] = c.chartX - k : e[1] = c.chartY - b));
        return e.map(Math.round);
      };
      d.prototype.getLabel = function () {
        var a = this,
          d = this.chart.styledMode,
          l = this.options,
          e = this.split && this.allowShared,
          g = "tooltip" + (c(l.className) ? " " + l.className : ""),
          b = l.style.pointerEvents || (!this.followPointer && l.stickOnContact ? "auto" : "none"),
          B = function () {
            a.inContact = !0;
          },
          u = function (b) {
            var e = a.chart.hoverSeries;
            a.inContact = a.shouldStickOnContact() && a.chart.pointer.inClass(b.relatedTarget, "highcharts-tooltip");
            if (!a.inContact && e && e.onMouseOut) e.onMouseOut();
          },
          r,
          x = this.chart.renderer;
        if (a.label) {
          var n = !a.label.hasClass("highcharts-label");
          (e && !n || !e && n) && a.destroy();
        }
        if (!this.label) {
          if (this.outside) {
            n = this.chart.options.chart.style;
            var m = F.getRendererType();
            this.container = r = h.doc.createElement("div");
            r.className = "highcharts-tooltip-container";
            f(r, {
              position: "absolute",
              top: "1px",
              pointerEvents: b,
              zIndex: Math.max(this.options.style.zIndex || 0, (n && n.zIndex || 0) + 3)
            });
            q(r, "mouseenter", B);
            q(r, "mouseleave", u);
            h.doc.body.appendChild(r);
            this.renderer = x = new m(r, 0, 0, n, void 0, void 0, x.styledMode);
          }
          e ? this.label = x.g(g) : (this.label = x.label("", 0, 0, l.shape, void 0, void 0, l.useHTML, void 0, g).attr({
            padding: l.padding,
            r: l.borderRadius
          }), d || this.label.attr({
            fill: l.backgroundColor,
            "stroke-width": l.borderWidth
          }).css(l.style).css({
            pointerEvents: b
          }).shadow(l.shadow));
          d && l.shadow && (this.applyFilter(), this.label.attr({
            filter: "url(#drop-shadow-" + this.chart.index + ")"
          }));
          if (a.outside && !a.split) {
            var z = this.label,
              p = z.xSetter,
              v = z.ySetter;
            z.xSetter = function (b) {
              p.call(z, a.distance);
              r.style.left = b + "px";
            };
            z.ySetter = function (b) {
              v.call(z, a.distance);
              r.style.top = b + "px";
            };
          }
          this.label.on("mouseenter", B).on("mouseleave", u).attr({
            zIndex: 8
          }).add();
        }
        return this.label;
      };
      d.prototype.getPosition = function (a, c, l) {
        var e = this.chart,
          g = this.distance,
          b = {},
          k = e.inverted && l.h || 0,
          f = this.outside,
          r = f ? H.documentElement.clientWidth - 2 * g : e.chartWidth,
          d = f ? Math.max(H.body.scrollHeight, H.documentElement.scrollHeight, H.body.offsetHeight, H.documentElement.offsetHeight, H.documentElement.clientHeight) : e.chartHeight,
          u = e.pointer.getChartPosition(),
          w = function (b) {
            var k = "x" === b;
            return [b, k ? r : d, k ? a : c].concat(f ? [k ? a * u.scaleX : c * u.scaleY, k ? u.left - g + (l.plotX + e.plotLeft) * u.scaleX : u.top - g + (l.plotY + e.plotTop) * u.scaleY, 0, k ? r : d] : [k ? a : c, k ? l.plotX + e.plotLeft : l.plotY + e.plotTop, k ? e.plotLeft : e.plotTop, k ? e.plotLeft + e.plotWidth : e.plotTop + e.plotHeight]);
          },
          n = w("y"),
          m = w("x"),
          z;
        w = !!l.negative;
        !e.polar && e.hoverSeries && e.hoverSeries.yAxis && e.hoverSeries.yAxis.reversed && (w = !w);
        var p = !this.followPointer && K(l.ttBelow, !e.inverted === w),
          v = function (e, a, l, c, r, d, x) {
            var B = f ? "y" === e ? g * u.scaleY : g * u.scaleX : g,
              w = (l - c) / 2,
              J = c < r - g,
              n = r + g + c < a,
              m = r - B - l + w;
            r = r + B - w;
            if (p && n) b[e] = r;else if (!p && J) b[e] = m;else if (J) b[e] = Math.min(x - c, 0 > m - k ? m : m - k);else if (n) b[e] = Math.max(d, r + k + l > a ? r : r + k);else return !1;
          },
          h = function (e, a, l, c, k) {
            var r;
            k < g || k > a - g ? r = !1 : b[e] = k < l / 2 ? 1 : k > a - c / 2 ? a - c - 2 : k - l / 2;
            return r;
          },
          Q = function (b) {
            var e = n;
            n = m;
            m = e;
            z = b;
          },
          q = function () {
            !1 !== v.apply(0, n) ? !1 !== h.apply(0, m) || z || (Q(!0), q()) : z ? b.x = b.y = 0 : (Q(!0), q());
          };
        (e.inverted || 1 < this.len) && Q();
        q();
        return b;
      };
      d.prototype.hide = function (a) {
        var c = this;
        t.clearTimeout(this.hideTimer);
        a = K(a, this.options.hideDelay);
        this.isHidden || (this.hideTimer = z(function () {
          c.getLabel().fadeOut(a ? void 0 : a);
          c.isHidden = !0;
        }, a));
      };
      d.prototype.init = function (a, c) {
        this.chart = a;
        this.options = c;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.split = c.split && !a.inverted && !a.polar;
        this.shared = c.shared || this.split;
        this.outside = K(c.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));
      };
      d.prototype.shouldStickOnContact = function () {
        return !(this.followPointer || !this.options.stickOnContact);
      };
      d.prototype.isStickyOnContact = function () {
        return !(!this.shouldStickOnContact() || !this.inContact);
      };
      d.prototype.move = function (a, c, l, e) {
        var g = this,
          b = g.now,
          k = !1 !== g.options.animation && !g.isHidden && (1 < Math.abs(a - b.x) || 1 < Math.abs(c - b.y)),
          f = g.followPointer || 1 < g.len;
        n(b, {
          x: k ? (2 * b.x + a) / 3 : a,
          y: k ? (b.y + c) / 2 : c,
          anchorX: f ? void 0 : k ? (2 * b.anchorX + l) / 3 : l,
          anchorY: f ? void 0 : k ? (b.anchorY + e) / 2 : e
        });
        g.getLabel().attr(b);
        g.drawTracker();
        k && (t.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
          g && g.move(a, c, l, e);
        }, 32));
      };
      d.prototype.refresh = function (a, c) {
        var l = this.chart,
          e = this.options,
          g = v(a),
          b = g[0],
          k = [],
          f = e.formatter || this.defaultFormatter,
          r = this.shared,
          d = l.styledMode,
          u = {};
        if (e.enabled) {
          t.clearTimeout(this.hideTimer);
          this.allowShared = !(!D(a) && a.series && a.series.noSharedTooltip);
          this.followPointer = !this.split && b.series.tooltipOptions.followPointer;
          a = this.getAnchor(a, c);
          var w = a[0],
            n = a[1];
          r && this.allowShared ? (l.pointer.applyInactiveState(g), g.forEach(function (b) {
            b.setState("hover");
            k.push(b.getLabelConfig());
          }), u = {
            x: b.category,
            y: b.y
          }, u.points = k) : u = b.getLabelConfig();
          this.len = k.length;
          f = f.call(u, this);
          r = b.series;
          this.distance = K(r.tooltipOptions.distance, 16);
          if (!1 === f) this.hide();else {
            if (this.split && this.allowShared) this.renderSplit(f, g);else {
              var z = w,
                p = n;
              c && l.pointer.isDirectTouch && (z = c.chartX - l.plotLeft, p = c.chartY - l.plotTop);
              if (l.polar || !1 === r.options.clip || g.some(function (b) {
                return b.series.shouldShowTooltip(z, p);
              })) c = this.getLabel(), e.style.width && !d || c.css({
                width: this.chart.spacingBox.width + "px"
              }), c.attr({
                text: f && f.join ? f.join("") : f
              }), c.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + K(b.colorIndex, r.colorIndex)), d || c.attr({
                stroke: e.borderColor || b.color || r.color || "#666666"
              }), this.updatePosition({
                plotX: w,
                plotY: n,
                negative: b.negative,
                ttBelow: b.ttBelow,
                h: a[2] || 0
              });else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({
              opacity: 1
            }).show();
            this.isHidden = !1;
          }
          m(this, "refresh");
        }
      };
      d.prototype.renderSplit = function (a, c) {
        function l(b, g, a, l, c) {
          void 0 === c && (c = !0);
          a ? (g = A ? 0 : ea, b = p(b - l / 2, R.left, R.right - l - (e.outside ? E : 0))) : (g -= G, b = c ? b - l - C : b + C, b = p(b, c ? b : R.left, R.right));
          return {
            x: b,
            y: g
          };
        }
        var e = this,
          g = e.chart,
          b = e.chart,
          k = b.chartWidth,
          f = b.chartHeight,
          r = b.plotHeight,
          d = b.plotLeft,
          u = b.plotTop,
          w = b.pointer,
          m = b.scrollablePixelsY;
        m = void 0 === m ? 0 : m;
        var z = b.scrollablePixelsX,
          v = b.scrollingContainer;
        v = void 0 === v ? {
          scrollLeft: 0,
          scrollTop: 0
        } : v;
        var h = v.scrollLeft;
        v = v.scrollTop;
        var q = b.styledMode,
          C = e.distance,
          Q = e.options,
          D = e.options.positioner,
          R = e.outside && "number" !== typeof z ? H.documentElement.getBoundingClientRect() : {
            left: h,
            right: h + k,
            top: v,
            bottom: v + f
          },
          L = e.getLabel(),
          t = this.renderer || g.renderer,
          A = !(!g.xAxis[0] || !g.xAxis[0].opposite);
        g = w.getChartPosition();
        var E = g.left;
        g = g.top;
        var G = u + v,
          F = 0,
          ea = r - m;
        I(a) && (a = [!1, a]);
        a = a.slice(0, c.length + 1).reduce(function (b, g, a) {
          if (!1 !== g && "" !== g) {
            a = c[a - 1] || {
              isHeader: !0,
              plotX: c[0].plotX,
              plotY: r,
              series: {}
            };
            var k = a.isHeader,
              f = k ? e : a.series;
            g = g.toString();
            var x = f.tt,
              B = a.isHeader;
            var w = a.series;
            var J = "highcharts-color-" + K(a.colorIndex, w.colorIndex, "none");
            x || (x = {
              padding: Q.padding,
              r: Q.borderRadius
            }, q || (x.fill = Q.backgroundColor, x["stroke-width"] = Q.borderWidth), x = t.label("", 0, 0, Q[B ? "headerShape" : "shape"], void 0, void 0, Q.useHTML).addClass((B ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + J).attr(x).add(L));
            x.isActive = !0;
            x.attr({
              text: g
            });
            q || x.css(Q.style).shadow(Q.shadow).attr({
              stroke: Q.borderColor || a.color || w.color || "#333333"
            });
            f = f.tt = x;
            B = f.getBBox();
            g = B.width + f.strokeWidth();
            k && (F = B.height, ea += F, A && (G -= F));
            w = a.plotX;
            w = void 0 === w ? 0 : w;
            J = a.plotY;
            J = void 0 === J ? 0 : J;
            x = a.series;
            if (a.isHeader) {
              w = d + w;
              var n = u + r / 2;
            } else {
              var m = x.xAxis,
                z = x.yAxis;
              w = m.pos + p(w, -C, m.len + C);
              x.shouldShowTooltip(0, z.pos - u + J, {
                ignoreX: !0
              }) && (n = z.pos + J);
            }
            w = p(w, R.left - C, R.right + C);
            "number" === typeof n ? (B = B.height + 1, J = D ? D.call(e, g, B, a) : l(w, n, k, g), b.push({
              align: D ? 0 : void 0,
              anchorX: w,
              anchorY: n,
              boxWidth: g,
              point: a,
              rank: K(J.rank, k ? 1 : 0),
              size: B,
              target: J.y,
              tt: f,
              x: J.x
            })) : f.isActive = !1;
          }
          return b;
        }, []);
        !D && a.some(function (b) {
          var g = (e.outside ? E : 0) + b.anchorX;
          return g < R.left && g + b.boxWidth < R.right ? !0 : g < E - R.left + b.boxWidth && R.right - g > g;
        }) && (a = a.map(function (b) {
          var e = l(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
          return n(b, {
            target: e.y,
            x: e.x
          });
        }));
        e.cleanSplit();
        y(a, ea);
        var N = E,
          Y = E;
        a.forEach(function (b) {
          var g = b.x,
            a = b.boxWidth;
          b = b.isHeader;
          b || (e.outside && E + g < N && (N = E + g), !b && e.outside && N + a > Y && (Y = E + g));
        });
        a.forEach(function (b) {
          var g = b.x,
            a = b.anchorX,
            l = b.pos,
            c = b.point.isHeader;
          l = {
            visibility: "undefined" === typeof l ? "hidden" : "inherit",
            x: g,
            y: l + G,
            anchorX: a,
            anchorY: b.anchorY
          };
          if (e.outside && g < a) {
            var k = E - N;
            0 < k && (c || (l.x = g + k, l.anchorX = a + k), c && (l.x = (Y - N) / 2, l.anchorX = a + k));
          }
          b.tt.attr(l);
        });
        a = e.container;
        m = e.renderer;
        e.outside && a && m && (b = L.getBBox(), m.setSize(b.width + b.x, b.height + b.y, !1), a.style.left = N + "px", a.style.top = g + "px");
      };
      d.prototype.drawTracker = function () {
        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
          var a = this.chart,
            c = this.label,
            l = this.shared ? a.hoverPoints : a.hoverPoint;
          if (c && l) {
            var e = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
            l = this.getAnchor(l);
            var g = c.getBBox();
            l[0] += a.plotLeft - c.translateX;
            l[1] += a.plotTop - c.translateY;
            e.x = Math.min(0, l[0]);
            e.y = Math.min(0, l[1]);
            e.width = 0 > l[0] ? Math.max(Math.abs(l[0]), g.width - l[0]) : Math.max(Math.abs(l[0]), g.width);
            e.height = 0 > l[1] ? Math.max(Math.abs(l[1]), g.height - Math.abs(l[1])) : Math.max(Math.abs(l[1]), g.height);
            this.tracker ? this.tracker.attr(e) : (this.tracker = c.renderer.rect(e).addClass("highcharts-tracker").add(c), a.styledMode || this.tracker.attr({
              fill: "rgba(0,0,0,0)"
            }));
          }
        }
      };
      d.prototype.styledModeFormat = function (a) {
        return a.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
      };
      d.prototype.tooltipFooterHeaderFormatter = function (a, c) {
        var l = a.series,
          e = l.tooltipOptions,
          g = l.xAxis,
          b = g && g.dateTime;
        g = {
          isFooter: c,
          labelConfig: a
        };
        var k = e.xDateFormat,
          f = e[c ? "footerFormat" : "headerFormat"];
        m(this, "headerFormatter", g, function (g) {
          b && !k && C(a.key) && (k = b.getXDateFormat(a.key, e.dateTimeLabelFormats));
          b && k && (a.point && a.point.tooltipDateKeys || ["key"]).forEach(function (b) {
            f = f.replace("{point." + b + "}", "{point." + b + ":" + k + "}");
          });
          l.chart.styledMode && (f = this.styledModeFormat(f));
          g.text = E(f, {
            point: a,
            series: l
          }, this.chart);
        });
        return g.text;
      };
      d.prototype.update = function (a) {
        this.destroy();
        L(!0, this.chart.options.tooltip.userOptions, a);
        this.init(this.chart, L(!0, this.options, a));
      };
      d.prototype.updatePosition = function (a) {
        var c = this.chart,
          l = this.options,
          e = c.pointer,
          g = this.getLabel();
        e = e.getChartPosition();
        var b = (l.positioner || this.getPosition).call(this, g.width, g.height, a),
          k = a.plotX + c.plotLeft;
        a = a.plotY + c.plotTop;
        if (this.outside) {
          l = l.borderWidth + 2 * this.distance;
          this.renderer.setSize(g.width + l, g.height + l, !1);
          if (1 !== e.scaleX || 1 !== e.scaleY) f(this.container, {
            transform: "scale(" + e.scaleX + ", " + e.scaleY + ")"
          }), k *= e.scaleX, a *= e.scaleY;
          k += e.left - b.x;
          a += e.top - b.y;
        }
        this.move(Math.round(b.x), Math.round(b.y || 0), k, a);
      };
      return d;
    }();
    "";
    return d;
  });
  N(h, "Core/Series/Point.js", [h["Core/Renderer/HTML/AST.js"], h["Core/Animation/AnimationUtilities.js"], h["Core/DefaultOptions.js"], h["Core/FormatUtilities.js"], h["Core/Utilities.js"]], function (d, h, A, F, t) {
    var E = h.animObject,
      H = A.defaultOptions,
      y = F.format,
      q = t.addEvent,
      p = t.defined,
      f = t.erase,
      c = t.extend,
      a = t.fireEvent,
      n = t.getNestedProperty,
      m = t.isArray,
      D = t.isFunction,
      C = t.isNumber,
      I = t.isObject,
      L = t.merge,
      K = t.objectEach,
      v = t.pick,
      z = t.syncTimeout,
      u = t.removeEvent,
      k = t.uniqueKey;
    h = function () {
      function w() {
        this.colorIndex = this.category = void 0;
        this.formatPrefix = "point";
        this.id = void 0;
        this.isNull = !1;
        this.percentage = this.options = this.name = void 0;
        this.selected = !1;
        this.total = this.series = void 0;
        this.visible = !0;
        this.x = void 0;
      }
      w.prototype.animateBeforeDestroy = function () {
        var a = this,
          e = {
            x: a.startXPos,
            opacity: 0
          },
          g = a.getGraphicalProps();
        g.singular.forEach(function (b) {
          a[b] = a[b].animate("dataLabel" === b ? {
            x: a[b].startXPos,
            y: a[b].startYPos,
            opacity: 0
          } : e);
        });
        g.plural.forEach(function (b) {
          a[b].forEach(function (b) {
            b.element && b.animate(c({
              x: a.startXPos
            }, b.startYPos ? {
              x: b.startXPos,
              y: b.startYPos
            } : {}));
          });
        });
      };
      w.prototype.applyOptions = function (a, e) {
        var g = this.series,
          b = g.options.pointValKey || g.pointValKey;
        a = w.prototype.optionsToObject.call(this, a);
        c(this, a);
        this.options = this.options ? c(this.options, a) : a;
        a.group && delete this.group;
        a.dataLabels && delete this.dataLabels;
        b && (this.y = w.prototype.getNestedProperty.call(this, b));
        this.formatPrefix = (this.isNull = v(this.isValid && !this.isValid(), null === this.x || !C(this.y))) ? "null" : "point";
        this.selected && (this.state = "select");
        "name" in this && "undefined" === typeof e && g.xAxis && g.xAxis.hasNames && (this.x = g.xAxis.nameToX(this));
        "undefined" === typeof this.x && g ? this.x = "undefined" === typeof e ? g.autoIncrement() : e : C(a.x) && g.options.relativeXValue && (this.x = g.autoIncrement(a.x));
        return this;
      };
      w.prototype.destroy = function () {
        function a() {
          if (e.graphic || e.dataLabel || e.dataLabels) u(e), e.destroyElements();
          for (r in e) e[r] = null;
        }
        var e = this,
          g = e.series,
          b = g.chart;
        g = g.options.dataSorting;
        var c = b.hoverPoints,
          k = E(e.series.chart.renderer.globalAnimation),
          r;
        e.legendItem && b.legend.destroyItem(e);
        c && (e.setState(), f(c, e), c.length || (b.hoverPoints = null));
        if (e === b.hoverPoint) e.onMouseOut();
        g && g.enabled ? (this.animateBeforeDestroy(), z(a, k.duration)) : a();
        b.pointCount--;
      };
      w.prototype.destroyElements = function (a) {
        var e = this;
        a = e.getGraphicalProps(a);
        a.singular.forEach(function (g) {
          e[g] = e[g].destroy();
        });
        a.plural.forEach(function (g) {
          e[g].forEach(function (b) {
            b.element && b.destroy();
          });
          delete e[g];
        });
      };
      w.prototype.firePointEvent = function (l, e, g) {
        var b = this,
          c = this.series.options;
        (c.point.events[l] || b.options && b.options.events && b.options.events[l]) && b.importEvents();
        "click" === l && c.allowPointSelect && (g = function (e) {
          b.select && b.select(null, e.ctrlKey || e.metaKey || e.shiftKey);
        });
        a(b, l, e, g);
      };
      w.prototype.getClassName = function () {
        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
      };
      w.prototype.getGraphicalProps = function (a) {
        var e = this,
          g = [],
          b = {
            singular: [],
            plural: []
          },
          l;
        a = a || {
          graphic: 1,
          dataLabel: 1
        };
        a.graphic && g.push("graphic", "upperGraphic", "shadowGroup");
        a.dataLabel && g.push("dataLabel", "dataLabelUpper", "connector");
        for (l = g.length; l--;) {
          var c = g[l];
          e[c] && b.singular.push(c);
        }
        ["dataLabel", "connector"].forEach(function (g) {
          var l = g + "s";
          a[g] && e[l] && b.plural.push(l);
        });
        return b;
      };
      w.prototype.getLabelConfig = function () {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      };
      w.prototype.getNestedProperty = function (a) {
        if (a) return 0 === a.indexOf("custom.") ? n(a, this.options) : this[a];
      };
      w.prototype.getZone = function () {
        var a = this.series,
          e = a.zones;
        a = a.zoneAxis || "y";
        var g,
          b = 0;
        for (g = e[b]; this[a] >= g.value;) g = e[++b];
        this.nonZonedColor || (this.nonZonedColor = this.color);
        this.color = g && g.color && !this.options.color ? g.color : this.nonZonedColor;
        return g;
      };
      w.prototype.hasNewShapeType = function () {
        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
      };
      w.prototype.init = function (c, e, g) {
        this.series = c;
        this.applyOptions(e, g);
        this.id = p(this.id) ? this.id : k();
        this.resolveColor();
        c.chart.pointCount++;
        a(this, "afterInit");
        return this;
      };
      w.prototype.optionsToObject = function (a) {
        var e = this.series,
          g = e.options.keys,
          b = g || e.pointArrayMap || ["y"],
          c = b.length,
          l = {},
          k = 0,
          f = 0;
        if (C(a) || null === a) l[b[0]] = a;else if (m(a)) for (!g && a.length > c && (e = typeof a[0], "string" === e ? l.name = a[0] : "number" === e && (l.x = a[0]), k++); f < c;) g && "undefined" === typeof a[k] || (0 < b[f].indexOf(".") ? w.prototype.setNestedProperty(l, a[k], b[f]) : l[b[f]] = a[k]), k++, f++;else "object" === typeof a && (l = a, a.dataLabels && (e._hasPointLabels = !0), a.marker && (e._hasPointMarkers = !0));
        return l;
      };
      w.prototype.resolveColor = function () {
        var a = this.series,
          e = a.chart.styledMode;
        var g = a.chart.options.chart.colorCount;
        delete this.nonZonedColor;
        if (a.options.colorByPoint) {
          if (!e) {
            g = a.options.colors || a.chart.options.colors;
            var b = g[a.colorCounter];
            g = g.length;
          }
          e = a.colorCounter;
          a.colorCounter++;
          a.colorCounter === g && (a.colorCounter = 0);
        } else e || (b = a.color), e = a.colorIndex;
        this.colorIndex = v(this.options.colorIndex, e);
        this.color = v(this.options.color, b);
      };
      w.prototype.setNestedProperty = function (a, e, g) {
        g.split(".").reduce(function (b, g, a, c) {
          b[g] = c.length - 1 === a ? e : I(b[g], !0) ? b[g] : {};
          return b[g];
        }, a);
        return a;
      };
      w.prototype.tooltipFormatter = function (a) {
        var e = this.series,
          g = e.tooltipOptions,
          b = v(g.valueDecimals, ""),
          c = g.valuePrefix || "",
          l = g.valueSuffix || "";
        e.chart.styledMode && (a = e.chart.tooltip.styledModeFormat(a));
        (e.pointArrayMap || ["y"]).forEach(function (e) {
          e = "{point." + e;
          if (c || l) a = a.replace(RegExp(e + "}", "g"), c + e + "}" + l);
          a = a.replace(RegExp(e + "}", "g"), e + ":,." + b + "f}");
        });
        return y(a, {
          point: this,
          series: this.series
        }, e.chart);
      };
      w.prototype.update = function (a, e, g, b) {
        function c() {
          l.applyOptions(a);
          var b = f && l.hasDummyGraphic;
          b = null === l.y ? !b : b;
          f && b && (l.graphic = f.destroy(), delete l.hasDummyGraphic);
          I(a, !0) && (f && f.element && a && a.marker && "undefined" !== typeof a.marker.symbol && (l.graphic = f.destroy()), a && a.dataLabels && l.dataLabel && (l.dataLabel = l.dataLabel.destroy()), l.connector && (l.connector = l.connector.destroy()));
          w = l.index;
          k.updateParallelArrays(l, w);
          u.data[w] = I(u.data[w], !0) || I(a, !0) ? l.options : v(a, u.data[w]);
          k.isDirty = k.isDirtyData = !0;
          !k.fixedBox && k.hasCartesianSeries && (d.isDirtyBox = !0);
          "point" === u.legendType && (d.isDirtyLegend = !0);
          e && d.redraw(g);
        }
        var l = this,
          k = l.series,
          f = l.graphic,
          d = k.chart,
          u = k.options,
          w;
        e = v(e, !0);
        !1 === b ? c() : l.firePointEvent("update", {
          options: a
        }, c);
      };
      w.prototype.remove = function (a, e) {
        this.series.removePoint(this.series.data.indexOf(this), a, e);
      };
      w.prototype.select = function (a, e) {
        var g = this,
          b = g.series,
          c = b.chart;
        this.selectedStaging = a = v(a, !g.selected);
        g.firePointEvent(a ? "select" : "unselect", {
          accumulate: e
        }, function () {
          g.selected = g.options.selected = a;
          b.options.data[b.data.indexOf(g)] = g.options;
          g.setState(a && "select");
          e || c.getSelectedPoints().forEach(function (b) {
            var e = b.series;
            b.selected && b !== g && (b.selected = b.options.selected = !1, e.options.data[e.data.indexOf(b)] = b.options, b.setState(c.hoverPoints && e.options.inactiveOtherPoints ? "inactive" : ""), b.firePointEvent("unselect"));
          });
        });
        delete this.selectedStaging;
      };
      w.prototype.onMouseOver = function (a) {
        var e = this.series.chart,
          g = e.pointer;
        a = a ? g.normalize(a) : g.getChartCoordinatesFromPoint(this, e.inverted);
        g.runPointActions(a, this);
      };
      w.prototype.onMouseOut = function () {
        var a = this.series.chart;
        this.firePointEvent("mouseOut");
        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (e) {
          e.setState();
        });
        a.hoverPoints = a.hoverPoint = null;
      };
      w.prototype.importEvents = function () {
        if (!this.hasImportedEvents) {
          var a = this,
            e = L(a.series.options.point, a.options).events;
          a.events = e;
          K(e, function (e, b) {
            D(e) && q(a, b, e);
          });
          this.hasImportedEvents = !0;
        }
      };
      w.prototype.setState = function (l, e) {
        var g = this.series,
          b = this.state,
          k = g.options.states[l || "normal"] || {},
          f = H.plotOptions[g.type].marker && g.options.marker,
          r = f && !1 === f.enabled,
          x = f && f.states && f.states[l || "normal"] || {},
          u = !1 === x.enabled,
          w = this.marker || {},
          n = g.chart,
          m = f && g.markerAttribs,
          z = g.halo,
          p,
          h = g.stateMarkerGraphic;
        l = l || "";
        if (!(l === this.state && !e || this.selected && "select" !== l || !1 === k.enabled || l && (u || r && !1 === x.enabled) || l && w.states && w.states[l] && !1 === w.states[l].enabled)) {
          this.state = l;
          m && (p = g.markerAttribs(this, l));
          if (this.graphic && !this.hasDummyGraphic) {
            b && this.graphic.removeClass("highcharts-point-" + b);
            l && this.graphic.addClass("highcharts-point-" + l);
            if (!n.styledMode) {
              var q = g.pointAttribs(this, l);
              var Q = v(n.options.chart.animation, k.animation);
              g.options.inactiveOtherPoints && C(q.opacity) && ((this.dataLabels || []).forEach(function (b) {
                b && b.animate({
                  opacity: q.opacity
                }, Q);
              }), this.connector && this.connector.animate({
                opacity: q.opacity
              }, Q));
              this.graphic.animate(q, Q);
            }
            p && this.graphic.animate(p, v(n.options.chart.animation, x.animation, f.animation));
            h && h.hide();
          } else {
            if (l && x) {
              b = w.symbol || g.symbol;
              h && h.currentSymbol !== b && (h = h.destroy());
              if (p) if (h) h[e ? "animate" : "attr"]({
                x: p.x,
                y: p.y
              });else b && (g.stateMarkerGraphic = h = n.renderer.symbol(b, p.x, p.y, p.width, p.height).add(g.markerGroup), h.currentSymbol = b);
              !n.styledMode && h && "inactive" !== this.state && h.attr(g.pointAttribs(this, l));
            }
            h && (h[l && this.isInside ? "show" : "hide"](), h.element.point = this, h.addClass(this.getClassName(), !0));
          }
          k = k.halo;
          p = (h = this.graphic || h) && h.visibility || "inherit";
          k && k.size && h && "hidden" !== p && !this.isCluster ? (z || (g.halo = z = n.renderer.path().add(h.parentGroup)), z.show()[e ? "animate" : "attr"]({
            d: this.haloPath(k.size)
          }), z.attr({
            "class": "highcharts-halo highcharts-color-" + v(this.colorIndex, g.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: p,
            zIndex: -1
          }), z.point = this, n.styledMode || z.attr(c({
            fill: this.color || g.color,
            "fill-opacity": k.opacity
          }, d.filterUserAttributes(k.attributes || {})))) : z && z.point && z.point.haloPath && z.animate({
            d: z.point.haloPath(0)
          }, null, z.hide);
          a(this, "afterSetState", {
            state: l
          });
        }
      };
      w.prototype.haloPath = function (a) {
        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
      };
      return w;
    }();
    "";
    return h;
  });
  N(h, "Core/Pointer.js", [h["Core/Color/Color.js"], h["Core/Globals.js"], h["Core/Tooltip.js"], h["Core/Utilities.js"]], function (d, h, A, F) {
    var t = d.parse,
      E = h.charts,
      H = h.noop,
      y = F.addEvent,
      q = F.attr,
      p = F.css,
      f = F.defined,
      c = F.extend,
      a = F.find,
      n = F.fireEvent,
      m = F.isNumber,
      D = F.isObject,
      C = F.objectEach,
      I = F.offset,
      L = F.pick,
      K = F.splat;
    d = function () {
      function d(a, c) {
        this.lastValidTouch = {};
        this.pinchDown = [];
        this.runChartClick = !1;
        this.eventsToUnbind = [];
        this.chart = a;
        this.hasDragged = !1;
        this.options = c;
        this.init(a, c);
      }
      d.prototype.applyInactiveState = function (a) {
        var c = [],
          k;
        (a || []).forEach(function (a) {
          k = a.series;
          c.push(k);
          k.linkedParent && c.push(k.linkedParent);
          k.linkedSeries && (c = c.concat(k.linkedSeries));
          k.navigatorSeries && c.push(k.navigatorSeries);
        });
        this.chart.series.forEach(function (a) {
          -1 === c.indexOf(a) ? a.setState("inactive", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState("inactive");
        });
      };
      d.prototype.destroy = function () {
        var a = this;
        this.eventsToUnbind.forEach(function (a) {
          return a();
        });
        this.eventsToUnbind = [];
        h.chartCount || (d.unbindDocumentMouseUp && (d.unbindDocumentMouseUp = d.unbindDocumentMouseUp()), d.unbindDocumentTouchEnd && (d.unbindDocumentTouchEnd = d.unbindDocumentTouchEnd()));
        clearInterval(a.tooltipTimeout);
        C(a, function (c, k) {
          a[k] = void 0;
        });
      };
      d.prototype.drag = function (a) {
        var c = this.chart,
          k = c.options.chart,
          f = this.zoomHor,
          l = this.zoomVert,
          e = c.plotLeft,
          g = c.plotTop,
          b = c.plotWidth,
          d = c.plotHeight,
          n = this.mouseDownX || 0,
          r = this.mouseDownY || 0,
          x = D(k.panning) ? k.panning && k.panning.enabled : k.panning,
          m = k.panKey && a[k.panKey + "Key"],
          z = a.chartX,
          p = a.chartY,
          h = this.selectionMarker;
        if (!h || !h.touch) if (z < e ? z = e : z > e + b && (z = e + b), p < g ? p = g : p > g + d && (p = g + d), this.hasDragged = Math.sqrt(Math.pow(n - z, 2) + Math.pow(r - p, 2)), 10 < this.hasDragged) {
          var v = c.isInsidePlot(n - e, r - g, {
            visiblePlotOnly: !0
          });
          !c.hasCartesianSeries && !c.mapView || !this.zoomX && !this.zoomY || !v || m || h || (this.selectionMarker = h = c.renderer.rect(e, g, f ? 1 : b, l ? 1 : d, 0).attr({
            "class": "highcharts-selection-marker",
            zIndex: 7
          }).add(), c.styledMode || h.attr({
            fill: k.selectionMarkerFill || t("#335cad").setOpacity(.25).get()
          }));
          h && f && (f = z - n, h.attr({
            width: Math.abs(f),
            x: (0 < f ? 0 : f) + n
          }));
          h && l && (f = p - r, h.attr({
            height: Math.abs(f),
            y: (0 < f ? 0 : f) + r
          }));
          v && !h && x && c.pan(a, k.panning);
        }
      };
      d.prototype.dragStart = function (a) {
        var c = this.chart;
        c.mouseIsDown = a.type;
        c.cancelClick = !1;
        c.mouseDownX = this.mouseDownX = a.chartX;
        c.mouseDownY = this.mouseDownY = a.chartY;
      };
      d.prototype.drop = function (a) {
        var d = this,
          k = this.chart,
          w = this.hasPinched;
        if (this.selectionMarker) {
          var l = this.selectionMarker,
            e = l.attr ? l.attr("x") : l.x,
            g = l.attr ? l.attr("y") : l.y,
            b = l.attr ? l.attr("width") : l.width,
            B = l.attr ? l.attr("height") : l.height,
            z = {
              originalEvent: a,
              xAxis: [],
              yAxis: [],
              x: e,
              y: g,
              width: b,
              height: B
            },
            r = !!k.mapView;
          if (this.hasDragged || w) k.axes.forEach(function (c) {
            if (c.zoomEnabled && f(c.min) && (w || d[{
              xAxis: "zoomX",
              yAxis: "zoomY"
            }[c.coll]]) && m(e) && m(g)) {
              var l = c.horiz,
                k = "touchend" === a.type ? c.minPixelPadding : 0,
                x = c.toValue((l ? e : g) + k);
              l = c.toValue((l ? e + b : g + B) - k);
              z[c.coll].push({
                axis: c,
                min: Math.min(x, l),
                max: Math.max(x, l)
              });
              r = !0;
            }
          }), r && n(k, "selection", z, function (b) {
            k.zoom(c(b, w ? {
              animation: !1
            } : null));
          });
          m(k.index) && (this.selectionMarker = this.selectionMarker.destroy());
          w && this.scaleGroups();
        }
        k && m(k.index) && (p(k.container, {
          cursor: k._cursor
        }), k.cancelClick = 10 < this.hasDragged, k.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
      };
      d.prototype.findNearestKDPoint = function (a, c, k) {
        var f = this.chart,
          l = f.hoverPoint;
        f = f.tooltip;
        if (l && f && f.isStickyOnContact()) return l;
        var e;
        a.forEach(function (a) {
          var b = !(a.noSharedTooltip && c) && 0 > a.options.findNearestPointBy.indexOf("y");
          a = a.searchPoint(k, b);
          if ((b = D(a, !0) && a.series) && !(b = !D(e, !0))) {
            b = e.distX - a.distX;
            var g = e.dist - a.dist,
              l = (a.series.group && a.series.group.zIndex) - (e.series.group && e.series.group.zIndex);
            b = 0 < (0 !== b && c ? b : 0 !== g ? g : 0 !== l ? l : e.series.index > a.series.index ? -1 : 1);
          }
          b && (e = a);
        });
        return e;
      };
      d.prototype.getChartCoordinatesFromPoint = function (a, c) {
        var k = a.series,
          f = k.xAxis;
        k = k.yAxis;
        var l = a.shapeArgs;
        if (f && k) {
          var e = L(a.clientX, a.plotX),
            g = a.plotY || 0;
          a.isNode && l && m(l.x) && m(l.y) && (e = l.x, g = l.y);
          return c ? {
            chartX: k.len + k.pos - g,
            chartY: f.len + f.pos - e
          } : {
            chartX: e + f.pos,
            chartY: g + k.pos
          };
        }
        if (l && l.x && l.y) return {
          chartX: l.x,
          chartY: l.y
        };
      };
      d.prototype.getChartPosition = function () {
        if (this.chartPosition) return this.chartPosition;
        var a = this.chart.container,
          c = I(a);
        this.chartPosition = {
          left: c.left,
          top: c.top,
          scaleX: 1,
          scaleY: 1
        };
        var k = a.offsetWidth;
        a = a.offsetHeight;
        2 < k && 2 < a && (this.chartPosition.scaleX = c.width / k, this.chartPosition.scaleY = c.height / a);
        return this.chartPosition;
      };
      d.prototype.getCoordinates = function (a) {
        var c = {
          xAxis: [],
          yAxis: []
        };
        this.chart.axes.forEach(function (k) {
          c[k.isXAxis ? "xAxis" : "yAxis"].push({
            axis: k,
            value: k.toValue(a[k.horiz ? "chartX" : "chartY"])
          });
        });
        return c;
      };
      d.prototype.getHoverData = function (c, f, k, d, l, e) {
        var g = [];
        d = !(!d || !c);
        var b = {
          chartX: e ? e.chartX : void 0,
          chartY: e ? e.chartY : void 0,
          shared: l
        };
        n(this, "beforeGetHoverData", b);
        var u = f && !f.stickyTracking ? [f] : k.filter(function (e) {
          return b.filter ? b.filter(e) : e.visible && !(!l && e.directTouch) && L(e.options.enableMouseTracking, !0) && e.stickyTracking;
        });
        var w = d || !e ? c : this.findNearestKDPoint(u, l, e);
        f = w && w.series;
        w && (l && !f.noSharedTooltip ? (u = k.filter(function (e) {
          return b.filter ? b.filter(e) : e.visible && !(!l && e.directTouch) && L(e.options.enableMouseTracking, !0) && !e.noSharedTooltip;
        }), u.forEach(function (b) {
          var e = a(b.points, function (b) {
            return b.x === w.x && !b.isNull;
          });
          D(e) && (b.chart.isBoosting && (e = b.getPoint(e)), g.push(e));
        })) : g.push(w));
        b = {
          hoverPoint: w
        };
        n(this, "afterGetHoverData", b);
        return {
          hoverPoint: b.hoverPoint,
          hoverSeries: f,
          hoverPoints: g
        };
      };
      d.prototype.getPointFromEvent = function (a) {
        a = a.target;
        for (var c; a && !c;) c = a.point, a = a.parentNode;
        return c;
      };
      d.prototype.onTrackerMouseOut = function (a) {
        a = a.relatedTarget || a.toElement;
        var c = this.chart.hoverSeries;
        this.isDirectTouch = !1;
        if (!(!c || !a || c.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + c.index) && this.inClass(a, "highcharts-tracker"))) c.onMouseOut();
      };
      d.prototype.inClass = function (a, c) {
        for (var k; a;) {
          if (k = q(a, "class")) {
            if (-1 !== k.indexOf(c)) return !0;
            if (-1 !== k.indexOf("highcharts-container")) return !1;
          }
          a = a.parentNode;
        }
      };
      d.prototype.init = function (a, c) {
        this.options = c;
        this.chart = a;
        this.runChartClick = !(!c.chart.events || !c.chart.events.click);
        this.pinchDown = [];
        this.lastValidTouch = {};
        A && (a.tooltip = new A(a, c.tooltip), this.followTouchMove = L(c.tooltip.followTouchMove, !0));
        this.setDOMEvents();
      };
      d.prototype.normalize = function (a, f) {
        var k = a.touches,
          d = k ? k.length ? k.item(0) : L(k.changedTouches, a.changedTouches)[0] : a;
        f || (f = this.getChartPosition());
        k = d.pageX - f.left;
        d = d.pageY - f.top;
        k /= f.scaleX;
        d /= f.scaleY;
        return c(a, {
          chartX: Math.round(k),
          chartY: Math.round(d)
        });
      };
      d.prototype.onContainerClick = function (a) {
        var f = this.chart,
          k = f.hoverPoint;
        a = this.normalize(a);
        var d = f.plotLeft,
          l = f.plotTop;
        f.cancelClick || (k && this.inClass(a.target, "highcharts-tracker") ? (n(k.series, "click", c(a, {
          point: k
        })), f.hoverPoint && k.firePointEvent("click", a)) : (c(a, this.getCoordinates(a)), f.isInsidePlot(a.chartX - d, a.chartY - l, {
          visiblePlotOnly: !0
        }) && n(f, "click", a)));
      };
      d.prototype.onContainerMouseDown = function (a) {
        var c = 1 === ((a.buttons || a.button) & 1);
        a = this.normalize(a);
        if (h.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);
        if ("undefined" === typeof a.button || c) this.zoomOption(a), c && a.preventDefault && a.preventDefault(), this.dragStart(a);
      };
      d.prototype.onContainerMouseLeave = function (a) {
        var c = E[L(d.hoverChartIndex, -1)],
          k = this.chart.tooltip;
        k && k.shouldStickOnContact() && this.inClass(a.relatedTarget, "highcharts-tooltip-container") || (a = this.normalize(a), c && (a.relatedTarget || a.toElement) && (c.pointer.reset(), c.pointer.chartPosition = void 0), k && !k.isHidden && this.reset());
      };
      d.prototype.onContainerMouseEnter = function (a) {
        delete this.chartPosition;
      };
      d.prototype.onContainerMouseMove = function (a) {
        var c = this.chart;
        a = this.normalize(a);
        this.setHoverChartIndex();
        a.preventDefault || (a.returnValue = !1);
        ("mousedown" === c.mouseIsDown || this.touchSelect(a)) && this.drag(a);
        c.openMenu || !this.inClass(a.target, "highcharts-tracker") && !c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
          visiblePlotOnly: !0
        }) || (this.inClass(a.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(a));
      };
      d.prototype.onDocumentTouchEnd = function (a) {
        var c = E[L(d.hoverChartIndex, -1)];
        c && c.pointer.drop(a);
      };
      d.prototype.onContainerTouchMove = function (a) {
        if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);
      };
      d.prototype.onContainerTouchStart = function (a) {
        if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);
      };
      d.prototype.onDocumentMouseMove = function (a) {
        var c = this.chart,
          k = this.chartPosition;
        a = this.normalize(a, k);
        var f = c.tooltip;
        !k || f && f.isStickyOnContact() || c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
          visiblePlotOnly: !0
        }) || this.inClass(a.target, "highcharts-tracker") || this.reset();
      };
      d.prototype.onDocumentMouseUp = function (a) {
        var c = E[L(d.hoverChartIndex, -1)];
        c && c.pointer.drop(a);
      };
      d.prototype.pinch = function (a) {
        var f = this,
          k = f.chart,
          d = f.pinchDown,
          l = a.touches || [],
          e = l.length,
          g = f.lastValidTouch,
          b = f.hasZoom,
          B = {},
          m = 1 === e && (f.inClass(a.target, "highcharts-tracker") && k.runTrackerClick || f.runChartClick),
          r = {},
          x = f.selectionMarker;
        1 < e ? f.initiated = !0 : 1 === e && this.followTouchMove && (f.initiated = !1);
        b && f.initiated && !m && !1 !== a.cancelable && a.preventDefault();
        [].map.call(l, function (b) {
          return f.normalize(b);
        });
        "touchstart" === a.type ? ([].forEach.call(l, function (b, e) {
          d[e] = {
            chartX: b.chartX,
            chartY: b.chartY
          };
        }), g.x = [d[0].chartX, d[1] && d[1].chartX], g.y = [d[0].chartY, d[1] && d[1].chartY], k.axes.forEach(function (b) {
          if (b.zoomEnabled) {
            var e = k.bounds[b.horiz ? "h" : "v"],
              a = b.minPixelPadding,
              g = b.toPixels(Math.min(L(b.options.min, b.dataMin), b.dataMin)),
              c = b.toPixels(Math.max(L(b.options.max, b.dataMax), b.dataMax)),
              l = Math.max(g, c);
            e.min = Math.min(b.pos, Math.min(g, c) - a);
            e.max = Math.max(b.pos + b.len, l + a);
          }
        }), f.res = !0) : f.followTouchMove && 1 === e ? this.runPointActions(f.normalize(a)) : d.length && (n(k, "touchpan", {
          originalEvent: a
        }, function () {
          x || (f.selectionMarker = x = c({
            destroy: H,
            touch: !0
          }, k.plotBox));
          f.pinchTranslate(d, l, B, x, r, g);
          f.hasPinched = b;
          f.scaleGroups(B, r);
        }), f.res && (f.res = !1, this.reset(!1, 0)));
      };
      d.prototype.pinchTranslate = function (a, c, k, f, l, e) {
        this.zoomHor && this.pinchTranslateDirection(!0, a, c, k, f, l, e);
        this.zoomVert && this.pinchTranslateDirection(!1, a, c, k, f, l, e);
      };
      d.prototype.pinchTranslateDirection = function (a, c, k, f, l, e, g, b) {
        var d = this.chart,
          n = a ? "x" : "y",
          r = a ? "X" : "Y",
          x = "chart" + r,
          m = a ? "width" : "height",
          w = d["plot" + (a ? "Left" : "Top")],
          u = d.inverted,
          p = d.bounds[a ? "h" : "v"],
          h = 1 === c.length,
          v = c[0][x],
          z = !h && c[1][x];
        c = function () {
          "number" === typeof I && 20 < Math.abs(v - z) && (C = b || Math.abs(R - I) / Math.abs(v - z));
          Q = (w - R) / C + v;
          q = d["plot" + (a ? "Width" : "Height")] / C;
        };
        var q,
          Q,
          C = b || 1,
          R = k[0][x],
          I = !h && k[1][x];
        c();
        k = Q;
        if (k < p.min) {
          k = p.min;
          var D = !0;
        } else k + q > p.max && (k = p.max - q, D = !0);
        D ? (R -= .8 * (R - g[n][0]), "number" === typeof I && (I -= .8 * (I - g[n][1])), c()) : g[n] = [R, I];
        u || (e[n] = Q - w, e[m] = q);
        e = u ? 1 / C : C;
        l[m] = q;
        l[n] = k;
        f[u ? a ? "scaleY" : "scaleX" : "scale" + r] = C;
        f["translate" + r] = e * w + (R - e * v);
      };
      d.prototype.reset = function (a, c) {
        var k = this.chart,
          f = k.hoverSeries,
          l = k.hoverPoint,
          e = k.hoverPoints,
          g = k.tooltip,
          b = g && g.shared ? e : l;
        a && b && K(b).forEach(function (b) {
          b.series.isCartesian && "undefined" === typeof b.plotX && (a = !1);
        });
        if (a) g && b && K(b).length && (g.refresh(b), g.shared && e ? e.forEach(function (b) {
          b.setState(b.state, !0);
          b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));
        }) : l && (l.setState(l.state, !0), k.axes.forEach(function (b) {
          b.crosshair && l.series[b.coll] === b && b.drawCrosshair(null, l);
        })));else {
          if (l) l.onMouseOut();
          e && e.forEach(function (b) {
            b.setState();
          });
          if (f) f.onMouseOut();
          g && g.hide(c);
          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
          k.axes.forEach(function (b) {
            b.hideCrosshair();
          });
          this.hoverX = k.hoverPoints = k.hoverPoint = null;
        }
      };
      d.prototype.runPointActions = function (c, f) {
        var k = this.chart,
          n = k.tooltip && k.tooltip.options.enabled ? k.tooltip : void 0,
          l = n ? n.shared : !1,
          e = f || k.hoverPoint,
          g = e && e.series || k.hoverSeries;
        f = this.getHoverData(e, g, k.series, (!c || "touchmove" !== c.type) && (!!f || g && g.directTouch && this.isDirectTouch), l, c);
        e = f.hoverPoint;
        g = f.hoverSeries;
        var b = f.hoverPoints;
        f = g && g.tooltipOptions.followPointer && !g.tooltipOptions.split;
        l = l && g && !g.noSharedTooltip;
        if (e && (e !== k.hoverPoint || n && n.isHidden)) {
          (k.hoverPoints || []).forEach(function (a) {
            -1 === b.indexOf(a) && a.setState();
          });
          if (k.hoverSeries !== g) g.onMouseOver();
          this.applyInactiveState(b);
          (b || []).forEach(function (b) {
            b.setState("hover");
          });
          k.hoverPoint && k.hoverPoint.firePointEvent("mouseOut");
          if (!e.series) return;
          k.hoverPoints = b;
          k.hoverPoint = e;
          e.firePointEvent("mouseOver");
          n && n.refresh(l ? b : e, c);
        } else f && n && !n.isHidden && (e = n.getAnchor([{}], c), k.isInsidePlot(e[0], e[1], {
          visiblePlotOnly: !0
        }) && n.updatePosition({
          plotX: e[0],
          plotY: e[1]
        }));
        this.unDocMouseMove || (this.unDocMouseMove = y(k.container.ownerDocument, "mousemove", function (b) {
          var a = E[d.hoverChartIndex];
          if (a) a.pointer.onDocumentMouseMove(b);
        }), this.eventsToUnbind.push(this.unDocMouseMove));
        k.axes.forEach(function (e) {
          var g = L((e.crosshair || {}).snap, !0),
            l;
          g && ((l = k.hoverPoint) && l.series[e.coll] === e || (l = a(b, function (b) {
            return b.series[e.coll] === e;
          })));
          l || !g ? e.drawCrosshair(c, l) : e.hideCrosshair();
        });
      };
      d.prototype.scaleGroups = function (a, c) {
        var k = this.chart;
        k.series.forEach(function (f) {
          var l = a || f.getPlotBox();
          f.group && (f.xAxis && f.xAxis.zoomEnabled || k.mapView) && (f.group.attr(l), f.markerGroup && (f.markerGroup.attr(l), f.markerGroup.clip(c ? k.clipRect : null)), f.dataLabelsGroup && f.dataLabelsGroup.attr(l));
        });
        k.clipRect.attr(c || k.clipBox);
      };
      d.prototype.setDOMEvents = function () {
        var a = this,
          c = this.chart.container,
          k = c.ownerDocument;
        c.onmousedown = this.onContainerMouseDown.bind(this);
        c.onmousemove = this.onContainerMouseMove.bind(this);
        c.onclick = this.onContainerClick.bind(this);
        this.eventsToUnbind.push(y(c, "mouseenter", this.onContainerMouseEnter.bind(this)));
        this.eventsToUnbind.push(y(c, "mouseleave", this.onContainerMouseLeave.bind(this)));
        d.unbindDocumentMouseUp || (d.unbindDocumentMouseUp = y(k, "mouseup", this.onDocumentMouseUp.bind(this)));
        for (var f = this.chart.renderTo.parentElement; f && "BODY" !== f.tagName;) this.eventsToUnbind.push(y(f, "scroll", function () {
          delete a.chartPosition;
        })), f = f.parentElement;
        h.hasTouch && (this.eventsToUnbind.push(y(c, "touchstart", this.onContainerTouchStart.bind(this), {
          passive: !1
        })), this.eventsToUnbind.push(y(c, "touchmove", this.onContainerTouchMove.bind(this), {
          passive: !1
        })), d.unbindDocumentTouchEnd || (d.unbindDocumentTouchEnd = y(k, "touchend", this.onDocumentTouchEnd.bind(this), {
          passive: !1
        })));
      };
      d.prototype.setHoverChartIndex = function () {
        var a = this.chart,
          c = h.charts[L(d.hoverChartIndex, -1)];
        if (c && c !== a) c.pointer.onContainerMouseLeave({
          relatedTarget: !0
        });
        c && c.mouseIsDown || (d.hoverChartIndex = a.index);
      };
      d.prototype.touch = function (a, c) {
        var k = this.chart,
          f;
        this.setHoverChartIndex();
        if (1 === a.touches.length) {
          if (a = this.normalize(a), (f = k.isInsidePlot(a.chartX - k.plotLeft, a.chartY - k.plotTop, {
            visiblePlotOnly: !0
          })) && !k.openMenu) {
            c && this.runPointActions(a);
            if ("touchmove" === a.type) {
              c = this.pinchDown;
              var l = c[0] ? 4 <= Math.sqrt(Math.pow(c[0].chartX - a.chartX, 2) + Math.pow(c[0].chartY - a.chartY, 2)) : !1;
            }
            L(l, !0) && this.pinch(a);
          } else c && this.reset();
        } else 2 === a.touches.length && this.pinch(a);
      };
      d.prototype.touchSelect = function (a) {
        return !(!this.chart.options.chart.zoomBySingleTouch || !a.touches || 1 !== a.touches.length);
      };
      d.prototype.zoomOption = function (a) {
        var c = this.chart,
          k = c.options.chart;
        c = c.inverted;
        var f = k.zoomType || "";
        /touch/.test(a.type) && (f = L(k.pinchType, f));
        this.zoomX = a = /x/.test(f);
        this.zoomY = k = /y/.test(f);
        this.zoomHor = a && !c || k && c;
        this.zoomVert = k && !c || a && c;
        this.hasZoom = a || k;
      };
      return d;
    }();
    "";
    return d;
  });
  N(h, "Core/MSPointer.js", [h["Core/Globals.js"], h["Core/Pointer.js"], h["Core/Utilities.js"]], function (d, h, A) {
    function E() {
      var c = [];
      c.item = function (a) {
        return this[a];
      };
      a(m, function (a) {
        c.push({
          pageX: a.pageX,
          pageY: a.pageY,
          target: a.target
        });
      });
      return c;
    }
    function t(a, c, f, d) {
      var n = H[h.hoverChartIndex || NaN];
      "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !n || (n = n.pointer, d(a), n[c]({
        type: f,
        target: a.currentTarget,
        preventDefault: q,
        touches: E()
      }));
    }
    var G = this && this.__extends || function () {
        var a = function (c, f) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);
          };
          return a(c, f);
        };
        return function (c, f) {
          function d() {
            this.constructor = c;
          }
          a(c, f);
          c.prototype = null === f ? Object.create(f) : (d.prototype = f.prototype, new d());
        };
      }(),
      H = d.charts,
      y = d.doc,
      q = d.noop,
      p = d.win,
      f = A.addEvent,
      c = A.css,
      a = A.objectEach,
      n = A.removeEvent,
      m = {},
      D = !!p.PointerEvent;
    return function (a) {
      function h() {
        return null !== a && a.apply(this, arguments) || this;
      }
      G(h, a);
      h.isRequired = function () {
        return !(d.hasTouch || !p.PointerEvent && !p.MSPointerEvent);
      };
      h.prototype.batchMSEvents = function (a) {
        a(this.chart.container, D ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
        a(this.chart.container, D ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
        a(y, D ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
      };
      h.prototype.destroy = function () {
        this.batchMSEvents(n);
        a.prototype.destroy.call(this);
      };
      h.prototype.init = function (f, d) {
        a.prototype.init.call(this, f, d);
        this.hasZoom && c(f.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      };
      h.prototype.onContainerPointerDown = function (a) {
        t(a, "onContainerTouchStart", "touchstart", function (a) {
          m[a.pointerId] = {
            pageX: a.pageX,
            pageY: a.pageY,
            target: a.currentTarget
          };
        });
      };
      h.prototype.onContainerPointerMove = function (a) {
        t(a, "onContainerTouchMove", "touchmove", function (a) {
          m[a.pointerId] = {
            pageX: a.pageX,
            pageY: a.pageY
          };
          m[a.pointerId].target || (m[a.pointerId].target = a.currentTarget);
        });
      };
      h.prototype.onDocumentPointerUp = function (a) {
        t(a, "onDocumentTouchEnd", "touchend", function (a) {
          delete m[a.pointerId];
        });
      };
      h.prototype.setDOMEvents = function () {
        a.prototype.setDOMEvents.call(this);
        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(f);
      };
      return h;
    }(h);
  });
  N(h, "Core/Legend/Legend.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/FormatUtilities.js"], h["Core/Globals.js"], h["Core/Series/Point.js"], h["Core/Renderer/RendererUtilities.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G) {
    var E = d.animObject,
      y = d.setAnimation,
      q = h.format;
    d = A.isFirefox;
    var p = A.marginNames;
    A = A.win;
    var f = t.distribute,
      c = G.addEvent,
      a = G.createElement,
      n = G.css,
      m = G.defined,
      D = G.discardElement,
      C = G.find,
      I = G.fireEvent,
      L = G.isNumber,
      K = G.merge,
      v = G.pick,
      z = G.relativeLength,
      u = G.stableSort,
      k = G.syncTimeout;
    t = G.wrap;
    G = function () {
      function d(a, e) {
        this.allItems = [];
        this.contentGroup = this.box = void 0;
        this.display = !1;
        this.group = void 0;
        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
        this.options = {};
        this.padding = 0;
        this.pages = [];
        this.proximate = !1;
        this.scrollGroup = void 0;
        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
        this.chart = a;
        this.init(a, e);
      }
      d.prototype.init = function (a, e) {
        this.chart = a;
        this.setOptions(e);
        e.enabled && (this.render(), c(this.chart, "endResize", function () {
          this.legend.positionCheckboxes();
        }), this.proximate ? this.unchartrender = c(this.chart, "render", function () {
          this.legend.proximatePositions();
          this.legend.positionItems();
        }) : this.unchartrender && this.unchartrender());
      };
      d.prototype.setOptions = function (a) {
        var e = v(a.padding, 8);
        this.options = a;
        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = K(this.itemStyle, a.itemHiddenStyle));
        this.itemMarginTop = a.itemMarginTop || 0;
        this.itemMarginBottom = a.itemMarginBottom || 0;
        this.padding = e;
        this.initialItemY = e - 5;
        this.symbolWidth = v(a.symbolWidth, 16);
        this.pages = [];
        this.proximate = "proximate" === a.layout && !this.chart.inverted;
        this.baseline = void 0;
      };
      d.prototype.update = function (a, e) {
        var g = this.chart;
        this.setOptions(K(!0, this.options, a));
        this.destroy();
        g.isDirtyLegend = g.isDirtyBox = !0;
        v(e, !0) && g.redraw();
        I(this, "afterUpdate");
      };
      d.prototype.colorizeItem = function (a, e) {
        a.legendGroup[e ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
        if (!this.chart.styledMode) {
          var g = this.options,
            b = a.legendItem,
            c = a.legendLine,
            l = a.legendSymbol,
            k = this.itemHiddenStyle.color;
          g = e ? g.itemStyle.color : k;
          var f = e ? a.color || k : k,
            d = a.options && a.options.marker,
            n = {
              fill: f
            };
          b && b.css({
            fill: g,
            color: g
          });
          c && c.attr({
            stroke: f
          });
          l && (d && l.isMarker && (n = a.pointAttribs(), e || (n.stroke = n.fill = k)), l.attr(n));
        }
        I(this, "afterColorizeItem", {
          item: a,
          visible: e
        });
      };
      d.prototype.positionItems = function () {
        this.allItems.forEach(this.positionItem, this);
        this.chart.isResizing || this.positionCheckboxes();
      };
      d.prototype.positionItem = function (a) {
        var e = this,
          g = this.options,
          b = g.symbolPadding,
          c = !g.rtl,
          l = a._legendItemPos;
        g = l[0];
        l = l[1];
        var k = a.checkbox,
          f = a.legendGroup;
        f && f.element && (b = {
          translateX: c ? g : this.legendWidth - g - 2 * b - 4,
          translateY: l
        }, c = function () {
          I(e, "afterPositionItem", {
            item: a
          });
        }, m(f.translateY) ? f.animate(b, void 0, c) : (f.attr(b), c()));
        k && (k.x = g, k.y = l);
      };
      d.prototype.destroyItem = function (a) {
        var e = a.checkbox;
        ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (e) {
          a[e] && (a[e] = a[e].destroy());
        });
        e && D(a.checkbox);
      };
      d.prototype.destroy = function () {
        function a(a) {
          this[a] && (this[a] = this[a].destroy());
        }
        this.getAllItems().forEach(function (e) {
          ["legendItem", "legendGroup"].forEach(a, e);
        });
        "clipRect up down pager nav box title group".split(" ").forEach(a, this);
        this.display = null;
      };
      d.prototype.positionCheckboxes = function () {
        var a = this.group && this.group.alignAttr,
          e = this.clipHeight || this.legendHeight,
          g = this.titleHeight;
        if (a) {
          var b = a.translateY;
          this.allItems.forEach(function (c) {
            var l = c.checkbox;
            if (l) {
              var k = b + g + l.y + (this.scrollOffset || 0) + 3;
              n(l, {
                left: a.translateX + c.checkboxOffset + l.x - 20 + "px",
                top: k + "px",
                display: this.proximate || k > b - 6 && k < b + e - 6 ? "" : "none"
              });
            }
          }, this);
        }
      };
      d.prototype.renderTitle = function () {
        var a = this.options,
          e = this.padding,
          g = a.title,
          b = 0;
        g.text && (this.title || (this.title = this.chart.renderer.label(g.text, e - 3, e - 4, null, null, null, a.useHTML, null, "legend-title").attr({
          zIndex: 1
        }), this.chart.styledMode || this.title.css(g.style), this.title.add(this.group)), g.width || this.title.css({
          width: this.maxLegendWidth + "px"
        }), a = this.title.getBBox(), b = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
          translateY: b
        }));
        this.titleHeight = b;
      };
      d.prototype.setText = function (a) {
        var e = this.options;
        a.legendItem.attr({
          text: e.labelFormat ? q(e.labelFormat, a, this.chart) : e.labelFormatter.call(a)
        });
      };
      d.prototype.renderItem = function (a) {
        var e = this.chart,
          g = e.renderer,
          b = this.options,
          c = this.symbolWidth,
          k = b.symbolPadding || 0,
          l = this.itemStyle,
          f = this.itemHiddenStyle,
          d = "horizontal" === b.layout ? v(b.itemDistance, 20) : 0,
          n = !b.rtl,
          m = !a.series,
          p = !m && a.series.drawLegendSymbol ? a.series : a,
          h = p.options,
          u = this.createCheckboxForItem && h && h.showCheckbox,
          w = b.useHTML,
          q = a.options.className,
          Q = a.legendItem;
        h = c + k + d + (u ? 20 : 0);
        Q || (a.legendGroup = g.g("legend-item").addClass("highcharts-" + p.type + "-series highcharts-color-" + a.colorIndex + (q ? " " + q : "") + (m ? " highcharts-series-" + a.index : "")).attr({
          zIndex: 1
        }).add(this.scrollGroup), a.legendItem = Q = g.text("", n ? c + k : -k, this.baseline || 0, w), e.styledMode || Q.css(K(a.visible ? l : f)), Q.attr({
          align: n ? "left" : "right",
          zIndex: 2
        }).add(a.legendGroup), this.baseline || (this.fontMetrics = g.fontMetrics(e.styledMode ? 12 : l.fontSize, Q), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, Q.attr("y", this.baseline), this.symbolHeight = b.symbolHeight || this.fontMetrics.f, b.squareSymbol && (this.symbolWidth = v(b.symbolWidth, Math.max(this.symbolHeight, 16)), h = this.symbolWidth + k + d + (u ? 20 : 0), n && Q.attr("x", this.symbolWidth + k))), p.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, Q, w));
        u && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);
        this.colorizeItem(a, a.visible);
        !e.styledMode && l.width || Q.css({
          width: (b.itemWidth || this.widthOption || e.spacingBox.width) - h + "px"
        });
        this.setText(a);
        e = Q.getBBox();
        g = this.fontMetrics && this.fontMetrics.h || 0;
        a.itemWidth = a.checkboxOffset = b.itemWidth || a.legendItemWidth || e.width + h;
        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);
        this.totalItemWidth += a.itemWidth;
        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || (e.height > 1.5 * g ? e.height : g));
      };
      d.prototype.layoutItem = function (a) {
        var e = this.options,
          g = this.padding,
          b = "horizontal" === e.layout,
          c = a.itemHeight,
          k = this.itemMarginBottom,
          l = this.itemMarginTop,
          f = b ? v(e.itemDistance, 20) : 0,
          d = this.maxLegendWidth;
        e = e.alignColumns && this.totalItemWidth > d ? this.maxItemWidth : a.itemWidth;
        b && this.itemX - g + e > d && (this.itemX = g, this.lastLineHeight && (this.itemY += l + this.lastLineHeight + k), this.lastLineHeight = 0);
        this.lastItemY = l + this.itemY + k;
        this.lastLineHeight = Math.max(c, this.lastLineHeight);
        a._legendItemPos = [this.itemX, this.itemY];
        b ? this.itemX += e : (this.itemY += l + c + k, this.lastLineHeight = c);
        this.offsetWidth = this.widthOption || Math.max((b ? this.itemX - g - (a.checkbox ? 0 : f) : e) + g, this.offsetWidth);
      };
      d.prototype.getAllItems = function () {
        var a = [];
        this.chart.series.forEach(function (e) {
          var g = e && e.options;
          e && v(g.showInLegend, m(g.linkedTo) ? !1 : void 0, !0) && (a = a.concat(e.legendItems || ("point" === g.legendType ? e.data : e)));
        });
        I(this, "afterGetAllItems", {
          allItems: a
        });
        return a;
      };
      d.prototype.getAlignment = function () {
        var a = this.options;
        return this.proximate ? a.align.charAt(0) + "tv" : a.floating ? "" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);
      };
      d.prototype.adjustMargins = function (a, e) {
        var g = this.chart,
          b = this.options,
          c = this.getAlignment();
        c && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (k, l) {
          k.test(c) && !m(a[l]) && (g[p[l]] = Math.max(g[p[l]], g.legend[(l + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][l] * b[l % 2 ? "x" : "y"] + v(b.margin, 12) + e[l] + (g.titleOffset[l] || 0)));
        });
      };
      d.prototype.proximatePositions = function () {
        var a = this.chart,
          e = [],
          g = "left" === this.options.align;
        this.allItems.forEach(function (b) {
          var c;
          var k = g;
          if (b.yAxis) {
            b.xAxis.options.reversed && (k = !k);
            b.points && (c = C(k ? b.points : b.points.slice(0).reverse(), function (b) {
              return L(b.plotY);
            }));
            k = this.itemMarginTop + b.legendItem.getBBox().height + this.itemMarginBottom;
            var l = b.yAxis.top - a.plotTop;
            b.visible ? (c = c ? c.plotY : b.yAxis.height, c += l - .3 * k) : c = l + b.yAxis.height;
            e.push({
              target: c,
              size: k,
              item: b
            });
          }
        }, this);
        f(e, a.plotHeight).forEach(function (b) {
          b.item._legendItemPos && (b.item._legendItemPos[1] = a.plotTop - a.spacing[0] + b.pos);
        });
      };
      d.prototype.render = function () {
        var a = this.chart,
          e = a.renderer,
          g = this.options,
          b = this.padding,
          c = this.getAllItems(),
          k = this.group,
          f = this.box;
        this.itemX = b;
        this.itemY = this.initialItemY;
        this.lastItemY = this.offsetWidth = 0;
        this.widthOption = z(g.width, a.spacingBox.width - b);
        var d = a.spacingBox.width - 2 * b - g.x;
        -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (d /= 2);
        this.maxLegendWidth = this.widthOption || d;
        k || (this.group = k = e.g("legend").addClass(g.className || "").attr({
          zIndex: 7
        }).add(), this.contentGroup = e.g().attr({
          zIndex: 1
        }).add(k), this.scrollGroup = e.g().add(this.contentGroup));
        this.renderTitle();
        u(c, function (b, a) {
          return (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0);
        });
        g.reversed && c.reverse();
        this.allItems = c;
        this.display = d = !!c.length;
        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
        c.forEach(this.renderItem, this);
        c.forEach(this.layoutItem, this);
        c = (this.widthOption || this.offsetWidth) + b;
        var n = this.lastItemY + this.lastLineHeight + this.titleHeight;
        n = this.handleOverflow(n);
        n += b;
        f || (this.box = f = e.rect().addClass("highcharts-legend-box").attr({
          r: g.borderRadius
        }).add(k), f.isNew = !0);
        a.styledMode || f.attr({
          stroke: g.borderColor,
          "stroke-width": g.borderWidth || 0,
          fill: g.backgroundColor || "none"
        }).shadow(g.shadow);
        0 < c && 0 < n && (f[f.isNew ? "attr" : "animate"](f.crisp.call({}, {
          x: 0,
          y: 0,
          width: c,
          height: n
        }, f.strokeWidth())), f.isNew = !1);
        f[d ? "show" : "hide"]();
        a.styledMode && "none" === k.getStyle("display") && (c = n = 0);
        this.legendWidth = c;
        this.legendHeight = n;
        d && this.align();
        this.proximate || this.positionItems();
        I(this, "afterRender");
      };
      d.prototype.align = function (a) {
        void 0 === a && (a = this.chart.spacingBox);
        var e = this.chart,
          g = this.options,
          b = a.y;
        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < e.titleOffset[0] ? b += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < e.titleOffset[2] && (b -= e.titleOffset[2]);
        b !== a.y && (a = K(a, {
          y: b
        }));
        this.group.align(K(g, {
          width: this.legendWidth,
          height: this.legendHeight,
          verticalAlign: this.proximate ? "top" : g.verticalAlign
        }), !0, a);
      };
      d.prototype.handleOverflow = function (a) {
        var e = this,
          g = this.chart,
          b = g.renderer,
          c = this.options,
          k = c.y,
          f = "top" === c.verticalAlign,
          l = this.padding,
          d = c.maxHeight,
          n = c.navigation,
          m = v(n.animation, !0),
          p = n.arrowSize || 12,
          h = this.pages,
          u = this.allItems,
          w = function (b) {
            "number" === typeof b ? C.attr({
              height: b
            }) : C && (e.clipRect = C.destroy(), e.contentGroup.clip());
            e.contentGroup.div && (e.contentGroup.div.style.clip = b ? "rect(" + l + "px,9999px," + (l + b) + "px,0)" : "auto");
          },
          q = function (a) {
            e[a] = b.circle(0, 0, 1.3 * p).translate(p / 2, p / 2).add(R);
            g.styledMode || e[a].attr("fill", "rgba(0,0,0,0.0001)");
            return e[a];
          },
          Q,
          z;
        k = g.spacingBox.height + (f ? -k : k) - l;
        var R = this.nav,
          C = this.clipRect;
        "horizontal" !== c.layout || "middle" === c.verticalAlign || c.floating || (k /= 2);
        d && (k = Math.min(k, d));
        h.length = 0;
        a && 0 < k && a > k && !1 !== n.enabled ? (this.clipHeight = Q = Math.max(k - 20 - this.titleHeight - l, 0), this.currentPage = v(this.currentPage, 1), this.fullHeight = a, u.forEach(function (b, a) {
          var e = b._legendItemPos[1],
            g = Math.round(b.legendItem.getBBox().height),
            c = h.length;
          if (!c || e - h[c - 1] > Q && (z || e) !== h[c - 1]) h.push(z || e), c++;
          b.pageIx = c - 1;
          z && (u[a - 1].pageIx = c - 1);
          a === u.length - 1 && e + g - h[c - 1] > Q && g <= Q && (h.push(e), b.pageIx = c);
          e !== z && (z = e);
        }), C || (C = e.clipRect = b.clipRect(0, l, 9999, 0), e.contentGroup.clip(C)), w(Q), R || (this.nav = R = b.g().attr({
          zIndex: 1
        }).add(this.group), this.up = b.symbol("triangle", 0, 0, p, p).add(R), q("upTracker").on("click", function () {
          e.scroll(-1, m);
        }), this.pager = b.text("", 15, 10).addClass("highcharts-legend-navigation"), g.styledMode || this.pager.css(n.style), this.pager.add(R), this.down = b.symbol("triangle-down", 0, 0, p, p).add(R), q("downTracker").on("click", function () {
          e.scroll(1, m);
        })), e.scroll(0), a = k) : R && (w(), this.nav = R.destroy(), this.scrollGroup.attr({
          translateY: 1
        }), this.clipHeight = 0);
        return a;
      };
      d.prototype.scroll = function (a, e) {
        var g = this,
          b = this.chart,
          c = this.pages,
          f = c.length,
          l = this.clipHeight,
          d = this.options.navigation,
          n = this.pager,
          m = this.padding,
          p = this.currentPage + a;
        p > f && (p = f);
        0 < p && ("undefined" !== typeof e && y(e, b), this.nav.attr({
          translateX: m,
          translateY: l + this.padding + 7 + this.titleHeight,
          visibility: "visible"
        }), [this.up, this.upTracker].forEach(function (b) {
          b.attr({
            "class": 1 === p ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }), n.attr({
          text: p + "/" + f
        }), [this.down, this.downTracker].forEach(function (b) {
          b.attr({
            x: 18 + this.pager.getBBox().width,
            "class": p === f ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }, this), b.styledMode || (this.up.attr({
          fill: 1 === p ? d.inactiveColor : d.activeColor
        }), this.upTracker.css({
          cursor: 1 === p ? "default" : "pointer"
        }), this.down.attr({
          fill: p === f ? d.inactiveColor : d.activeColor
        }), this.downTracker.css({
          cursor: p === f ? "default" : "pointer"
        })), this.scrollOffset = -c[p - 1] + this.initialItemY, this.scrollGroup.animate({
          translateY: this.scrollOffset
        }), this.currentPage = p, this.positionCheckboxes(), a = E(v(e, b.renderer.globalAnimation, !0)), k(function () {
          I(g, "afterScroll", {
            currentPage: p
          });
        }, a.duration));
      };
      d.prototype.setItemEvents = function (a, e, g) {
        var b = this,
          c = b.chart.renderer.boxWrapper,
          k = a instanceof F,
          f = "highcharts-legend-" + (k ? "point" : "series") + "-active",
          l = b.chart.styledMode,
          d = function (e) {
            b.allItems.forEach(function (b) {
              a !== b && [b].concat(b.linkedSeries || []).forEach(function (b) {
                b.setState(e, !k);
              });
            });
          };
        (g ? [e, a.legendSymbol] : [a.legendGroup]).forEach(function (g) {
          if (g) g.on("mouseover", function () {
            a.visible && d("inactive");
            a.setState("hover");
            a.visible && c.addClass(f);
            l || e.css(b.options.itemHoverStyle);
          }).on("mouseout", function () {
            b.chart.styledMode || e.css(K(a.visible ? b.itemStyle : b.itemHiddenStyle));
            d("");
            c.removeClass(f);
            a.setState();
          }).on("click", function (b) {
            var e = function () {
              a.setVisible && a.setVisible();
              d(a.visible ? "inactive" : "");
            };
            c.removeClass(f);
            b = {
              browserEvent: b
            };
            a.firePointEvent ? a.firePointEvent("legendItemClick", b, e) : I(a, "legendItemClick", b, e);
          });
        });
      };
      d.prototype.createCheckboxForItem = function (k) {
        k.checkbox = a("input", {
          type: "checkbox",
          className: "highcharts-legend-checkbox",
          checked: k.selected,
          defaultChecked: k.selected
        }, this.options.itemCheckboxStyle, this.chart.container);
        c(k.checkbox, "click", function (a) {
          I(k.series || k, "checkboxClick", {
            checked: a.target.checked,
            item: k
          }, function () {
            k.select();
          });
        });
      };
      return d;
    }();
    (/Trident\/7\.0/.test(A.navigator && A.navigator.userAgent) || d) && t(G.prototype, "positionItem", function (a, c) {
      var e = this,
        g = function () {
          c._legendItemPos && a.call(e, c);
        };
      g();
      e.bubbleLegend || setTimeout(g);
    });
    "";
    return G;
  });
  N(h, "Core/Series/SeriesRegistry.js", [h["Core/Globals.js"], h["Core/DefaultOptions.js"], h["Core/Series/Point.js"], h["Core/Utilities.js"]], function (d, h, A, F) {
    var t = h.defaultOptions,
      E = F.error,
      H = F.extendClass,
      y = F.merge,
      q;
    (function (p) {
      function f(c, a) {
        var f = t.plotOptions || {},
          d = a.defaultOptions;
        a.prototype.pointClass || (a.prototype.pointClass = A);
        a.prototype.type = c;
        d && (f[c] = d);
        p.seriesTypes[c] = a;
      }
      p.seriesTypes = d.seriesTypes;
      p.getSeries = function (c, a) {
        void 0 === a && (a = {});
        var f = c.options.chart;
        f = a.type || f.type || f.defaultSeriesType || "";
        var d = p.seriesTypes[f];
        p || E(17, !0, c, {
          missingModuleFor: f
        });
        f = new d();
        "function" === typeof f.init && f.init(c, a);
        return f;
      };
      p.registerSeriesType = f;
      p.seriesType = function (c, a, d, m, h) {
        var n = t.plotOptions || {};
        a = a || "";
        n[c] = y(n[a], d);
        f(c, H(p.seriesTypes[a] || function () {}, m));
        p.seriesTypes[c].prototype.type = c;
        h && (p.seriesTypes[c].prototype.pointClass = H(A, h));
        return p.seriesTypes[c];
      };
    })(q || (q = {}));
    return q;
  });
  N(h, "Core/Chart/Chart.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/Axis/Axis.js"], h["Core/FormatUtilities.js"], h["Core/Foundation.js"], h["Core/Globals.js"], h["Core/Legend/Legend.js"], h["Core/MSPointer.js"], h["Core/DefaultOptions.js"], h["Core/Pointer.js"], h["Core/Renderer/RendererRegistry.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Renderer/SVG/SVGRenderer.js"], h["Core/Time.js"], h["Core/Utilities.js"], h["Core/Renderer/HTML/AST.js"]], function (d, h, A, F, t, G, H, y, q, p, f, c, a, n, m) {
    var D = d.animate,
      C = d.animObject,
      I = d.setAnimation,
      L = A.numberFormat,
      K = F.registerEventOptions,
      v = t.charts,
      z = t.doc,
      u = t.marginNames,
      k = t.svg,
      w = t.win,
      l = y.defaultOptions,
      e = y.defaultTime,
      g = f.seriesTypes,
      b = n.addEvent,
      B = n.attr,
      J = n.cleanRecursively,
      r = n.createElement,
      x = n.css,
      M = n.defined,
      X = n.discardElement,
      P = n.erase,
      O = n.error,
      W = n.extend,
      Z = n.find,
      E = n.fireEvent,
      aa = n.getStyle,
      Q = n.isArray,
      ba = n.isNumber,
      R = n.isObject,
      ca = n.isString,
      T = n.merge,
      U = n.objectEach,
      S = n.pick,
      da = n.pInt,
      ia = n.relativeLength,
      N = n.removeEvent,
      fa = n.splat,
      Y = n.syncTimeout,
      ja = n.uniqueKey;
    d = function () {
      function f(b, a, e) {
        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
        this.sharedClips = {};
        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
        this.getArgs(b, a, e);
      }
      f.chart = function (b, a, e) {
        return new f(b, a, e);
      };
      f.prototype.getArgs = function (b, a, e) {
        ca(b) || b.nodeName ? (this.renderTo = b, this.init(a, e)) : this.init(b, a);
      };
      f.prototype.init = function (b, e) {
        var g = b.plotOptions || {};
        E(this, "init", {
          args: arguments
        }, function () {
          var c = T(l, b),
            f = c.chart;
          U(c.plotOptions, function (b, a) {
            R(b) && (b.tooltip = g[a] && T(g[a].tooltip) || void 0);
          });
          c.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
          this.userOptions = b;
          this.margin = [];
          this.spacing = [];
          this.bounds = {
            h: {},
            v: {}
          };
          this.labelCollectors = [];
          this.callback = e;
          this.isResizing = 0;
          this.options = c;
          this.axes = [];
          this.series = [];
          this.time = b.time && Object.keys(b.time).length ? new a(b.time) : t.time;
          this.numberFormatter = f.numberFormatter || L;
          this.styledMode = f.styledMode;
          this.hasCartesianSeries = f.showAxes;
          this.index = v.length;
          v.push(this);
          t.chartCount++;
          K(this, f);
          this.xAxis = [];
          this.yAxis = [];
          this.pointCount = this.colorCounter = this.symbolCounter = 0;
          E(this, "afterInit");
          this.firstRender();
        });
      };
      f.prototype.initSeries = function (b) {
        var a = this.options.chart;
        a = b.type || a.type || a.defaultSeriesType;
        var e = g[a];
        e || O(17, !0, this, {
          missingModuleFor: a
        });
        a = new e();
        "function" === typeof a.init && a.init(this, b);
        return a;
      };
      f.prototype.setSeriesData = function () {
        this.getSeriesOrderByLinks().forEach(function (b) {
          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
        });
      };
      f.prototype.getSeriesOrderByLinks = function () {
        return this.series.concat().sort(function (b, a) {
          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;
        });
      };
      f.prototype.orderSeries = function (b) {
        var a = this.series;
        b = b || 0;
        for (var e = a.length; b < e; ++b) a[b] && (a[b].index = b, a[b].name = a[b].getName());
      };
      f.prototype.isInsidePlot = function (b, a, e) {
        void 0 === e && (e = {});
        var g = this.inverted,
          c = this.plotBox,
          f = this.plotLeft,
          k = this.plotTop,
          l = this.scrollablePlotBox,
          d = 0;
        var r = 0;
        e.visiblePlotOnly && this.scrollingContainer && (r = this.scrollingContainer, d = r.scrollLeft, r = r.scrollTop);
        var x = e.series;
        c = e.visiblePlotOnly && l || c;
        l = e.inverted ? a : b;
        a = e.inverted ? b : a;
        b = {
          x: l,
          y: a,
          isInsidePlot: !0
        };
        if (!e.ignoreX) {
          var n = x && (g ? x.yAxis : x.xAxis) || {
            pos: f,
            len: Infinity
          };
          l = e.paneCoordinates ? n.pos + l : f + l;
          l >= Math.max(d + f, n.pos) && l <= Math.min(d + f + c.width, n.pos + n.len) || (b.isInsidePlot = !1);
        }
        !e.ignoreY && b.isInsidePlot && (g = x && (g ? x.xAxis : x.yAxis) || {
          pos: k,
          len: Infinity
        }, e = e.paneCoordinates ? g.pos + a : k + a, e >= Math.max(r + k, g.pos) && e <= Math.min(r + k + c.height, g.pos + g.len) || (b.isInsidePlot = !1));
        E(this, "afterIsInsidePlot", b);
        return b.isInsidePlot;
      };
      f.prototype.redraw = function (b) {
        E(this, "beforeRedraw");
        var a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
          e = this.series,
          g = this.pointer,
          c = this.legend,
          f = this.userOptions.legend,
          k = this.renderer,
          l = k.isHidden(),
          d = [],
          r = this.isDirtyBox,
          x = this.isDirtyLegend;
        this.setResponsive && this.setResponsive(!1);
        I(this.hasRendered ? b : !1, this);
        l && this.temporaryDisplay();
        this.layOutTitles();
        for (b = e.length; b--;) {
          var n = e[b];
          if (n.options.stacking || n.options.centerInCategory) {
            var m = !0;
            if (n.isDirty) {
              var p = !0;
              break;
            }
          }
        }
        if (p) for (b = e.length; b--;) n = e[b], n.options.stacking && (n.isDirty = !0);
        e.forEach(function (b) {
          b.isDirty && ("point" === b.options.legendType ? ("function" === typeof b.updateTotals && b.updateTotals(), x = !0) : f && (f.labelFormatter || f.labelFormat) && (x = !0));
          b.isDirtyData && E(b, "updatedData");
        });
        x && c && c.options.enabled && (c.render(), this.isDirtyLegend = !1);
        m && this.getStacks();
        a.forEach(function (b) {
          b.updateNames();
          b.setScale();
        });
        this.getMargins();
        a.forEach(function (b) {
          b.isDirty && (r = !0);
        });
        a.forEach(function (b) {
          var a = b.min + "," + b.max;
          b.extKey !== a && (b.extKey = a, d.push(function () {
            E(b, "afterSetExtremes", W(b.eventArgs, b.getExtremes()));
            delete b.eventArgs;
          }));
          (r || m) && b.redraw();
        });
        r && this.drawChartBox();
        E(this, "predraw");
        e.forEach(function (b) {
          (r || b.isDirty) && b.visible && b.redraw();
          b.isDirtyData = !1;
        });
        g && g.reset(!0);
        k.draw();
        E(this, "redraw");
        E(this, "render");
        l && this.temporaryDisplay(!0);
        d.forEach(function (b) {
          b.call();
        });
      };
      f.prototype.get = function (b) {
        function a(a) {
          return a.id === b || a.options && a.options.id === b;
        }
        for (var e = this.series, g = Z(this.axes, a) || Z(this.series, a), c = 0; !g && c < e.length; c++) g = Z(e[c].points || [], a);
        return g;
      };
      f.prototype.getAxes = function () {
        var b = this,
          a = this.options,
          e = a.xAxis = fa(a.xAxis || {});
        a = a.yAxis = fa(a.yAxis || {});
        E(this, "getAxes");
        e.forEach(function (b, a) {
          b.index = a;
          b.isX = !0;
        });
        a.forEach(function (b, a) {
          b.index = a;
        });
        e.concat(a).forEach(function (a) {
          new h(b, a);
        });
        E(this, "afterGetAxes");
      };
      f.prototype.getSelectedPoints = function () {
        return this.series.reduce(function (b, a) {
          a.getPointsCollection().forEach(function (a) {
            S(a.selectedStaging, a.selected) && b.push(a);
          });
          return b;
        }, []);
      };
      f.prototype.getSelectedSeries = function () {
        return this.series.filter(function (b) {
          return b.selected;
        });
      };
      f.prototype.setTitle = function (b, a, e) {
        this.applyDescription("title", b);
        this.applyDescription("subtitle", a);
        this.applyDescription("caption", void 0);
        this.layOutTitles(e);
      };
      f.prototype.applyDescription = function (b, a) {
        var e = this,
          g = "title" === b ? {
            color: "#333333",
            fontSize: this.options.isStock ? "16px" : "18px"
          } : {
            color: "#666666"
          };
        g = this.options[b] = T(!this.styledMode && {
          style: g
        }, this.options[b], a);
        var c = this[b];
        c && a && (this[b] = c = c.destroy());
        g && !c && (c = this.renderer.text(g.text, 0, 0, g.useHTML).attr({
          align: g.align,
          "class": "highcharts-" + b,
          zIndex: g.zIndex || 4
        }).add(), c.update = function (a) {
          e[{
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }[b]](a);
        }, this.styledMode || c.css(g.style), this[b] = c);
      };
      f.prototype.layOutTitles = function (b) {
        var a = [0, 0, 0],
          e = this.renderer,
          g = this.spacingBox;
        ["title", "subtitle", "caption"].forEach(function (b) {
          var c = this[b],
            f = this.options[b],
            k = f.verticalAlign || "top";
          b = "title" === b ? "top" === k ? -3 : 0 : "top" === k ? a[0] + 2 : 0;
          var l;
          if (c) {
            this.styledMode || (l = f.style && f.style.fontSize);
            l = e.fontMetrics(l, c).b;
            c.css({
              width: (f.width || g.width + (f.widthAdjust || 0)) + "px"
            });
            var d = Math.round(c.getBBox(f.useHTML).height);
            c.align(W({
              y: "bottom" === k ? l : b + l,
              height: d
            }, f), !1, "spacingBox");
            f.floating || ("top" === k ? a[0] = Math.ceil(a[0] + d) : "bottom" === k && (a[2] = Math.ceil(a[2] + d)));
          }
        }, this);
        a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
        a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
        var c = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
        this.titleOffset = a;
        E(this, "afterLayOutTitles");
        !this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && S(b, !0) && this.isDirtyBox && this.redraw());
      };
      f.prototype.getChartSize = function () {
        var b = this.options.chart,
          a = b.width;
        b = b.height;
        var e = this.renderTo;
        M(a) || (this.containerWidth = aa(e, "width"));
        M(b) || (this.containerHeight = aa(e, "height"));
        this.chartWidth = Math.max(0, a || this.containerWidth || 600);
        this.chartHeight = Math.max(0, ia(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
      };
      f.prototype.temporaryDisplay = function (b) {
        var a = this.renderTo;
        if (b) for (; a && a.style;) a.hcOrigStyle && (x(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (z.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {
          z.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, z.body.appendChild(a));
          if ("none" === aa(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
            display: a.style.display,
            height: a.style.height,
            overflow: a.style.overflow
          }, b = {
            display: "block",
            overflow: "hidden"
          }, a !== this.renderTo && (b.height = 0), x(a, b), a.offsetWidth || a.style.setProperty("display", "block", "important");
          a = a.parentNode;
          if (a === z.body) break;
        }
      };
      f.prototype.setClassName = function (b) {
        this.container.className = "highcharts-container " + (b || "");
      };
      f.prototype.getContainer = function () {
        var b = this.options,
          a = b.chart,
          e = ja(),
          g,
          f = this.renderTo;
        f || (this.renderTo = f = a.renderTo);
        ca(f) && (this.renderTo = f = z.getElementById(f));
        f || O(13, !0, this);
        var l = da(B(f, "data-highcharts-chart"));
        ba(l) && v[l] && v[l].hasRendered && v[l].destroy();
        B(f, "data-highcharts-chart", this.index);
        f.innerHTML = m.emptyHTML;
        a.skipClone || f.offsetWidth || this.temporaryDisplay();
        this.getChartSize();
        l = this.chartWidth;
        var d = this.chartHeight;
        x(f, {
          overflow: "hidden"
        });
        this.styledMode || (g = W({
          position: "relative",
          overflow: "hidden",
          width: l + "px",
          height: d + "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
          userSelect: "none",
          "touch-action": "manipulation",
          outline: "none"
        }, a.style || {}));
        this.container = e = r("div", {
          id: e
        }, g, f);
        this._cursor = e.style.cursor;
        this.renderer = new (a.renderer || !k ? p.getRendererType(a.renderer) : c)(e, l, d, void 0, a.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);
        I(void 0, this);
        this.setClassName(a.className);
        if (this.styledMode) for (var n in b.defs) this.renderer.definition(b.defs[n]);else this.renderer.setStyle(a.style);
        this.renderer.chartIndex = this.index;
        E(this, "afterGetContainer");
      };
      f.prototype.getMargins = function (b) {
        var a = this.spacing,
          e = this.margin,
          g = this.titleOffset;
        this.resetMargins();
        g[0] && !M(e[0]) && (this.plotTop = Math.max(this.plotTop, g[0] + a[0]));
        g[2] && !M(e[2]) && (this.marginBottom = Math.max(this.marginBottom, g[2] + a[2]));
        this.legend && this.legend.display && this.legend.adjustMargins(e, a);
        E(this, "getMargins");
        b || this.getAxisMargins();
      };
      f.prototype.getAxisMargins = function () {
        var b = this,
          a = b.axisOffset = [0, 0, 0, 0],
          e = b.colorAxis,
          g = b.margin,
          c = function (b) {
            b.forEach(function (b) {
              b.visible && b.getOffset();
            });
          };
        b.hasCartesianSeries ? c(b.axes) : e && e.length && c(e);
        u.forEach(function (e, c) {
          M(g[c]) || (b[e] += a[c]);
        });
        b.setChartSize();
      };
      f.prototype.reflow = function (b) {
        var a = this,
          e = a.options.chart,
          g = a.renderTo,
          c = M(e.width) && M(e.height),
          f = e.width || aa(g, "width");
        e = e.height || aa(g, "height");
        g = b ? b.target : w;
        delete a.pointer.chartPosition;
        if (!c && !a.isPrinting && f && e && (g === w || g === z)) {
          if (f !== a.containerWidth || e !== a.containerHeight) n.clearTimeout(a.reflowTimeout), a.reflowTimeout = Y(function () {
            a.container && a.setSize(void 0, void 0, !1);
          }, b ? 100 : 0);
          a.containerWidth = f;
          a.containerHeight = e;
        }
      };
      f.prototype.setReflow = function (a) {
        var e = this;
        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = b(w, "resize", function (b) {
          e.options && e.reflow(b);
        }), b(this, "destroy", this.unbindReflow));
      };
      f.prototype.setSize = function (b, a, e) {
        var g = this,
          c = g.renderer;
        g.isResizing += 1;
        I(e, g);
        e = c.globalAnimation;
        g.oldChartHeight = g.chartHeight;
        g.oldChartWidth = g.chartWidth;
        "undefined" !== typeof b && (g.options.chart.width = b);
        "undefined" !== typeof a && (g.options.chart.height = a);
        g.getChartSize();
        g.styledMode || (e ? D : x)(g.container, {
          width: g.chartWidth + "px",
          height: g.chartHeight + "px"
        }, e);
        g.setChartSize(!0);
        c.setSize(g.chartWidth, g.chartHeight, e);
        g.axes.forEach(function (b) {
          b.isDirty = !0;
          b.setScale();
        });
        g.isDirtyLegend = !0;
        g.isDirtyBox = !0;
        g.layOutTitles();
        g.getMargins();
        g.redraw(e);
        g.oldChartHeight = null;
        E(g, "resize");
        Y(function () {
          g && E(g, "endResize", null, function () {
            --g.isResizing;
          });
        }, C(e).duration);
      };
      f.prototype.setChartSize = function (b) {
        var a = this.inverted,
          e = this.renderer,
          g = this.chartWidth,
          c = this.chartHeight,
          f = this.options.chart,
          k = this.spacing,
          l = this.clipOffset,
          d,
          r,
          x,
          n;
        this.plotLeft = d = Math.round(this.plotLeft);
        this.plotTop = r = Math.round(this.plotTop);
        this.plotWidth = x = Math.max(0, Math.round(g - d - this.marginRight));
        this.plotHeight = n = Math.max(0, Math.round(c - r - this.marginBottom));
        this.plotSizeX = a ? n : x;
        this.plotSizeY = a ? x : n;
        this.plotBorderWidth = f.plotBorderWidth || 0;
        this.spacingBox = e.spacingBox = {
          x: k[3],
          y: k[0],
          width: g - k[3] - k[1],
          height: c - k[0] - k[2]
        };
        this.plotBox = e.plotBox = {
          x: d,
          y: r,
          width: x,
          height: n
        };
        a = 2 * Math.floor(this.plotBorderWidth / 2);
        g = Math.ceil(Math.max(a, l[3]) / 2);
        c = Math.ceil(Math.max(a, l[0]) / 2);
        this.clipBox = {
          x: g,
          y: c,
          width: Math.floor(this.plotSizeX - Math.max(a, l[1]) / 2 - g),
          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, l[2]) / 2 - c))
        };
        b || (this.axes.forEach(function (b) {
          b.setAxisSize();
          b.setAxisTranslation();
        }), e.alignElements());
        E(this, "afterSetChartSize", {
          skipAxes: b
        });
      };
      f.prototype.resetMargins = function () {
        E(this, "resetMargins");
        var b = this,
          a = b.options.chart;
        ["margin", "spacing"].forEach(function (e) {
          var g = a[e],
            c = R(g) ? g : [g, g, g, g];
          ["Top", "Right", "Bottom", "Left"].forEach(function (g, f) {
            b[e][f] = S(a[e + g], c[f]);
          });
        });
        u.forEach(function (a, e) {
          b[a] = S(b.margin[e], b.spacing[e]);
        });
        b.axisOffset = [0, 0, 0, 0];
        b.clipOffset = [0, 0, 0, 0];
      };
      f.prototype.drawChartBox = function () {
        var b = this.options.chart,
          a = this.renderer,
          e = this.chartWidth,
          g = this.chartHeight,
          c = this.styledMode,
          f = this.plotBGImage,
          k = b.backgroundColor,
          l = b.plotBackgroundColor,
          d = b.plotBackgroundImage,
          r = this.plotLeft,
          x = this.plotTop,
          n = this.plotWidth,
          m = this.plotHeight,
          p = this.plotBox,
          h = this.clipRect,
          B = this.clipBox,
          u = this.chartBackground,
          w = this.plotBackground,
          J = this.plotBorder,
          v,
          q = "animate";
        u || (this.chartBackground = u = a.rect().addClass("highcharts-background").add(), q = "attr");
        if (c) var Q = v = u.strokeWidth();else {
          Q = b.borderWidth || 0;
          v = Q + (b.shadow ? 8 : 0);
          k = {
            fill: k || "none"
          };
          if (Q || u["stroke-width"]) k.stroke = b.borderColor, k["stroke-width"] = Q;
          u.attr(k).shadow(b.shadow);
        }
        u[q]({
          x: v / 2,
          y: v / 2,
          width: e - v - Q % 2,
          height: g - v - Q % 2,
          r: b.borderRadius
        });
        q = "animate";
        w || (q = "attr", this.plotBackground = w = a.rect().addClass("highcharts-plot-background").add());
        w[q](p);
        c || (w.attr({
          fill: l || "none"
        }).shadow(b.plotShadow), d && (f ? (d !== f.attr("href") && f.attr("href", d), f.animate(p)) : this.plotBGImage = a.image(d, r, x, n, m).add()));
        h ? h.animate({
          width: B.width,
          height: B.height
        }) : this.clipRect = a.clipRect(B);
        q = "animate";
        J || (q = "attr", this.plotBorder = J = a.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
        }).add());
        c || J.attr({
          stroke: b.plotBorderColor,
          "stroke-width": b.plotBorderWidth || 0,
          fill: "none"
        });
        J[q](J.crisp({
          x: r,
          y: x,
          width: n,
          height: m
        }, -J.strokeWidth()));
        this.isDirtyBox = !1;
        E(this, "afterDrawChartBox");
      };
      f.prototype.propFromSeries = function () {
        var b = this,
          a = b.options.chart,
          e = b.options.series,
          c,
          f,
          k;
        ["inverted", "angular", "polar"].forEach(function (l) {
          f = g[a.type || a.defaultSeriesType];
          k = a[l] || f && f.prototype[l];
          for (c = e && e.length; !k && c--;) (f = g[e[c].type]) && f.prototype[l] && (k = !0);
          b[l] = k;
        });
      };
      f.prototype.linkSeries = function () {
        var b = this,
          a = b.series;
        a.forEach(function (b) {
          b.linkedSeries.length = 0;
        });
        a.forEach(function (a) {
          var e = a.options.linkedTo;
          ca(e) && (e = ":previous" === e ? b.series[a.index - 1] : b.get(e)) && e.linkedParent !== a && (e.linkedSeries.push(a), a.linkedParent = e, e.enabledDataSorting && a.setDataSortingOptions(), a.visible = S(a.options.visible, e.options.visible, a.visible));
        });
        E(this, "afterLinkSeries");
      };
      f.prototype.renderSeries = function () {
        this.series.forEach(function (b) {
          b.translate();
          b.render();
        });
      };
      f.prototype.renderLabels = function () {
        var b = this,
          a = b.options.labels;
        a.items && a.items.forEach(function (e) {
          var g = W(a.style, e.style),
            c = da(g.left) + b.plotLeft,
            f = da(g.top) + b.plotTop + 12;
          delete g.left;
          delete g.top;
          b.renderer.text(e.html, c, f).attr({
            zIndex: 2
          }).css(g).add();
        });
      };
      f.prototype.render = function () {
        var b = this.axes,
          a = this.colorAxis,
          e = this.renderer,
          g = this.options,
          c = function (b) {
            b.forEach(function (b) {
              b.visible && b.render();
            });
          },
          f = 0;
        this.setTitle();
        this.legend = new G(this, g.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        g = this.plotWidth;
        b.some(function (b) {
          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return f = 21, !0;
        });
        var k = this.plotHeight = Math.max(this.plotHeight - f, 0);
        b.forEach(function (b) {
          b.setScale();
        });
        this.getAxisMargins();
        var l = 1.1 < g / this.plotWidth,
          d = 1.05 < k / this.plotHeight;
        if (l || d) b.forEach(function (b) {
          (b.horiz && l || !b.horiz && d) && b.setTickInterval(!0);
        }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries ? c(b) : a && a.length && c(a);
        this.seriesGroup || (this.seriesGroup = e.g("series-group").attr({
          zIndex: 3
        }).add());
        this.renderSeries();
        this.renderLabels();
        this.addCredits();
        this.setResponsive && this.setResponsive();
        this.hasRendered = !0;
      };
      f.prototype.addCredits = function (b) {
        var a = this,
          e = T(!0, this.options.credits, b);
        e.enabled && !this.credits && (this.credits = this.renderer.text(e.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
          e.href && (w.location.href = e.href);
        }).attr({
          align: e.position.align,
          zIndex: 8
        }), a.styledMode || this.credits.css(e.style), this.credits.add().align(e.position), this.credits.update = function (b) {
          a.credits = a.credits.destroy();
          a.addCredits(b);
        });
      };
      f.prototype.destroy = function () {
        var b = this,
          a = b.axes,
          e = b.series,
          g = b.container,
          c = g && g.parentNode,
          f;
        E(b, "destroy");
        b.renderer.forExport ? P(v, b) : v[b.index] = void 0;
        t.chartCount--;
        b.renderTo.removeAttribute("data-highcharts-chart");
        N(b);
        for (f = a.length; f--;) a[f] = a[f].destroy();
        this.scroller && this.scroller.destroy && this.scroller.destroy();
        for (f = e.length; f--;) e[f] = e[f].destroy();
        "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
          var e = b[a];
          e && e.destroy && (b[a] = e.destroy());
        });
        g && (g.innerHTML = m.emptyHTML, N(g), c && X(g));
        U(b, function (a, e) {
          delete b[e];
        });
      };
      f.prototype.firstRender = function () {
        var b = this,
          a = b.options;
        if (!b.isReadyToRender || b.isReadyToRender()) {
          b.getContainer();
          b.resetMargins();
          b.setChartSize();
          b.propFromSeries();
          b.getAxes();
          (Q(a.series) ? a.series : []).forEach(function (a) {
            b.initSeries(a);
          });
          b.linkSeries();
          b.setSeriesData();
          E(b, "beforeRender");
          q && (H.isRequired() ? b.pointer = new H(b, a) : b.pointer = new q(b, a));
          b.render();
          b.pointer.getChartPosition();
          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
          b.temporaryDisplay(!0);
        }
      };
      f.prototype.onload = function () {
        this.callbacks.concat([this.callback]).forEach(function (b) {
          b && "undefined" !== typeof this.index && b.apply(this, [this]);
        }, this);
        E(this, "load");
        E(this, "render");
        M(this.index) && this.setReflow(this.options.chart.reflow);
        this.hasLoaded = !0;
      };
      f.prototype.addSeries = function (b, a, e) {
        var g = this,
          c;
        b && (a = S(a, !0), E(g, "addSeries", {
          options: b
        }, function () {
          c = g.initSeries(b);
          g.isDirtyLegend = !0;
          g.linkSeries();
          c.enabledDataSorting && c.setData(b.data, !1);
          E(g, "afterAddSeries", {
            series: c
          });
          a && g.redraw(e);
        }));
        return c;
      };
      f.prototype.addAxis = function (b, a, e, g) {
        return this.createAxis(a ? "xAxis" : "yAxis", {
          axis: b,
          redraw: e,
          animation: g
        });
      };
      f.prototype.addColorAxis = function (b, a, e) {
        return this.createAxis("colorAxis", {
          axis: b,
          redraw: a,
          animation: e
        });
      };
      f.prototype.createAxis = function (b, a) {
        b = new h(this, T(a.axis, {
          index: this[b].length,
          isX: "xAxis" === b
        }));
        S(a.redraw, !0) && this.redraw(a.animation);
        return b;
      };
      f.prototype.showLoading = function (a) {
        var e = this,
          g = e.options,
          c = g.loading,
          f = function () {
            k && x(k, {
              left: e.plotLeft + "px",
              top: e.plotTop + "px",
              width: e.plotWidth + "px",
              height: e.plotHeight + "px"
            });
          },
          k = e.loadingDiv,
          l = e.loadingSpan;
        k || (e.loadingDiv = k = r("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, e.container));
        l || (e.loadingSpan = l = r("span", {
          className: "highcharts-loading-inner"
        }, null, k), b(e, "redraw", f));
        k.className = "highcharts-loading";
        m.setElementHTML(l, S(a, g.lang.loading, ""));
        e.styledMode || (x(k, W(c.style, {
          zIndex: 10
        })), x(l, c.labelStyle), e.loadingShown || (x(k, {
          opacity: 0,
          display: ""
        }), D(k, {
          opacity: c.style.opacity || .5
        }, {
          duration: c.showDuration || 0
        })));
        e.loadingShown = !0;
        f();
      };
      f.prototype.hideLoading = function () {
        var b = this.options,
          a = this.loadingDiv;
        a && (a.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || D(a, {
          opacity: 0
        }, {
          duration: b.loading.hideDuration || 100,
          complete: function () {
            x(a, {
              display: "none"
            });
          }
        }));
        this.loadingShown = !1;
      };
      f.prototype.update = function (b, g, c, f) {
        var k = this,
          l = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          },
          d = b.isResponsiveOptions,
          r = [],
          x,
          n;
        E(k, "update", {
          options: b
        });
        d || k.setResponsive(!1, !0);
        b = J(b, k.options);
        k.userOptions = T(k.userOptions, b);
        var m = b.chart;
        if (m) {
          T(!0, k.options.chart, m);
          "className" in m && k.setClassName(m.className);
          "reflow" in m && k.setReflow(m.reflow);
          if ("inverted" in m || "polar" in m || "type" in m) {
            k.propFromSeries();
            var p = !0;
          }
          "alignTicks" in m && (p = !0);
          "events" in m && K(this, m);
          U(m, function (b, a) {
            -1 !== k.propsRequireUpdateSeries.indexOf("chart." + a) && (x = !0);
            -1 !== k.propsRequireDirtyBox.indexOf(a) && (k.isDirtyBox = !0);
            -1 !== k.propsRequireReflow.indexOf(a) && (d ? k.isDirtyBox = !0 : n = !0);
          });
          !k.styledMode && m.style && k.renderer.setStyle(k.options.chart.style || {});
        }
        !k.styledMode && b.colors && (this.options.colors = b.colors);
        b.time && (this.time === e && (this.time = new a(b.time)), T(!0, k.options.time, b.time));
        U(b, function (a, e) {
          if (k[e] && "function" === typeof k[e].update) k[e].update(a, !1);else if ("function" === typeof k[l[e]]) k[l[e]](a);else "colors" !== e && -1 === k.collectionsWithUpdate.indexOf(e) && T(!0, k.options[e], b[e]);
          "chart" !== e && -1 !== k.propsRequireUpdateSeries.indexOf(e) && (x = !0);
        });
        this.collectionsWithUpdate.forEach(function (a) {
          if (b[a]) {
            var e = [];
            k[a].forEach(function (b, a) {
              b.options.isInternal || e.push(S(b.options.index, a));
            });
            fa(b[a]).forEach(function (b, g) {
              var f = M(b.id),
                l;
              f && (l = k.get(b.id));
              !l && k[a] && (l = k[a][e ? e[g] : g]) && f && M(l.options.id) && (l = void 0);
              l && l.coll === a && (l.update(b, !1), c && (l.touched = !0));
              !l && c && k.collectionsWithInit[a] && (k.collectionsWithInit[a][0].apply(k, [b].concat(k.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);
            });
            c && k[a].forEach(function (b) {
              b.touched || b.options.isInternal ? delete b.touched : r.push(b);
            });
          }
        });
        r.forEach(function (b) {
          b.chart && b.remove && b.remove(!1);
        });
        p && k.axes.forEach(function (b) {
          b.update({}, !1);
        });
        x && k.getSeriesOrderByLinks().forEach(function (b) {
          b.chart && b.update({}, !1);
        }, this);
        p = m && m.width;
        m = m && (ca(m.height) ? ia(m.height, p || k.chartWidth) : m.height);
        n || ba(p) && p !== k.chartWidth || ba(m) && m !== k.chartHeight ? k.setSize(p, m, f) : S(g, !0) && k.redraw(f);
        E(k, "afterUpdate", {
          options: b,
          redraw: g,
          animation: f
        });
      };
      f.prototype.setSubtitle = function (b, a) {
        this.applyDescription("subtitle", b);
        this.layOutTitles(a);
      };
      f.prototype.setCaption = function (b, a) {
        this.applyDescription("caption", b);
        this.layOutTitles(a);
      };
      f.prototype.showResetZoom = function () {
        function b() {
          a.zoomOut();
        }
        var a = this,
          e = l.lang,
          g = a.options.chart.resetZoomButton,
          c = g.theme,
          f = c.states,
          k = "chart" === g.relativeTo || "spacingBox" === g.relativeTo ? null : "scrollablePlotBox";
        E(this, "beforeShowResetZoom", null, function () {
          a.resetZoomButton = a.renderer.button(e.resetZoom, null, null, b, c, f && f.hover).attr({
            align: g.position.align,
            title: e.resetZoomTitle
          }).addClass("highcharts-reset-zoom").add().align(g.position, !1, k);
        });
        E(this, "afterShowResetZoom");
      };
      f.prototype.zoomOut = function () {
        E(this, "selection", {
          resetSelection: !0
        }, this.zoom);
      };
      f.prototype.zoom = function (b) {
        var a = this,
          e = a.pointer,
          g = a.inverted ? e.mouseDownX : e.mouseDownY,
          c = !1,
          f;
        !b || b.resetSelection ? (a.axes.forEach(function (b) {
          f = b.zoom();
        }), e.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {
          var k = b.axis,
            l = a.inverted ? k.left : k.top,
            d = a.inverted ? l + k.width : l + k.height,
            r = k.isXAxis,
            x = !1;
          if (!r && g >= l && g <= d || r || !M(g)) x = !0;
          e[r ? "zoomX" : "zoomY"] && x && (f = k.zoom(b.min, b.max), k.displayBtn && (c = !0));
        });
        var k = a.resetZoomButton;
        c && !k ? a.showResetZoom() : !c && R(k) && (a.resetZoomButton = k.destroy());
        f && a.redraw(S(a.options.chart.animation, b && b.animation, 100 > a.pointCount));
      };
      f.prototype.pan = function (b, a) {
        var e = this,
          g = e.hoverPoints;
        a = "object" === typeof a ? a : {
          enabled: a,
          type: "x"
        };
        var c = e.options.chart,
          f = e.options.mapNavigation && e.options.mapNavigation.enabled;
        c && c.panning && (c.panning = a);
        var k = a.type,
          l;
        E(this, "pan", {
          originalEvent: b
        }, function () {
          g && g.forEach(function (b) {
            b.setState();
          });
          var a = e.xAxis;
          "xy" === k ? a = a.concat(e.yAxis) : "y" === k && (a = e.yAxis);
          var c = {};
          a.forEach(function (a) {
            if (a.options.panningEnabled && !a.options.isInternal) {
              var g = a.horiz,
                d = b[g ? "chartX" : "chartY"];
              g = g ? "mouseDownX" : "mouseDownY";
              var r = e[g],
                x = a.minPointOffset || 0,
                n = a.reversed && !e.inverted || !a.reversed && e.inverted ? -1 : 1,
                m = a.getExtremes(),
                p = a.toValue(r - d, !0) + x * n,
                h = a.toValue(r + a.len - d, !0) - (x * n || a.isXAxis && a.pointRangePadding || 0),
                u = h < p;
              n = a.hasVerticalPanning();
              r = u ? h : p;
              p = u ? p : h;
              var B = a.panningState;
              !n || a.isXAxis || B && !B.isDirty || a.series.forEach(function (b) {
                var a = b.getProcessedData(!0);
                a = b.getExtremes(a.yData, !0);
                B || (B = {
                  startMin: Number.MAX_VALUE,
                  startMax: -Number.MAX_VALUE
                });
                ba(a.dataMin) && ba(a.dataMax) && (B.startMin = Math.min(S(b.options.threshold, Infinity), a.dataMin, B.startMin), B.startMax = Math.max(S(b.options.threshold, -Infinity), a.dataMax, B.startMax));
              });
              n = Math.min(S(B && B.startMin, m.dataMin), x ? m.min : a.toValue(a.toPixels(m.min) - a.minPixelPadding));
              h = Math.max(S(B && B.startMax, m.dataMax), x ? m.max : a.toValue(a.toPixels(m.max) + a.minPixelPadding));
              a.panningState = B;
              a.isOrdinal || (x = n - r, 0 < x && (p += x, r = n), x = p - h, 0 < x && (p = h, r -= x), a.series.length && r !== m.min && p !== m.max && r >= n && p <= h && (a.setExtremes(r, p, !1, !1, {
                trigger: "pan"
              }), e.resetZoomButton || f || r === n || p === h || !k.match("y") || (e.showResetZoom(), a.displayBtn = !1), l = !0), c[g] = d);
            }
          });
          U(c, function (b, a) {
            e[a] = b;
          });
          l && e.redraw(!1);
          x(e.container, {
            cursor: "move"
          });
        });
      };
      return f;
    }();
    W(d.prototype, {
      callbacks: [],
      collectionsWithInit: {
        xAxis: [d.prototype.addAxis, [!0]],
        yAxis: [d.prototype.addAxis, [!1]],
        series: [d.prototype.addSeries]
      },
      collectionsWithUpdate: ["xAxis", "yAxis", "series"],
      propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
      propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
    });
    "";
    return d;
  });
  N(h, "Core/Legend/LegendSymbol.js", [h["Core/Utilities.js"]], function (d) {
    var h = d.merge,
      A = d.pick,
      F;
    (function (d) {
      d.drawLineMarker = function (d) {
        var t = this.options,
          y = d.symbolWidth,
          q = d.symbolHeight,
          p = q / 2,
          f = this.chart.renderer,
          c = this.legendGroup;
        d = d.baseline - Math.round(.3 * d.fontMetrics.b);
        var a = {},
          n = t.marker;
        this.chart.styledMode || (a = {
          "stroke-width": t.lineWidth || 0
        }, t.dashStyle && (a.dashstyle = t.dashStyle));
        this.legendLine = f.path([["M", 0, d], ["L", y, d]]).addClass("highcharts-graph").attr(a).add(c);
        n && !1 !== n.enabled && y && (t = Math.min(A(n.radius, p), p), 0 === this.symbol.indexOf("url") && (n = h(n, {
          width: q,
          height: q
        }), t = 0), this.legendSymbol = y = f.symbol(this.symbol, y / 2 - t, d - t, 2 * t, 2 * t, n).addClass("highcharts-point").add(c), y.isMarker = !0);
      };
      d.drawRectangle = function (d, h) {
        var t = d.symbolHeight,
          q = d.options.squareSymbol;
        h.legendSymbol = this.chart.renderer.rect(q ? (d.symbolWidth - t) / 2 : 0, d.baseline - t + 1, q ? t : d.symbolWidth, t, A(d.options.symbolRadius, t / 2)).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(h.legendGroup);
      };
    })(F || (F = {}));
    return F;
  });
  N(h, "Core/Series/SeriesDefaults.js", [], function () {
    return {
      lineWidth: 2,
      allowPointSelect: !1,
      crisp: !0,
      showCheckbox: !1,
      animation: {
        duration: 1E3
      },
      events: {},
      marker: {
        enabledThreshold: 2,
        lineColor: "#ffffff",
        lineWidth: 0,
        radius: 4,
        states: {
          normal: {
            animation: !0
          },
          hover: {
            animation: {
              duration: 50
            },
            enabled: !0,
            radiusPlus: 2,
            lineWidthPlus: 1
          },
          select: {
            fillColor: "#cccccc",
            lineColor: "#000000",
            lineWidth: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        animation: {},
        align: "center",
        defer: !0,
        formatter: function () {
          var d = this.series.chart.numberFormatter;
          return "number" !== typeof this.y ? "" : d(this.y, -1);
        },
        padding: 5,
        style: {
          fontSize: "11px",
          fontWeight: "bold",
          color: "contrast",
          textOutline: "1px contrast"
        },
        verticalAlign: "bottom",
        x: 0,
        y: 0
      },
      cropThreshold: 300,
      opacity: 1,
      pointRange: 0,
      softThreshold: !0,
      states: {
        normal: {
          animation: !0
        },
        hover: {
          animation: {
            duration: 50
          },
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10,
            opacity: .25
          }
        },
        select: {
          animation: {
            duration: 0
          }
        },
        inactive: {
          animation: {
            duration: 50
          },
          opacity: .2
        }
      },
      stickyTracking: !0,
      turboThreshold: 1E3,
      findNearestPointBy: "x"
    };
  });
  N(h, "Core/Series/Series.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/DefaultOptions.js"], h["Core/Foundation.js"], h["Core/Globals.js"], h["Core/Legend/LegendSymbol.js"], h["Core/Series/Point.js"], h["Core/Series/SeriesDefaults.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Renderer/SVG/SVGElement.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G, H, y, q, p) {
    var f = d.animObject,
      c = d.setAnimation,
      a = h.defaultOptions,
      n = A.registerEventOptions,
      m = F.hasTouch,
      D = F.svg,
      C = F.win,
      I = y.seriesTypes,
      L = p.addEvent,
      K = p.arrayMax,
      v = p.arrayMin,
      z = p.clamp,
      u = p.cleanRecursively,
      k = p.correctFloat,
      w = p.defined,
      l = p.erase,
      e = p.error,
      g = p.extend,
      b = p.find,
      B = p.fireEvent,
      J = p.getNestedProperty,
      r = p.isArray,
      x = p.isNumber,
      M = p.isString,
      E = p.merge,
      P = p.objectEach,
      O = p.pick,
      W = p.removeEvent,
      Z = p.splat,
      ha = p.syncTimeout;
    d = function () {
      function d() {
        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
      }
      d.prototype.init = function (b, a) {
        B(this, "init", {
          options: a
        });
        var e = this,
          c = b.series;
        this.eventsToUnbind = [];
        e.chart = b;
        e.options = e.setOptions(a);
        a = e.options;
        e.linkedSeries = [];
        e.bindAxes();
        g(e, {
          name: a.name,
          state: "",
          visible: !1 !== a.visible,
          selected: !0 === a.selected
        });
        n(this, a);
        var f = a.events;
        if (f && f.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) b.runTrackerClick = !0;
        e.getColor();
        e.getSymbol();
        e.parallelArrays.forEach(function (b) {
          e[b + "Data"] || (e[b + "Data"] = []);
        });
        e.isCartesian && (b.hasCartesianSeries = !0);
        var k;
        c.length && (k = c[c.length - 1]);
        e._i = O(k && k._i, -1) + 1;
        e.opacity = e.options.opacity;
        b.orderSeries(this.insert(c));
        a.dataSorting && a.dataSorting.enabled ? e.setDataSortingOptions() : e.points || e.data || e.setData(a.data, !1);
        B(this, "afterInit");
      };
      d.prototype.is = function (b) {
        return I[b] && this instanceof I[b];
      };
      d.prototype.insert = function (b) {
        var a = this.options.index,
          e;
        if (x(a)) {
          for (e = b.length; e--;) if (a >= O(b[e].options.index, b[e]._i)) {
            b.splice(e + 1, 0, this);
            break;
          }
          -1 === e && b.unshift(this);
          e += 1;
        } else b.push(this);
        return O(e, b.length - 1);
      };
      d.prototype.bindAxes = function () {
        var b = this,
          a = b.options,
          g = b.chart,
          c;
        B(this, "bindAxes", null, function () {
          (b.axisTypes || []).forEach(function (f) {
            var k = 0;
            g[f].forEach(function (e) {
              c = e.options;
              if (a[f] === k && !c.isInternal || "undefined" !== typeof a[f] && a[f] === c.id || "undefined" === typeof a[f] && 0 === c.index) b.insert(e.series), b[f] = e, e.isDirty = !0;
              c.isInternal || k++;
            });
            b[f] || b.optionalAxis === f || e(18, !0, g);
          });
        });
        B(this, "afterBindAxes");
      };
      d.prototype.updateParallelArrays = function (b, a) {
        var e = b.series,
          g = arguments,
          c = x(a) ? function (g) {
            var c = "y" === g && e.toYData ? e.toYData(b) : b[g];
            e[g + "Data"][a] = c;
          } : function (b) {
            Array.prototype[a].apply(e[b + "Data"], Array.prototype.slice.call(g, 2));
          };
        e.parallelArrays.forEach(c);
      };
      d.prototype.hasData = function () {
        return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
      };
      d.prototype.autoIncrement = function (b) {
        var a = this.options,
          e = a.pointIntervalUnit,
          g = a.relativeXValue,
          c = this.chart.time,
          f = this.xIncrement,
          k;
        f = O(f, a.pointStart, 0);
        this.pointInterval = k = O(this.pointInterval, a.pointInterval, 1);
        g && x(b) && (k *= b);
        e && (a = new c.Date(f), "day" === e ? c.set("Date", a, c.get("Date", a) + k) : "month" === e ? c.set("Month", a, c.get("Month", a) + k) : "year" === e && c.set("FullYear", a, c.get("FullYear", a) + k), k = a.getTime() - f);
        if (g && x(b)) return f + k;
        this.xIncrement = f + k;
        return f;
      };
      d.prototype.setDataSortingOptions = function () {
        var b = this.options;
        g(this, {
          requireSorting: !1,
          sorted: !1,
          enabledDataSorting: !0,
          allowDG: !1
        });
        w(b.pointRange) || (b.pointRange = 1);
      };
      d.prototype.setOptions = function (b) {
        var e = this.chart,
          g = e.options,
          c = g.plotOptions,
          f = e.userOptions || {};
        b = E(b);
        e = e.styledMode;
        var k = {
          plotOptions: c,
          userOptions: b
        };
        B(this, "setOptions", k);
        var d = k.plotOptions[this.type],
          l = f.plotOptions || {};
        this.userOptions = k.userOptions;
        f = E(d, c.series, f.plotOptions && f.plotOptions[this.type], b);
        this.tooltipOptions = E(a.tooltip, a.plotOptions.series && a.plotOptions.series.tooltip, a.plotOptions[this.type].tooltip, g.tooltip.userOptions, c.series && c.series.tooltip, c[this.type].tooltip, b.tooltip);
        this.stickyTracking = O(b.stickyTracking, l[this.type] && l[this.type].stickyTracking, l.series && l.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);
        null === d.marker && delete f.marker;
        this.zoneAxis = f.zoneAxis;
        c = this.zones = (f.zones || []).slice();
        !f.negativeColor && !f.negativeFillColor || f.zones || (g = {
          value: f[this.zoneAxis + "Threshold"] || f.threshold || 0,
          className: "highcharts-negative"
        }, e || (g.color = f.negativeColor, g.fillColor = f.negativeFillColor), c.push(g));
        c.length && w(c[c.length - 1].value) && c.push(e ? {} : {
          color: this.color,
          fillColor: this.fillColor
        });
        B(this, "afterSetOptions", {
          options: f
        });
        return f;
      };
      d.prototype.getName = function () {
        return O(this.options.name, "Series " + (this.index + 1));
      };
      d.prototype.getCyclic = function (b, a, e) {
        var g = this.chart,
          c = this.userOptions,
          f = b + "Index",
          k = b + "Counter",
          d = e ? e.length : O(g.options.chart[b + "Count"], g[b + "Count"]);
        if (!a) {
          var l = O(c[f], c["_" + f]);
          w(l) || (g.series.length || (g[k] = 0), c["_" + f] = l = g[k] % d, g[k] += 1);
          e && (a = e[l]);
        }
        "undefined" !== typeof l && (this[f] = l);
        this[b] = a;
      };
      d.prototype.getColor = function () {
        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || a.plotOptions[this.type].color, this.chart.options.colors);
      };
      d.prototype.getPointsCollection = function () {
        return (this.hasGroupedData ? this.points : this.data) || [];
      };
      d.prototype.getSymbol = function () {
        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
      };
      d.prototype.findPointIndex = function (a, e) {
        var g = a.id,
          c = a.x,
          f = this.points,
          k = this.options.dataSorting,
          d,
          l;
        if (g) k = this.chart.get(g), k instanceof G && (d = k);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (d = function (b) {
          return !b.touched && b.index === a.index;
        }, k && k.matchByName ? d = function (b) {
          return !b.touched && b.name === a.name;
        } : this.options.relativeXValue && (d = function (b) {
          return !b.touched && b.options.x === a.x;
        }), d = b(f, d), !d) return;
        if (d) {
          var r = d && d.index;
          "undefined" !== typeof r && (l = !0);
        }
        "undefined" === typeof r && x(c) && (r = this.xData.indexOf(c, e));
        -1 !== r && "undefined" !== typeof r && this.cropped && (r = r >= this.cropStart ? r - this.cropStart : r);
        !l && x(r) && f[r] && f[r].touched && (r = void 0);
        return r;
      };
      d.prototype.updateData = function (b, a) {
        var e = this.options,
          g = e.dataSorting,
          c = this.points,
          f = [],
          k = this.requireSorting,
          d = b.length === c.length,
          l,
          r,
          n,
          m = !0;
        this.xIncrement = null;
        b.forEach(function (b, a) {
          var r = w(b) && this.pointClass.prototype.optionsToObject.call({
              series: this
            }, b) || {},
            m = r.x;
          if (r.id || x(m)) {
            if (r = this.findPointIndex(r, n), -1 === r || "undefined" === typeof r ? f.push(b) : c[r] && b !== e.data[r] ? (c[r].update(b, !1, null, !1), c[r].touched = !0, k && (n = r + 1)) : c[r] && (c[r].touched = !0), !d || a !== r || g && g.enabled || this.hasDerivedData) l = !0;
          } else f.push(b);
        }, this);
        if (l) for (b = c.length; b--;) (r = c[b]) && !r.touched && r.remove && r.remove(!1, a);else !d || g && g.enabled ? m = !1 : (b.forEach(function (b, a) {
          b !== c[a].y && c[a].update && c[a].update(b, !1, null, !1);
        }), f.length = 0);
        c.forEach(function (b) {
          b && (b.touched = !1);
        });
        if (!m) return !1;
        f.forEach(function (b) {
          this.addPoint(b, !1, null, null, !1);
        }, this);
        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = K(this.xData), this.autoIncrement());
        return !0;
      };
      d.prototype.setData = function (b, a, g, c) {
        var f = this,
          k = f.points,
          d = k && k.length || 0,
          l = f.options,
          n = f.chart,
          m = l.dataSorting,
          p = f.xAxis,
          h = l.turboThreshold,
          B = this.xData,
          u = this.yData,
          w = f.pointArrayMap;
        w = w && w.length;
        var J = l.keys,
          v,
          q = 0,
          z = 1,
          Q = null;
        b = b || [];
        var C = b.length;
        a = O(a, !0);
        m && m.enabled && (b = this.sortData(b));
        !1 !== c && C && d && !f.cropped && !f.hasGroupedData && f.visible && !f.isSeriesBoosting && (v = this.updateData(b, g));
        if (!v) {
          f.xIncrement = null;
          f.colorCounter = 0;
          this.parallelArrays.forEach(function (b) {
            f[b + "Data"].length = 0;
          });
          if (h && C > h) {
            if (Q = f.getFirstValidPoint(b), x(Q)) for (g = 0; g < C; g++) B[g] = this.autoIncrement(), u[g] = b[g];else if (r(Q)) {
              if (w) {
                if (Q.length === w) for (g = 0; g < C; g++) B[g] = this.autoIncrement(), u[g] = b[g];else for (g = 0; g < C; g++) c = b[g], B[g] = c[0], u[g] = c.slice(1, w + 1);
              } else if (J && (q = J.indexOf("x"), z = J.indexOf("y"), q = 0 <= q ? q : 0, z = 0 <= z ? z : 1), 1 === Q.length && (z = 0), q === z) for (g = 0; g < C; g++) B[g] = this.autoIncrement(), u[g] = b[g][z];else for (g = 0; g < C; g++) c = b[g], B[g] = c[q], u[g] = c[z];
            } else e(12, !1, n);
          } else for (g = 0; g < C; g++) "undefined" !== typeof b[g] && (c = {
            series: f
          }, f.pointClass.prototype.applyOptions.apply(c, [b[g]]), f.updateParallelArrays(c, g));
          u && M(u[0]) && e(14, !0, n);
          f.data = [];
          f.options.data = f.userOptions.data = b;
          for (g = d; g--;) k[g] && k[g].destroy && k[g].destroy();
          p && (p.minRange = p.userMinRange);
          f.isDirty = n.isDirtyBox = !0;
          f.isDirtyData = !!k;
          g = !1;
        }
        "point" === l.legendType && (this.processData(), this.generatePoints());
        a && n.redraw(g);
      };
      d.prototype.sortData = function (b) {
        var a = this,
          e = a.options.dataSorting.sortKey || "y",
          g = function (b, a) {
            return w(a) && b.pointClass.prototype.optionsToObject.call({
              series: b
            }, a) || {};
          };
        b.forEach(function (e, c) {
          b[c] = g(a, e);
          b[c].index = c;
        }, this);
        b.concat().sort(function (b, a) {
          b = J(e, b);
          a = J(e, a);
          return a < b ? -1 : a > b ? 1 : 0;
        }).forEach(function (b, a) {
          b.x = a;
        }, this);
        a.linkedSeries && a.linkedSeries.forEach(function (a) {
          var e = a.options,
            c = e.data;
          e.dataSorting && e.dataSorting.enabled || !c || (c.forEach(function (e, f) {
            c[f] = g(a, e);
            b[f] && (c[f].x = b[f].x, c[f].index = f);
          }), a.setData(c, !1));
        });
        return b;
      };
      d.prototype.getProcessedData = function (b) {
        var a = this.xAxis,
          g = this.options,
          c = g.cropThreshold,
          f = b || this.getExtremesFromAll || g.getExtremesFromAll,
          k = this.isCartesian;
        b = a && a.val2lin;
        g = !(!a || !a.logarithmic);
        var d = 0,
          l = this.xData,
          r = this.yData,
          x = this.requireSorting;
        var n = !1;
        var m = l.length;
        if (a) {
          n = a.getExtremes();
          var p = n.min;
          var h = n.max;
          n = a.categories && !a.names.length;
        }
        if (k && this.sorted && !f && (!c || m > c || this.forceCrop)) if (l[m - 1] < p || l[0] > h) l = [], r = [];else if (this.yData && (l[0] < p || l[m - 1] > h)) {
          var B = this.cropData(this.xData, this.yData, p, h);
          l = B.xData;
          r = B.yData;
          d = B.start;
          B = !0;
        }
        for (c = l.length || 1; --c;) if (a = g ? b(l[c]) - b(l[c - 1]) : l[c] - l[c - 1], 0 < a && ("undefined" === typeof u || a < u)) var u = a;else 0 > a && x && !n && (e(15, !1, this.chart), x = !1);
        return {
          xData: l,
          yData: r,
          cropped: B,
          cropStart: d,
          closestPointRange: u
        };
      };
      d.prototype.processData = function (b) {
        var a = this.xAxis;
        if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;
        b = this.getProcessedData();
        this.cropped = b.cropped;
        this.cropStart = b.cropStart;
        this.processedXData = b.xData;
        this.processedYData = b.yData;
        this.closestPointRange = this.basePointRange = b.closestPointRange;
        B(this, "afterProcessData");
      };
      d.prototype.cropData = function (b, a, e, g, c) {
        var f = b.length,
          k,
          d = 0,
          l = f;
        c = O(c, this.cropShoulder);
        for (k = 0; k < f; k++) if (b[k] >= e) {
          d = Math.max(0, k - c);
          break;
        }
        for (e = k; e < f; e++) if (b[e] > g) {
          l = e + c;
          break;
        }
        return {
          xData: b.slice(d, l),
          yData: a.slice(d, l),
          start: d,
          end: l
        };
      };
      d.prototype.generatePoints = function () {
        var b = this.options,
          a = b.data,
          e = this.processedXData,
          c = this.processedYData,
          f = this.pointClass,
          k = e.length,
          d = this.cropStart || 0,
          l = this.hasGroupedData,
          r = b.keys,
          n = [];
        b = b.dataGrouping && b.dataGrouping.groupAll ? d : 0;
        var x,
          m,
          p = this.data;
        if (!p && !l) {
          var h = [];
          h.length = a.length;
          p = this.data = h;
        }
        r && l && (this.options.keys = !1);
        for (m = 0; m < k; m++) {
          h = d + m;
          if (l) {
            var u = new f().init(this, [e[m]].concat(Z(c[m])));
            u.dataGroup = this.groupMap[b + m];
            u.dataGroup.options && (u.options = u.dataGroup.options, g(u, u.dataGroup.options), delete u.dataLabels);
          } else (u = p[h]) || "undefined" === typeof a[h] || (p[h] = u = new f().init(this, a[h], e[m]));
          u && (u.index = l ? b + m : h, n[m] = u);
        }
        this.options.keys = r;
        if (p && (k !== (x = p.length) || l)) for (m = 0; m < x; m++) m !== d || l || (m += k), p[m] && (p[m].destroyElements(), p[m].plotX = void 0);
        this.data = p;
        this.points = n;
        B(this, "afterGeneratePoints");
      };
      d.prototype.getXExtremes = function (b) {
        return {
          min: v(b),
          max: K(b)
        };
      };
      d.prototype.getExtremes = function (b, a) {
        var e = this.xAxis,
          g = this.yAxis,
          c = this.processedXData || this.xData,
          f = [],
          k = this.requireSorting ? this.cropShoulder : 0;
        g = g ? g.positiveValuesOnly : !1;
        var d,
          l = 0,
          n = 0,
          m = 0;
        b = b || this.stackedYData || this.processedYData || [];
        var p = b.length;
        if (e) {
          var h = e.getExtremes();
          l = h.min;
          n = h.max;
        }
        for (d = 0; d < p; d++) {
          var u = c[d];
          h = b[d];
          var w = (x(h) || r(h)) && (h.length || 0 < h || !g);
          u = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !e || (c[d + k] || u) >= l && (c[d - k] || u) <= n;
          if (w && u) if (w = h.length) for (; w--;) x(h[w]) && (f[m++] = h[w]);else f[m++] = h;
        }
        b = {
          activeYData: f,
          dataMin: v(f),
          dataMax: K(f)
        };
        B(this, "afterGetExtremes", {
          dataExtremes: b
        });
        return b;
      };
      d.prototype.applyExtremes = function () {
        var b = this.getExtremes();
        this.dataMin = b.dataMin;
        this.dataMax = b.dataMax;
        return b;
      };
      d.prototype.getFirstValidPoint = function (b) {
        for (var a = b.length, e = 0, g = null; null === g && e < a;) g = b[e], e++;
        return g;
      };
      d.prototype.translate = function () {
        this.processedXData || this.processData();
        this.generatePoints();
        var b = this.options,
          a = b.stacking,
          e = this.xAxis,
          g = e.categories,
          c = this.enabledDataSorting,
          f = this.yAxis,
          d = this.points,
          l = d.length,
          n = this.pointPlacementToXValue(),
          m = !!n,
          p = b.threshold,
          h = b.startFromThreshold ? p : 0,
          u = this.zoneAxis || "y",
          J,
          v,
          q = Number.MAX_VALUE;
        for (J = 0; J < l; J++) {
          var M = d[J],
            C = M.x,
            D = void 0,
            I = void 0,
            L = M.y,
            K = M.low,
            t = a && f.stacking && f.stacking.stacks[(this.negStacks && L < (h ? 0 : p) ? "-" : "") + this.stackKey];
          if (f.positiveValuesOnly && !f.validatePositiveValue(L) || e.positiveValuesOnly && !e.validatePositiveValue(C)) M.isNull = !0;
          M.plotX = v = k(z(e.translate(C, 0, 0, 0, 1, n, "flags" === this.type), -1E5, 1E5));
          if (a && this.visible && t && t[C]) {
            var y = this.getStackIndicator(y, C, this.index);
            M.isNull || (D = t[C], I = D.points[y.key]);
          }
          r(I) && (K = I[0], L = I[1], K === h && y.key === t[C].base && (K = O(x(p) && p, f.min)), f.positiveValuesOnly && 0 >= K && (K = null), M.total = M.stackTotal = D.total, M.percentage = D.total && M.y / D.total * 100, M.stackY = L, this.irregularWidths || D.setOffset(this.pointXOffset || 0, this.barW || 0));
          M.yBottom = w(K) ? z(f.translate(K, 0, 1, 0, 1), -1E5, 1E5) : null;
          this.dataModify && (L = this.dataModify.modifyValue(L, J));
          M.plotY = void 0;
          x(L) && (D = f.translate(L, !1, !0, !1, !0), "undefined" !== typeof D && (M.plotY = z(D, -1E5, 1E5)));
          M.isInside = this.isPointInside(M);
          M.clientX = m ? k(e.translate(C, 0, 0, 0, 1, n)) : v;
          M.negative = M[u] < (b[u + "Threshold"] || p || 0);
          M.category = g && "undefined" !== typeof g[M.x] ? g[M.x] : M.x;
          if (!M.isNull && !1 !== M.visible) {
            "undefined" !== typeof P && (q = Math.min(q, Math.abs(v - P)));
            var P = v;
          }
          M.zone = this.zones.length ? M.getZone() : void 0;
          !M.graphic && this.group && c && (M.isNew = !0);
        }
        this.closestPointRangePx = q;
        B(this, "afterTranslate");
      };
      d.prototype.getValidPoints = function (b, a, e) {
        var g = this.chart;
        return (b || this.points || []).filter(function (b) {
          return a && !g.isInsidePlot(b.plotX, b.plotY, {
            inverted: g.inverted
          }) ? !1 : !1 !== b.visible && (e || !b.isNull);
        });
      };
      d.prototype.getClipBox = function () {
        var b = this.chart,
          a = this.xAxis,
          e = this.yAxis,
          g = E(b.clipBox);
        a && a.len !== b.plotSizeX && (g.width = a.len);
        e && e.len !== b.plotSizeY && (g.height = e.len);
        return g;
      };
      d.prototype.getSharedClipKey = function () {
        return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
      };
      d.prototype.setClip = function () {
        var b = this.chart,
          a = this.group,
          e = this.markerGroup,
          g = b.sharedClips;
        b = b.renderer;
        var c = this.getClipBox(),
          f = this.getSharedClipKey(),
          k = g[f];
        k ? k.animate(c) : g[f] = k = b.clipRect(c);
        a && a.clip(!1 === this.options.clip ? void 0 : k);
        e && e.clip();
      };
      d.prototype.animate = function (b) {
        var a = this.chart,
          e = this.group,
          g = this.markerGroup,
          c = a.inverted,
          k = f(this.options.animation),
          d = [this.getSharedClipKey(), k.duration, k.easing, k.defer].join(),
          l = a.sharedClips[d],
          r = a.sharedClips[d + "m"];
        if (b && e) k = this.getClipBox(), l ? l.attr("height", k.height) : (k.width = 0, c && (k.x = a.plotHeight), l = a.renderer.clipRect(k), a.sharedClips[d] = l, r = a.renderer.clipRect({
          x: c ? (a.plotSizeX || 0) + 99 : -99,
          y: c ? -a.plotLeft : -a.plotTop,
          width: 99,
          height: c ? a.chartWidth : a.chartHeight
        }), a.sharedClips[d + "m"] = r), e.clip(l), g && g.clip(r);else if (l && !l.hasClass("highcharts-animating")) {
          a = this.getClipBox();
          var n = k.step;
          g && g.element.childNodes.length && (k.step = function (b, a) {
            n && n.apply(a, arguments);
            r && r.element && r.attr(a.prop, "width" === a.prop ? b + 99 : b);
          });
          l.addClass("highcharts-animating").animate(a, k);
        }
      };
      d.prototype.afterAnimate = function () {
        var b = this;
        this.setClip();
        P(this.chart.sharedClips, function (a, e, g) {
          a && !b.chart.container.querySelector('[clip-path="url(#' + a.id + ')"]') && (a.destroy(), delete g[e]);
        });
        this.finishedAnimating = !0;
        B(this, "afterAnimate");
      };
      d.prototype.drawPoints = function () {
        var b = this.points,
          a = this.chart,
          e = this.options.marker,
          g = this[this.specialGroup] || this.markerGroup,
          c = this.xAxis,
          f = O(e.enabled, !c || c.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius),
          k,
          d;
        if (!1 !== e.enabled || this._hasPointMarkers) for (k = 0; k < b.length; k++) {
          var l = b[k];
          var r = (d = l.graphic) ? "animate" : "attr";
          var n = l.marker || {};
          var x = !!l.marker;
          if ((f && "undefined" === typeof n.enabled || n.enabled) && !l.isNull && !1 !== l.visible) {
            var m = O(n.symbol, this.symbol, "rect");
            var p = this.markerAttribs(l, l.selected && "select");
            this.enabledDataSorting && (l.startXPos = c.reversed ? -(p.width || 0) : c.width);
            var h = !1 !== l.isInside;
            d ? d[h ? "show" : "hide"](h).animate(p) : h && (0 < (p.width || 0) || l.hasImage) && (l.graphic = d = a.renderer.symbol(m, p.x, p.y, p.width, p.height, x ? n : e).add(g), this.enabledDataSorting && a.hasRendered && (d.attr({
              x: l.startXPos
            }), r = "animate"));
            d && "animate" === r && d[h ? "show" : "hide"](h).animate(p);
            if (d && !a.styledMode) d[r](this.pointAttribs(l, l.selected && "select"));
            d && d.addClass(l.getClassName(), !0);
          } else d && (l.graphic = d.destroy());
        }
      };
      d.prototype.markerAttribs = function (b, a) {
        var e = this.options,
          g = e.marker,
          c = b.marker || {},
          f = c.symbol || g.symbol,
          k = O(c.radius, g.radius);
        a && (g = g.states[a], a = c.states && c.states[a], k = O(a && a.radius, g && g.radius, k + (g && g.radiusPlus || 0)));
        b.hasImage = f && 0 === f.indexOf("url");
        b.hasImage && (k = 0);
        b = {
          x: e.crisp ? Math.floor(b.plotX - k) : b.plotX - k,
          y: b.plotY - k
        };
        k && (b.width = b.height = 2 * k);
        return b;
      };
      d.prototype.pointAttribs = function (b, a) {
        var e = this.options.marker,
          g = b && b.options,
          c = g && g.marker || {},
          f = g && g.color,
          k = b && b.color,
          d = b && b.zone && b.zone.color,
          l = this.color;
        b = O(c.lineWidth, e.lineWidth);
        g = 1;
        l = f || d || k || l;
        f = c.fillColor || e.fillColor || l;
        k = c.lineColor || e.lineColor || l;
        a = a || "normal";
        e = e.states[a] || {};
        a = c.states && c.states[a] || {};
        b = O(a.lineWidth, e.lineWidth, b + O(a.lineWidthPlus, e.lineWidthPlus, 0));
        f = a.fillColor || e.fillColor || f;
        k = a.lineColor || e.lineColor || k;
        g = O(a.opacity, e.opacity, g);
        return {
          stroke: k,
          "stroke-width": b,
          fill: f,
          opacity: g
        };
      };
      d.prototype.destroy = function (b) {
        var a = this,
          e = a.chart,
          g = /AppleWebKit\/533/.test(C.navigator.userAgent),
          c = a.data || [],
          f,
          k,
          d,
          r;
        B(a, "destroy");
        this.removeEvents(b);
        (a.axisTypes || []).forEach(function (b) {
          (r = a[b]) && r.series && (l(r.series, a), r.isDirty = r.forceRedraw = !0);
        });
        a.legendItem && a.chart.legend.destroyItem(a);
        for (k = c.length; k--;) (d = c[k]) && d.destroy && d.destroy();
        a.clips && a.clips.forEach(function (b) {
          return b.destroy();
        });
        p.clearTimeout(a.animationTimeout);
        P(a, function (b, a) {
          b instanceof q && !b.survive && (f = g && "group" === a ? "hide" : "destroy", b[f]());
        });
        e.hoverSeries === a && (e.hoverSeries = void 0);
        l(e.series, a);
        e.orderSeries();
        P(a, function (e, g) {
          b && "hcEvents" === g || delete a[g];
        });
      };
      d.prototype.applyZones = function () {
        var b = this,
          a = this.chart,
          e = a.renderer,
          g = this.zones,
          c = this.clips || [],
          f = this.graph,
          k = this.area,
          d = Math.max(a.chartWidth, a.chartHeight),
          l = this[(this.zoneAxis || "y") + "Axis"],
          r = a.inverted,
          n,
          x,
          m,
          p,
          h,
          u,
          B,
          w,
          J = !1;
        if (g.length && (f || k) && l && "undefined" !== typeof l.min) {
          var v = l.reversed;
          var q = l.horiz;
          f && !this.showLine && f.hide();
          k && k.hide();
          var M = l.getExtremes();
          g.forEach(function (g, C) {
            n = v ? q ? a.plotWidth : 0 : q ? 0 : l.toPixels(M.min) || 0;
            n = z(O(x, n), 0, d);
            x = z(Math.round(l.toPixels(O(g.value, M.max), !0) || 0), 0, d);
            J && (n = x = l.toPixels(M.max));
            p = Math.abs(n - x);
            h = Math.min(n, x);
            u = Math.max(n, x);
            l.isXAxis ? (m = {
              x: r ? u : h,
              y: 0,
              width: p,
              height: d
            }, q || (m.x = a.plotHeight - m.x)) : (m = {
              x: 0,
              y: r ? u : h,
              width: d,
              height: p
            }, q && (m.y = a.plotWidth - m.y));
            r && e.isVML && (m = l.isXAxis ? {
              x: 0,
              y: v ? h : u,
              height: m.width,
              width: a.chartWidth
            } : {
              x: m.y - a.plotLeft - a.spacingBox.x,
              y: 0,
              width: m.height,
              height: a.chartHeight
            });
            c[C] ? c[C].animate(m) : c[C] = e.clipRect(m);
            B = b["zone-area-" + C];
            w = b["zone-graph-" + C];
            f && w && w.clip(c[C]);
            k && B && B.clip(c[C]);
            J = g.value > M.max;
            b.resetZones && 0 === x && (x = void 0);
          });
          this.clips = c;
        } else b.visible && (f && f.show(!0), k && k.show(!0));
      };
      d.prototype.invertGroups = function (b) {
        function a() {
          ["group", "markerGroup"].forEach(function (a) {
            e[a] && (g.renderer.isVML && e[a].attr({
              width: e.yAxis.len,
              height: e.xAxis.len
            }), e[a].width = e.yAxis.len, e[a].height = e.xAxis.len, e[a].invert(e.isRadialSeries ? !1 : b));
          });
        }
        var e = this,
          g = e.chart;
        e.xAxis && (e.eventsToUnbind.push(L(g, "resize", a)), a(), e.invertGroups = a);
      };
      d.prototype.plotGroup = function (b, a, e, g, c) {
        var f = this[b],
          k = !f;
        e = {
          visibility: e,
          zIndex: g || .1
        };
        "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (e.opacity = this.opacity);
        k && (this[b] = f = this.chart.renderer.g().add(c));
        f.addClass("highcharts-" + a + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (w(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (f.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
        f.attr(e)[k ? "attr" : "animate"](this.getPlotBox());
        return f;
      };
      d.prototype.getPlotBox = function () {
        var b = this.chart,
          a = this.xAxis,
          e = this.yAxis;
        b.inverted && (a = e, e = this.xAxis);
        return {
          translateX: a ? a.left : b.plotLeft,
          translateY: e ? e.top : b.plotTop,
          scaleX: 1,
          scaleY: 1
        };
      };
      d.prototype.removeEvents = function (b) {
        b || W(this);
        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {
          b();
        }), this.eventsToUnbind.length = 0);
      };
      d.prototype.render = function () {
        var b = this,
          a = b.chart,
          e = b.options,
          g = f(e.animation),
          c = b.visible ? "inherit" : "hidden",
          k = e.zIndex,
          d = b.hasRendered,
          l = a.seriesGroup,
          r = a.inverted;
        a = !b.finishedAnimating && a.renderer.isSVG ? g.duration : 0;
        B(this, "render");
        var n = b.plotGroup("group", "series", c, k, l);
        b.markerGroup = b.plotGroup("markerGroup", "markers", c, k, l);
        !1 !== e.clip && b.setClip();
        b.animate && a && b.animate(!0);
        n.inverted = O(b.invertible, b.isCartesian) ? r : !1;
        b.drawGraph && (b.drawGraph(), b.applyZones());
        b.visible && b.drawPoints();
        b.drawDataLabels && b.drawDataLabels();
        b.redrawPoints && b.redrawPoints();
        b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();
        b.invertGroups(r);
        b.animate && a && b.animate();
        d || (a && g.defer && (a += g.defer), b.animationTimeout = ha(function () {
          b.afterAnimate();
        }, a || 0));
        b.isDirty = !1;
        b.hasRendered = !0;
        B(b, "afterRender");
      };
      d.prototype.redraw = function () {
        var b = this.chart,
          a = this.isDirty || this.isDirtyData,
          e = this.group,
          g = this.xAxis,
          c = this.yAxis;
        e && (b.inverted && e.attr({
          width: b.plotWidth,
          height: b.plotHeight
        }), e.animate({
          translateX: O(g && g.left, b.plotLeft),
          translateY: O(c && c.top, b.plotTop)
        }));
        this.translate();
        this.render();
        a && delete this.kdTree;
      };
      d.prototype.searchPoint = function (b, a) {
        var e = this.xAxis,
          g = this.yAxis,
          c = this.chart.inverted;
        return this.searchKDTree({
          clientX: c ? e.len - b.chartY + e.pos : b.chartX - e.pos,
          plotY: c ? g.len - b.chartX + g.pos : b.chartY - g.pos
        }, a, b);
      };
      d.prototype.buildKDTree = function (b) {
        function a(b, g, c) {
          var f = b && b.length;
          if (f) {
            var k = e.kdAxisArray[g % c];
            b.sort(function (b, a) {
              return b[k] - a[k];
            });
            f = Math.floor(f / 2);
            return {
              point: b[f],
              left: a(b.slice(0, f), g + 1, c),
              right: a(b.slice(f + 1), g + 1, c)
            };
          }
        }
        this.buildingKdTree = !0;
        var e = this,
          g = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        delete e.kdTree;
        ha(function () {
          e.kdTree = a(e.getValidPoints(null, !e.directTouch), g, g);
          e.buildingKdTree = !1;
        }, e.options.kdNow || b && "touchstart" === b.type ? 0 : 1);
      };
      d.prototype.searchKDTree = function (b, a, e) {
        function g(b, a, e, l) {
          var r = a.point,
            n = c.kdAxisArray[e % l],
            x = r,
            m = w(b[f]) && w(r[f]) ? Math.pow(b[f] - r[f], 2) : null;
          var p = w(b[k]) && w(r[k]) ? Math.pow(b[k] - r[k], 2) : null;
          p = (m || 0) + (p || 0);
          r.dist = w(p) ? Math.sqrt(p) : Number.MAX_VALUE;
          r.distX = w(m) ? Math.sqrt(m) : Number.MAX_VALUE;
          n = b[n] - r[n];
          p = 0 > n ? "left" : "right";
          m = 0 > n ? "right" : "left";
          a[p] && (p = g(b, a[p], e + 1, l), x = p[d] < x[d] ? p : r);
          a[m] && Math.sqrt(n * n) < x[d] && (b = g(b, a[m], e + 1, l), x = b[d] < x[d] ? b : x);
          return x;
        }
        var c = this,
          f = this.kdAxisArray[0],
          k = this.kdAxisArray[1],
          d = a ? "distX" : "dist";
        a = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        this.kdTree || this.buildingKdTree || this.buildKDTree(e);
        if (this.kdTree) return g(b, this.kdTree, a, a);
      };
      d.prototype.pointPlacementToXValue = function () {
        var b = this.options,
          a = b.pointRange,
          e = this.xAxis;
        b = b.pointPlacement;
        "between" === b && (b = e.reversed ? -.5 : .5);
        return x(b) ? b * (a || e.pointRange) : 0;
      };
      d.prototype.isPointInside = function (b) {
        var a = this.chart,
          e = this.xAxis,
          g = this.yAxis;
        return "undefined" !== typeof b.plotY && "undefined" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (g ? g.len : a.plotHeight) && 0 <= b.plotX && b.plotX <= (e ? e.len : a.plotWidth);
      };
      d.prototype.drawTracker = function () {
        var b = this,
          a = b.options,
          e = a.trackByArea,
          g = [].concat(e ? b.areaPath : b.graphPath),
          c = b.chart,
          f = c.pointer,
          k = c.renderer,
          d = c.options.tooltip.snap,
          l = b.tracker,
          r = function (a) {
            if (c.hoverSeries !== b) b.onMouseOver();
          },
          n = "rgba(192,192,192," + (D ? .0001 : .002) + ")";
        l ? l.attr({
          d: g
        }) : b.graph && (b.tracker = k.path(g).attr({
          visibility: b.visible ? "visible" : "hidden",
          zIndex: 2
        }).addClass(e ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b.group), c.styledMode || b.tracker.attr({
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          stroke: n,
          fill: e ? n : "none",
          "stroke-width": b.graph.strokeWidth() + (e ? 0 : 2 * d)
        }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {
          if (b && (b.addClass("highcharts-tracker").on("mouseover", r).on("mouseout", function (b) {
            f.onTrackerMouseOut(b);
          }), a.cursor && !c.styledMode && b.css({
            cursor: a.cursor
          }), m)) b.on("touchstart", r);
        }));
        B(this, "afterDrawTracker");
      };
      d.prototype.addPoint = function (b, a, e, g, c) {
        var f = this.options,
          k = this.data,
          d = this.chart,
          l = this.xAxis;
        l = l && l.hasNames && l.names;
        var r = f.data,
          n = this.xData,
          x;
        a = O(a, !0);
        var m = {
          series: this
        };
        this.pointClass.prototype.applyOptions.apply(m, [b]);
        var p = m.x;
        var h = n.length;
        if (this.requireSorting && p < n[h - 1]) for (x = !0; h && n[h - 1] > p;) h--;
        this.updateParallelArrays(m, "splice", h, 0, 0);
        this.updateParallelArrays(m, h);
        l && m.name && (l[p] = m.name);
        r.splice(h, 0, b);
        x && (this.data.splice(h, 0, null), this.processData());
        "point" === f.legendType && this.generatePoints();
        e && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), this.updateParallelArrays(m, "shift"), r.shift()));
        !1 !== c && B(this, "addPoint", {
          point: m
        });
        this.isDirtyData = this.isDirty = !0;
        a && d.redraw(g);
      };
      d.prototype.removePoint = function (b, a, e) {
        var g = this,
          f = g.data,
          k = f[b],
          d = g.points,
          l = g.chart,
          r = function () {
            d && d.length === f.length && d.splice(b, 1);
            f.splice(b, 1);
            g.options.data.splice(b, 1);
            g.updateParallelArrays(k || {
              series: g
            }, "splice", b, 1);
            k && k.destroy();
            g.isDirty = !0;
            g.isDirtyData = !0;
            a && l.redraw();
          };
        c(e, l);
        a = O(a, !0);
        k ? k.firePointEvent("remove", null, r) : r();
      };
      d.prototype.remove = function (b, a, e, g) {
        function c() {
          f.destroy(g);
          k.isDirtyLegend = k.isDirtyBox = !0;
          k.linkSeries();
          O(b, !0) && k.redraw(a);
        }
        var f = this,
          k = f.chart;
        !1 !== e ? B(f, "remove", null, c) : c();
      };
      d.prototype.update = function (b, a) {
        b = u(b, this.userOptions);
        B(this, "update", {
          options: b
        });
        var c = this,
          f = c.chart,
          k = c.userOptions,
          d = c.initialType || c.type,
          l = f.options.plotOptions,
          r = I[d].prototype,
          n = c.finishedAnimating && {
            animation: !1
          },
          x = {},
          m,
          p = ["eventOptions", "navigatorSeries", "baseSeries"],
          h = b.type || k.type || f.options.chart.type,
          w = !(this.hasDerivedData || h && h !== this.type || "undefined" !== typeof b.pointStart || "undefined" !== typeof b.pointInterval || "undefined" !== typeof b.relativeXValue || c.hasOptionChanged("dataGrouping") || c.hasOptionChanged("pointStart") || c.hasOptionChanged("pointInterval") || c.hasOptionChanged("pointIntervalUnit") || c.hasOptionChanged("keys"));
        h = h || d;
        w && (p.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== b.visible && p.push("area", "graph"), c.parallelArrays.forEach(function (b) {
          p.push(b + "Data");
        }), b.data && (b.dataSorting && g(c.options.dataSorting, b.dataSorting), this.setData(b.data, !1)));
        b = E(k, n, {
          index: "undefined" === typeof k.index ? c.index : k.index,
          pointStart: O(l && l.series && l.series.pointStart, k.pointStart, c.xData[0])
        }, !w && {
          data: c.options.data
        }, b);
        w && b.data && (b.data = c.options.data);
        p = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p);
        p.forEach(function (b) {
          p[b] = c[b];
          delete c[b];
        });
        l = !1;
        if (I[h]) {
          if (l = h !== c.type, c.remove(!1, !1, !1, !0), l) if (Object.setPrototypeOf) Object.setPrototypeOf(c, I[h].prototype);else {
            n = Object.hasOwnProperty.call(c, "hcEvents") && c.hcEvents;
            for (m in r) c[m] = void 0;
            g(c, I[h].prototype);
            n ? c.hcEvents = n : delete c.hcEvents;
          }
        } else e(17, !0, f, {
          missingModuleFor: h
        });
        p.forEach(function (b) {
          c[b] = p[b];
        });
        c.init(f, b);
        if (w && this.points) {
          var J = c.options;
          !1 === J.visible ? (x.graphic = 1, x.dataLabel = 1) : c._hasPointLabels || (b = J.marker, r = J.dataLabels, !b || !1 !== b.enabled && (k.marker && k.marker.symbol) === b.symbol || (x.graphic = 1), r && !1 === r.enabled && (x.dataLabel = 1));
          this.points.forEach(function (b) {
            b && b.series && (b.resolveColor(), Object.keys(x).length && b.destroyElements(x), !1 === J.showInLegend && b.legendItem && f.legend.destroyItem(b));
          }, this);
        }
        c.initialType = d;
        f.linkSeries();
        l && c.linkedSeries.length && (c.isDirtyData = !0);
        B(this, "afterUpdate");
        O(a, !0) && f.redraw(w ? void 0 : !1);
      };
      d.prototype.setName = function (b) {
        this.name = this.options.name = this.userOptions.name = b;
        this.chart.isDirtyLegend = !0;
      };
      d.prototype.hasOptionChanged = function (b) {
        var a = this.options[b],
          e = this.chart.options.plotOptions,
          g = this.userOptions[b];
        return g ? a !== g : a !== O(e && e[this.type] && e[this.type][b], e && e.series && e.series[b], a);
      };
      d.prototype.onMouseOver = function () {
        var b = this.chart,
          a = b.hoverSeries;
        b.pointer.setHoverChartIndex();
        if (a && a !== this) a.onMouseOut();
        this.options.events.mouseOver && B(this, "mouseOver");
        this.setState("hover");
        b.hoverSeries = this;
      };
      d.prototype.onMouseOut = function () {
        var b = this.options,
          a = this.chart,
          e = a.tooltip,
          g = a.hoverPoint;
        a.hoverSeries = null;
        if (g) g.onMouseOut();
        this && b.events.mouseOut && B(this, "mouseOut");
        !e || this.stickyTracking || e.shared && !this.noSharedTooltip || e.hide();
        a.series.forEach(function (b) {
          b.setState("", !0);
        });
      };
      d.prototype.setState = function (b, a) {
        var e = this,
          g = e.options,
          c = e.graph,
          f = g.inactiveOtherPoints,
          k = g.states,
          d = O(k[b || "normal"] && k[b || "normal"].animation, e.chart.options.chart.animation),
          l = g.lineWidth,
          r = 0,
          n = g.opacity;
        b = b || "";
        if (e.state !== b && ([e.group, e.markerGroup, e.dataLabelsGroup].forEach(function (a) {
          a && (e.state && a.removeClass("highcharts-series-" + e.state), b && a.addClass("highcharts-series-" + b));
        }), e.state = b, !e.chart.styledMode)) {
          if (k[b] && !1 === k[b].enabled) return;
          b && (l = k[b].lineWidth || l + (k[b].lineWidthPlus || 0), n = O(k[b].opacity, n));
          if (c && !c.dashstyle) for (g = {
            "stroke-width": l
          }, c.animate(g, d); e["zone-graph-" + r];) e["zone-graph-" + r].animate(g, d), r += 1;
          f || [e.group, e.markerGroup, e.dataLabelsGroup, e.labelBySeries].forEach(function (b) {
            b && b.animate({
              opacity: n
            }, d);
          });
        }
        a && f && e.points && e.setAllPointsToState(b || void 0);
      };
      d.prototype.setAllPointsToState = function (b) {
        this.points.forEach(function (a) {
          a.setState && a.setState(b);
        });
      };
      d.prototype.setVisible = function (b, a) {
        var e = this,
          g = e.chart,
          c = e.legendItem,
          f = g.options.chart.ignoreHiddenSeries,
          k = e.visible,
          d = (e.visible = b = e.options.visible = e.userOptions.visible = "undefined" === typeof b ? !k : b) ? "show" : "hide";
        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (b) {
          if (e[b]) e[b][d]();
        });
        if (g.hoverSeries === e || (g.hoverPoint && g.hoverPoint.series) === e) e.onMouseOut();
        c && g.legend.colorizeItem(e, b);
        e.isDirty = !0;
        e.options.stacking && g.series.forEach(function (b) {
          b.options.stacking && b.visible && (b.isDirty = !0);
        });
        e.linkedSeries.forEach(function (a) {
          a.setVisible(b, !1);
        });
        f && (g.isDirtyBox = !0);
        B(e, d);
        !1 !== a && g.redraw();
      };
      d.prototype.show = function () {
        this.setVisible(!0);
      };
      d.prototype.hide = function () {
        this.setVisible(!1);
      };
      d.prototype.select = function (b) {
        this.selected = b = this.options.selected = "undefined" === typeof b ? !this.selected : b;
        this.checkbox && (this.checkbox.checked = b);
        B(this, b ? "select" : "unselect");
      };
      d.prototype.shouldShowTooltip = function (b, a, e) {
        void 0 === e && (e = {});
        e.series = this;
        e.visiblePlotOnly = !0;
        return this.chart.isInsidePlot(b, a, e);
      };
      d.defaultOptions = H;
      return d;
    }();
    g(d.prototype, {
      axisTypes: ["xAxis", "yAxis"],
      coll: "series",
      colorCounter: 0,
      cropShoulder: 1,
      directTouch: !1,
      drawLegendSymbol: t.drawLineMarker,
      isCartesian: !0,
      kdAxisArray: ["clientX", "plotY"],
      parallelArrays: ["x", "y"],
      pointClass: G,
      requireSorting: !0,
      sorted: !0
    });
    y.series = d;
    "";
    "";
    return d;
  });
  N(h, "Extensions/ScrollablePlotArea.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/Axis/Axis.js"], h["Core/Chart/Chart.js"], h["Core/Series/Series.js"], h["Core/Renderer/RendererRegistry.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G) {
    var E = d.stop,
      y = G.addEvent,
      q = G.createElement,
      p = G.merge,
      f = G.pick;
    y(A, "afterSetChartSize", function (c) {
      var a = this.options.chart.scrollablePlotArea,
        f = a && a.minWidth;
      a = a && a.minHeight;
      if (!this.renderer.forExport) {
        if (f) {
          if (this.scrollablePixelsX = f = Math.max(0, f - this.chartWidth)) {
            this.scrollablePlotBox = this.renderer.scrollablePlotBox = p(this.plotBox);
            this.plotBox.width = this.plotWidth += f;
            this.inverted ? this.clipBox.height += f : this.clipBox.width += f;
            var d = {
              1: {
                name: "right",
                value: f
              }
            };
          }
        } else a && (this.scrollablePixelsY = f = Math.max(0, a - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = p(this.plotBox), this.plotBox.height = this.plotHeight += f, this.inverted ? this.clipBox.width += f : this.clipBox.height += f, d = {
          2: {
            name: "bottom",
            value: f
          }
        });
        d && !c.skipAxes && this.axes.forEach(function (a) {
          d[a.side] ? a.getPlotLinePath = function () {
            var c = d[a.side].name,
              f = this[c];
            this[c] = f - d[a.side].value;
            var n = h.prototype.getPlotLinePath.apply(this, arguments);
            this[c] = f;
            return n;
          } : (a.setAxisSize(), a.setAxisTranslation());
        });
      }
    });
    y(A, "render", function () {
      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
    });
    A.prototype.setUpScrolling = function () {
      var c = this,
        a = {
          WebkitOverflowScrolling: "touch",
          overflowX: "hidden",
          overflowY: "hidden"
        };
      this.scrollablePixelsX && (a.overflowX = "auto");
      this.scrollablePixelsY && (a.overflowY = "auto");
      this.scrollingParent = q("div", {
        className: "highcharts-scrolling-parent"
      }, {
        position: "relative"
      }, this.renderTo);
      this.scrollingContainer = q("div", {
        className: "highcharts-scrolling"
      }, a, this.scrollingParent);
      y(this.scrollingContainer, "scroll", function () {
        c.pointer && delete c.pointer.chartPosition;
      });
      this.innerContainer = q("div", {
        className: "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null;
    };
    A.prototype.moveFixedElements = function () {
      var c = this.container,
        a = this.fixedRenderer,
        f = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
        d;
      this.scrollablePixelsX && !this.inverted ? d = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? d = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? d = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (d = ".highcharts-yaxis");
      d && f.push(d + ":not(.highcharts-radial-axis)", d + "-labels:not(.highcharts-radial-axis-labels)");
      f.forEach(function (f) {
        [].forEach.call(c.querySelectorAll(f), function (c) {
          (c.namespaceURI === a.SVG_NS ? a.box : a.box.parentNode).appendChild(c);
          c.style.pointerEvents = "auto";
        });
      });
    };
    A.prototype.applyFixed = function () {
      var c = !this.fixedDiv,
        a = this.options.chart,
        d = a.scrollablePlotArea,
        m = t.getRendererType();
      c ? (this.fixedDiv = q("div", {
        className: "highcharts-fixed"
      }, {
        position: "absolute",
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: (a.style && a.style.zIndex || 0) + 2,
        top: 0
      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = a = new m(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = a.path().attr({
        fill: this.options.chart.backgroundColor || "#fff",
        "fill-opacity": f(d.opacity, .85),
        zIndex: -1
      }).addClass("highcharts-scrollable-mask").add(), y(this, "afterShowResetZoom", this.moveFixedElements), y(this, "afterDrilldown", this.moveFixedElements), y(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      if (this.scrollableDirty || c) this.scrollableDirty = !1, this.moveFixedElements();
      a = this.chartWidth + (this.scrollablePixelsX || 0);
      m = this.chartHeight + (this.scrollablePixelsY || 0);
      E(this.container);
      this.container.style.width = a + "px";
      this.container.style.height = m + "px";
      this.renderer.boxWrapper.attr({
        width: a,
        height: m,
        viewBox: [0, 0, a, m].join(" ")
      });
      this.chartBackground.attr({
        width: a,
        height: m
      });
      this.scrollingContainer.style.height = this.chartHeight + "px";
      c && (d.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * d.scrollPositionX), d.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * d.scrollPositionY));
      m = this.axisOffset;
      c = this.plotTop - m[0] - 1;
      d = this.plotLeft - m[3] - 1;
      a = this.plotTop + this.plotHeight + m[2] + 1;
      m = this.plotLeft + this.plotWidth + m[1] + 1;
      var p = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
        h = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
      c = this.scrollablePixelsX ? [["M", 0, c], ["L", this.plotLeft - 1, c], ["L", this.plotLeft - 1, a], ["L", 0, a], ["Z"], ["M", p, c], ["L", this.chartWidth, c], ["L", this.chartWidth, a], ["L", p, a], ["Z"]] : this.scrollablePixelsY ? [["M", d, 0], ["L", d, this.plotTop - 1], ["L", m, this.plotTop - 1], ["L", m, 0], ["Z"], ["M", d, h], ["L", d, this.chartHeight], ["L", m, this.chartHeight], ["L", m, h], ["Z"]] : [["M", 0, 0]];
      "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
        d: c
      });
    };
    y(h, "afterInit", function () {
      this.chart.scrollableDirty = !0;
    });
    y(F, "show", function () {
      this.chart.scrollableDirty = !0;
    });
    "";
  });
  N(h, "Core/Axis/StackingAxis.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/Axis/Axis.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = d.getDeferredAnimation,
      t = A.addEvent,
      G = A.destroyObjectProperties,
      H = A.fireEvent,
      y = A.isNumber,
      q = A.objectEach,
      p;
    (function (f) {
      function c() {
        var a = this.stacking;
        if (a) {
          var c = a.stacks;
          q(c, function (a, f) {
            G(a);
            c[f] = null;
          });
          a && a.stackTotalGroup && a.stackTotalGroup.destroy();
        }
      }
      function a() {
        this.stacking || (this.stacking = new m(this));
      }
      var d = [];
      f.compose = function (f) {
        -1 === d.indexOf(f) && (d.push(f), t(f, "init", a), t(f, "destroy", c));
        return f;
      };
      var m = function () {
        function a(a) {
          this.oldStacks = {};
          this.stacks = {};
          this.stacksTouched = 0;
          this.axis = a;
        }
        a.prototype.buildStacks = function () {
          var a = this.axis,
            c = a.series,
            f = a.options.reversedStacks,
            d = c.length,
            n;
          if (!a.isXAxis) {
            this.usePercentage = !1;
            for (n = d; n--;) {
              var m = c[f ? n : d - n - 1];
              m.setStackedPoints();
              m.setGroupedPoints();
            }
            for (n = 0; n < d; n++) c[n].modifyStacks();
            H(a, "afterBuildStacks");
          }
        };
        a.prototype.cleanStacks = function () {
          if (!this.axis.isXAxis) {
            if (this.oldStacks) var a = this.stacks = this.oldStacks;
            q(a, function (a) {
              q(a, function (a) {
                a.cumulative = a.total;
              });
            });
          }
        };
        a.prototype.resetStacks = function () {
          var a = this,
            c = a.stacks;
          a.axis.isXAxis || q(c, function (c) {
            q(c, function (f, d) {
              y(f.touched) && f.touched < a.stacksTouched ? (f.destroy(), delete c[d]) : (f.total = null, f.cumulative = null);
            });
          });
        };
        a.prototype.renderStackTotals = function () {
          var a = this.axis,
            c = a.chart,
            f = c.renderer,
            d = this.stacks;
          a = E(c, a.options.stackLabels && a.options.stackLabels.animation || !1);
          var n = this.stackTotalGroup = this.stackTotalGroup || f.g("stack-labels").attr({
            visibility: "visible",
            zIndex: 6,
            opacity: 0
          }).add();
          n.translate(c.plotLeft, c.plotTop);
          q(d, function (a) {
            q(a, function (a) {
              a.render(n);
            });
          });
          n.animate({
            opacity: 1
          }, a);
        };
        return a;
      }();
      f.Additions = m;
    })(p || (p = {}));
    return p;
  });
  N(h, "Extensions/Stacking.js", [h["Core/Axis/Axis.js"], h["Core/Chart/Chart.js"], h["Core/FormatUtilities.js"], h["Core/Globals.js"], h["Core/Series/Series.js"], h["Core/Axis/StackingAxis.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G, H) {
    var y = A.format,
      q = H.correctFloat,
      p = H.defined,
      f = H.destroyObjectProperties,
      c = H.isArray,
      a = H.isNumber,
      n = H.objectEach,
      m = H.pick,
      D = function () {
        function c(a, c, f, d, n) {
          var m = a.chart.inverted;
          this.axis = a;
          this.isNegative = f;
          this.options = c = c || {};
          this.x = d;
          this.total = null;
          this.points = {};
          this.hasValidPoints = !1;
          this.stack = n;
          this.rightCliff = this.leftCliff = 0;
          this.alignOptions = {
            align: c.align || (m ? f ? "left" : "right" : "center"),
            verticalAlign: c.verticalAlign || (m ? "middle" : f ? "bottom" : "top"),
            y: c.y,
            x: c.x
          };
          this.textAlign = c.textAlign || (m ? f ? "right" : "left" : "center");
        }
        c.prototype.destroy = function () {
          f(this, this.axis);
        };
        c.prototype.render = function (a) {
          var c = this.axis.chart,
            f = this.options,
            d = f.format;
          d = d ? y(d, this, c) : f.formatter.call(this);
          this.label ? this.label.attr({
            text: d,
            visibility: "hidden"
          }) : (this.label = c.renderer.label(d, null, null, f.shape, null, null, f.useHTML, !1, "stack-labels"), d = {
            r: f.borderRadius || 0,
            text: d,
            rotation: f.rotation,
            padding: m(f.padding, 5),
            visibility: "hidden"
          }, c.styledMode || (d.fill = f.backgroundColor, d.stroke = f.borderColor, d["stroke-width"] = f.borderWidth, this.label.css(f.style)), this.label.attr(d), this.label.added || this.label.add(a));
          this.label.labelrank = c.plotSizeY;
        };
        c.prototype.setOffset = function (c, f, d, n, h) {
          var u = this.axis,
            k = u.chart;
          n = u.translate(u.stacking.usePercentage ? 100 : n ? n : this.total, 0, 0, 0, 1);
          d = u.translate(d ? d : 0);
          d = p(n) && Math.abs(n - d);
          c = m(h, k.xAxis[0].translate(this.x)) + c;
          u = p(n) && this.getStackBox(k, this, c, n, f, d, u);
          f = this.label;
          d = this.isNegative;
          c = "justify" === m(this.options.overflow, "justify");
          var w = this.textAlign;
          f && u && (h = f.getBBox(), n = f.padding, w = "left" === w ? k.inverted ? -n : n : "right" === w ? h.width : k.inverted && "center" === w ? h.width / 2 : k.inverted ? d ? h.width + n : -n : h.width / 2, d = k.inverted ? h.height / 2 : d ? -n : h.height, this.alignOptions.x = m(this.options.x, 0), this.alignOptions.y = m(this.options.y, 0), u.x -= w, u.y -= d, f.align(this.alignOptions, null, u), k.isInsidePlot(f.alignAttr.x + w - this.alignOptions.x, f.alignAttr.y + d - this.alignOptions.y) ? f.show() : (f.alignAttr.y = -9999, c = !1), c && t.prototype.justifyDataLabel.call(this.axis, f, this.alignOptions, f.alignAttr, h, u), f.attr({
            x: f.alignAttr.x,
            y: f.alignAttr.y
          }), m(!c && this.options.crop, !0) && ((k = a(f.x) && a(f.y) && k.isInsidePlot(f.x - n + f.width, f.y) && k.isInsidePlot(f.x + n, f.y)) || f.hide()));
        };
        c.prototype.getStackBox = function (a, c, f, d, n, m, k) {
          var p = c.axis.reversed,
            l = a.inverted,
            e = k.height + k.pos - (l ? a.plotLeft : a.plotTop);
          c = c.isNegative && !p || !c.isNegative && p;
          return {
            x: l ? c ? d - k.right : d - m + k.pos - a.plotLeft : f + a.xAxis[0].transB - a.plotLeft,
            y: l ? k.height - f - n : c ? e - d - m : e - d,
            width: l ? m : n,
            height: l ? n : m
          };
        };
        return c;
      }();
    h.prototype.getStacks = function () {
      var a = this,
        c = a.inverted;
      a.yAxis.forEach(function (a) {
        a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);
      });
      a.series.forEach(function (f) {
        var d = f.xAxis && f.xAxis.options || {};
        !f.options.stacking || !0 !== f.visible && !1 !== a.options.chart.ignoreHiddenSeries || (f.stackKey = [f.type, m(f.options.stack, ""), c ? d.top : d.left, c ? d.height : d.width].join());
      });
    };
    G.compose(d);
    t.prototype.setGroupedPoints = function () {
      var a = this.yAxis.stacking;
      this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? t.prototype.setStackedPoints.call(this, "group") : a && n(a.stacks, function (c, f) {
        "group" === f.slice(-5) && (n(c, function (a) {
          return a.destroy();
        }), delete a.stacks[f]);
      });
    };
    t.prototype.setStackedPoints = function (a) {
      var f = a || this.options.stacking;
      if (f && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
        var d = this.processedXData,
          n = this.processedYData,
          h = [],
          z = n.length,
          u = this.options,
          k = u.threshold,
          w = m(u.startFromThreshold && k, 0);
        u = u.stack;
        a = a ? this.type + "," + f : this.stackKey;
        var l = "-" + a,
          e = this.negStacks,
          g = this.yAxis,
          b = g.stacking.stacks,
          B = g.stacking.oldStacks,
          J,
          r;
        g.stacking.stacksTouched += 1;
        for (r = 0; r < z; r++) {
          var x = d[r];
          var M = n[r];
          var C = this.getStackIndicator(C, x, this.index);
          var t = C.key;
          var O = (J = e && M < (w ? 0 : k)) ? l : a;
          b[O] || (b[O] = {});
          b[O][x] || (B[O] && B[O][x] ? (b[O][x] = B[O][x], b[O][x].total = null) : b[O][x] = new D(g, g.options.stackLabels, J, x, u));
          O = b[O][x];
          null !== M ? (O.points[t] = O.points[this.index] = [m(O.cumulative, w)], p(O.cumulative) || (O.base = t), O.touched = g.stacking.stacksTouched, 0 < C.index && !1 === this.singleStacks && (O.points[t][0] = O.points[this.index + "," + x + ",0"][0])) : O.points[t] = O.points[this.index] = null;
          "percent" === f ? (J = J ? a : l, e && b[J] && b[J][x] ? (J = b[J][x], O.total = J.total = Math.max(J.total, O.total) + Math.abs(M) || 0) : O.total = q(O.total + (Math.abs(M) || 0))) : "group" === f ? (c(M) && (M = M[0]), null !== M && (O.total = (O.total || 0) + 1)) : O.total = q(O.total + (M || 0));
          O.cumulative = "group" === f ? (O.total || 1) - 1 : m(O.cumulative, w) + (M || 0);
          null !== M && (O.points[t].push(O.cumulative), h[r] = O.cumulative, O.hasValidPoints = !0);
        }
        "percent" === f && (g.stacking.usePercentage = !0);
        "group" !== f && (this.stackedYData = h);
        g.stacking.oldStacks = {};
      }
    };
    t.prototype.modifyStacks = function () {
      var a = this,
        c = a.stackKey,
        f = a.yAxis.stacking.stacks,
        d = a.processedXData,
        n,
        m = a.options.stacking;
      a[m + "Stacker"] && [c, "-" + c].forEach(function (c) {
        for (var k = d.length, p, l; k--;) if (p = d[k], n = a.getStackIndicator(n, p, a.index, c), l = (p = f[c] && f[c][p]) && p.points[n.key]) a[m + "Stacker"](l, p, k);
      });
    };
    t.prototype.percentStacker = function (a, c, f) {
      c = c.total ? 100 / c.total : 0;
      a[0] = q(a[0] * c);
      a[1] = q(a[1] * c);
      this.stackedYData[f] = a[1];
    };
    t.prototype.getStackIndicator = function (a, c, f, d) {
      !p(a) || a.x !== c || d && a.key !== d ? a = {
        x: c,
        index: 0,
        key: d
      } : a.index++;
      a.key = [f, c, a.index].join();
      return a;
    };
    F.StackItem = D;
    "";
    return F.StackItem;
  });
  N(h, "Series/Line/LineSeries.js", [h["Core/Series/Series.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = this && this.__extends || function () {
        var d = function (h, q) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, f) {
            d.__proto__ = f;
          } || function (d, f) {
            for (var c in f) f.hasOwnProperty(c) && (d[c] = f[c]);
          };
          return d(h, q);
        };
        return function (h, q) {
          function p() {
            this.constructor = h;
          }
          d(h, q);
          h.prototype = null === q ? Object.create(q) : (p.prototype = q.prototype, new p());
        };
      }(),
      t = A.defined,
      G = A.merge;
    A = function (h) {
      function y() {
        var d = null !== h && h.apply(this, arguments) || this;
        d.data = void 0;
        d.options = void 0;
        d.points = void 0;
        return d;
      }
      E(y, h);
      y.prototype.drawGraph = function () {
        var d = this,
          p = this.options,
          f = (this.gappedPath || this.getGraphPath).call(this),
          c = this.chart.styledMode,
          a = [["graph", "highcharts-graph"]];
        c || a[0].push(p.lineColor || this.color || "#cccccc", p.dashStyle);
        a = d.getZonesGraphs(a);
        a.forEach(function (a, m) {
          var n = a[0],
            h = d[n],
            q = h ? "animate" : "attr";
          h ? (h.endX = d.preventGraphAnimation ? null : f.xMap, h.animate({
            d: f
          })) : f.length && (d[n] = h = d.chart.renderer.path(f).addClass(a[1]).attr({
            zIndex: 1
          }).add(d.group));
          h && !c && (n = {
            stroke: a[2],
            "stroke-width": p.lineWidth,
            fill: d.fillGraph && d.color || "none"
          }, a[3] ? n.dashstyle = a[3] : "square" !== p.linecap && (n["stroke-linecap"] = n["stroke-linejoin"] = "round"), h[q](n).shadow(2 > m && p.shadow));
          h && (h.startX = f.xMap, h.isArea = f.isArea);
        });
      };
      y.prototype.getGraphPath = function (d, p, f) {
        var c = this,
          a = c.options,
          n = [],
          m = [],
          h,
          q = a.step;
        d = d || c.points;
        var I = d.reversed;
        I && d.reverse();
        (q = {
          right: 1,
          center: 2
        }[q] || q && 3) && I && (q = 4 - q);
        d = this.getValidPoints(d, !1, !(a.connectNulls && !p && !f));
        d.forEach(function (D, C) {
          var v = D.plotX,
            z = D.plotY,
            u = d[C - 1];
          (D.leftCliff || u && u.rightCliff) && !f && (h = !0);
          D.isNull && !t(p) && 0 < C ? h = !a.connectNulls : D.isNull && !p ? h = !0 : (0 === C || h ? C = [["M", D.plotX, D.plotY]] : c.getPointSpline ? C = [c.getPointSpline(d, D, C)] : q ? (C = 1 === q ? [["L", u.plotX, z]] : 2 === q ? [["L", (u.plotX + v) / 2, u.plotY], ["L", (u.plotX + v) / 2, z]] : [["L", v, u.plotY]], C.push(["L", v, z])) : C = [["L", v, z]], m.push(D.x), q && (m.push(D.x), 2 === q && m.push(D.x)), n.push.apply(n, C), h = !1);
        });
        n.xMap = m;
        return c.graphPath = n;
      };
      y.prototype.getZonesGraphs = function (d) {
        this.zones.forEach(function (h, f) {
          f = ["zone-graph-" + f, "highcharts-graph highcharts-zone-graph-" + f + " " + (h.className || "")];
          this.chart.styledMode || f.push(h.color || this.color, h.dashStyle || this.options.dashStyle);
          d.push(f);
        }, this);
        return d;
      };
      y.defaultOptions = G(d.defaultOptions, {});
      return y;
    }(d);
    h.registerSeriesType("line", A);
    "";
    return A;
  });
  N(h, "Series/Area/AreaSeries.js", [h["Core/Color/Color.js"], h["Core/Legend/LegendSymbol.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A, F) {
    var t = this && this.__extends || function () {
        var f = function (c, a) {
          f = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);
          };
          return f(c, a);
        };
        return function (c, a) {
          function d() {
            this.constructor = c;
          }
          f(c, a);
          c.prototype = null === a ? Object.create(a) : (d.prototype = a.prototype, new d());
        };
      }(),
      E = d.parse,
      H = A.seriesTypes.line;
    d = F.extend;
    var y = F.merge,
      q = F.objectEach,
      p = F.pick;
    F = function (f) {
      function c() {
        var a = null !== f && f.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      t(c, f);
      c.prototype.drawGraph = function () {
        this.areaPath = [];
        f.prototype.drawGraph.apply(this);
        var a = this,
          c = this.areaPath,
          d = this.options,
          h = [["area", "highcharts-area", this.color, d.fillColor]];
        this.zones.forEach(function (c, f) {
          h.push(["zone-area-" + f, "highcharts-area highcharts-zone-area-" + f + " " + c.className, c.color || a.color, c.fillColor || d.fillColor]);
        });
        h.forEach(function (f) {
          var n = f[0],
            m = a[n],
            h = m ? "animate" : "attr",
            q = {};
          m ? (m.endX = a.preventGraphAnimation ? null : c.xMap, m.animate({
            d: c
          })) : (q.zIndex = 0, m = a[n] = a.chart.renderer.path(c).addClass(f[1]).add(a.group), m.isArea = !0);
          a.chart.styledMode || (q.fill = p(f[3], E(f[2]).setOpacity(p(d.fillOpacity, .75)).get()));
          m[h](q);
          m.startX = c.xMap;
          m.shiftUnit = d.step ? 2 : 1;
        });
      };
      c.prototype.getGraphPath = function (a) {
        var c = H.prototype.getGraphPath,
          f = this.options,
          d = f.stacking,
          h = this.yAxis,
          q,
          t = [],
          y = [],
          v = this.index,
          z = h.stacking.stacks[this.stackKey],
          u = f.threshold,
          k = Math.round(h.getThreshold(f.threshold));
        f = p(f.connectNulls, "percent" === d);
        var w = function (b, g, c) {
          var f = a[b];
          b = d && z[f.x].points[v];
          var l = f[c + "Null"] || 0;
          c = f[c + "Cliff"] || 0;
          f = !0;
          if (c || l) {
            var n = (l ? b[0] : b[1]) + c;
            var m = b[0] + c;
            f = !!l;
          } else !d && a[g] && a[g].isNull && (n = m = u);
          "undefined" !== typeof n && (y.push({
            plotX: e,
            plotY: null === n ? k : h.getThreshold(n),
            isNull: f,
            isCliff: !0
          }), t.push({
            plotX: e,
            plotY: null === m ? k : h.getThreshold(m),
            doCurve: !1
          }));
        };
        a = a || this.points;
        d && (a = this.getStackPoints(a));
        for (q = 0; q < a.length; q++) {
          d || (a[q].leftCliff = a[q].rightCliff = a[q].leftNull = a[q].rightNull = void 0);
          var l = a[q].isNull;
          var e = p(a[q].rectPlotX, a[q].plotX);
          var g = d ? p(a[q].yBottom, k) : k;
          if (!l || f) f || w(q, q - 1, "left"), l && !d && f || (y.push(a[q]), t.push({
            x: q,
            plotX: e,
            plotY: g
          })), f || w(q, q + 1, "right");
        }
        q = c.call(this, y, !0, !0);
        t.reversed = !0;
        l = c.call(this, t, !0, !0);
        (g = l[0]) && "M" === g[0] && (l[0] = ["L", g[1], g[2]]);
        l = q.concat(l);
        l.length && l.push(["Z"]);
        c = c.call(this, y, !1, f);
        l.xMap = q.xMap;
        this.areaPath = l;
        return c;
      };
      c.prototype.getStackPoints = function (a) {
        var c = this,
          f = [],
          d = [],
          h = this.xAxis,
          t = this.yAxis,
          y = t.stacking.stacks[this.stackKey],
          E = {},
          v = t.series,
          z = v.length,
          u = t.options.reversedStacks ? 1 : -1,
          k = v.indexOf(c);
        a = a || this.points;
        if (this.options.stacking) {
          for (var w = 0; w < a.length; w++) a[w].leftNull = a[w].rightNull = void 0, E[a[w].x] = a[w];
          q(y, function (a, g) {
            null !== a.total && d.push(g);
          });
          d.sort(function (a, g) {
            return a - g;
          });
          var l = v.map(function (a) {
            return a.visible;
          });
          d.forEach(function (a, g) {
            var b = 0,
              e,
              n;
            if (E[a] && !E[a].isNull) f.push(E[a]), [-1, 1].forEach(function (b) {
              var f = 1 === b ? "rightNull" : "leftNull",
                r = 0,
                x = y[d[g + b]];
              if (x) for (var h = k; 0 <= h && h < z;) {
                var m = v[h].index;
                e = x.points[m];
                e || (m === c.index ? E[a][f] = !0 : l[h] && (n = y[a].points[m]) && (r -= n[1] - n[0]));
                h += u;
              }
              E[a][1 === b ? "rightCliff" : "leftCliff"] = r;
            });else {
              for (var r = k; 0 <= r && r < z;) {
                if (e = y[a].points[v[r].index]) {
                  b = e[1];
                  break;
                }
                r += u;
              }
              b = p(b, 0);
              b = t.translate(b, 0, 1, 0, 1);
              f.push({
                isNull: !0,
                plotX: h.translate(a, 0, 0, 0, 1),
                x: a,
                plotY: b,
                yBottom: b
              });
            }
          });
        }
        return f;
      };
      c.defaultOptions = y(H.defaultOptions, {
        threshold: 0
      });
      return c;
    }(H);
    d(F.prototype, {
      singleStacks: !1,
      drawLegendSymbol: h.drawRectangle
    });
    A.registerSeriesType("area", F);
    "";
    return F;
  });
  N(h, "Series/Spline/SplineSeries.js", [h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h) {
    var E = this && this.__extends || function () {
        var d = function (h, q) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, f) {
            d.__proto__ = f;
          } || function (d, f) {
            for (var c in f) f.hasOwnProperty(c) && (d[c] = f[c]);
          };
          return d(h, q);
        };
        return function (h, q) {
          function p() {
            this.constructor = h;
          }
          d(h, q);
          h.prototype = null === q ? Object.create(q) : (p.prototype = q.prototype, new p());
        };
      }(),
      F = d.seriesTypes.line,
      t = h.merge,
      G = h.pick;
    h = function (d) {
      function h() {
        var h = null !== d && d.apply(this, arguments) || this;
        h.data = void 0;
        h.options = void 0;
        h.points = void 0;
        return h;
      }
      E(h, d);
      h.prototype.getPointSpline = function (d, h, f) {
        var c = h.plotX || 0,
          a = h.plotY || 0,
          n = d[f - 1];
        f = d[f + 1];
        if (n && !n.isNull && !1 !== n.doCurve && !h.isCliff && f && !f.isNull && !1 !== f.doCurve && !h.isCliff) {
          d = n.plotY || 0;
          var m = f.plotX || 0;
          f = f.plotY || 0;
          var p = 0;
          var q = (1.5 * c + (n.plotX || 0)) / 2.5;
          var t = (1.5 * a + d) / 2.5;
          m = (1.5 * c + m) / 2.5;
          var y = (1.5 * a + f) / 2.5;
          m !== q && (p = (y - t) * (m - c) / (m - q) + a - y);
          t += p;
          y += p;
          t > d && t > a ? (t = Math.max(d, a), y = 2 * a - t) : t < d && t < a && (t = Math.min(d, a), y = 2 * a - t);
          y > f && y > a ? (y = Math.max(f, a), t = 2 * a - y) : y < f && y < a && (y = Math.min(f, a), t = 2 * a - y);
          h.rightContX = m;
          h.rightContY = y;
        }
        h = ["C", G(n.rightContX, n.plotX, 0), G(n.rightContY, n.plotY, 0), G(q, c, 0), G(t, a, 0), c, a];
        n.rightContX = n.rightContY = void 0;
        return h;
      };
      h.defaultOptions = t(F.defaultOptions);
      return h;
    }(F);
    d.registerSeriesType("spline", h);
    "";
    return h;
  });
  N(h, "Series/AreaSpline/AreaSplineSeries.js", [h["Series/Area/AreaSeries.js"], h["Series/Spline/SplineSeries.js"], h["Core/Legend/LegendSymbol.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A, F, t) {
    var E = this && this.__extends || function () {
        var d = function (f, c) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);
          };
          return d(f, c);
        };
        return function (f, c) {
          function a() {
            this.constructor = f;
          }
          d(f, c);
          f.prototype = null === c ? Object.create(c) : (a.prototype = c.prototype, new a());
        };
      }(),
      H = d.prototype,
      y = t.extend,
      q = t.merge;
    t = function (p) {
      function f() {
        var c = null !== p && p.apply(this, arguments) || this;
        c.data = void 0;
        c.points = void 0;
        c.options = void 0;
        return c;
      }
      E(f, p);
      f.defaultOptions = q(h.defaultOptions, d.defaultOptions);
      return f;
    }(h);
    y(t.prototype, {
      getGraphPath: H.getGraphPath,
      getStackPoints: H.getStackPoints,
      drawGraph: H.drawGraph,
      drawLegendSymbol: A.drawRectangle
    });
    F.registerSeriesType("areaspline", t);
    "";
    return t;
  });
  N(h, "Series/Column/ColumnSeries.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/Color/Color.js"], h["Core/Globals.js"], h["Core/Legend/LegendSymbol.js"], h["Core/Series/Series.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G, H) {
    var y = this && this.__extends || function () {
        var a = function (c, f) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
          };
          return a(c, f);
        };
        return function (c, f) {
          function d() {
            this.constructor = c;
          }
          a(c, f);
          c.prototype = null === f ? Object.create(f) : (d.prototype = f.prototype, new d());
        };
      }(),
      q = d.animObject,
      p = h.parse,
      f = A.hasTouch;
    d = A.noop;
    var c = H.clamp,
      a = H.css,
      n = H.defined,
      m = H.extend,
      D = H.fireEvent,
      C = H.isArray,
      I = H.isNumber,
      E = H.merge,
      K = H.pick,
      v = H.objectEach;
    H = function (d) {
      function h() {
        var a = null !== d && d.apply(this, arguments) || this;
        a.borderWidth = void 0;
        a.data = void 0;
        a.group = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      y(h, d);
      h.prototype.animate = function (a) {
        var f = this,
          d = this.yAxis,
          e = f.options,
          g = this.chart.inverted,
          b = {},
          k = g ? "translateX" : "translateY";
        if (a) b.scaleY = .001, a = c(d.toPixels(e.threshold), d.pos, d.pos + d.len), g ? b.translateX = a - d.len : b.translateY = a, f.clipBox && f.setClip(), f.group.attr(b);else {
          var h = Number(f.group.attr(k));
          f.group.animate({
            scaleY: 1
          }, m(q(f.options.animation), {
            step: function (a, e) {
              f.group && (b[k] = h + e.pos * (d.pos - h), f.group.attr(b));
            }
          }));
        }
      };
      h.prototype.init = function (a, c) {
        d.prototype.init.apply(this, arguments);
        var f = this;
        a = f.chart;
        a.hasRendered && a.series.forEach(function (a) {
          a.type === f.type && (a.isDirty = !0);
        });
      };
      h.prototype.getColumnMetrics = function () {
        var a = this,
          c = a.options,
          f = a.xAxis,
          e = a.yAxis,
          g = f.options.reversedStacks;
        g = f.reversed && !g || !f.reversed && g;
        var b = {},
          d,
          h = 0;
        !1 === c.grouping ? h = 1 : a.chart.series.forEach(function (c) {
          var g = c.yAxis,
            f = c.options;
          if (c.type === a.type && (c.visible || !a.chart.options.chart.ignoreHiddenSeries) && e.len === g.len && e.pos === g.pos) {
            if (f.stacking && "group" !== f.stacking) {
              d = c.stackKey;
              "undefined" === typeof b[d] && (b[d] = h++);
              var k = b[d];
            } else !1 !== f.grouping && (k = h++);
            c.columnIndex = k;
          }
        });
        var r = Math.min(Math.abs(f.transA) * (f.ordinal && f.ordinal.slope || c.pointRange || f.closestPointRange || f.tickInterval || 1), f.len),
          n = r * c.groupPadding,
          m = (r - 2 * n) / (h || 1);
        c = Math.min(c.maxPointWidth || f.len, K(c.pointWidth, m * (1 - 2 * c.pointPadding)));
        a.columnMetrics = {
          width: c,
          offset: (m - c) / 2 + (n + ((a.columnIndex || 0) + (g ? 1 : 0)) * m - r / 2) * (g ? -1 : 1),
          paddedWidth: m,
          columnCount: h
        };
        return a.columnMetrics;
      };
      h.prototype.crispCol = function (a, c, f, e) {
        var g = this.chart,
          b = this.borderWidth,
          d = -(b % 2 ? .5 : 0);
        b = b % 2 ? .5 : 1;
        g.inverted && g.renderer.isVML && (b += 1);
        this.options.crisp && (f = Math.round(a + f) + d, a = Math.round(a) + d, f -= a);
        e = Math.round(c + e) + b;
        d = .5 >= Math.abs(c) && .5 < e;
        c = Math.round(c) + b;
        e -= c;
        d && e && (--c, e += 1);
        return {
          x: a,
          y: c,
          width: f,
          height: e
        };
      };
      h.prototype.adjustForMissingColumns = function (a, c, f, e) {
        var g = this,
          b = this.options.stacking;
        if (!f.isNull && 1 < e.columnCount) {
          var d = 0,
            k = 0;
          v(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {
            if ("number" === typeof f.x && (a = a[f.x.toString()])) {
              var e = a.points[g.index],
                c = a.total;
              b ? (e && (d = k), a.hasValidPoints && k++) : C(e) && (d = e[1], k = c || 0);
            }
          });
          a = (f.plotX || 0) + ((k - 1) * e.paddedWidth + c) / 2 - c - d * e.paddedWidth;
        }
        return a;
      };
      h.prototype.translate = function () {
        var a = this,
          f = a.chart,
          d = a.options,
          e = a.dense = 2 > a.closestPointRange * a.xAxis.transA;
        e = a.borderWidth = K(d.borderWidth, e ? 0 : 1);
        var g = a.xAxis,
          b = a.yAxis,
          h = d.threshold,
          m = a.translatedThreshold = b.getThreshold(h),
          r = K(d.minPointLength, 5),
          x = a.getColumnMetrics(),
          p = x.width,
          u = a.pointXOffset = x.offset,
          q = a.dataMin,
          v = a.dataMax,
          z = a.barW = Math.max(p, 1 + 2 * e);
        f.inverted && (m -= .5);
        d.pointPadding && (z = Math.ceil(z));
        t.prototype.translate.apply(a);
        a.points.forEach(function (e) {
          var k = K(e.yBottom, m),
            l = 999 + Math.abs(k),
            B = e.plotX || 0;
          l = c(e.plotY, -l, b.len + l);
          var w = Math.min(l, k),
            J = Math.max(l, k) - w,
            M = p,
            D = B + u,
            t = z;
          r && Math.abs(J) < r && (J = r, B = !b.reversed && !e.negative || b.reversed && e.negative, I(h) && I(v) && e.y === h && v <= h && (b.min || 0) < h && (q !== v || (b.max || 0) <= h) && (B = !B), w = Math.abs(w - m) > r ? k - r : m - (B ? r : 0));
          n(e.options.pointWidth) && (M = t = Math.ceil(e.options.pointWidth), D -= Math.round((M - p) / 2));
          d.centerInCategory && (D = a.adjustForMissingColumns(D, M, e, x));
          e.barX = D;
          e.pointWidth = M;
          e.tooltipPos = f.inverted ? [c(b.len + b.pos - f.plotLeft - l, b.pos - f.plotLeft, b.len + b.pos - f.plotLeft), g.len + g.pos - f.plotTop - D - t / 2, J] : [g.left - f.plotLeft + D + t / 2, c(l + b.pos - f.plotTop, b.pos - f.plotTop, b.len + b.pos - f.plotTop), J];
          e.shapeType = a.pointClass.prototype.shapeType || "rect";
          e.shapeArgs = a.crispCol.apply(a, e.isNull ? [D, m, t, 0] : [D, w, t, J]);
        });
      };
      h.prototype.drawGraph = function () {
        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
      };
      h.prototype.pointAttribs = function (a, c) {
        var f = this.options,
          e = this.pointAttrToOptions || {},
          g = e.stroke || "borderColor",
          b = e["stroke-width"] || "borderWidth",
          d = a && a.color || this.color,
          k = a && a[g] || f[g] || d;
        e = a && a.options.dashStyle || f.dashStyle;
        var r = a && a[b] || f[b] || this[b] || 0,
          h = K(a && a.opacity, f.opacity, 1);
        if (a && this.zones.length) {
          var n = a.getZone();
          d = a.options.color || n && (n.color || a.nonZonedColor) || this.color;
          n && (k = n.borderColor || k, e = n.dashStyle || e, r = n.borderWidth || r);
        }
        c && a && (a = E(f.states[c], a.options.states && a.options.states[c] || {}), c = a.brightness, d = a.color || "undefined" !== typeof c && p(d).brighten(a.brightness).get() || d, k = a[g] || k, r = a[b] || r, e = a.dashStyle || e, h = K(a.opacity, h));
        g = {
          fill: d,
          stroke: k,
          "stroke-width": r,
          opacity: h
        };
        e && (g.dashstyle = e);
        return g;
      };
      h.prototype.drawPoints = function () {
        var a = this,
          c = this.chart,
          f = a.options,
          e = c.renderer,
          g = f.animationLimit || 250,
          b;
        a.points.forEach(function (d) {
          var k = d.graphic,
            l = !!k,
            h = k && c.pointCount < g ? "animate" : "attr";
          if (I(d.plotY) && null !== d.y) {
            b = d.shapeArgs;
            k && d.hasNewShapeType() && (k = k.destroy());
            a.enabledDataSorting && (d.startXPos = a.xAxis.reversed ? -(b ? b.width || 0 : 0) : a.xAxis.width);
            k || (d.graphic = k = e[d.shapeType](b).add(d.group || a.group)) && a.enabledDataSorting && c.hasRendered && c.pointCount < g && (k.attr({
              x: d.startXPos
            }), l = !0, h = "animate");
            if (k && l) k[h](E(b));
            if (f.borderRadius) k[h]({
              r: f.borderRadius
            });
            c.styledMode || k[h](a.pointAttribs(d, d.selected && "select")).shadow(!1 !== d.allowShadow && f.shadow, null, f.stacking && !f.borderRadius);
            k && (k.addClass(d.getClassName(), !0), k.attr({
              visibility: d.visible ? "inherit" : "hidden"
            }));
          } else k && (d.graphic = k.destroy());
        });
      };
      h.prototype.drawTracker = function () {
        var c = this,
          d = c.chart,
          l = d.pointer,
          e = function (b) {
            var a = l.getPointFromEvent(b);
            "undefined" !== typeof a && (l.isDirectTouch = !0, a.onMouseOver(b));
          },
          g;
        c.points.forEach(function (b) {
          g = C(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];
          b.graphic && (b.graphic.element.point = b);
          g.forEach(function (a) {
            a.div ? a.div.point = b : a.element.point = b;
          });
        });
        c._hasTracking || (c.trackerGroups.forEach(function (b) {
          if (c[b]) {
            c[b].addClass("highcharts-tracker").on("mouseover", e).on("mouseout", function (b) {
              l.onTrackerMouseOut(b);
            });
            if (f) c[b].on("touchstart", e);
            !d.styledMode && c.options.cursor && c[b].css(a).css({
              cursor: c.options.cursor
            });
          }
        }), c._hasTracking = !0);
        D(this, "afterDrawTracker");
      };
      h.prototype.remove = function () {
        var a = this,
          c = a.chart;
        c.hasRendered && c.series.forEach(function (c) {
          c.type === a.type && (c.isDirty = !0);
        });
        t.prototype.remove.apply(a, arguments);
      };
      h.defaultOptions = E(t.defaultOptions, {
        borderRadius: 0,
        centerInCategory: !1,
        groupPadding: .2,
        marker: null,
        pointPadding: .1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
          hover: {
            halo: !1,
            brightness: .1
          },
          select: {
            color: "#cccccc",
            borderColor: "#000000"
          }
        },
        dataLabels: {
          align: void 0,
          verticalAlign: void 0,
          y: void 0
        },
        startFromThreshold: !0,
        stickyTracking: !1,
        tooltip: {
          distance: 6
        },
        threshold: 0,
        borderColor: "#ffffff"
      });
      return h;
    }(t);
    m(H.prototype, {
      cropShoulder: 0,
      directTouch: !0,
      drawLegendSymbol: F.drawRectangle,
      getSymbol: d,
      negStacks: !0,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    G.registerSeriesType("column", H);
    "";
    "";
    return H;
  });
  N(h, "Core/Series/DataLabel.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/FormatUtilities.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = d.getDeferredAnimation,
      t = h.format,
      G = A.defined,
      H = A.extend,
      y = A.fireEvent,
      q = A.isArray,
      p = A.merge,
      f = A.objectEach,
      c = A.pick,
      a = A.splat,
      n;
    (function (d) {
      function h(a, f, d, l, e) {
        var g = this,
          b = this.chart,
          k = this.isCartesian && b.inverted,
          h = this.enabledDataSorting,
          r = c(a.dlBox && a.dlBox.centerX, a.plotX, -9999),
          n = c(a.plotY, -9999),
          m = f.getBBox(),
          p = d.rotation,
          u = d.align,
          q = b.isInsidePlot(r, Math.round(n), {
            inverted: k,
            paneCoordinates: !0,
            series: g
          }),
          w = function (b) {
            h && g.xAxis && !v && g.setDataLabelStartPos(a, f, e, q, b);
          },
          v = "justify" === c(d.overflow, h ? "none" : "justify"),
          z = this.visible && !1 !== a.visible && (a.series.forceDL || h && !v || q || c(d.inside, !!this.options.stacking) && l && b.isInsidePlot(r, k ? l.x + 1 : l.y + l.height - 1, {
            inverted: k,
            paneCoordinates: !0,
            series: g
          }));
        if (z) {
          var D = b.renderer.fontMetrics(b.styledMode ? void 0 : d.style.fontSize, f).b;
          l = H({
            x: k ? this.yAxis.len - n : r,
            y: Math.round(k ? this.xAxis.len - r : n),
            width: 0,
            height: 0
          }, l);
          H(d, {
            width: m.width,
            height: m.height
          });
          p ? (v = !1, r = b.renderer.rotCorr(D, p), r = {
            x: l.x + (d.x || 0) + l.width / 2 + r.x,
            y: l.y + (d.y || 0) + {
              top: 0,
              middle: .5,
              bottom: 1
            }[d.verticalAlign] * l.height
          }, w(r), f[e ? "attr" : "animate"](r).attr({
            align: u
          }), w = (p + 720) % 360, w = 180 < w && 360 > w, "left" === u ? r.y -= w ? m.height : 0 : "center" === u ? (r.x -= m.width / 2, r.y -= m.height / 2) : "right" === u && (r.x -= m.width, r.y -= w ? 0 : m.height), f.placed = !0, f.alignAttr = r) : (w(l), f.align(d, void 0, l), r = f.alignAttr);
          v && 0 <= l.height ? this.justifyDataLabel(f, d, r, m, l, e) : c(d.crop, !0) && (z = b.isInsidePlot(r.x, r.y, {
            paneCoordinates: !0,
            series: g
          }) && b.isInsidePlot(r.x + m.width, r.y + m.height, {
            paneCoordinates: !0,
            series: g
          }));
          if (d.shape && !p) f[e ? "attr" : "animate"]({
            anchorX: k ? b.plotWidth - a.plotY : a.plotX,
            anchorY: k ? b.plotHeight - a.plotX : a.plotY
          });
        }
        e && h && (f.placed = !1);
        z || h && !v || (f.hide(!0), f.placed = !1);
      }
      function n(a, c) {
        var f = c.filter;
        return f ? (c = f.operator, a = a[f.property], f = f.value, ">" === c && a > f || "<" === c && a < f || ">=" === c && a >= f || "<=" === c && a <= f || "==" === c && a == f || "===" === c && a === f ? !0 : !1) : !0;
      }
      function m() {
        var d = this,
          k = d.chart,
          h = d.options,
          l = d.points,
          e = d.hasRendered || 0,
          g = k.renderer,
          b = h.dataLabels,
          m,
          p = b.animation;
        p = b.defer ? E(k, p, d) : {
          defer: 0,
          duration: 0
        };
        b = K(K(k.options.plotOptions && k.options.plotOptions.series && k.options.plotOptions.series.dataLabels, k.options.plotOptions && k.options.plotOptions[d.type] && k.options.plotOptions[d.type].dataLabels), b);
        y(this, "drawDataLabels");
        if (q(b) || b.enabled || d._hasPointLabels) {
          var r = d.plotGroup("dataLabelsGroup", "data-labels", e ? "inherit" : "hidden", b.zIndex || 6);
          r.attr({
            opacity: +e
          });
          !e && (e = d.dataLabelsGroup) && (d.visible && r.show(!0), e[h.animation ? "animate" : "attr"]({
            opacity: 1
          }, p));
          l.forEach(function (e) {
            m = a(K(b, e.dlOptions || e.options && e.options.dataLabels));
            m.forEach(function (b, a) {
              var l = b.enabled && (!e.isNull || e.dataLabelOnNull) && n(e, b),
                m = e.connectors ? e.connectors[a] : e.connector,
                p = e.dataLabels ? e.dataLabels[a] : e.dataLabel,
                x = c(b.distance, e.labelDistance),
                u = !p;
              if (l) {
                var B = e.getLabelConfig();
                var q = c(b[e.formatPrefix + "Format"], b.format);
                B = G(q) ? t(q, B, k) : (b[e.formatPrefix + "Formatter"] || b.formatter).call(B, b);
                q = b.style;
                var w = b.rotation;
                k.styledMode || (q.color = c(b.color, q.color, d.color, "#000000"), "contrast" === q.color ? (e.contrastColor = g.getContrast(e.color || d.color), q.color = !G(x) && b.inside || 0 > x || h.stacking ? e.contrastColor : "#000000") : delete e.contrastColor, h.cursor && (q.cursor = h.cursor));
                var v = {
                  r: b.borderRadius || 0,
                  rotation: w,
                  padding: b.padding,
                  zIndex: 1
                };
                k.styledMode || (v.fill = b.backgroundColor, v.stroke = b.borderColor, v["stroke-width"] = b.borderWidth);
                f(v, function (b, a) {
                  "undefined" === typeof b && delete v[a];
                });
              }
              !p || l && G(B) && !!p.div === !!b.useHTML || (e.dataLabel = p = e.dataLabel && e.dataLabel.destroy(), e.dataLabels && (1 === e.dataLabels.length ? delete e.dataLabels : delete e.dataLabels[a]), a || delete e.dataLabel, m && (e.connector = e.connector.destroy(), e.connectors && (1 === e.connectors.length ? delete e.connectors : delete e.connectors[a])));
              l && G(B) && (p ? v.text = B : (e.dataLabels = e.dataLabels || [], p = e.dataLabels[a] = w ? g.text(B, 0, -9999, b.useHTML).addClass("highcharts-data-label") : g.label(B, 0, -9999, b.shape, null, null, b.useHTML, null, "data-label"), a || (e.dataLabel = p), p.addClass(" highcharts-data-label-color-" + e.colorIndex + " " + (b.className || "") + (b.useHTML ? " highcharts-tracker" : ""))), p.options = b, p.attr(v), k.styledMode || p.css(q).shadow(b.shadow), p.added || p.add(r), b.textPath && !b.useHTML && (p.setTextPath(e.getDataLabelPath && e.getDataLabelPath(p) || e.graphic, b.textPath), e.dataLabelPath && !b.textPath.enabled && (e.dataLabelPath = e.dataLabelPath.destroy())), d.alignDataLabel(e, p, b, null, u));
            });
          });
        }
        y(this, "afterDrawDataLabels");
      }
      function A(a, c, f, d, e, g) {
        var b = this.chart,
          k = c.align,
          l = c.verticalAlign,
          r = a.box ? 0 : a.padding || 0,
          h = c.x;
        h = void 0 === h ? 0 : h;
        var n = c.y;
        n = void 0 === n ? 0 : n;
        var m = (f.x || 0) + r;
        if (0 > m) {
          "right" === k && 0 <= h ? (c.align = "left", c.inside = !0) : h -= m;
          var p = !0;
        }
        m = (f.x || 0) + d.width - r;
        m > b.plotWidth && ("left" === k && 0 >= h ? (c.align = "right", c.inside = !0) : h += b.plotWidth - m, p = !0);
        m = f.y + r;
        0 > m && ("bottom" === l && 0 <= n ? (c.verticalAlign = "top", c.inside = !0) : n -= m, p = !0);
        m = (f.y || 0) + d.height - r;
        m > b.plotHeight && ("top" === l && 0 >= n ? (c.verticalAlign = "bottom", c.inside = !0) : n += b.plotHeight - m, p = !0);
        p && (c.x = h, c.y = n, a.placed = !g, a.align(c, void 0, e));
        return p;
      }
      function K(a, c) {
        var f = [],
          d;
        if (q(a) && !q(c)) f = a.map(function (a) {
          return p(a, c);
        });else if (q(c) && !q(a)) f = c.map(function (e) {
          return p(a, e);
        });else if (q(a) || q(c)) for (d = Math.max(a.length, c.length); d--;) f[d] = p(a[d], c[d]);else f = p(a, c);
        return f;
      }
      function v(a, c, f, d, e) {
        var g = this.chart,
          b = g.inverted,
          k = this.xAxis,
          l = k.reversed,
          r = b ? c.height / 2 : c.width / 2;
        a = (a = a.pointWidth) ? a / 2 : 0;
        c.startXPos = b ? e.x : l ? -r - a : k.width - r + a;
        c.startYPos = b ? l ? this.yAxis.height - r + a : -r - a : e.y;
        d ? "hidden" === c.visibility && (c.show(), c.attr({
          opacity: 0
        }).animate({
          opacity: 1
        })) : c.attr({
          opacity: 1
        }).animate({
          opacity: 0
        }, void 0, c.hide);
        g.hasRendered && (f && c.attr({
          x: c.startXPos,
          y: c.startYPos
        }), c.placed = !0);
      }
      var z = [];
      d.compose = function (a) {
        if (-1 === z.indexOf(a)) {
          var c = a.prototype;
          z.push(a);
          c.alignDataLabel = h;
          c.drawDataLabels = m;
          c.justifyDataLabel = A;
          c.setDataLabelStartPos = v;
        }
      };
    })(n || (n = {}));
    "";
    return n;
  });
  N(h, "Series/Column/ColumnDataLabel.js", [h["Core/Series/DataLabel.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = h.series,
      t = A.merge,
      G = A.pick,
      H;
    (function (h) {
      function q(f, c, a, d, h) {
        var n = this.chart.inverted,
          m = f.series,
          p = (m.xAxis ? m.xAxis.len : this.chart.plotSizeX) || 0;
        m = (m.yAxis ? m.yAxis.len : this.chart.plotSizeY) || 0;
        var q = f.dlBox || f.shapeArgs,
          y = G(f.below, f.plotY > G(this.translatedThreshold, m)),
          v = G(a.inside, !!this.options.stacking);
        q && (d = t(q), 0 > d.y && (d.height += d.y, d.y = 0), q = d.y + d.height - m, 0 < q && q < d.height && (d.height -= q), n && (d = {
          x: m - d.y - d.height,
          y: p - d.x - d.width,
          width: d.height,
          height: d.width
        }), v || (n ? (d.x += y ? 0 : d.width, d.width = 0) : (d.y += y ? d.height : 0, d.height = 0)));
        a.align = G(a.align, !n || v ? "center" : y ? "right" : "left");
        a.verticalAlign = G(a.verticalAlign, n || v ? "middle" : y ? "top" : "bottom");
        E.prototype.alignDataLabel.call(this, f, c, a, d, h);
        a.inside && f.contrastColor && c.css({
          color: f.contrastColor
        });
      }
      var p = [];
      h.compose = function (f) {
        d.compose(E);
        -1 === p.indexOf(f) && (p.push(f), f.prototype.alignDataLabel = q);
      };
    })(H || (H = {}));
    return H;
  });
  N(h, "Series/Bar/BarSeries.js", [h["Series/Column/ColumnSeries.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = this && this.__extends || function () {
        var d = function (h, q) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, f) {
            d.__proto__ = f;
          } || function (d, f) {
            for (var c in f) f.hasOwnProperty(c) && (d[c] = f[c]);
          };
          return d(h, q);
        };
        return function (h, q) {
          function p() {
            this.constructor = h;
          }
          d(h, q);
          h.prototype = null === q ? Object.create(q) : (p.prototype = q.prototype, new p());
        };
      }(),
      t = A.extend,
      G = A.merge;
    A = function (h) {
      function t() {
        var d = null !== h && h.apply(this, arguments) || this;
        d.data = void 0;
        d.options = void 0;
        d.points = void 0;
        return d;
      }
      E(t, h);
      t.defaultOptions = G(d.defaultOptions, {});
      return t;
    }(d);
    t(A.prototype, {
      inverted: !0
    });
    h.registerSeriesType("bar", A);
    "";
    return A;
  });
  N(h, "Series/Scatter/ScatterSeries.js", [h["Series/Column/ColumnSeries.js"], h["Series/Line/LineSeries.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A, F) {
    var t = this && this.__extends || function () {
        var d = function (h, f) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (c, a) {
            c.__proto__ = a;
          } || function (c, a) {
            for (var f in a) a.hasOwnProperty(f) && (c[f] = a[f]);
          };
          return d(h, f);
        };
        return function (h, f) {
          function c() {
            this.constructor = h;
          }
          d(h, f);
          h.prototype = null === f ? Object.create(f) : (c.prototype = f.prototype, new c());
        };
      }(),
      E = F.addEvent,
      H = F.extend,
      y = F.merge;
    F = function (d) {
      function p() {
        var f = null !== d && d.apply(this, arguments) || this;
        f.data = void 0;
        f.options = void 0;
        f.points = void 0;
        return f;
      }
      t(p, d);
      p.prototype.applyJitter = function () {
        var f = this,
          c = this.options.jitter,
          a = this.points.length;
        c && this.points.forEach(function (d, h) {
          ["x", "y"].forEach(function (n, m) {
            var p = "plot" + n.toUpperCase();
            if (c[n] && !d.isNull) {
              var q = f[n + "Axis"];
              var t = c[n] * q.transA;
              if (q && !q.isLog) {
                var v = Math.max(0, d[p] - t);
                q = Math.min(q.len, d[p] + t);
                m = 1E4 * Math.sin(h + m * a);
                d[p] = v + (q - v) * (m - Math.floor(m));
                "x" === n && (d.clientX = d.plotX);
              }
            }
          });
        });
      };
      p.prototype.drawGraph = function () {
        this.options.lineWidth ? d.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
      };
      p.defaultOptions = y(h.defaultOptions, {
        lineWidth: 0,
        findNearestPointBy: "xy",
        jitter: {
          x: 0,
          y: 0
        },
        marker: {
          enabled: !0
        },
        tooltip: {
          headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
          pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
        }
      });
      return p;
    }(h);
    H(F.prototype, {
      drawTracker: d.prototype.drawTracker,
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1
    });
    E(F, "afterTranslate", function () {
      this.applyJitter();
    });
    A.registerSeriesType("scatter", F);
    "";
    return F;
  });
  N(h, "Series/CenteredUtilities.js", [h["Core/Globals.js"], h["Core/Series/Series.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = d.deg2rad,
      t = A.isNumber,
      G = A.pick,
      H = A.relativeLength,
      y;
    (function (d) {
      d.getCenter = function () {
        var d = this.options,
          f = this.chart,
          c = 2 * (d.slicedOffset || 0),
          a = f.plotWidth - 2 * c,
          n = f.plotHeight - 2 * c,
          m = d.center,
          q = Math.min(a, n),
          t = d.size,
          y = d.innerSize || 0;
        "string" === typeof t && (t = parseFloat(t));
        "string" === typeof y && (y = parseFloat(y));
        d = [G(m[0], "50%"), G(m[1], "50%"), G(t && 0 > t ? void 0 : d.size, "100%"), G(y && 0 > y ? void 0 : d.innerSize || 0, "0%")];
        !f.angular || this instanceof h || (d[3] = 0);
        for (m = 0; 4 > m; ++m) t = d[m], f = 2 > m || 2 === m && /%$/.test(t), d[m] = H(t, [a, n, q, d[2]][m]) + (f ? c : 0);
        d[3] > d[2] && (d[3] = d[2]);
        return d;
      };
      d.getStartAndEndRadians = function (d, f) {
        d = t(d) ? d : 0;
        f = t(f) && f > d && 360 > f - d ? f : d + 360;
        return {
          start: E * (d + -90),
          end: E * (f + -90)
        };
      };
    })(y || (y = {}));
    "";
    return y;
  });
  N(h, "Series/Pie/PiePoint.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/Series/Point.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = this && this.__extends || function () {
        var f = function (c, a) {
          f = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);
          };
          return f(c, a);
        };
        return function (c, a) {
          function d() {
            this.constructor = c;
          }
          f(c, a);
          c.prototype = null === a ? Object.create(a) : (d.prototype = a.prototype, new d());
        };
      }(),
      t = d.setAnimation,
      G = A.addEvent,
      H = A.defined;
    d = A.extend;
    var y = A.isNumber,
      q = A.pick,
      p = A.relativeLength;
    h = function (f) {
      function c() {
        var a = null !== f && f.apply(this, arguments) || this;
        a.labelDistance = void 0;
        a.options = void 0;
        a.series = void 0;
        return a;
      }
      E(c, f);
      c.prototype.getConnectorPath = function () {
        var a = this.labelPosition,
          c = this.series.options.dataLabels,
          f = this.connectorShapes,
          d = c.connectorShape;
        f[d] && (d = f[d]);
        return d.call(this, {
          x: a.final.x,
          y: a.final.y,
          alignment: a.alignment
        }, a.connectorPosition, c);
      };
      c.prototype.getTranslate = function () {
        return this.sliced ? this.slicedTranslation : {
          translateX: 0,
          translateY: 0
        };
      };
      c.prototype.haloPath = function (a) {
        var c = this.shapeArgs;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {
          innerR: c.r - 1,
          start: c.start,
          end: c.end
        });
      };
      c.prototype.init = function () {
        var a = this;
        f.prototype.init.apply(this, arguments);
        this.name = q(this.name, "Slice");
        var c = function (c) {
          a.slice("select" === c.type);
        };
        G(this, "select", c);
        G(this, "unselect", c);
        return this;
      };
      c.prototype.isValid = function () {
        return y(this.y) && 0 <= this.y;
      };
      c.prototype.setVisible = function (a, c) {
        var f = this,
          d = this.series,
          h = d.chart,
          n = d.options.ignoreHiddenPoint;
        c = q(c, n);
        a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a, d.options.data[d.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (c) {
          if (f[c]) f[c][a ? "show" : "hide"](a);
        }), this.legendItem && h.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""), n && (d.isDirty = !0), c && h.redraw());
      };
      c.prototype.slice = function (a, c, f) {
        var d = this.series;
        t(f, d.chart);
        q(c, !0);
        this.sliced = this.options.sliced = H(a) ? a : !this.sliced;
        d.options.data[d.data.indexOf(this)] = this.options;
        this.graphic && this.graphic.animate(this.getTranslate());
        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
      };
      return c;
    }(h);
    d(h.prototype, {
      connectorShapes: {
        fixedOffset: function (f, c, a) {
          var d = c.breakAt;
          c = c.touchingSliceAt;
          return [["M", f.x, f.y], a.softConnector ? ["C", f.x + ("left" === f.alignment ? -5 : 5), f.y, 2 * d.x - c.x, 2 * d.y - c.y, d.x, d.y] : ["L", d.x, d.y], ["L", c.x, c.y]];
        },
        straight: function (f, c) {
          c = c.touchingSliceAt;
          return [["M", f.x, f.y], ["L", c.x, c.y]];
        },
        crookedLine: function (f, c, a) {
          c = c.touchingSliceAt;
          var d = this.series,
            h = d.center[0],
            q = d.chart.plotWidth,
            t = d.chart.plotLeft;
          d = f.alignment;
          var y = this.shapeArgs.r;
          a = p(a.crookDistance, 1);
          q = "left" === d ? h + y + (q + t - h - y) * (1 - a) : t + (h - y) * a;
          a = ["L", q, f.y];
          h = !0;
          if ("left" === d ? q > f.x || q < c.x : q < f.x || q > c.x) h = !1;
          f = [["M", f.x, f.y]];
          h && f.push(a);
          f.push(["L", c.x, c.y]);
          return f;
        }
      }
    });
    return h;
  });
  N(h, "Series/Pie/PieSeries.js", [h["Series/CenteredUtilities.js"], h["Series/Column/ColumnSeries.js"], h["Core/Globals.js"], h["Core/Legend/LegendSymbol.js"], h["Series/Pie/PiePoint.js"], h["Core/Series/Series.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Renderer/SVG/Symbols.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G, H, y, q) {
    var p = this && this.__extends || function () {
        var a = function (c, f) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);
          };
          return a(c, f);
        };
        return function (c, f) {
          function d() {
            this.constructor = c;
          }
          a(c, f);
          c.prototype = null === f ? Object.create(f) : (d.prototype = f.prototype, new d());
        };
      }(),
      f = d.getStartAndEndRadians;
    A = A.noop;
    var c = q.clamp,
      a = q.extend,
      n = q.fireEvent,
      m = q.merge,
      D = q.pick,
      C = q.relativeLength;
    q = function (a) {
      function d() {
        var c = null !== a && a.apply(this, arguments) || this;
        c.center = void 0;
        c.data = void 0;
        c.maxLabelDistance = void 0;
        c.options = void 0;
        c.points = void 0;
        return c;
      }
      p(d, a);
      d.prototype.animate = function (a) {
        var c = this,
          f = c.points,
          d = c.startAngleRad;
        a || f.forEach(function (a) {
          var f = a.graphic,
            k = a.shapeArgs;
          f && k && (f.attr({
            r: D(a.startR, c.center && c.center[3] / 2),
            start: d,
            end: d
          }), f.animate({
            r: k.r,
            start: k.start,
            end: k.end
          }, c.options.animation));
        });
      };
      d.prototype.drawEmpty = function () {
        var a = this.startAngleRad,
          c = this.endAngleRad,
          f = this.options;
        if (0 === this.total && this.center) {
          var d = this.center[0];
          var k = this.center[1];
          this.graph || (this.graph = this.chart.renderer.arc(d, k, this.center[1] / 2, 0, a, c).addClass("highcharts-empty-series").add(this.group));
          this.graph.attr({
            d: y.arc(d, k, this.center[2] / 2, 0, {
              start: a,
              end: c,
              innerR: this.center[3] / 2
            })
          });
          this.chart.styledMode || this.graph.attr({
            "stroke-width": f.borderWidth,
            fill: f.fillColor || "none",
            stroke: f.color || "#cccccc"
          });
        } else this.graph && (this.graph = this.graph.destroy());
      };
      d.prototype.drawPoints = function () {
        var a = this.chart.renderer;
        this.points.forEach(function (c) {
          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
          c.graphic || (c.graphic = a[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
        });
      };
      d.prototype.generatePoints = function () {
        a.prototype.generatePoints.call(this);
        this.updateTotals();
      };
      d.prototype.getX = function (a, f, d) {
        var h = this.center,
          k = this.radii ? this.radii[d.index] || 0 : h[2] / 2;
        a = Math.asin(c((a - h[1]) / (k + d.labelDistance), -1, 1));
        return h[0] + (f ? -1 : 1) * Math.cos(a) * (k + d.labelDistance) + (0 < d.labelDistance ? (f ? -1 : 1) * this.options.dataLabels.padding : 0);
      };
      d.prototype.hasData = function () {
        return !!this.processedXData.length;
      };
      d.prototype.redrawPoints = function () {
        var a = this,
          c = a.chart,
          f = c.renderer,
          d = a.options.shadow,
          k,
          h,
          l,
          e;
        this.drawEmpty();
        !d || a.shadowGroup || c.styledMode || (a.shadowGroup = f.g("shadow").attr({
          zIndex: -1
        }).add(a.group));
        a.points.forEach(function (g) {
          var b = {};
          h = g.graphic;
          if (!g.isNull && h) {
            var n = void 0;
            e = g.shapeArgs;
            k = g.getTranslate();
            c.styledMode || (n = g.shadowGroup, d && !n && (n = g.shadowGroup = f.g("shadow").add(a.shadowGroup)), n && n.attr(k), l = a.pointAttribs(g, g.selected && "select"));
            g.delayedRendering ? (h.setRadialReference(a.center).attr(e).attr(k), c.styledMode || h.attr(l).attr({
              "stroke-linejoin": "round"
            }).shadow(d, n), g.delayedRendering = !1) : (h.setRadialReference(a.center), c.styledMode || m(!0, b, l), m(!0, b, e, k), h.animate(b));
            h.attr({
              visibility: g.visible ? "inherit" : "hidden"
            });
            h.addClass(g.getClassName(), !0);
          } else h && (g.graphic = h.destroy());
        });
      };
      d.prototype.sortByAngle = function (a, c) {
        a.sort(function (a, f) {
          return "undefined" !== typeof a.angle && (f.angle - a.angle) * c;
        });
      };
      d.prototype.translate = function (a) {
        this.generatePoints();
        var c = this.options,
          d = c.slicedOffset,
          h = d + (c.borderWidth || 0),
          k = f(c.startAngle, c.endAngle),
          m = this.startAngleRad = k.start;
        k = (this.endAngleRad = k.end) - m;
        var l = this.points,
          e = c.dataLabels.distance;
        c = c.ignoreHiddenPoint;
        var g = l.length,
          b,
          p = 0;
        a || (this.center = a = this.getCenter());
        for (b = 0; b < g; b++) {
          var q = l[b];
          var r = m + p * k;
          !q.isValid() || c && !q.visible || (p += q.percentage / 100);
          var x = m + p * k;
          var M = {
            x: a[0],
            y: a[1],
            r: a[2] / 2,
            innerR: a[3] / 2,
            start: Math.round(1E3 * r) / 1E3,
            end: Math.round(1E3 * x) / 1E3
          };
          q.shapeType = "arc";
          q.shapeArgs = M;
          q.labelDistance = D(q.options.dataLabels && q.options.dataLabels.distance, e);
          q.labelDistance = C(q.labelDistance, M.r);
          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, q.labelDistance);
          x = (x + r) / 2;
          x > 1.5 * Math.PI ? x -= 2 * Math.PI : x < -Math.PI / 2 && (x += 2 * Math.PI);
          q.slicedTranslation = {
            translateX: Math.round(Math.cos(x) * d),
            translateY: Math.round(Math.sin(x) * d)
          };
          M = Math.cos(x) * a[2] / 2;
          var t = Math.sin(x) * a[2] / 2;
          q.tooltipPos = [a[0] + .7 * M, a[1] + .7 * t];
          q.half = x < -Math.PI / 2 || x > Math.PI / 2 ? 1 : 0;
          q.angle = x;
          r = Math.min(h, q.labelDistance / 5);
          q.labelPosition = {
            natural: {
              x: a[0] + M + Math.cos(x) * q.labelDistance,
              y: a[1] + t + Math.sin(x) * q.labelDistance
            },
            "final": {},
            alignment: 0 > q.labelDistance ? "center" : q.half ? "right" : "left",
            connectorPosition: {
              breakAt: {
                x: a[0] + M + Math.cos(x) * r,
                y: a[1] + t + Math.sin(x) * r
              },
              touchingSliceAt: {
                x: a[0] + M,
                y: a[1] + t
              }
            }
          };
        }
        n(this, "afterTranslate");
      };
      d.prototype.updateTotals = function () {
        var a = this.points,
          c = a.length,
          f = this.options.ignoreHiddenPoint,
          d,
          k = 0;
        for (d = 0; d < c; d++) {
          var h = a[d];
          !h.isValid() || f && !h.visible || (k += h.y);
        }
        this.total = k;
        for (d = 0; d < c; d++) h = a[d], h.percentage = 0 < k && (h.visible || !f) ? h.y / k * 100 : 0, h.total = k;
      };
      d.defaultOptions = m(G.defaultOptions, {
        center: [null, null],
        clip: !1,
        colorByPoint: !0,
        dataLabels: {
          allowOverlap: !0,
          connectorPadding: 5,
          connectorShape: "fixedOffset",
          crookDistance: "70%",
          distance: 30,
          enabled: !0,
          formatter: function () {
            return this.point.isNull ? void 0 : this.point.name;
          },
          softConnector: !0,
          x: 0
        },
        fillColor: void 0,
        ignoreHiddenPoint: !0,
        inactiveOtherPoints: !0,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: !1,
        slicedOffset: 10,
        stickyTracking: !1,
        tooltip: {
          followPointer: !0
        },
        borderColor: "#ffffff",
        borderWidth: 1,
        lineWidth: void 0,
        states: {
          hover: {
            brightness: .1
          }
        }
      });
      return d;
    }(G);
    a(q.prototype, {
      axisTypes: [],
      directTouch: !0,
      drawGraph: void 0,
      drawLegendSymbol: F.drawRectangle,
      drawTracker: h.prototype.drawTracker,
      getCenter: d.getCenter,
      getSymbol: A,
      isCartesian: !1,
      noSharedTooltip: !0,
      pointAttribs: h.prototype.pointAttribs,
      pointClass: t,
      requireSorting: !1,
      searchPoint: A,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    H.registerSeriesType("pie", q);
    "";
    return q;
  });
  N(h, "Series/Pie/PieDataLabel.js", [h["Core/Series/DataLabel.js"], h["Core/Globals.js"], h["Core/Renderer/RendererUtilities.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A, F, t) {
    var E = h.noop,
      H = A.distribute,
      y = F.series,
      q = t.arrayMax,
      p = t.clamp,
      f = t.defined,
      c = t.merge,
      a = t.pick,
      n = t.relativeLength,
      m;
    (function (h) {
      function m() {
        var d = this,
          h = d.data,
          k = d.chart,
          m = d.options.dataLabels || {},
          l = m.connectorPadding,
          e = k.plotWidth,
          g = k.plotHeight,
          b = k.plotLeft,
          n = Math.round(k.chartWidth / 3),
          p = d.center,
          r = p[2] / 2,
          x = p[1],
          v = [[], []],
          t = [0, 0, 0, 0],
          D = d.dataLabelPositioners,
          C,
          E,
          A,
          I,
          F,
          G,
          L,
          K,
          N,
          T,
          U,
          S;
        d.visible && (m.enabled || d._hasPointLabels) && (h.forEach(function (b) {
          b.dataLabel && b.visible && b.dataLabel.shortened && (b.dataLabel.attr({
            width: "auto"
          }).css({
            width: "auto",
            textOverflow: "clip"
          }), b.dataLabel.shortened = !1);
        }), y.prototype.drawDataLabels.apply(d), h.forEach(function (b) {
          b.dataLabel && (b.visible ? (v[b.half].push(b), b.dataLabel._pos = null, !f(m.style.width) && !f(b.options.dataLabels && b.options.dataLabels.style && b.options.dataLabels.style.width) && b.dataLabel.getBBox().width > n && (b.dataLabel.css({
            width: Math.round(.7 * n) + "px"
          }), b.dataLabel.shortened = !0)) : (b.dataLabel = b.dataLabel.destroy(), b.dataLabels && 1 === b.dataLabels.length && delete b.dataLabels));
        }), v.forEach(function (c, h) {
          var n = c.length,
            q = [],
            B;
          if (n) {
            d.sortByAngle(c, h - .5);
            if (0 < d.maxLabelDistance) {
              var u = Math.max(0, x - r - d.maxLabelDistance);
              var w = Math.min(x + r + d.maxLabelDistance, k.plotHeight);
              c.forEach(function (b) {
                0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, x - r - b.labelDistance), b.bottom = Math.min(x + r + b.labelDistance, k.plotHeight), B = b.dataLabel.getBBox().height || 21, b.distributeBox = {
                  target: b.labelPosition.natural.y - b.top + B / 2,
                  size: B,
                  rank: b.y
                }, q.push(b.distributeBox));
              });
              u = w + B - u;
              H(q, u, u / 5);
            }
            for (U = 0; U < n; U++) {
              C = c[U];
              G = C.labelPosition;
              I = C.dataLabel;
              T = !1 === C.visible ? "hidden" : "inherit";
              N = u = G.natural.y;
              q && f(C.distributeBox) && ("undefined" === typeof C.distributeBox.pos ? T = "hidden" : (L = C.distributeBox.size, N = D.radialDistributionY(C)));
              delete C.positionIndex;
              if (m.justify) K = D.justify(C, r, p);else switch (m.alignTo) {
                case "connectors":
                  K = D.alignToConnectors(c, h, e, b);
                  break;
                case "plotEdges":
                  K = D.alignToPlotEdges(I, h, e, b);
                  break;
                default:
                  K = D.radialDistributionX(d, C, N, u);
              }
              I._attr = {
                visibility: T,
                align: G.alignment
              };
              S = C.options.dataLabels || {};
              I._pos = {
                x: K + a(S.x, m.x) + ({
                  left: l,
                  right: -l
                }[G.alignment] || 0),
                y: N + a(S.y, m.y) - 10
              };
              G.final.x = K;
              G.final.y = N;
              a(m.crop, !0) && (F = I.getBBox().width, u = null, K - F < l && 1 === h ? (u = Math.round(F - K + l), t[3] = Math.max(u, t[3])) : K + F > e - l && 0 === h && (u = Math.round(K + F - e + l), t[1] = Math.max(u, t[1])), 0 > N - L / 2 ? t[0] = Math.max(Math.round(-N + L / 2), t[0]) : N + L / 2 > g && (t[2] = Math.max(Math.round(N + L / 2 - g), t[2])), I.sideOverflow = u);
            }
          }
        }), 0 === q(t) || this.verifyDataLabelOverflow(t)) && (this.placeDataLabels(), this.points.forEach(function (b) {
          S = c(m, b.options.dataLabels);
          if (E = a(S.connectorWidth, 1)) {
            var e;
            A = b.connector;
            if ((I = b.dataLabel) && I._pos && b.visible && 0 < b.labelDistance) {
              T = I._attr.visibility;
              if (e = !A) b.connector = A = k.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + b.colorIndex + (b.className ? " " + b.className : "")).add(d.dataLabelsGroup), k.styledMode || A.attr({
                "stroke-width": E,
                stroke: S.connectorColor || b.color || "#666666"
              });
              A[e ? "attr" : "animate"]({
                d: b.getConnectorPath()
              });
              A.attr("visibility", T);
            } else A && (b.connector = A.destroy());
          }
        }));
      }
      function t() {
        this.points.forEach(function (a) {
          var c = a.dataLabel,
            f;
          c && a.visible && ((f = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
            width: c._attr.width + "px",
            textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
          }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](f), c.moved = !0) : c && c.attr({
            y: -9999
          }));
          delete a.distributeBox;
        }, this);
      }
      function D(a) {
        var c = this.center,
          f = this.options,
          d = f.center,
          l = f.minSize || 80,
          e = null !== f.size;
        if (!e) {
          if (null !== d[0]) var g = Math.max(c[2] - Math.max(a[1], a[3]), l);else g = Math.max(c[2] - a[1] - a[3], l), c[0] += (a[3] - a[1]) / 2;
          null !== d[1] ? g = p(g, l, c[2] - Math.max(a[0], a[2])) : (g = p(g, l, c[2] - a[0] - a[2]), c[1] += (a[0] - a[2]) / 2);
          g < c[2] ? (c[2] = g, c[3] = Math.min(n(f.innerSize || 0, g), g), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : e = !0;
        }
        return e;
      }
      var A = [],
        v = {
          radialDistributionY: function (a) {
            return a.top + a.distributeBox.pos;
          },
          radialDistributionX: function (a, c, f, d) {
            return a.getX(f < c.top + 2 || f > c.bottom - 2 ? d : f, c.half, c);
          },
          justify: function (a, c, f) {
            return f[0] + (a.half ? -1 : 1) * (c + a.labelDistance);
          },
          alignToPlotEdges: function (a, c, f, d) {
            a = a.getBBox().width;
            return c ? a + d : f - a - d;
          },
          alignToConnectors: function (a, c, f, d) {
            var k = 0,
              e;
            a.forEach(function (a) {
              e = a.dataLabel.getBBox().width;
              e > k && (k = e);
            });
            return c ? k + d : f - k - d;
          }
        };
      h.compose = function (a) {
        d.compose(y);
        -1 === A.indexOf(a) && (A.push(a), a = a.prototype, a.dataLabelPositioners = v, a.alignDataLabel = E, a.drawDataLabels = m, a.placeDataLabels = t, a.verifyDataLabelOverflow = D);
      };
    })(m || (m = {}));
    return m;
  });
  N(h, "Extensions/OverlappingDataLabels.js", [h["Core/Chart/Chart.js"], h["Core/Utilities.js"]], function (d, h) {
    function E(d, f) {
      var c = !1;
      if (d) {
        var a = d.newOpacity;
        d.oldOpacity !== a && (d.alignAttr && d.placed ? (d[a ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), c = !0, d.alignAttr.opacity = a, d[d.isOld ? "animate" : "attr"](d.alignAttr, null, function () {
          f.styledMode || d.css({
            pointerEvents: a ? "auto" : "none"
          });
        }), t(f, "afterHideOverlappingLabel")) : d.attr({
          opacity: a
        }));
        d.isOld = !0;
      }
      return c;
    }
    var F = h.addEvent,
      t = h.fireEvent,
      G = h.isArray,
      H = h.isNumber,
      y = h.objectEach,
      q = h.pick;
    F(d, "render", function () {
      var d = this,
        f = [];
      (this.labelCollectors || []).forEach(function (c) {
        f = f.concat(c());
      });
      (this.yAxis || []).forEach(function (c) {
        c.stacking && c.options.stackLabels && !c.options.stackLabels.allowOverlap && y(c.stacking.stacks, function (a) {
          y(a, function (a) {
            a.label && "hidden" !== a.label.visibility && f.push(a.label);
          });
        });
      });
      (this.series || []).forEach(function (c) {
        var a = c.options.dataLabels;
        c.visible && (!1 !== a.enabled || c._hasPointLabels) && (a = function (a) {
          return a.forEach(function (a) {
            a.visible && (G(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : []).forEach(function (c) {
              var h = c.options;
              c.labelrank = q(h.labelrank, a.labelrank, a.shapeArgs && a.shapeArgs.height);
              h.allowOverlap ? (c.oldOpacity = c.opacity, c.newOpacity = 1, E(c, d)) : f.push(c);
            });
          });
        }, a(c.nodes || []), a(c.points));
      });
      this.hideOverlappingLabels(f);
    });
    d.prototype.hideOverlappingLabels = function (d) {
      var f = this,
        c = d.length,
        a = f.renderer,
        h,
        m,
        p,
        q = !1;
      var y = function (c) {
        var f,
          d = c.box ? 0 : c.padding || 0,
          k = f = 0,
          h;
        if (c && (!c.alignAttr || c.placed)) {
          var l = c.alignAttr || {
            x: c.attr("x"),
            y: c.attr("y")
          };
          var e = c.parentGroup;
          c.width || (f = c.getBBox(), c.width = f.width, c.height = f.height, f = a.fontMetrics(null, c.element).h);
          var g = c.width - 2 * d;
          (h = {
            left: "0",
            center: "0.5",
            right: "1"
          }[c.alignValue]) ? k = +h * g : H(c.x) && Math.round(c.x) !== c.translateX && (k = c.x - c.translateX);
          return {
            x: l.x + (e.translateX || 0) + d - (k || 0),
            y: l.y + (e.translateY || 0) + d - f,
            width: c.width - 2 * d,
            height: c.height - 2 * d
          };
        }
      };
      for (m = 0; m < c; m++) if (h = d[m]) h.oldOpacity = h.opacity, h.newOpacity = 1, h.absoluteBox = y(h);
      d.sort(function (a, c) {
        return (c.labelrank || 0) - (a.labelrank || 0);
      });
      for (m = 0; m < c; m++) {
        var A = (y = d[m]) && y.absoluteBox;
        for (h = m + 1; h < c; ++h) {
          var F = (p = d[h]) && p.absoluteBox;
          !A || !F || y === p || 0 === y.newOpacity || 0 === p.newOpacity || F.x >= A.x + A.width || F.x + F.width <= A.x || F.y >= A.y + A.height || F.y + F.height <= A.y || ((y.labelrank < p.labelrank ? y : p).newOpacity = 0);
        }
      }
      d.forEach(function (a) {
        E(a, f) && (q = !0);
      });
      q && t(f, "afterHideAllOverlappingLabels");
    };
  });
  N(h, "Core/Responsive.js", [h["Core/Utilities.js"]], function (d) {
    var h = d.extend,
      A = d.find,
      F = d.isArray,
      t = d.isObject,
      G = d.merge,
      H = d.objectEach,
      y = d.pick,
      q = d.splat,
      p = d.uniqueKey,
      f;
    (function (c) {
      var a = [];
      c.compose = function (c) {
        -1 === a.indexOf(c) && (a.push(c), h(c.prototype, f.prototype));
        return c;
      };
      var f = function () {
        function a() {}
        a.prototype.currentOptions = function (a) {
          function c(a, d, h, m) {
            var k;
            H(a, function (a, l) {
              if (!m && -1 < f.collectionsWithUpdate.indexOf(l) && d[l]) for (a = q(a), h[l] = [], k = 0; k < Math.max(a.length, d[l].length); k++) d[l][k] && (void 0 === a[k] ? h[l][k] = d[l][k] : (h[l][k] = {}, c(a[k], d[l][k], h[l][k], m + 1)));else t(a) ? (h[l] = F(a) ? [] : {}, c(a, d[l] || {}, h[l], m + 1)) : h[l] = "undefined" === typeof d[l] ? null : d[l];
            });
          }
          var f = this,
            d = {};
          c(a, this.options, d, 0);
          return d;
        };
        a.prototype.matchResponsiveRule = function (a, c) {
          var f = a.condition;
          (f.callback || function () {
            return this.chartWidth <= y(f.maxWidth, Number.MAX_VALUE) && this.chartHeight <= y(f.maxHeight, Number.MAX_VALUE) && this.chartWidth >= y(f.minWidth, 0) && this.chartHeight >= y(f.minHeight, 0);
          }).call(this) && c.push(a._id);
        };
        a.prototype.setResponsive = function (a, c) {
          var f = this,
            d = this.options.responsive,
            h = this.currentResponsive,
            m = [];
          !c && d && d.rules && d.rules.forEach(function (a) {
            "undefined" === typeof a._id && (a._id = p());
            f.matchResponsiveRule(a, m);
          }, this);
          c = G.apply(void 0, m.map(function (a) {
            return A((d || {}).rules || [], function (c) {
              return c._id === a;
            });
          }).map(function (a) {
            return a && a.chartOptions;
          }));
          c.isResponsiveOptions = !0;
          m = m.toString() || void 0;
          m !== (h && h.ruleIds) && (h && this.update(h.undoOptions, a, !0), m ? (h = this.currentOptions(c), h.isResponsiveOptions = !0, this.currentResponsive = {
            ruleIds: m,
            mergedOptions: c,
            undoOptions: h
          }, this.update(c, a, !0)) : this.currentResponsive = void 0);
        };
        return a;
      }();
    })(f || (f = {}));
    "";
    "";
    return f;
  });
  N(h, "masters/highcharts.src.js", [h["Core/Globals.js"], h["Core/Utilities.js"], h["Core/DefaultOptions.js"], h["Core/Animation/Fx.js"], h["Core/Animation/AnimationUtilities.js"], h["Core/Renderer/HTML/AST.js"], h["Core/FormatUtilities.js"], h["Core/Renderer/RendererUtilities.js"], h["Core/Renderer/SVG/SVGElement.js"], h["Core/Renderer/SVG/SVGRenderer.js"], h["Core/Renderer/HTML/HTMLElement.js"], h["Core/Renderer/HTML/HTMLRenderer.js"], h["Core/Axis/Axis.js"], h["Core/Axis/DateTimeAxis.js"], h["Core/Axis/LogarithmicAxis.js"], h["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], h["Core/Axis/Tick.js"], h["Core/Tooltip.js"], h["Core/Series/Point.js"], h["Core/Pointer.js"], h["Core/MSPointer.js"], h["Core/Legend/Legend.js"], h["Core/Chart/Chart.js"], h["Core/Series/Series.js"], h["Core/Series/SeriesRegistry.js"], h["Series/Column/ColumnSeries.js"], h["Series/Column/ColumnDataLabel.js"], h["Series/Pie/PieSeries.js"], h["Series/Pie/PieDataLabel.js"], h["Core/Series/DataLabel.js"], h["Core/Responsive.js"], h["Core/Color/Color.js"], h["Core/Time.js"]], function (d, h, A, F, t, G, H, y, q, p, f, c, a, n, m, D, C, I, L, K, v, z, u, k, w, l, e, g, b, B, J, r, x) {
    d.animate = t.animate;
    d.animObject = t.animObject;
    d.getDeferredAnimation = t.getDeferredAnimation;
    d.setAnimation = t.setAnimation;
    d.stop = t.stop;
    d.timers = F.timers;
    d.AST = G;
    d.Axis = a;
    d.Chart = u;
    d.chart = u.chart;
    d.Fx = F;
    d.Legend = z;
    d.PlotLineOrBand = D;
    d.Point = L;
    d.Pointer = v.isRequired() ? v : K;
    d.Series = k;
    d.SVGElement = q;
    d.SVGRenderer = p;
    d.Tick = C;
    d.Time = x;
    d.Tooltip = I;
    d.Color = r;
    d.color = r.parse;
    c.compose(p);
    f.compose(q);
    d.defaultOptions = A.defaultOptions;
    d.getOptions = A.getOptions;
    d.time = A.defaultTime;
    d.setOptions = A.setOptions;
    d.dateFormat = H.dateFormat;
    d.format = H.format;
    d.numberFormat = H.numberFormat;
    d.addEvent = h.addEvent;
    d.arrayMax = h.arrayMax;
    d.arrayMin = h.arrayMin;
    d.attr = h.attr;
    d.clearTimeout = h.clearTimeout;
    d.correctFloat = h.correctFloat;
    d.createElement = h.createElement;
    d.css = h.css;
    d.defined = h.defined;
    d.destroyObjectProperties = h.destroyObjectProperties;
    d.discardElement = h.discardElement;
    d.distribute = y.distribute;
    d.erase = h.erase;
    d.error = h.error;
    d.extend = h.extend;
    d.extendClass = h.extendClass;
    d.find = h.find;
    d.fireEvent = h.fireEvent;
    d.getMagnitude = h.getMagnitude;
    d.getStyle = h.getStyle;
    d.inArray = h.inArray;
    d.isArray = h.isArray;
    d.isClass = h.isClass;
    d.isDOMElement = h.isDOMElement;
    d.isFunction = h.isFunction;
    d.isNumber = h.isNumber;
    d.isObject = h.isObject;
    d.isString = h.isString;
    d.keys = h.keys;
    d.merge = h.merge;
    d.normalizeTickInterval = h.normalizeTickInterval;
    d.objectEach = h.objectEach;
    d.offset = h.offset;
    d.pad = h.pad;
    d.pick = h.pick;
    d.pInt = h.pInt;
    d.relativeLength = h.relativeLength;
    d.removeEvent = h.removeEvent;
    d.seriesType = w.seriesType;
    d.splat = h.splat;
    d.stableSort = h.stableSort;
    d.syncTimeout = h.syncTimeout;
    d.timeUnits = h.timeUnits;
    d.uniqueKey = h.uniqueKey;
    d.useSerialIds = h.useSerialIds;
    d.wrap = h.wrap;
    e.compose(l);
    B.compose(k);
    n.compose(a);
    m.compose(a);
    b.compose(g);
    D.compose(a);
    J.compose(u);
    return d;
  });
  N(h, "Core/Axis/OrdinalAxis.js", [h["Core/Axis/Axis.js"], h["Core/Globals.js"], h["Core/Series/Series.js"], h["Core/Utilities.js"]], function (d, h, A, F) {
    var t = F.addEvent,
      E = F.correctFloat,
      H = F.css,
      y = F.defined,
      q = F.error,
      p = F.pick,
      f = F.timeUnits,
      c = [],
      a;
    (function (a) {
      function d(a, c, b, d, k, l, h) {
        void 0 === k && (k = []);
        void 0 === l && (l = 0);
        var e = {},
          g = this.options.tickPixelInterval,
          r = this.chart.time,
          m = [],
          n,
          p,
          x = 0,
          B = [],
          u = -Number.MAX_VALUE;
        if (!this.options.ordinal && !this.options.breaks || !k || 3 > k.length || "undefined" === typeof c) return r.getTimeTicks.apply(r, arguments);
        var J = k.length;
        for (n = 0; n < J; n++) {
          var w = n && k[n - 1] > b;
          k[n] < c && (x = n);
          if (n === J - 1 || k[n + 1] - k[n] > 5 * l || w) {
            if (k[n] > u) {
              for (p = r.getTimeTicks(a, k[x], k[n], d); p.length && p[0] <= u;) p.shift();
              p.length && (u = p[p.length - 1]);
              m.push(B.length);
              B = B.concat(p);
            }
            x = n + 1;
          }
          if (w) break;
        }
        if (p) {
          p = p.info;
          if (h && p.unitRange <= f.hour) {
            n = B.length - 1;
            for (x = 1; x < n; x++) if (r.dateFormat("%d", B[x]) !== r.dateFormat("%d", B[x - 1])) {
              e[B[x]] = "day";
              var v = !0;
            }
            v && (e[B[0]] = "day");
            p.higherRanks = e;
          }
          p.segmentStarts = m;
          B.info = p;
        } else q(12, !1, this.chart);
        if (h && y(g)) {
          p = B.length;
          r = [];
          x = [];
          n = void 0;
          for (v = p; v--;) m = this.translate(B[v]), n && (x[v] = n - m), r[v] = n = m;
          x.sort();
          x = x[Math.floor(x.length / 2)];
          x < .6 * g && (x = null);
          v = B[p - 1] > b ? p - 1 : p;
          for (n = void 0; v--;) m = r[v], p = Math.abs(n - m), n && p < .8 * g && (null === x || p < .8 * x) ? (e[B[v]] && !e[B[v + 1]] ? (p = v + 1, n = m) : p = v, B.splice(p, 1)) : n = m;
        }
        return B;
      }
      function n(a) {
        var e = this.ordinal.positions;
        if (!e) return a;
        var b = e.length - 1;
        if (0 > a) a = e[0];else if (a > b) a = e[b];else {
          b = Math.floor(a);
          var c = a - b;
        }
        return "undefined" !== typeof c && "undefined" !== typeof e[b] ? e[b] + (c ? c * (e[b + 1] - e[b]) : 0) : a;
      }
      function C(a) {
        var e = this.ordinal,
          b = e.positions;
        if (!b) return a;
        var c = (a - (this.old ? this.old.min : this.min)) * (this.old ? this.old.transA : this.transA) + this.minPixelPadding;
        0 < c && c < this.left + this.len || (e.extendedOrdinalPositions || (e.extendedOrdinalPositions = e.getExtendedPositions()), b = e.extendedOrdinalPositions);
        if (b && b.length) {
          a = e.getIndexOfPoint(c, b);
          e = E(a % 1);
          if (0 <= a && a < b.length - 1) return b[Math.floor(a)] + e * (b[Math.ceil(a)] - b[Math.floor(a)]);
          e = b.length;
          c = b[0];
          b = b[e - 1];
          var f = (b - c) / (e - 1);
          return 0 > a ? c + f * a : b + f * (a - e);
        }
        return a;
      }
      function I(e, c) {
        var b = a.Additions.findIndexOf(e, c, !0);
        return e[b] === c ? b : b + (c - e[b]) / (e[b + 1] - e[b]);
      }
      function F() {
        this.ordinal || (this.ordinal = new a.Additions(this));
      }
      function G() {
        this.isXAxis && y(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && "navigator" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && y(this.userMin) && (this.min += this.options.overscroll));
      }
      function v() {
        this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);
      }
      function z() {
        this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));
      }
      function u(a) {
        var e = this.xAxis[0],
          b = e.options.overscroll,
          c = a.originalEvent.chartX,
          f = this.options.chart.panning,
          d = !1;
        if (f && "y" !== f.type && e.options.ordinal && e.series.length) {
          var k = this.mouseDownX,
            l = e.getExtremes(),
            h = l.dataMax,
            m = l.min,
            n = l.max,
            p = this.hoverPoints,
            q = e.closestPointRange || e.ordinal && e.ordinal.overscrollPointsRange;
          k = (k - c) / (e.translationSlope * (e.ordinal.slope || q));
          q = {
            ordinal: {
              positions: e.ordinal.getExtendedPositions()
            }
          };
          var u = e.index2val,
            w = e.val2lin,
            v = void 0,
            t = v = void 0,
            z = void 0;
          q.ordinal.positions ? 1 < Math.abs(k) && (p && p.forEach(function (a) {
            a.setState();
          }), 0 > k ? (t = q, z = e.ordinal.positions ? e : q) : (t = e.ordinal.positions ? e : q, z = q), v = z.ordinal.positions, h > v[v.length - 1] && v.push(h), this.fixedRange = n - m, v = e.navigatorAxis.toFixedRange(void 0, void 0, u.apply(t, [w.apply(t, [m, !0]) + k]), u.apply(z, [w.apply(z, [n, !0]) + k])), v.min >= Math.min(l.dataMin, m) && v.max <= Math.max(h, n) + b && e.setExtremes(v.min, v.max, !0, !1, {
            trigger: "pan"
          }), this.mouseDownX = c, H(this.container, {
            cursor: "move"
          })) : d = !0;
        } else d = !0;
        d || f && /y/.test(f.type) ? b && (e.max = e.dataMax + b) : a.preventDefault();
      }
      function k() {
        var a = this.xAxis;
        a && a.options.ordinal && (delete a.ordinal.index, delete a.ordinal.extendedOrdinalPositions);
      }
      function w(a, c) {
        var b = this.ordinal,
          e = b.positions,
          g = b.slope,
          f = b.extendedOrdinalPositions;
        if (!e) return a;
        var d = e.length;
        if (e[0] <= a && e[d - 1] >= a) a = I(e, a);else {
          f || (f = b.getExtendedPositions && b.getExtendedPositions(), b.extendedOrdinalPositions = f);
          if (!f || !f.length) return a;
          d = f.length;
          g || (g = (f[d - 1] - f[0]) / d);
          e = I(f, e[0]);
          a >= f[0] && a <= f[d - 1] ? a = I(f, a) - e : a < f[0] ? (a = f[0] - a, a = -e - a / g) : (a -= f[d - 1], a = a / g + d - e);
        }
        return c ? a : g * (a || 0) + b.offset;
      }
      a.compose = function (a, g, b) {
        if (-1 === c.indexOf(a)) {
          c.push(a);
          var e = a.prototype;
          e.getTimeTicks = d;
          e.index2val = n;
          e.lin2val = C;
          e.val2lin = w;
          e.ordinal2lin = e.val2lin;
          t(a, "afterInit", F);
          t(a, "foundExtremes", G);
          t(a, "afterSetScale", v);
          t(a, "initialAxisTranslation", z);
        }
        -1 === c.indexOf(b) && (c.push(b), t(b, "pan", u));
        -1 === c.indexOf(g) && (c.push(g), t(g, "updatedData", k));
        return a;
      };
      var l = function () {
        function a(a) {
          this.index = {};
          this.axis = a;
        }
        a.prototype.beforeSetTickPositions = function () {
          var a = this.axis,
            b = a.ordinal,
            e = a.getExtremes(),
            c = e.min,
            f = e.max,
            d = a.isXAxis && !!a.options.breaks;
          e = a.options.ordinal;
          var k = a.chart.options.chart.ignoreHiddenSeries,
            l,
            h,
            m = [],
            n = Number.MAX_VALUE,
            q = !1;
          if (e || d) {
            a.series.forEach(function (a, b) {
              l = [];
              if (!(k && !1 === a.visible || !1 === a.takeOrdinalPosition && !d) && (m = m.concat(a.processedXData), u = m.length, m.sort(function (a, b) {
                return a - b;
              }), n = Math.min(n, p(a.closestPointRange, n)), u)) {
                for (b = 0; b < u - 1;) m[b] !== m[b + 1] && l.push(m[b + 1]), b++;
                l[0] !== m[0] && l.unshift(m[0]);
                m = l;
              }
            });
            var u = m.length;
            if (2 < u) {
              var w = m[1] - m[0];
              for (h = u - 1; h-- && !q;) m[h + 1] - m[h] !== w && (q = !0);
              !a.options.keepOrdinalPadding && (m[0] - c > w || f - m[m.length - 1] > w) && (q = !0);
            } else a.options.overscroll && (2 === u ? n = m[1] - m[0] : 1 === u ? (n = a.options.overscroll, m = [m[0], m[0] + n]) : n = b.overscrollPointsRange);
            q || a.forceOrdinal ? (a.options.overscroll && (b.overscrollPointsRange = n, m = m.concat(b.getOverscrollPositions())), b.positions = m, w = a.ordinal2lin(Math.max(c, m[0]), !0), h = Math.max(a.ordinal2lin(Math.min(f, m[m.length - 1]), !0), 1), b.slope = f = (f - c) / (h - w), b.offset = c - w * f) : (b.overscrollPointsRange = p(a.closestPointRange, b.overscrollPointsRange), b.positions = a.ordinal.slope = b.offset = void 0);
          }
          a.isOrdinal = e && q;
          b.groupIntervalFactor = null;
        };
        a.findIndexOf = function (a, b, e) {
          for (var c = 0, g = a.length - 1, f; c < g;) f = Math.ceil((c + g) / 2), a[f] <= b ? c = f : g = f - 1;
          return a[c] === b ? c : e ? c : -1;
        };
        a.prototype.getExtendedPositions = function () {
          var a = this,
            b = a.axis,
            e = b.constructor.prototype,
            c = b.chart,
            f = b.series[0].currentDataGrouping,
            d = f ? f.count + f.unitName : "raw",
            k = b.options.overscroll,
            l = b.getExtremes(),
            m = void 0,
            n = a.index;
          n || (n = a.index = {});
          if (!n[d]) {
            var p = {
              series: [],
              chart: c,
              forceOrdinal: !1,
              getExtremes: function () {
                return {
                  min: l.dataMin,
                  max: l.dataMax + k
                };
              },
              getGroupPixelWidth: e.getGroupPixelWidth,
              getTimeTicks: e.getTimeTicks,
              options: {
                ordinal: !0
              },
              ordinal: {
                getGroupIntervalFactor: this.getGroupIntervalFactor
              },
              ordinal2lin: e.ordinal2lin,
              getIndexOfPoint: e.getIndexOfPoint,
              val2lin: e.val2lin
            };
            p.ordinal.axis = p;
            b.series.forEach(function (b) {
              m = {
                xAxis: p,
                xData: b.xData.slice(),
                chart: c,
                destroyGroupedData: h.noop,
                getProcessedData: A.prototype.getProcessedData,
                applyGrouping: A.prototype.applyGrouping
              };
              m.xData = m.xData.concat(a.getOverscrollPositions());
              m.options = {
                dataGrouping: f ? {
                  firstAnchor: "firstPoint",
                  anchor: "middle",
                  lastAnchor: "lastPoint",
                  enabled: !0,
                  forced: !0,
                  approximation: "open",
                  units: [[f.unitName, [f.count]]]
                } : {
                  enabled: !1
                }
              };
              p.series.push(m);
              b.processData.apply(m);
            });
            m.closestPointRange !== m.basePointRange && m.currentDataGrouping && (p.forceOrdinal = !0);
            b.ordinal.beforeSetTickPositions.apply({
              axis: p
            });
            n[d] = p.ordinal.positions;
          }
          return n[d];
        };
        a.prototype.getGroupIntervalFactor = function (a, b, e) {
          e = e.processedXData;
          var c = e.length,
            f = [];
          var g = this.groupIntervalFactor;
          if (!g) {
            for (g = 0; g < c - 1; g++) f[g] = e[g + 1] - e[g];
            f.sort(function (a, b) {
              return a - b;
            });
            f = f[Math.floor(c / 2)];
            a = Math.max(a, e[0]);
            b = Math.min(b, e[c - 1]);
            this.groupIntervalFactor = g = c * f / (b - a);
          }
          return g;
        };
        a.prototype.getIndexOfPoint = function (e, b) {
          var c = this.axis,
            f = this.positions ? this.positions[0] : 0,
            g = c.series[0].points && c.series[0].points[0] && c.series[0].points[0].plotX || c.minPixelPadding;
          1 < c.series.length && c.series.forEach(function (a) {
            a.points && y(a.points[0]) && y(a.points[0].plotX) && a.points[0].plotX < g && (g = a.points[0].plotX);
          });
          e = (e - g) / (c.translationSlope * (this.slope || c.closestPointRange || this.overscrollPointsRange));
          return a.findIndexOf(b, f) + e;
        };
        a.prototype.getOverscrollPositions = function () {
          var a = this.axis,
            b = a.options.overscroll,
            e = this.overscrollPointsRange,
            c = [],
            f = a.dataMax;
          if (y(e)) for (; f <= a.dataMax + b;) f += e, c.push(f);
          return c;
        };
        a.prototype.postProcessTickInterval = function (a) {
          var b = this.axis,
            e = this.slope;
          return e ? b.options.breaks ? b.closestPointRange || a : a / (e / b.closestPointRange) : a;
        };
        return a;
      }();
      a.Additions = l;
    })(a || (a = {}));
    return a;
  });
  N(h, "Series/DataModifyComposition.js", [h["Core/Axis/Axis.js"], h["Core/Series/Point.js"], h["Core/Series/Series.js"], h["Core/Utilities.js"]], function (d, h, A, F) {
    var t = h.prototype.tooltipFormatter,
      E = F.addEvent,
      H = F.arrayMax,
      y = F.arrayMin,
      q = F.correctFloat,
      p = F.defined,
      f = F.isArray,
      c = F.isNumber,
      a = F.isString,
      n = F.pick,
      m;
    (function (d) {
      function h(e, b, c) {
        this.isXAxis || (this.series.forEach(function (c) {
          "compare" === e && "boolean" !== typeof b ? c.setCompare(b, !1) : "cumulative" !== e || a(b) || c.setCumulative(b, !1);
        }), n(c, !0) && this.chart.redraw());
      }
      function m(a) {
        var b = this,
          e = b.series.chart.numberFormatter,
          c = function (c) {
            a = a.replace("{point." + c + "}", (0 < b[c] && "change" === c ? "+" : "") + e(b[c], n(b.series.tooltipOptions.changeDecimals, 2)));
          };
        p(b.change) && c("change");
        p(b.cumulativeSum) && c("cumulativeSum");
        return t.apply(this, [a]);
      }
      function D() {
        var a = this.options.compare;
        if ("percent" === a || "value" === a || this.options.cumulative) {
          var b = new e(this);
          "percent" === a || "value" === a ? b.initCompare(a) : b.initCumulative();
        }
        this.dataModify = b;
      }
      function A(a) {
        a = a.dataExtremes;
        var b = a.activeYData;
        if (this.dataModify && a) {
          var c = void 0;
          this.options.compare ? c = [this.dataModify.modifyValue(a.dataMin), this.dataModify.modifyValue(a.dataMax)] : this.options.cumulative && f(b) && 2 <= b.length && (c = e.getCumulativeExtremes(b));
          c && (a.dataMin = y(c), a.dataMax = H(c));
        }
      }
      function v(a, b) {
        this.options.compare = this.userOptions.compare = a;
        this.update({}, n(b, !0));
        !this.dataModify || "value" !== a && "percent" !== a ? this.points.forEach(function (a) {
          delete a.change;
        }) : this.dataModify.initCompare(a);
      }
      function z() {
        if (this.xAxis && this.processedYData && this.dataModify) {
          var a = this.processedXData,
            b = this.processedYData,
            e = b.length,
            f = !0 === this.options.compareStart ? 0 : 1,
            d = -1,
            k;
          this.pointArrayMap && (d = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || "y"));
          for (k = 0; k < e - f; k++) {
            var l = b[k] && -1 < d ? b[k][d] : b[k];
            if (c(l) && 0 !== l && a[k + f] >= (this.xAxis.min || 0)) {
              this.dataModify.compareValue = l;
              break;
            }
          }
        }
      }
      function u(a, b) {
        this.setModifier("compare", a, b);
      }
      function k(a, b) {
        a = n(a, !1);
        this.options.cumulative = this.userOptions.cumulative = a;
        this.update({}, n(b, !0));
        this.dataModify ? this.dataModify.initCumulative() : this.points.forEach(function (a) {
          delete a.cumulativeSum;
        });
      }
      function w(a, b) {
        this.setModifier("cumulative", a, b);
      }
      var l = [];
      d.compose = function (a, b, e) {
        if (-1 === l.indexOf(a)) {
          l.push(a);
          var c = a.prototype;
          c.setCompare = v;
          c.setCumulative = k;
          E(a, "afterInit", D);
          E(a, "afterGetExtremes", A);
          E(a, "afterProcessData", z);
        }
        -1 === l.indexOf(b) && (l.push(b), b = b.prototype, b.setCompare = u, b.setModifier = h, b.setCumulative = w);
        -1 === l.indexOf(e) && (l.push(e), e.prototype.tooltipFormatter = m);
        return a;
      };
      var e = function () {
        function a(a) {
          this.series = a;
        }
        a.prototype.modifyValue = function () {
          return 0;
        };
        a.getCumulativeExtremes = function (a) {
          var b = Infinity,
            e = -Infinity;
          a.reduce(function (a, c) {
            c = a + c;
            b = Math.min(b, c, a);
            e = Math.max(e, c, a);
            return c;
          });
          return [b, e];
        };
        a.prototype.initCompare = function (a) {
          this.modifyValue = function (b, e) {
            null === b && (b = 0);
            var c = this.compareValue;
            return "undefined" !== typeof b && "undefined" !== typeof c ? (b = "value" === a ? b - c : b / c * 100 - (100 === this.series.options.compareBase ? 0 : 100), "undefined" !== typeof e && (e = this.series.points[e]) && (e.change = b), b) : 0;
          };
        };
        a.prototype.initCumulative = function () {
          this.modifyValue = function (a, e) {
            null === a && (a = 0);
            if (void 0 !== a && void 0 !== e) {
              var b = 0 < e ? this.series.points[e - 1] : null;
              b && b.cumulativeSum && (a = q(b.cumulativeSum + a));
              if (e = this.series.points[e]) e.cumulativeSum = a;
              return a;
            }
            return 0;
          };
        };
        return a;
      }();
      d.Additions = e;
    })(m || (m = {}));
    "";
    return m;
  });
  N(h, "Core/Axis/BrokenAxis.js", [h["Extensions/Stacking.js"], h["Core/Utilities.js"]], function (d, h) {
    var A = h.addEvent,
      E = h.find,
      t = h.fireEvent,
      G = h.isArray,
      H = h.isNumber,
      y = h.pick,
      q;
    (function (h) {
      function f() {
        "undefined" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);
      }
      function c() {
        this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);
      }
      function a() {
        var a = this.brokenAxis;
        if (a && a.hasBreaks) {
          for (var c = this.tickPositions, f = this.tickPositions.info, d = [], h = 0; h < c.length; h++) a.isInAnyBreak(c[h]) || d.push(c[h]);
          this.tickPositions = d;
          this.tickPositions.info = f;
        }
      }
      function n() {
        this.brokenAxis || (this.brokenAxis = new K(this));
      }
      function m() {
        var a = this.options.connectNulls,
          c = this.points,
          f = this.xAxis,
          d = this.yAxis;
        if (this.isDirty) for (var h = c.length; h--;) {
          var l = c[h],
            e = !(null === l.y && !1 === a) && (f && f.brokenAxis && f.brokenAxis.isInAnyBreak(l.x, !0) || d && d.brokenAxis && d.brokenAxis.isInAnyBreak(l.y, !0));
          l.visible = e ? !1 : !1 !== l.options.visible;
        }
      }
      function p() {
        this.drawBreaks(this.xAxis, ["x"]);
        this.drawBreaks(this.yAxis, y(this.pointArrayMap, ["y"]));
      }
      function q(a, c) {
        var f = this,
          d = f.points,
          h,
          l,
          e,
          g;
        if (a && a.brokenAxis && a.brokenAxis.hasBreaks) {
          var b = a.brokenAxis;
          c.forEach(function (c) {
            h = b && b.breakArray || [];
            l = a.isXAxis ? a.min : y(f.options.threshold, a.min);
            d.forEach(function (b) {
              g = y(b["stack" + c.toUpperCase()], b[c]);
              h.forEach(function (c) {
                if (H(l) && H(g)) {
                  e = !1;
                  if (l < c.from && g > c.to || l > c.from && g < c.from) e = "pointBreak";else if (l < c.from && g > c.from && g < c.to || l > c.from && g > c.to && g < c.from) e = "pointInBreak";
                  e && t(a, e, {
                    point: b,
                    brk: c
                  });
                }
              });
            });
          });
        }
      }
      function I() {
        var a = this.currentDataGrouping,
          c = a && a.gapSize;
        a = this.points.slice();
        var f = this.yAxis,
          k = this.options.gapSize,
          h = a.length - 1,
          l;
        if (k && 0 < h) for ("value" !== this.options.gapUnit && (k *= this.basePointRange), c && c > k && c >= this.basePointRange && (k = c), l = void 0; h--;) l && !1 !== l.visible || (l = a[h + 1]), c = a[h], !1 !== l.visible && !1 !== c.visible && (l.x - c.x > k && (l = (c.x + l.x) / 2, a.splice(h + 1, 0, {
          isNull: !0,
          x: l
        }), f.stacking && this.options.stacking && (l = f.stacking.stacks[this.stackKey][l] = new d(f, f.options.stackLabels, !1, l, this.stack), l.total = 0)), l = c);
        return this.getGraphPath(a);
      }
      var F = [];
      h.compose = function (d, h) {
        -1 === F.indexOf(d) && (F.push(d), d.keepProps.push("brokenAxis"), A(d, "init", n), A(d, "afterInit", f), A(d, "afterSetTickPositions", a), A(d, "afterSetOptions", c));
        if (-1 === F.indexOf(h)) {
          F.push(h);
          var u = h.prototype;
          u.drawBreaks = q;
          u.gappedPath = I;
          A(h, "afterGeneratePoints", m);
          A(h, "afterRender", p);
        }
        return d;
      };
      var K = function () {
        function a(a) {
          this.hasBreaks = !1;
          this.axis = a;
        }
        a.isInBreak = function (a, c) {
          var f = a.repeat || Infinity,
            d = a.from,
            l = a.to - a.from;
          c = c >= d ? (c - d) % f : f - (d - c) % f;
          return a.inclusive ? c <= l : c < l && 0 !== c;
        };
        a.lin2Val = function (c) {
          var f = this.brokenAxis;
          f = f && f.breakArray;
          if (!f || !H(c)) return c;
          var d;
          for (d = 0; d < f.length; d++) {
            var h = f[d];
            if (h.from >= c) break;else h.to < c ? c += h.len : a.isInBreak(h, c) && (c += h.len);
          }
          return c;
        };
        a.val2Lin = function (c) {
          var f = this.brokenAxis;
          f = f && f.breakArray;
          if (!f || !H(c)) return c;
          var d = c,
            h;
          for (h = 0; h < f.length; h++) {
            var l = f[h];
            if (l.to <= c) d -= l.len;else if (l.from >= c) break;else if (a.isInBreak(l, c)) {
              d -= c - l.from;
              break;
            }
          }
          return d;
        };
        a.prototype.findBreakAt = function (a, c) {
          return E(c, function (c) {
            return c.from < a && a < c.to;
          });
        };
        a.prototype.isInAnyBreak = function (c, f) {
          var d = this.axis,
            h = d.options.breaks || [],
            l = h.length,
            e;
          if (l && H(c)) {
            for (; l--;) if (a.isInBreak(h[l], c)) {
              var g = !0;
              e || (e = y(h[l].showPoints, !d.isXAxis));
            }
            var b = g && f ? g && !e : g;
          }
          return b;
        };
        a.prototype.setBreaks = function (c, f) {
          var d = this,
            h = d.axis,
            l = G(c) && !!c.length;
          h.isDirty = d.hasBreaks !== l;
          d.hasBreaks = l;
          h.options.breaks = h.userOptions.breaks = c;
          h.forceRedraw = !0;
          h.series.forEach(function (a) {
            a.isDirty = !0;
          });
          l || h.val2lin !== a.val2Lin || (delete h.val2lin, delete h.lin2val);
          l && (h.userOptions.ordinal = !1, h.lin2val = a.lin2Val, h.val2lin = a.val2Lin, h.setExtremes = function (a, c, b, f, k) {
            if (d.hasBreaks) {
              for (var e = this.options.breaks || [], g; g = d.findBreakAt(a, e);) a = g.to;
              for (; g = d.findBreakAt(c, e);) c = g.from;
              c < a && (c = a);
            }
            h.constructor.prototype.setExtremes.call(this, a, c, b, f, k);
          }, h.setAxisTranslation = function () {
            h.constructor.prototype.setAxisTranslation.call(this);
            d.unitLength = void 0;
            if (d.hasBreaks) {
              var c = h.options.breaks || [],
                f = [],
                b = [],
                k = y(h.pointRangePadding, 0),
                l = 0,
                r,
                m = h.userMin || h.min,
                n = h.userMax || h.max,
                p;
              c.forEach(function (b) {
                r = b.repeat || Infinity;
                H(m) && H(n) && (a.isInBreak(b, m) && (m += b.to % r - m % r), a.isInBreak(b, n) && (n -= n % r - b.from % r));
              });
              c.forEach(function (a) {
                u = a.from;
                r = a.repeat || Infinity;
                if (H(m) && H(n)) {
                  for (; u - r > m;) u -= r;
                  for (; u < m;) u += r;
                  for (p = u; p < n; p += r) f.push({
                    value: p,
                    move: "in"
                  }), f.push({
                    value: p + a.to - a.from,
                    move: "out",
                    size: a.breakSize
                  });
                }
              });
              f.sort(function (a, b) {
                return a.value === b.value ? ("in" === a.move ? 0 : 1) - ("in" === b.move ? 0 : 1) : a.value - b.value;
              });
              var q = 0;
              var u = m;
              f.forEach(function (a) {
                q += "in" === a.move ? 1 : -1;
                1 === q && "in" === a.move && (u = a.value);
                0 === q && H(u) && (b.push({
                  from: u,
                  to: a.value,
                  len: a.value - u - (a.size || 0)
                }), l += a.value - u - (a.size || 0));
              });
              d.breakArray = b;
              H(m) && H(n) && H(h.min) && (d.unitLength = n - m - l + k, t(h, "afterBreaks"), h.staticScale ? h.transA = h.staticScale : d.unitLength && (h.transA *= (n - h.min + k) / d.unitLength), k && (h.minPixelPadding = h.transA * (h.minPointOffset || 0)), h.min = m, h.max = n);
            }
          });
          y(f, !0) && h.chart.redraw();
        };
        return a;
      }();
      h.Additions = K;
    })(q || (q = {}));
    return q;
  });
  N(h, "masters/modules/broken-axis.src.js", [h["Core/Globals.js"], h["Core/Axis/BrokenAxis.js"]], function (d, h) {
    h.compose(d.Axis, d.Series);
  });
  N(h, "Extensions/DataGrouping.js", [h["Core/Axis/Axis.js"], h["Core/Axis/DateTimeAxis.js"], h["Core/FormatUtilities.js"], h["Core/Globals.js"], h["Core/Series/Point.js"], h["Core/Series/Series.js"], h["Core/Tooltip.js"], h["Core/DefaultOptions.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G, H, y, q) {
    var p = A.format,
      f = G.prototype;
    A = q.addEvent;
    var c = q.arrayMax,
      a = q.arrayMin,
      n = q.correctFloat,
      m = q.defined,
      D = q.error,
      C = q.extend,
      I = q.isNumber,
      E = q.merge,
      K = q.pick;
    "";
    var v = F.approximations = {
      sum: function (a) {
        var c = a.length;
        if (!c && a.hasNulls) var b = null;else if (c) for (b = 0; c--;) b += a[c];
        return b;
      },
      average: function (a) {
        var c = a.length;
        a = v.sum(a);
        I(a) && c && (a = n(a / c));
        return a;
      },
      averages: function () {
        var a = [];
        [].forEach.call(arguments, function (c) {
          a.push(v.average(c));
        });
        return "undefined" === typeof a[0] ? void 0 : a;
      },
      open: function (a) {
        return a.length ? a[0] : a.hasNulls ? null : void 0;
      },
      high: function (a) {
        return a.length ? c(a) : a.hasNulls ? null : void 0;
      },
      low: function (c) {
        return c.length ? a(c) : c.hasNulls ? null : void 0;
      },
      close: function (a) {
        return a.length ? a[a.length - 1] : a.hasNulls ? null : void 0;
      },
      hlc: function (a, c, b) {
        a = v.high(a);
        c = v.low(c);
        b = v.close(b);
        if (I(a) || I(c) || I(b)) return [a, c, b];
      },
      ohlc: function (a, c, b, f) {
        a = v.open(a);
        c = v.high(c);
        b = v.low(b);
        f = v.close(f);
        if (I(a) || I(c) || I(b) || I(f)) return [a, c, b, f];
      },
      range: function (a, c) {
        a = v.low(a);
        c = v.high(c);
        if (I(a) || I(c)) return [a, c];
        if (null === a && null === c) return null;
      }
    };
    q = function (a, c, b, f) {
      var e = this,
        d = e.data,
        g = e.options && e.options.data,
        k = [],
        l = [],
        h = [],
        n = a.length,
        p = !!c,
        q = [],
        u = e.pointArrayMap,
        B = u && u.length,
        w = ["x"].concat(u || ["y"]),
        t = this.options.dataGrouping && this.options.dataGrouping.groupAll,
        z = 0,
        y = 0,
        D;
      f = "function" === typeof f ? f : v[f] ? v[f] : v[e.getDGApproximation && e.getDGApproximation() || "average"];
      B ? u.forEach(function () {
        q.push([]);
      }) : q.push([]);
      var C = B || 1;
      for (D = 0; D <= n && !(a[D] >= b[0]); D++);
      for (D; D <= n; D++) {
        for (; "undefined" !== typeof b[z + 1] && a[D] >= b[z + 1] || D === n;) {
          var A = b[z];
          e.dataGroupInfo = {
            start: t ? y : e.cropStart + y,
            length: q[0].length
          };
          var F = f.apply(e, q);
          e.pointClass && !m(e.dataGroupInfo.options) && (e.dataGroupInfo.options = E(e.pointClass.prototype.optionsToObject.call({
            series: e
          }, e.options.data[e.cropStart + y])), w.forEach(function (a) {
            delete e.dataGroupInfo.options[a];
          }));
          "undefined" !== typeof F && (k.push(A), l.push(F), h.push(e.dataGroupInfo));
          y = D;
          for (A = 0; A < C; A++) q[A].length = 0, q[A].hasNulls = !1;
          z += 1;
          if (D === n) break;
        }
        if (D === n) break;
        if (u) {
          A = e.options.dataGrouping && e.options.dataGrouping.groupAll ? D : e.cropStart + D;
          F = d && d[A] || e.pointClass.prototype.applyOptions.apply({
            series: e
          }, [g[A]]);
          var G = void 0;
          for (A = 0; A < B; A++) G = F[u[A]], I(G) ? q[A].push(G) : null === G && (q[A].hasNulls = !0);
        } else A = p ? c[D] : null, I(A) ? q[0].push(A) : null === A && (q[0].hasNulls = !0);
      }
      return {
        groupedXData: k,
        groupedYData: l,
        groupMap: h
      };
    };
    var z = {
        approximations: v,
        groupData: q
      },
      u = f.generatePoints,
      k = {
        groupPixelWidth: 2,
        dateTimeLabelFormats: {
          millisecond: ["%A, %b %e, %H:%M:%S.%L", "%A, %b %e, %H:%M:%S.%L", "-%H:%M:%S.%L"],
          second: ["%A, %b %e, %H:%M:%S", "%A, %b %e, %H:%M:%S", "-%H:%M:%S"],
          minute: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"],
          hour: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"],
          day: ["%A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"],
          week: ["Week from %A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"],
          month: ["%B %Y", "%B", "-%B %Y"],
          year: ["%Y", "%Y", "-%Y"]
        }
      },
      w = {
        line: {},
        spline: {},
        area: {},
        areaspline: {},
        arearange: {},
        column: {
          groupPixelWidth: 10
        },
        columnrange: {
          groupPixelWidth: 10
        },
        candlestick: {
          groupPixelWidth: 10
        },
        ohlc: {
          groupPixelWidth: 5
        },
        hlc: {
          groupPixelWidth: 5
        },
        heikinashi: {
          groupPixelWidth: 10
        }
      },
      l = F.defaultDataGroupingUnits = [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]];
    f.getDGApproximation = function () {
      return this.is("arearange") ? "range" : this.is("ohlc") ? "ohlc" : this.is("hlc") ? "hlc" : this.is("column") ? "sum" : "average";
    };
    f.groupData = q;
    f.applyGrouping = function (a) {
      var c = this.chart,
        b = this.options.dataGrouping,
        e = !1 !== this.allowDG && b && K(b.enabled, c.options.isStock),
        d = this.visible || !c.options.chart.ignoreHiddenSeries,
        k,
        n = this.currentDataGrouping,
        p = !1;
      e && !this.requireSorting && (this.requireSorting = p = !0);
      a = !1 === !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !a) || !e;
      p && (this.requireSorting = !1);
      if (!a) {
        this.destroyGroupedData();
        e = b.groupAll ? this.xData : this.processedXData;
        var q = b.groupAll ? this.yData : this.processedYData;
        a = c.plotSizeX;
        p = this.xAxis;
        var u = p.options.ordinal,
          w = this.groupPixelWidth;
        if (w && e && e.length) {
          this.isDirty = k = !0;
          this.points = null;
          var v = p.getExtremes();
          var t = v.min;
          v = v.max;
          u = u && p.ordinal && p.ordinal.getGroupIntervalFactor(t, v, this) || 1;
          a = p.getTimeTicks(h.Additions.prototype.normalizeTimeTickInterval(w * (v - t) / a * u, b.units || l), Math.min(t, e[0]), Math.max(v, e[e.length - 1]), p.options.startOfWeek, e, this.closestPointRange);
          w = f.groupData.apply(this, [e, q, a, b.approximation]);
          e = w.groupedXData;
          q = w.groupedYData;
          u = 0;
          b && b.smoothed && e.length && (b.firstAnchor = "firstPoint", b.anchor = "middle", b.lastAnchor = "lastPoint", D(32, !1, c, {
            "dataGrouping.smoothed": "use dataGrouping.anchor"
          }));
          c = e;
          var z = this.options.dataGrouping;
          t = this.currentDataGrouping && this.currentDataGrouping.gapSize;
          if (z && this.xData && t && this.groupMap) {
            var y = c.length - 1;
            var C = z.anchor;
            var A = K(z.firstAnchor, C);
            z = K(z.lastAnchor, C);
            if (C && "start" !== C) {
              var F = t * {
                middle: .5,
                end: 1
              }[C];
              for (C = c.length - 1; C-- && 0 < C;) c[C] += F;
            }
            if (A && "start" !== A && this.xData[0] >= c[0]) {
              C = this.groupMap[0].start;
              F = this.groupMap[0].length;
              var E = void 0;
              I(C) && I(F) && (E = C + (F - 1));
              c[0] = {
                middle: c[0] + .5 * t,
                end: c[0] + t,
                firstPoint: this.xData[0],
                lastPoint: E && this.xData[E]
              }[A];
            }
            z && "start" !== z && t && c[y] >= v - t && (v = this.groupMap[this.groupMap.length - 1].start, c[y] = {
              middle: c[y] + .5 * t,
              end: c[y] + t,
              firstPoint: v && this.xData[v],
              lastPoint: this.xData[this.xData.length - 1]
            }[z]);
          }
          for (v = 1; v < a.length; v++) a.info.segmentStarts && -1 !== a.info.segmentStarts.indexOf(v) || (u = Math.max(a[v] - a[v - 1], u));
          v = a.info;
          v.gapSize = u;
          this.closestPointRange = a.info.totalRange;
          this.groupMap = w.groupMap;
          if (d) {
            d = e;
            if (m(d[0]) && I(p.min) && I(p.dataMin) && d[0] < p.min) {
              if (!m(p.options.min) && p.min <= p.dataMin || p.min === p.dataMin) p.min = Math.min(d[0], p.min);
              p.dataMin = Math.min(d[0], p.dataMin);
            }
            if (m(d[d.length - 1]) && I(p.max) && I(p.dataMax) && d[d.length - 1] > p.max) {
              if (!m(p.options.max) && I(p.dataMax) && p.max >= p.dataMax || p.max === p.dataMax) p.max = Math.max(d[d.length - 1], p.max);
              p.dataMax = Math.max(d[d.length - 1], p.dataMax);
            }
          }
          b.groupAll && (this.allGroupedData = q, b = this.cropData(e, q, p.min, p.max, 1), e = b.xData, q = b.yData, this.cropStart = b.start);
          this.processedXData = e;
          this.processedYData = q;
        } else this.groupMap = null;
        this.hasGroupedData = k;
        this.currentDataGrouping = v;
        this.preventGraphAnimation = (n && n.totalRange) !== (v && v.totalRange);
      }
    };
    f.destroyGroupedData = function () {
      this.groupedData && (this.groupedData.forEach(function (a, c) {
        a && (this.groupedData[c] = a.destroy ? a.destroy() : null);
      }, this), this.groupedData.length = 0);
    };
    f.generatePoints = function () {
      u.apply(this);
      this.destroyGroupedData();
      this.groupedData = this.hasGroupedData ? this.points : null;
    };
    d.prototype.applyGrouping = function (a) {
      var c = this;
      c.series.forEach(function (b) {
        b.groupPixelWidth = void 0;
        b.groupPixelWidth = c.getGroupPixelWidth && c.getGroupPixelWidth();
        b.groupPixelWidth && (b.hasProcessed = !0);
        b.applyGrouping(!!a.hasExtemesChanged);
      });
    };
    d.prototype.getGroupPixelWidth = function () {
      var a = this.series,
        c = a.length,
        b,
        f = 0,
        d = !1,
        l;
      for (b = c; b--;) (l = a[b].options.dataGrouping) && (f = Math.max(f, K(l.groupPixelWidth, k.groupPixelWidth)));
      for (b = c; b--;) if (l = a[b].options.dataGrouping) if (c = (a[b].processedXData || a[b].data).length, a[b].groupPixelWidth || c > this.chart.plotSizeX / f || c && l.forced) d = !0;
      return d ? f : 0;
    };
    d.prototype.setDataGrouping = function (a, c) {
      var b;
      c = K(c, !0);
      a || (a = {
        forced: !1,
        units: null
      });
      if (this instanceof d) for (b = this.series.length; b--;) this.series[b].update({
        dataGrouping: a
      }, !1);else this.chart.options.series.forEach(function (b) {
        b.dataGrouping = a;
      }, !1);
      this.ordinal && (this.ordinal.slope = void 0);
      c && this.chart.redraw();
    };
    A(d, "postProcessData", d.prototype.applyGrouping);
    A(t, "update", function () {
      if (this.dataGroup) return D(24, !1, this.series.chart), !1;
    });
    A(H, "headerFormatter", function (a) {
      var c = this.chart,
        b = c.time,
        e = a.labelConfig,
        f = e.series,
        d = f.tooltipOptions,
        l = f.options.dataGrouping,
        h = d.xDateFormat,
        m = f.xAxis,
        n = d[a.isFooter ? "footerFormat" : "headerFormat"];
      if (m && "datetime" === m.options.type && l && I(e.key)) {
        var q = f.currentDataGrouping;
        l = l.dateTimeLabelFormats || k.dateTimeLabelFormats;
        if (q) {
          if (d = l[q.unitName], 1 === q.count) h = d[0];else {
            h = d[1];
            var u = d[2];
          }
        } else !h && l && m.dateTime && (h = m.dateTime.getXDateFormat(e.x, d.dateTimeLabelFormats));
        h = b.dateFormat(h, e.key);
        u && (h += b.dateFormat(u, e.key + q.totalRange - 1));
        f.chart.styledMode && (n = this.styledModeFormat(n));
        a.text = p(n, {
          point: C(e.point, {
            key: h
          }),
          series: f
        }, c);
        a.preventDefault();
      }
    });
    A(G, "destroy", f.destroyGroupedData);
    A(G, "afterSetOptions", function (a) {
      a = a.options;
      var c = this.type,
        b = this.chart.options.plotOptions,
        e = y.defaultOptions.plotOptions[c].dataGrouping,
        f = this.useCommonDataGrouping && k;
      if (b && (w[c] || f)) {
        e || (e = E(k, w[c]));
        var d = this.chart.rangeSelector;
        a.dataGrouping = E(f, e, b.series && b.series.dataGrouping, b[c].dataGrouping, this.userOptions.dataGrouping, !a.isInternal && d && I(d.selected) && d.buttonOptions[d.selected].dataGrouping);
      }
    });
    A(d, "afterSetScale", function () {
      this.series.forEach(function (a) {
        a.hasProcessed = !1;
      });
    });
    F.dataGrouping = z;
    "";
    return z;
  });
  N(h, "Series/HLC/HLCPoint.js", [h["Core/Series/SeriesRegistry.js"]], function (d) {
    var h = this && this.__extends || function () {
      var d = function (h, t) {
        d = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, h) {
          d.__proto__ = h;
        } || function (d, h) {
          for (var t in h) h.hasOwnProperty(t) && (d[t] = h[t]);
        };
        return d(h, t);
      };
      return function (h, t) {
        function A() {
          this.constructor = h;
        }
        d(h, t);
        h.prototype = null === t ? Object.create(t) : (A.prototype = t.prototype, new A());
      };
    }();
    return function (d) {
      function A() {
        var h = null !== d && d.apply(this, arguments) || this;
        h.close = void 0;
        h.high = void 0;
        h.low = void 0;
        h.options = void 0;
        h.plotClose = void 0;
        h.series = void 0;
        return h;
      }
      h(A, d);
      return A;
    }(d.seriesTypes.column.prototype.pointClass);
  });
  N(h, "Series/HLC/HLCSeries.js", [h["Series/HLC/HLCPoint.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var F = this && this.__extends || function () {
        var d = function (h, p) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (f, c) {
            f.__proto__ = c;
          } || function (f, c) {
            for (var a in c) c.hasOwnProperty(a) && (f[a] = c[a]);
          };
          return d(h, p);
        };
        return function (h, p) {
          function f() {
            this.constructor = h;
          }
          d(h, p);
          h.prototype = null === p ? Object.create(p) : (f.prototype = p.prototype, new f());
        };
      }(),
      t = h.seriesTypes.column,
      E = A.extend,
      H = A.merge;
    A = function (d) {
      function h() {
        var h = null !== d && d.apply(this, arguments) || this;
        h.data = void 0;
        h.options = void 0;
        h.points = void 0;
        h.yData = void 0;
        return h;
      }
      F(h, d);
      h.prototype.extendStem = function (d, f, c) {
        var a = d[0];
        d = d[1];
        "number" === typeof a[2] && (a[2] = Math.max(c + f, a[2]));
        "number" === typeof d[2] && (d[2] = Math.min(c - f, d[2]));
      };
      h.prototype.getPointPath = function (d, f) {
        f = f.strokeWidth();
        var c = d.series,
          a = f % 2 / 2,
          h = Math.round(d.plotX) - a,
          m = Math.round(d.shapeArgs.width / 2);
        var p = [["M", h, Math.round(d.yBottom)], ["L", h, Math.round(d.plotHigh)]];
        null !== d.close && (d = Math.round(d.plotClose) + a, p.push(["M", h, d], ["L", h + m, d]), c.extendStem(p, f / 2, d));
        return p;
      };
      h.prototype.drawSinglePoint = function (d) {
        var f = d.series,
          c = f.chart,
          a = d.graphic,
          h = !a;
        "undefined" !== typeof d.plotY && (a || (d.graphic = a = c.renderer.path().add(f.group)), c.styledMode || a.attr(f.pointAttribs(d, d.selected && "select")), f = f.getPointPath(d, a), a[h ? "attr" : "animate"]({
          d: f
        }).addClass(d.getClassName(), !0));
      };
      h.prototype.drawPoints = function () {
        this.points.forEach(this.drawSinglePoint);
      };
      h.prototype.init = function () {
        d.prototype.init.apply(this, arguments);
        this.options.stacking = void 0;
      };
      h.prototype.pointAttribs = function (h, f) {
        h = d.prototype.pointAttribs.call(this, h, f);
        delete h.fill;
        return h;
      };
      h.prototype.toYData = function (d) {
        return [d.high, d.low, d.close];
      };
      h.prototype.translate = function () {
        var h = this,
          f = h.yAxis,
          c = this.pointArrayMap && this.pointArrayMap.slice() || [],
          a = c.map(function (a) {
            return "plot" + (a.charAt(0).toUpperCase() + a.slice(1));
          });
        a.push("yBottom");
        c.push("low");
        d.prototype.translate.apply(h);
        h.points.forEach(function (d) {
          c.forEach(function (c, n) {
            c = d[c];
            null !== c && (h.dataModify && (c = h.dataModify.modifyValue(c)), d[a[n]] = f.toPixels(c, !0));
          });
          d.tooltipPos[1] = d.plotHigh + f.pos - h.chart.plotTop;
        });
      };
      h.defaultOptions = H(t.defaultOptions, {
        lineWidth: 1,
        tooltip: {
          pointFormat: '<span style="color:{point.color}">\u25cf</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'
        },
        threshold: null,
        states: {
          hover: {
            lineWidth: 3
          }
        },
        stickyTracking: !0
      });
      return h;
    }(t);
    E(A.prototype, {
      animate: null,
      directTouch: !1,
      pointArrayMap: ["high", "low", "close"],
      pointAttrToOptions: {
        stroke: "color",
        "stroke-width": "lineWidth"
      },
      pointValKey: "close"
    });
    A.prototype.pointClass = d;
    h.registerSeriesType("hlc", A);
    "";
    return A;
  });
  N(h, "Series/OHLC/OHLCPoint.js", [h["Core/Series/SeriesRegistry.js"]], function (d) {
    var h = this && this.__extends || function () {
      var d = function (h, t) {
        d = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, h) {
          d.__proto__ = h;
        } || function (d, h) {
          for (var t in h) h.hasOwnProperty(t) && (d[t] = h[t]);
        };
        return d(h, t);
      };
      return function (h, t) {
        function A() {
          this.constructor = h;
        }
        d(h, t);
        h.prototype = null === t ? Object.create(t) : (A.prototype = t.prototype, new A());
      };
    }();
    return function (d) {
      function A() {
        var h = null !== d && d.apply(this, arguments) || this;
        h.open = void 0;
        h.options = void 0;
        h.plotOpen = void 0;
        h.series = void 0;
        return h;
      }
      h(A, d);
      A.prototype.getClassName = function () {
        return d.prototype.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
      };
      A.prototype.resolveUpColor = function () {
        this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);
      };
      A.prototype.resolveColor = function () {
        d.prototype.resolveColor.call(this);
        this.resolveUpColor();
      };
      A.prototype.getZone = function () {
        var h = d.prototype.getZone.call(this);
        this.resolveUpColor();
        return h;
      };
      A.prototype.applyOptions = function () {
        d.prototype.applyOptions.apply(this, arguments);
        this.resolveColor && this.resolveColor();
        return this;
      };
      return A;
    }(d.seriesTypes.hlc.prototype.pointClass);
  });
  N(h, "Series/OHLC/OHLCSeries.js", [h["Series/OHLC/OHLCPoint.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = this && this.__extends || function () {
        var d = function (c, a) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var d in c) c.hasOwnProperty(d) && (a[d] = c[d]);
          };
          return d(c, a);
        };
        return function (c, a) {
          function f() {
            this.constructor = c;
          }
          d(c, a);
          c.prototype = null === a ? Object.create(a) : (f.prototype = a.prototype, new f());
        };
      }(),
      t = h.series,
      G = h.seriesTypes.hlc,
      H = A.addEvent,
      y = A.extend,
      q = A.merge,
      p = function (d) {
        function c() {
          var a = null !== d && d.apply(this, arguments) || this;
          a.data = void 0;
          a.options = void 0;
          a.points = void 0;
          return a;
        }
        E(c, d);
        c.prototype.getPointPath = function (a, c) {
          var f = d.prototype.getPointPath.call(this, a, c);
          c = c.strokeWidth();
          var h = c % 2 / 2,
            n = Math.round(a.plotX) - h,
            p = Math.round(a.shapeArgs.width / 2);
          null !== a.open && (a = Math.round(a.plotOpen) + h, f.push(["M", n, a], ["L", n - p, a]), d.prototype.extendStem.call(this, f, c / 2, a));
          return f;
        };
        c.prototype.pointAttribs = function (a, c) {
          c = d.prototype.pointAttribs.call(this, a, c);
          var f = this.options;
          delete c.fill;
          !a.options.color && f.upColor && a.open < a.close && (c.stroke = f.upColor);
          return c;
        };
        c.prototype.toYData = function (a) {
          return [a.open, a.high, a.low, a.close];
        };
        c.defaultOptions = q(G.defaultOptions, {
          tooltip: {
            pointFormat: '<span style="color:{point.color}">\u25cf</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'
          }
        });
        return c;
      }(G);
    y(p.prototype, {
      pointArrayMap: ["open", "high", "low", "close"]
    });
    p.prototype.pointClass = d;
    h.registerSeriesType("ohlc", p);
    H(t, "init", function (d) {
      d = d.options;
      d.useOhlcData && "highcharts-navigator-series" !== d.id && y(this, {
        pointValKey: p.prototype.pointValKey,
        pointArrayMap: p.prototype.pointArrayMap,
        toYData: p.prototype.toYData
      });
    });
    H(t, "afterSetOptions", function (d) {
      d = d.options;
      var c = d.dataGrouping;
      c && d.useOhlcData && "highcharts-navigator-series" !== d.id && (c.approximation = "ohlc");
    });
    "";
    return p;
  });
  N(h, "Series/Candlestick/CandlestickSeries.js", [h["Core/DefaultOptions.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = this && this.__extends || function () {
        var d = function (h, f) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (c, a) {
            c.__proto__ = a;
          } || function (c, a) {
            for (var d in a) a.hasOwnProperty(d) && (c[d] = a[d]);
          };
          return d(h, f);
        };
        return function (h, f) {
          function c() {
            this.constructor = h;
          }
          d(h, f);
          h.prototype = null === f ? Object.create(f) : (c.prototype = f.prototype, new c());
        };
      }(),
      t = d.defaultOptions;
    d = h.seriesTypes;
    var G = d.column,
      H = d.ohlc,
      y = A.merge;
    A = function (d) {
      function h() {
        var f = null !== d && d.apply(this, arguments) || this;
        f.data = void 0;
        f.options = void 0;
        f.points = void 0;
        return f;
      }
      E(h, d);
      h.prototype.pointAttribs = function (d, c) {
        var a = G.prototype.pointAttribs.call(this, d, c),
          f = this.options,
          h = d.open < d.close,
          p = f.lineColor || this.color,
          q = d.color || this.color;
        a["stroke-width"] = f.lineWidth;
        a.fill = d.options.color || (h ? f.upColor || q : q);
        a.stroke = d.options.lineColor || (h ? f.upLineColor || p : p);
        c && (d = f.states[c], a.fill = d.color || a.fill, a.stroke = d.lineColor || a.stroke, a["stroke-width"] = d.lineWidth || a["stroke-width"]);
        return a;
      };
      h.prototype.drawPoints = function () {
        var d = this,
          c = d.chart,
          a = d.yAxis.reversed;
        d.points.forEach(function (f) {
          var h = f.graphic,
            n = !h;
          if ("undefined" !== typeof f.plotY) {
            h || (f.graphic = h = c.renderer.path().add(d.group));
            d.chart.styledMode || h.attr(d.pointAttribs(f, f.selected && "select")).shadow(d.options.shadow);
            var p = h.strokeWidth() % 2 / 2;
            var q = Math.round(f.plotX) - p;
            var t = f.plotOpen;
            var y = f.plotClose;
            var v = Math.min(t, y);
            t = Math.max(t, y);
            var z = Math.round(f.shapeArgs.width / 2);
            y = a ? t !== f.yBottom : Math.round(v) !== Math.round(f.plotHigh);
            var u = a ? Math.round(v) !== Math.round(f.plotHigh) : t !== f.yBottom;
            v = Math.round(v) + p;
            t = Math.round(t) + p;
            p = [];
            p.push(["M", q - z, t], ["L", q - z, v], ["L", q + z, v], ["L", q + z, t], ["Z"], ["M", q, v], ["L", q, y ? Math.round(a ? f.yBottom : f.plotHigh) : v], ["M", q, t], ["L", q, u ? Math.round(a ? f.plotHigh : f.yBottom) : t]);
            h[n ? "attr" : "animate"]({
              d: p
            }).addClass(f.getClassName(), !0);
          }
        });
      };
      h.defaultOptions = y(H.defaultOptions, t.plotOptions, {
        states: {
          hover: {
            lineWidth: 2
          }
        },
        tooltip: t.plotOptions.ohlc.tooltip,
        threshold: null,
        lineColor: "#000000",
        lineWidth: 1,
        upColor: "#ffffff",
        stickyTracking: !0
      });
      return h;
    }(H);
    h.registerSeriesType("candlestick", A);
    "";
    return A;
  });
  N(h, "Series/Flags/FlagsPoint.js", [h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h) {
    var A = this && this.__extends || function () {
        var d = function (h, t) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, h) {
            d.__proto__ = h;
          } || function (d, h) {
            for (var p in h) h.hasOwnProperty(p) && (d[p] = h[p]);
          };
          return d(h, t);
        };
        return function (h, t) {
          function y() {
            this.constructor = h;
          }
          d(h, t);
          h.prototype = null === t ? Object.create(t) : (y.prototype = t.prototype, new y());
        };
      }(),
      E = h.isNumber;
    return function (d) {
      function h() {
        var h = null !== d && d.apply(this, arguments) || this;
        h.options = void 0;
        h.series = void 0;
        return h;
      }
      A(h, d);
      h.prototype.isValid = function () {
        return E(this.y) || "undefined" === typeof this.y;
      };
      h.prototype.hasNewShapeType = function () {
        var d = this.options.shape || this.series.options.shape;
        return this.graphic && d && d !== this.graphic.symbolKey;
      };
      return h;
    }(d.seriesTypes.column.prototype.pointClass);
  });
  N(h, "Series/OnSeriesComposition.js", [h["Series/Column/ColumnSeries.js"], h["Core/Series/Series.js"], h["Core/Utilities.js"]], function (d, h, A) {
    var E = d.prototype,
      t = h.prototype,
      G = A.defined,
      H = A.stableSort,
      y;
    (function (d) {
      function h() {
        return t.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);
      }
      function f() {
        E.translate.apply(this);
        var a = this,
          c = a.options,
          d = a.chart,
          f = a.points,
          h = c.onSeries,
          p = (h = h && d.get(h)) && h.options.step,
          q = h && h.points,
          t = d.inverted,
          v = a.xAxis,
          z = a.yAxis;
        d = f.length - 1;
        var u;
        c = c.onKey || "y";
        var k = q && q.length,
          w = 0,
          l;
        if (h && h.visible && k) {
          w = (h.pointXOffset || 0) + (h.barW || 0) / 2;
          var e = h.currentDataGrouping;
          var g = q[k - 1].x + (e ? e.totalRange : 0);
          H(f, function (a, b) {
            return a.x - b.x;
          });
          for (c = "plot" + c[0].toUpperCase() + c.substr(1); k-- && f[d];) {
            var b = q[k];
            e = f[d];
            e.y = b.y;
            if (b.x <= e.x && "undefined" !== typeof b[c]) {
              if (e.x <= g && (e.plotY = b[c], b.x < e.x && !p && (l = q[k + 1]) && "undefined" !== typeof l[c])) {
                var B = (e.x - b.x) / (l.x - b.x);
                e.plotY += B * (l[c] - b[c]);
                e.y += B * (l.y - b.y);
              }
              d--;
              k++;
              if (0 > d) break;
            }
          }
        }
        f.forEach(function (b, c) {
          b.plotX += w;
          if ("undefined" === typeof b.plotY || t) 0 <= b.plotX && b.plotX <= v.len ? t ? (b.plotY = v.translate(b.x, 0, 1, 0, 1), b.plotX = G(b.y) ? z.translate(b.y, 0, 0, 0, 1) : 0) : b.plotY = (v.opposite ? 0 : a.yAxis.len) + v.offset : b.shapeArgs = {};
          if ((u = f[c - 1]) && u.plotX === b.plotX) {
            "undefined" === typeof u.stackIndex && (u.stackIndex = 0);
            var e = u.stackIndex + 1;
          }
          b.stackIndex = e;
        });
        this.onSeries = h;
      }
      var c = [];
      d.compose = function (a) {
        if (-1 === c.indexOf(a)) {
          c.push(a);
          var d = a.prototype;
          d.getPlotBox = h;
          d.translate = f;
        }
        return a;
      };
      d.getPlotBox = h;
      d.translate = f;
    })(y || (y = {}));
    return y;
  });
  N(h, "Series/Flags/FlagsSymbols.js", [h["Core/Renderer/RendererRegistry.js"], h["Core/Renderer/SVG/SVGRenderer.js"]], function (d, h) {
    function A(d) {
      E[d + "pin"] = function (h, t, y, q, p) {
        var f = p && p.anchorX;
        p = p && p.anchorY;
        "circle" === d && q > y && (h -= Math.round((q - y) / 2), y = q);
        var c = E[d](h, t, y, q);
        if (f && p) {
          var a = f;
          "circle" === d ? a = h + y / 2 : (h = c[0], y = c[1], "M" === h[0] && "L" === y[0] && (a = (h[1] + y[1]) / 2));
          c.push(["M", a, t > p ? t : t + q], ["L", f, p]);
          c = c.concat(E.circle(f - 1, p - 1, 2, 2));
        }
        return c;
      };
    }
    var E = h.prototype.symbols;
    E.flag = function (d, h, A, y, q) {
      var p = q && q.anchorX || d;
      q = q && q.anchorY || h;
      var f = E.circle(p - 1, q - 1, 2, 2);
      f.push(["M", p, q], ["L", d, h + y], ["L", d, h], ["L", d + A, h], ["L", d + A, h + y], ["L", d, h + y], ["Z"]);
      return f;
    };
    A("circle");
    A("square");
    d = d.getRendererType();
    d !== h && (d.prototype.symbols.circlepin = E.circlepin, d.prototype.symbols.flag = E.flag, d.prototype.symbols.squarepin = E.squarepin);
    return E;
  });
  N(h, "Series/Flags/FlagsSeries.js", [h["Series/Flags/FlagsPoint.js"], h["Core/Globals.js"], h["Series/OnSeriesComposition.js"], h["Core/Renderer/RendererUtilities.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Renderer/SVG/SVGElement.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G, H) {
    var y = this && this.__extends || function () {
      var a = function (c, d) {
        a = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (a, c) {
          a.__proto__ = c;
        } || function (a, c) {
          for (var d in c) c.hasOwnProperty(d) && (a[d] = c[d]);
        };
        return a(c, d);
      };
      return function (c, d) {
        function f() {
          this.constructor = c;
        }
        a(c, d);
        c.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());
      };
    }();
    h = h.noop;
    var q = F.distribute,
      p = t.series,
      f = t.seriesTypes.column,
      c = H.addEvent,
      a = H.defined;
    F = H.extend;
    var n = H.merge,
      m = H.objectEach,
      D = H.wrap;
    H = function (d) {
      function h() {
        var a = null !== d && d.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      y(h, d);
      h.prototype.animate = function (a) {
        a && this.setClip();
      };
      h.prototype.drawPoints = function () {
        var c = this.points,
          d = this.chart,
          f = d.renderer,
          h = d.inverted,
          p = this.options,
          k = p.y,
          w,
          l = this.yAxis,
          e = {},
          g = [];
        for (w = c.length; w--;) {
          var b = c[w];
          var B = (h ? b.plotY : b.plotX) > this.xAxis.len;
          var t = b.plotX;
          var r = b.stackIndex;
          var x = b.options.shape || p.shape;
          var M = b.plotY;
          "undefined" !== typeof M && (M = b.plotY + k - ("undefined" !== typeof r && r * p.stackDistance));
          b.anchorX = r ? void 0 : b.plotX;
          var y = r ? void 0 : b.plotY;
          var A = "flag" !== x;
          r = b.graphic;
          "undefined" !== typeof M && 0 <= t && !B ? (r && b.hasNewShapeType() && (r = r.destroy()), r || (r = b.graphic = f.label("", null, null, x, null, null, p.useHTML).addClass("highcharts-point").add(this.markerGroup), b.graphic.div && (b.graphic.div.point = b), r.isNew = !0), r.attr({
            align: A ? "center" : "left",
            width: p.width,
            height: p.height,
            "text-align": p.textAlign
          }), d.styledMode || r.attr(this.pointAttribs(b)).css(n(p.style, b.style)).shadow(p.shadow), 0 < t && (t -= r.strokeWidth() % 2), x = {
            y: M,
            anchorY: y
          }, p.allowOverlapX && (x.x = t, x.anchorX = b.anchorX), r.attr({
            text: b.options.title || p.title || "A"
          })[r.isNew ? "attr" : "animate"](x), p.allowOverlapX || (e[b.plotX] ? e[b.plotX].size = Math.max(e[b.plotX].size, r.width) : e[b.plotX] = {
            align: A ? .5 : 0,
            size: r.width,
            target: t,
            anchorX: t
          }), b.tooltipPos = [t, M + l.pos - d.plotTop]) : r && (b.graphic = r.destroy());
        }
        if (!p.allowOverlapX) {
          var C = 100;
          m(e, function (a) {
            a.plotX = a.anchorX;
            g.push(a);
            C = Math.max(a.size, C);
          });
          q(g, h ? l.len : this.xAxis.len, C);
          c.forEach(function (b) {
            var c = b.graphic && e[b.plotX];
            c && (b.graphic[b.graphic.isNew ? "attr" : "animate"]({
              x: c.pos + c.align * c.size,
              anchorX: b.anchorX
            }), a(c.pos) ? b.graphic.isNew = !1 : (b.graphic.attr({
              x: -9999,
              anchorX: -9999
            }), b.graphic.isNew = !0));
          });
        }
        p.useHTML && D(this.markerGroup, "on", function (a) {
          return G.prototype.on.apply(a.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));
        });
      };
      h.prototype.drawTracker = function () {
        var a = this.points;
        d.prototype.drawTracker.call(this);
        a.forEach(function (d) {
          var f = d.graphic;
          f && (d.unbindMouseOver && d.unbindMouseOver(), d.unbindMouseOver = c(f.element, "mouseover", function () {
            0 < d.stackIndex && !d.raised && (d._y = f.y, f.attr({
              y: d._y - 8
            }), d.raised = !0);
            a.forEach(function (a) {
              a !== d && a.raised && a.graphic && (a.graphic.attr({
                y: a._y
              }), a.raised = !1);
            });
          }));
        });
      };
      h.prototype.pointAttribs = function (a, c) {
        var d = this.options,
          f = a && a.color || this.color,
          h = d.lineColor,
          k = a && a.lineWidth;
        a = a && a.fillColor || d.fillColor;
        c && (a = d.states[c].fillColor, h = d.states[c].lineColor, k = d.states[c].lineWidth);
        return {
          fill: a || f,
          stroke: h || f,
          "stroke-width": k || d.lineWidth || 0
        };
      };
      h.prototype.setClip = function () {
        p.prototype.setClip.apply(this, arguments);
        !1 !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
      };
      h.defaultOptions = n(f.defaultOptions, {
        pointRange: 0,
        allowOverlapX: !1,
        shape: "flag",
        stackDistance: 12,
        textAlign: "center",
        tooltip: {
          pointFormat: "{point.text}"
        },
        threshold: null,
        y: -30,
        fillColor: "#ffffff",
        lineWidth: 1,
        states: {
          hover: {
            lineColor: "#000000",
            fillColor: "#ccd6eb"
          }
        },
        style: {
          fontSize: "11px",
          fontWeight: "bold"
        }
      });
      return h;
    }(f);
    A.compose(H);
    F(H.prototype, {
      allowDG: !1,
      forceCrop: !0,
      invertible: !1,
      noSharedTooltip: !0,
      pointClass: d,
      sorted: !1,
      takeOrdinalPosition: !1,
      trackerGroups: ["markerGroup"],
      buildKDTree: h,
      init: p.prototype.init,
      invertGroups: h
    });
    t.registerSeriesType("flags", H);
    "";
    "";
    return H;
  });
  N(h, "Core/Axis/ScrollbarAxis.js", [h["Core/Utilities.js"]], function (d) {
    var h = d.addEvent,
      A = d.defined,
      F = d.pick;
    return function () {
      function d() {}
      d.compose = function (t, E) {
        if (-1 === d.composed.indexOf(t)) d.composed.push(t);else return t;
        var y = function (d) {
          var h = F(d.options && d.options.min, d.min),
            f = F(d.options && d.options.max, d.max);
          return {
            axisMin: h,
            axisMax: f,
            scrollMin: A(d.dataMin) ? Math.min(h, d.min, d.dataMin, F(d.threshold, Infinity)) : h,
            scrollMax: A(d.dataMax) ? Math.max(f, d.max, d.dataMax, F(d.threshold, -Infinity)) : f
          };
        };
        h(t, "afterInit", function () {
          var d = this;
          d.options && d.options.scrollbar && d.options.scrollbar.enabled && (d.options.scrollbar.vertical = !d.horiz, d.options.startOnTick = d.options.endOnTick = !1, d.scrollbar = new E(d.chart.renderer, d.options.scrollbar, d.chart), h(d.scrollbar, "changed", function (h) {
            var f = y(d),
              c = f.axisMax,
              a = f.scrollMin,
              p = f.scrollMax - a;
            A(f.axisMin) && A(c) && (d.horiz && !d.reversed || !d.horiz && d.reversed ? (f = a + p * this.to, a += p * this.from) : (f = a + p * (1 - this.from), a += p * (1 - this.to)), this.shouldUpdateExtremes(h.DOMType) ? d.setExtremes(a, f, !0, "mousemove" !== h.DOMType && "touchmove" !== h.DOMType, h) : this.setRange(this.from, this.to));
          }));
        });
        h(t, "afterRender", function () {
          var d = y(this),
            h = d.scrollMin,
            f = d.scrollMax;
          d = this.scrollbar;
          var c = this.axisTitleMargin + (this.titleOffset || 0),
            a = this.chart.scrollbarsOffsets,
            n = this.options.margin || 0;
          d && (this.horiz ? (this.opposite || (a[1] += c), d.position(this.left, this.top + this.height + 2 + a[1] - (this.opposite ? n : 0), this.width, this.height), this.opposite || (a[1] += n), c = 1) : (this.opposite && (a[0] += c), d.position(d.options.opposite ? this.left + this.width + 2 + a[0] - (this.opposite ? 0 : n) : this.opposite ? 0 : n, this.top, this.width, this.height), this.opposite && (a[0] += n), c = 0), a[c] += d.size + d.options.margin, isNaN(h) || isNaN(f) || !A(this.min) || !A(this.max) || this.min === this.max ? d.setRange(0, 1) : (a = (this.min - h) / (f - h), h = (this.max - h) / (f - h), this.horiz && !this.reversed || !this.horiz && this.reversed ? d.setRange(a, h) : d.setRange(1 - h, 1 - a)));
        });
        h(t, "afterGetOffset", function () {
          var d = this.scrollbar && !this.scrollbar.options.opposite;
          d = this.horiz ? 2 : d ? 3 : 1;
          var h = this.scrollbar;
          h && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[d] += h.size + h.options.margin);
        });
        return t;
      };
      d.composed = [];
      return d;
    }();
  });
  N(h, "Core/ScrollbarDefaults.js", [h["Core/Globals.js"]], function (d) {
    return {
      height: d.isTouchDevice ? 20 : 14,
      barBorderRadius: 0,
      buttonBorderRadius: 0,
      liveRedraw: void 0,
      margin: 10,
      minWidth: 6,
      opposite: !0,
      step: .2,
      zIndex: 3,
      barBackgroundColor: "#cccccc",
      barBorderWidth: 1,
      barBorderColor: "#cccccc",
      buttonArrowColor: "#333333",
      buttonBackgroundColor: "#e6e6e6",
      buttonBorderColor: "#cccccc",
      buttonBorderWidth: 1,
      rifleColor: "#333333",
      trackBackgroundColor: "#f2f2f2",
      trackBorderColor: "#f2f2f2",
      trackBorderWidth: 1
    };
  });
  N(h, "Core/Scrollbar.js", [h["Core/DefaultOptions.js"], h["Core/Globals.js"], h["Core/Axis/ScrollbarAxis.js"], h["Core/ScrollbarDefaults.js"], h["Core/Utilities.js"]], function (d, h, A, F, t) {
    var E = d.defaultOptions,
      H = t.addEvent,
      y = t.correctFloat,
      q = t.defined,
      p = t.destroyObjectProperties,
      f = t.fireEvent,
      c = t.merge,
      a = t.pick,
      n = t.removeEvent;
    d = function () {
      function d(a, c, d) {
        this._events = [];
        this.chart = void 0;
        this.from = this.chartY = this.chartX = 0;
        this.scrollbar = this.renderer = this.options = this.group = void 0;
        this.scrollbarButtons = [];
        this.scrollbarGroup = void 0;
        this.scrollbarLeft = 0;
        this.scrollbarRifles = void 0;
        this.scrollbarStrokeWidth = 1;
        this.to = this.size = this.scrollbarTop = 0;
        this.track = void 0;
        this.trackBorderWidth = 1;
        this.userOptions = void 0;
        this.y = this.x = 0;
        this.init(a, c, d);
      }
      d.compose = function (a) {
        A.compose(a, d);
      };
      d.swapXY = function (a, c) {
        c && a.forEach(function (a) {
          for (var c = a.length, d, f = 0; f < c; f += 2) d = a[f + 1], "number" === typeof d && (a[f + 1] = a[f + 2], a[f + 2] = d);
        });
        return a;
      };
      d.prototype.addEvents = function () {
        var a = this.options.inverted ? [1, 0] : [0, 1],
          c = this.scrollbarButtons,
          d = this.scrollbarGroup.element,
          f = this.track.element,
          m = this.mouseDownHandler.bind(this),
          n = this.mouseMoveHandler.bind(this),
          p = this.mouseUpHandler.bind(this);
        a = [[c[a[0]].element, "click", this.buttonToMinClick.bind(this)], [c[a[1]].element, "click", this.buttonToMaxClick.bind(this)], [f, "click", this.trackClick.bind(this)], [d, "mousedown", m], [d.ownerDocument, "mousemove", n], [d.ownerDocument, "mouseup", p]];
        h.hasTouch && a.push([d, "touchstart", m], [d.ownerDocument, "touchmove", n], [d.ownerDocument, "touchend", p]);
        a.forEach(function (a) {
          H.apply(null, a);
        });
        this._events = a;
      };
      d.prototype.buttonToMaxClick = function (c) {
        var d = (this.to - this.from) * a(this.options.step, .2);
        this.updatePosition(this.from + d, this.to + d);
        f(this, "changed", {
          from: this.from,
          to: this.to,
          trigger: "scrollbar",
          DOMEvent: c
        });
      };
      d.prototype.buttonToMinClick = function (c) {
        var d = y(this.to - this.from) * a(this.options.step, .2);
        this.updatePosition(y(this.from - d), y(this.to - d));
        f(this, "changed", {
          from: this.from,
          to: this.to,
          trigger: "scrollbar",
          DOMEvent: c
        });
      };
      d.prototype.cursorToScrollbarPosition = function (a) {
        var c = this.options;
        c = c.minWidth > this.calculatedWidth ? c.minWidth : 0;
        return {
          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - c),
          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - c)
        };
      };
      d.prototype.destroy = function () {
        var a = this,
          c = a.chart.scroller;
        a.removeEvents();
        ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function (c) {
          a[c] && a[c].destroy && (a[c] = a[c].destroy());
        });
        c && a === c.scrollbar && (c.scrollbar = null, p(c.scrollbarButtons));
      };
      d.prototype.drawScrollbarButton = function (a) {
        var c = this.renderer,
          f = this.scrollbarButtons,
          h = this.options,
          m = this.size,
          n = c.g().add(this.group);
        f.push(n);
        n = c.rect().addClass("highcharts-scrollbar-button").add(n);
        this.chart.styledMode || n.attr({
          stroke: h.buttonBorderColor,
          "stroke-width": h.buttonBorderWidth,
          fill: h.buttonBackgroundColor
        });
        n.attr(n.crisp({
          x: -.5,
          y: -.5,
          width: m + 1,
          height: m + 1,
          r: h.buttonBorderRadius
        }, n.strokeWidth()));
        n = c.path(d.swapXY([["M", m / 2 + (a ? -1 : 1), m / 2 - 3], ["L", m / 2 + (a ? -1 : 1), m / 2 + 3], ["L", m / 2 + (a ? 2 : -2), m / 2]], h.vertical)).addClass("highcharts-scrollbar-arrow").add(f[a]);
        this.chart.styledMode || n.attr({
          fill: h.buttonArrowColor
        });
      };
      d.prototype.init = function (d, f, h) {
        this.scrollbarButtons = [];
        this.renderer = d;
        this.userOptions = f;
        this.options = c(F, E.scrollbar, f);
        this.chart = h;
        this.size = a(this.options.size, this.options.height);
        f.enabled && (this.render(), this.addEvents());
      };
      d.prototype.mouseDownHandler = function (a) {
        a = this.chart.pointer.normalize(a);
        a = this.cursorToScrollbarPosition(a);
        this.chartX = a.chartX;
        this.chartY = a.chartY;
        this.initPositions = [this.from, this.to];
        this.grabbedCenter = !0;
      };
      d.prototype.mouseMoveHandler = function (a) {
        var c = this.chart.pointer.normalize(a),
          d = this.options.vertical ? "chartY" : "chartX",
          h = this.initPositions || [];
        !this.grabbedCenter || a.touches && 0 === a.touches[0][d] || (c = this.cursorToScrollbarPosition(c)[d], d = this[d], d = c - d, this.hasDragged = !0, this.updatePosition(h[0] + d, h[1] + d), this.hasDragged && f(this, "changed", {
          from: this.from,
          to: this.to,
          trigger: "scrollbar",
          DOMType: a.type,
          DOMEvent: a
        }));
      };
      d.prototype.mouseUpHandler = function (a) {
        this.hasDragged && f(this, "changed", {
          from: this.from,
          to: this.to,
          trigger: "scrollbar",
          DOMType: a.type,
          DOMEvent: a
        });
        this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
      };
      d.prototype.position = function (a, c, d, f) {
        var h = this.options.vertical,
          m = this.rendered ? "animate" : "attr",
          n = 0;
        this.x = a;
        this.y = c + this.trackBorderWidth;
        this.width = d;
        this.xOffset = this.height = f;
        this.yOffset = n;
        h ? (this.width = this.yOffset = d = n = this.size, this.xOffset = c = 0, this.barWidth = f - 2 * d, this.x = a += this.options.margin) : (this.height = this.xOffset = f = c = this.size, this.barWidth = d - 2 * f, this.y += this.options.margin);
        this.group[m]({
          translateX: a,
          translateY: this.y
        });
        this.track[m]({
          width: d,
          height: f
        });
        this.scrollbarButtons[1][m]({
          translateX: h ? 0 : d - c,
          translateY: h ? f - n : 0
        });
      };
      d.prototype.removeEvents = function () {
        this._events.forEach(function (a) {
          n.apply(null, a);
        });
        this._events.length = 0;
      };
      d.prototype.render = function () {
        var a = this.renderer,
          c = this.options,
          f = this.size,
          h = this.chart.styledMode,
          m = a.g("scrollbar").attr({
            zIndex: c.zIndex,
            translateY: -99999
          }).add();
        this.group = m;
        this.track = a.rect().addClass("highcharts-scrollbar-track").attr({
          x: 0,
          r: c.trackBorderRadius || 0,
          height: f,
          width: f
        }).add(m);
        h || this.track.attr({
          fill: c.trackBackgroundColor,
          stroke: c.trackBorderColor,
          "stroke-width": c.trackBorderWidth
        });
        this.trackBorderWidth = this.track.strokeWidth();
        this.track.attr({
          y: -this.trackBorderWidth % 2 / 2
        });
        this.scrollbarGroup = a.g().add(m);
        this.scrollbar = a.rect().addClass("highcharts-scrollbar-thumb").attr({
          height: f,
          width: f,
          r: c.barBorderRadius || 0
        }).add(this.scrollbarGroup);
        this.scrollbarRifles = a.path(d.swapXY([["M", -3, f / 4], ["L", -3, 2 * f / 3], ["M", 0, f / 4], ["L", 0, 2 * f / 3], ["M", 3, f / 4], ["L", 3, 2 * f / 3]], c.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);
        h || (this.scrollbar.attr({
          fill: c.barBackgroundColor,
          stroke: c.barBorderColor,
          "stroke-width": c.barBorderWidth
        }), this.scrollbarRifles.attr({
          stroke: c.rifleColor,
          "stroke-width": 1
        }));
        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();
        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);
        this.drawScrollbarButton(0);
        this.drawScrollbarButton(1);
      };
      d.prototype.setRange = function (a, c) {
        var d = this.options,
          f = d.vertical,
          h = d.minWidth,
          m = this.barWidth,
          n = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
        if (q(m)) {
          var p = m * Math.min(c, 1);
          a = Math.max(a, 0);
          var k = Math.ceil(m * a);
          this.calculatedWidth = p = y(p - k);
          p < h && (k = (m - h + p) * a, p = h);
          h = Math.floor(k + this.xOffset + this.yOffset);
          m = p / 2 - .5;
          this.from = a;
          this.to = c;
          f ? (this.scrollbarGroup[n]({
            translateY: h
          }), this.scrollbar[n]({
            height: p
          }), this.scrollbarRifles[n]({
            translateY: m
          }), this.scrollbarTop = h, this.scrollbarLeft = 0) : (this.scrollbarGroup[n]({
            translateX: h
          }), this.scrollbar[n]({
            width: p
          }), this.scrollbarRifles[n]({
            translateX: m
          }), this.scrollbarLeft = h, this.scrollbarTop = 0);
          12 >= p ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0);
          !1 === d.showFull && (0 >= a && 1 <= c ? this.group.hide() : this.group.show());
          this.rendered = !0;
        }
      };
      d.prototype.shouldUpdateExtremes = function (c) {
        return a(this.options.liveRedraw, h.svg && !h.isTouchDevice && !this.chart.isBoosting) || "mouseup" === c || "touchend" === c || !q(c);
      };
      d.prototype.trackClick = function (a) {
        var c = this.chart.pointer.normalize(a),
          d = this.to - this.from,
          h = this.y + this.scrollbarTop,
          m = this.x + this.scrollbarLeft;
        this.options.vertical && c.chartY > h || !this.options.vertical && c.chartX > m ? this.updatePosition(this.from + d, this.to + d) : this.updatePosition(this.from - d, this.to - d);
        f(this, "changed", {
          from: this.from,
          to: this.to,
          trigger: "scrollbar",
          DOMEvent: a
        });
      };
      d.prototype.update = function (a) {
        this.destroy();
        this.init(this.chart.renderer, c(!0, this.options, a), this.chart);
      };
      d.prototype.updatePosition = function (a, c) {
        1 < c && (a = y(1 - y(c - a)), c = 1);
        0 > a && (c = y(c - a), a = 0);
        this.from = a;
        this.to = c;
      };
      d.defaultOptions = F;
      return d;
    }();
    E.scrollbar = c(!0, d.defaultOptions, E.scrollbar);
    return d;
  });
  N(h, "Core/Axis/NavigatorAxis.js", [h["Core/Globals.js"], h["Core/Utilities.js"]], function (d, h) {
    var A = d.isTouchDevice,
      E = h.addEvent,
      t = h.correctFloat,
      G = h.defined,
      H = h.isNumber,
      y = h.pick,
      q = function () {
        function d(d) {
          this.axis = d;
        }
        d.prototype.destroy = function () {
          this.axis = void 0;
        };
        d.prototype.toFixedRange = function (d, c, a, h) {
          var f = this.axis,
            n = f.chart;
          n = n && n.fixedRange;
          var p = (f.pointRange || 0) / 2;
          d = y(a, f.translate(d, !0, !f.horiz));
          c = y(h, f.translate(c, !0, !f.horiz));
          f = n && (c - d) / n;
          G(a) || (d = t(d + p));
          G(h) || (c = t(c - p));
          .7 < f && 1.3 > f && (h ? d = c - n : c = d + n);
          H(d) && H(c) || (d = c = void 0);
          return {
            min: d,
            max: c
          };
        };
        return d;
      }();
    return function () {
      function d() {}
      d.compose = function (d) {
        d.keepProps.push("navigatorAxis");
        E(d, "init", function () {
          this.navigatorAxis || (this.navigatorAxis = new q(this));
        });
        E(d, "zoom", function (c) {
          var a = this.chart.options,
            d = a.navigator,
            f = this.navigatorAxis,
            h = a.chart.pinchType,
            p = a.rangeSelector;
          a = a.chart.zoomType;
          this.isXAxis && (d && d.enabled || p && p.enabled) && ("y" === a ? c.zoomed = !1 : (!A && "xy" === a || A && "xy" === h) && this.options.range && (d = f.previousZoom, G(c.newMin) ? f.previousZoom = [this.min, this.max] : d && (c.newMin = d[0], c.newMax = d[1], f.previousZoom = void 0)));
          "undefined" !== typeof c.zoomed && c.preventDefault();
        });
      };
      d.AdditionsClass = q;
      return d;
    }();
  });
  N(h, "Core/Navigator.js", [h["Core/Axis/Axis.js"], h["Core/Chart/Chart.js"], h["Core/Color/Color.js"], h["Core/Globals.js"], h["Core/Axis/NavigatorAxis.js"], h["Core/DefaultOptions.js"], h["Core/Renderer/RendererRegistry.js"], h["Core/Scrollbar.js"], h["Core/Series/Series.js"], h["Core/Series/SeriesRegistry.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G, H, y, q, p, f) {
    A = A.parse;
    var c = F.hasTouch,
      a = F.isTouchDevice,
      n = G.defaultOptions,
      m = f.addEvent,
      E = f.clamp,
      C = f.correctFloat,
      I = f.defined,
      L = f.destroyObjectProperties,
      K = f.erase,
      v = f.extend,
      z = f.find,
      u = f.isArray,
      k = f.isNumber,
      w = f.merge,
      l = f.pick,
      e = f.removeEvent,
      g = f.splat,
      b = function (a) {
        for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
        b = [].filter.call(b, k);
        if (b.length) return Math[a].apply(0, b);
      };
    G = "undefined" === typeof p.seriesTypes.areaspline ? "line" : "areaspline";
    v(n, {
      navigator: {
        height: 40,
        margin: 25,
        maskInside: !0,
        handles: {
          width: 7,
          height: 15,
          symbols: ["navigator-handle", "navigator-handle"],
          enabled: !0,
          lineWidth: 1,
          backgroundColor: "#f2f2f2",
          borderColor: "#999999"
        },
        maskFill: A("#6685c2").setOpacity(.3).get(),
        outlineColor: "#cccccc",
        outlineWidth: 1,
        series: {
          type: G,
          fillOpacity: .05,
          lineWidth: 1,
          compare: null,
          dataGrouping: {
            approximation: "average",
            enabled: !0,
            groupPixelWidth: 2,
            firstAnchor: "firstPoint",
            anchor: "middle",
            lastAnchor: "lastPoint",
            units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]]
          },
          dataLabels: {
            enabled: !1,
            zIndex: 2
          },
          id: "highcharts-navigator-series",
          className: "highcharts-navigator-series",
          lineColor: null,
          marker: {
            enabled: !1
          },
          threshold: null
        },
        xAxis: {
          overscroll: 0,
          className: "highcharts-navigator-xaxis",
          tickLength: 0,
          lineWidth: 0,
          gridLineColor: "#e6e6e6",
          gridLineWidth: 1,
          tickPixelInterval: 200,
          labels: {
            align: "left",
            style: {
              color: "#999999"
            },
            x: 3,
            y: -4
          },
          crosshair: !1
        },
        yAxis: {
          className: "highcharts-navigator-yaxis",
          gridLineWidth: 0,
          startOnTick: !1,
          endOnTick: !1,
          minPadding: .1,
          maxPadding: .1,
          labels: {
            enabled: !1
          },
          crosshair: !1,
          title: {
            text: null
          },
          tickLength: 0,
          tickWidth: 0
        }
      }
    });
    H.getRendererType().prototype.symbols["navigator-handle"] = function (a, b, c, e, d) {
      a = (d && d.width || 0) / 2;
      b = Math.round(a / 3) + .5;
      d = d && d.height || 0;
      return [["M", -a - 1, .5], ["L", a, .5], ["L", a, d + .5], ["L", -a - 1, d + .5], ["L", -a - 1, .5], ["M", -b, 4], ["L", -b, d - 3], ["M", b - 1, 4], ["L", b - 1, d - 3]];
    };
    var B = function () {
      function f(a) {
        this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;
        this.init(a);
      }
      f.prototype.drawHandle = function (a, b, c, d) {
        var e = this.navigatorOptions.handles.height;
        this.handles[b][d](c ? {
          translateX: Math.round(this.left + this.height / 2),
          translateY: Math.round(this.top + parseInt(a, 10) + .5 - e)
        } : {
          translateX: Math.round(this.left + parseInt(a, 10)),
          translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)
        });
      };
      f.prototype.drawOutline = function (a, b, c, d) {
        var e = this.navigatorOptions.maskInside,
          f = this.outline.strokeWidth(),
          g = f / 2,
          h = f % 2 / 2;
        f = this.outlineHeight;
        var k = this.scrollbarHeight || 0,
          l = this.size,
          m = this.left - k,
          r = this.top;
        c ? (m -= g, c = r + b + h, b = r + a + h, h = [["M", m + f, r - k - h], ["L", m + f, c], ["L", m, c], ["L", m, b], ["L", m + f, b], ["L", m + f, r + l + k]], e && h.push(["M", m + f, c - g], ["L", m + f, b + g])) : (a += m + k - h, b += m + k - h, r += g, h = [["M", m, r], ["L", a, r], ["L", a, r + f], ["L", b, r + f], ["L", b, r], ["L", m + l + 2 * k, r]], e && h.push(["M", a - g, r], ["L", b + g, r]));
        this.outline[d]({
          d: h
        });
      };
      f.prototype.drawMasks = function (a, b, c, d) {
        var e = this.left,
          f = this.top,
          g = this.height;
        if (c) {
          var h = [e, e, e];
          var k = [f, f + a, f + b];
          var l = [g, g, g];
          var m = [a, b - a, this.size - b];
        } else h = [e, e + a, e + b], k = [f, f, f], l = [a, b - a, this.size - b], m = [g, g, g];
        this.shades.forEach(function (a, b) {
          a[d]({
            x: h[b],
            y: k[b],
            width: l[b],
            height: m[b]
          });
        });
      };
      f.prototype.renderElements = function () {
        var a = this,
          b = a.navigatorOptions,
          c = b.maskInside,
          e = a.chart,
          d = e.renderer,
          f,
          g = {
            cursor: e.inverted ? "ns-resize" : "ew-resize"
          };
        a.navigatorGroup = f = d.g("navigator").attr({
          zIndex: 8,
          visibility: "hidden"
        }).add();
        [!c, c, !c].forEach(function (c, h) {
          a.shades[h] = d.rect().addClass("highcharts-navigator-mask" + (1 === h ? "-inside" : "-outside")).add(f);
          e.styledMode || a.shades[h].attr({
            fill: c ? b.maskFill : "rgba(0,0,0,0)"
          }).css(1 === h && g);
        });
        a.outline = d.path().addClass("highcharts-navigator-outline").add(f);
        e.styledMode || a.outline.attr({
          "stroke-width": b.outlineWidth,
          stroke: b.outlineColor
        });
        b.handles.enabled && [0, 1].forEach(function (c) {
          b.handles.inverted = e.inverted;
          a.handles[c] = d.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);
          a.handles[c].attr({
            zIndex: 7 - c
          }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][c]).add(f);
          if (!e.styledMode) {
            var h = b.handles;
            a.handles[c].attr({
              fill: h.backgroundColor,
              stroke: h.borderColor,
              "stroke-width": h.lineWidth
            }).css(g);
          }
        });
      };
      f.prototype.update = function (a) {
        (this.series || []).forEach(function (a) {
          a.baseSeries && delete a.baseSeries.navigatorSeries;
        });
        this.destroy();
        w(!0, this.chart.options.navigator, this.options, a);
        this.init(this.chart);
      };
      f.prototype.render = function (a, b, c, e) {
        var d = this.chart,
          f = this.scrollbarHeight,
          g,
          h = this.xAxis,
          m = h.pointRange || 0;
        var r = h.navigatorAxis.fake ? d.xAxis[0] : h;
        var n = this.navigatorEnabled,
          p,
          x = this.rendered;
        var q = d.inverted;
        var u = d.xAxis[0].minRange,
          B = d.xAxis[0].options.maxRange;
        if (!this.hasDragged || I(c)) {
          a = C(a - m / 2);
          b = C(b + m / 2);
          if (!k(a) || !k(b)) if (x) c = 0, e = l(h.width, r.width);else return;
          this.left = l(h.left, d.plotLeft + f + (q ? d.plotWidth : 0));
          this.size = p = g = l(h.len, (q ? d.plotHeight : d.plotWidth) - 2 * f);
          d = q ? f : g + 2 * f;
          c = l(c, h.toPixels(a, !0));
          e = l(e, h.toPixels(b, !0));
          k(c) && Infinity !== Math.abs(c) || (c = 0, e = d);
          a = h.toValue(c, !0);
          b = h.toValue(e, !0);
          var w = Math.abs(C(b - a));
          w < u ? this.grabbedLeft ? c = h.toPixels(b - u - m, !0) : this.grabbedRight && (e = h.toPixels(a + u + m, !0)) : I(B) && C(w - m) > B && (this.grabbedLeft ? c = h.toPixels(b - B - m, !0) : this.grabbedRight && (e = h.toPixels(a + B + m, !0)));
          this.zoomedMax = E(Math.max(c, e), 0, p);
          this.zoomedMin = E(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(c, e), 0, p);
          this.range = this.zoomedMax - this.zoomedMin;
          p = Math.round(this.zoomedMax);
          c = Math.round(this.zoomedMin);
          n && (this.navigatorGroup.attr({
            visibility: "visible"
          }), x = x && !this.hasDragged ? "animate" : "attr", this.drawMasks(c, p, q, x), this.drawOutline(c, p, q, x), this.navigatorOptions.handles.enabled && (this.drawHandle(c, 0, q, x), this.drawHandle(p, 1, q, x)));
          this.scrollbar && (q ? (q = this.top - f, r = this.left - f + (n || !r.opposite ? 0 : (r.titleOffset || 0) + r.axisTitleMargin), f = g + 2 * f) : (q = this.top + (n ? this.height : -f), r = this.left - f), this.scrollbar.position(r, q, d, f), this.scrollbar.setRange(this.zoomedMin / (g || 1), this.zoomedMax / (g || 1)));
          this.rendered = !0;
        }
      };
      f.prototype.addMouseEvents = function () {
        var a = this,
          b = a.chart,
          e = b.container,
          d = [],
          f,
          g;
        a.mouseMoveHandler = f = function (b) {
          a.onMouseMove(b);
        };
        a.mouseUpHandler = g = function (b) {
          a.onMouseUp(b);
        };
        d = a.getPartsEvents("mousedown");
        d.push(m(b.renderTo, "mousemove", f), m(e.ownerDocument, "mouseup", g));
        c && (d.push(m(b.renderTo, "touchmove", f), m(e.ownerDocument, "touchend", g)), d.concat(a.getPartsEvents("touchstart")));
        a.eventsToUnbind = d;
        a.series && a.series[0] && d.push(m(a.series[0].xAxis, "foundExtremes", function () {
          b.navigator.modifyNavigatorAxisExtremes();
        }));
      };
      f.prototype.getPartsEvents = function (a) {
        var b = this,
          c = [];
        ["shades", "handles"].forEach(function (d) {
          b[d].forEach(function (e, f) {
            c.push(m(e.element, a, function (a) {
              b[d + "Mousedown"](a, f);
            }));
          });
        });
        return c;
      };
      f.prototype.shadesMousedown = function (a, b) {
        a = this.chart.pointer.normalize(a);
        var c = this.chart,
          d = this.xAxis,
          e = this.zoomedMin,
          f = this.left,
          g = this.size,
          h = this.range,
          k = a.chartX;
        c.inverted && (k = a.chartY, f = this.top);
        if (1 === b) this.grabbedCenter = k, this.fixedWidth = h, this.dragOffset = k - e;else {
          a = k - f - h / 2;
          if (0 === b) a = Math.max(0, a);else if (2 === b && a + h >= g) if (a = g - h, this.reversedExtremes) {
            a -= h;
            var l = this.getUnionExtremes().dataMin;
          } else var m = this.getUnionExtremes().dataMax;
          a !== e && (this.fixedWidth = h, b = d.navigatorAxis.toFixedRange(a, a + h, l, m), I(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {
            trigger: "navigator"
          }));
        }
      };
      f.prototype.handlesMousedown = function (a, b) {
        this.chart.pointer.normalize(a);
        a = this.chart;
        var c = a.xAxis[0],
          d = this.reversedExtremes;
        0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);
        a.fixedRange = null;
      };
      f.prototype.onMouseMove = function (b) {
        var c = this,
          d = c.chart,
          e = c.left,
          f = c.navigatorSize,
          g = c.range,
          h = c.dragOffset,
          k = d.inverted;
        b.touches && 0 === b.touches[0].pageX || (b = d.pointer.normalize(b), d = b.chartX, k && (e = c.top, d = b.chartY), c.grabbedLeft ? (c.hasDragged = !0, c.render(0, 0, d - e, c.otherHandlePos)) : c.grabbedRight ? (c.hasDragged = !0, c.render(0, 0, c.otherHandlePos, d - e)) : c.grabbedCenter && (c.hasDragged = !0, d < h ? d = h : d > f + h - g && (d = f + h - g), c.render(0, 0, d - h, d - h + g)), c.hasDragged && c.scrollbar && l(c.scrollbar.options.liveRedraw, F.svg && !a && !this.chart.isBoosting) && (b.DOMType = b.type, setTimeout(function () {
          c.onMouseUp(b);
        }, 0)));
      };
      f.prototype.onMouseUp = function (a) {
        var b = this.chart,
          c = this.xAxis,
          d = this.scrollbar,
          e = a.DOMEvent || a,
          f = b.inverted,
          g = this.rendered && !this.hasDragged ? "animate" : "attr";
        if (this.hasDragged && (!d || !d.hasDragged) || "scrollbar" === a.trigger) {
          d = this.getUnionExtremes();
          if (this.zoomedMin === this.otherHandlePos) var h = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var l = this.fixedExtreme;
          this.zoomedMax === this.size && (l = this.reversedExtremes ? d.dataMin : d.dataMax);
          0 === this.zoomedMin && (h = this.reversedExtremes ? d.dataMax : d.dataMin);
          c = c.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, h, l);
          I(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, this.hasDragged ? !1 : null, {
            trigger: "navigator",
            triggerOp: "navigator-drag",
            DOMEvent: e
          });
        }
        "mousemove" !== a.DOMType && "touchmove" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);
        this.navigatorEnabled && k(this.zoomedMin) && k(this.zoomedMax) && (b = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(b, a, f, g), this.outline && this.drawOutline(b, a, f, g), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(b, 0, f, g), this.drawHandle(a, 1, f, g)));
      };
      f.prototype.removeEvents = function () {
        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {
          a();
        }), this.eventsToUnbind = void 0);
        this.removeBaseSeriesEvents();
      };
      f.prototype.removeBaseSeriesEvents = function () {
        var a = this.baseSeries || [];
        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {
          e(a, "updatedData", this.updatedDataHandler);
        }, this), a[0].xAxis && e(a[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
      };
      f.prototype.init = function (a) {
        var c = a.options,
          e = c.navigator,
          f = e.enabled,
          g = c.scrollbar,
          h = g.enabled;
        c = f ? e.height : 0;
        var k = h ? g.height : 0;
        this.handles = [];
        this.shades = [];
        this.chart = a;
        this.setBaseSeries();
        this.height = c;
        this.scrollbarHeight = k;
        this.scrollbarEnabled = h;
        this.navigatorEnabled = f;
        this.navigatorOptions = e;
        this.scrollbarOptions = g;
        this.outlineHeight = c + k;
        this.opposite = l(e.opposite, !(f || !a.inverted));
        var n = this;
        f = n.baseSeries;
        g = a.xAxis.length;
        h = a.yAxis.length;
        var p = f && f[0] && f[0].xAxis || a.xAxis[0] || {
          options: {}
        };
        a.isDirtyBox = !0;
        n.navigatorEnabled ? (n.xAxis = new d(a, w({
          breaks: p.options.breaks,
          ordinal: p.options.ordinal
        }, e.xAxis, {
          id: "navigator-x-axis",
          yAxis: "navigator-y-axis",
          isX: !0,
          type: "datetime",
          index: g,
          isInternal: !0,
          offset: 0,
          keepOrdinalPadding: !0,
          startOnTick: !1,
          endOnTick: !1,
          minPadding: 0,
          maxPadding: 0,
          zoomEnabled: !1
        }, a.inverted ? {
          offsets: [k, 0, -k, 0],
          width: c
        } : {
          offsets: [0, -k, 0, k],
          height: c
        })), n.yAxis = new d(a, w(e.yAxis, {
          id: "navigator-y-axis",
          alignTicks: !1,
          offset: 0,
          index: h,
          isInternal: !0,
          reversed: l(e.yAxis && e.yAxis.reversed, a.yAxis[0] && a.yAxis[0].reversed, !1),
          zoomEnabled: !1
        }, a.inverted ? {
          width: c
        } : {
          height: c
        })), f || e.series.data ? n.updateNavigatorSeries(!1) : 0 === a.series.length && (n.unbindRedraw = m(a, "beforeRedraw", function () {
          0 < a.series.length && !n.series && (n.setBaseSeries(), n.unbindRedraw());
        })), n.reversedExtremes = a.inverted && !n.xAxis.reversed || !a.inverted && n.xAxis.reversed, n.renderElements(), n.addMouseEvents()) : (n.xAxis = {
          chart: a,
          navigatorAxis: {
            fake: !0
          },
          translate: function (c, d) {
            var e = a.xAxis[0],
              f = e.getExtremes(),
              g = e.len - 2 * k,
              h = b("min", e.options.min, f.dataMin);
            e = b("max", e.options.max, f.dataMax) - h;
            return d ? c * e / g + h : g * (c - h) / e;
          },
          toPixels: function (a) {
            return this.translate(a);
          },
          toValue: function (a) {
            return this.translate(a, !0);
          }
        }, n.xAxis.navigatorAxis.axis = n.xAxis, n.xAxis.navigatorAxis.toFixedRange = t.AdditionsClass.prototype.toFixedRange.bind(n.xAxis.navigatorAxis));
        a.options.scrollbar.enabled && (a.scrollbar = n.scrollbar = new y(a.renderer, w(a.options.scrollbar, {
          margin: n.navigatorEnabled ? 0 : 10,
          vertical: a.inverted
        }), a), m(n.scrollbar, "changed", function (a) {
          var b = n.size,
            c = b * this.to;
          b *= this.from;
          n.hasDragged = n.scrollbar.hasDragged;
          n.render(0, 0, b, c);
          this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {
            n.onMouseUp(a);
          });
        }));
        n.addBaseSeriesEvents();
        n.addChartEvents();
      };
      f.prototype.getUnionExtremes = function (a) {
        var c = this.chart.xAxis[0],
          d = this.xAxis,
          e = d.options,
          f = c.options,
          g;
        a && null === c.dataMin || (g = {
          dataMin: l(e && e.min, b("min", f.min, c.dataMin, d.dataMin, d.min)),
          dataMax: l(e && e.max, b("max", f.max, c.dataMax, d.dataMax, d.max))
        });
        return g;
      };
      f.prototype.setBaseSeries = function (a, b) {
        var c = this.chart,
          d = this.baseSeries = [];
        a = a || c.options && c.options.navigator.baseSeries || (c.series.length ? z(c.series, function (a) {
          return !a.options.isInternal;
        }).index : 0);
        (c.series || []).forEach(function (b, c) {
          b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || d.push(b);
        });
        this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, b);
      };
      f.prototype.updateNavigatorSeries = function (a, b) {
        var c = this,
          d = c.chart,
          f = c.baseSeries,
          h,
          k,
          m = c.navigatorOptions.series,
          p,
          r = {
            enableMouseTracking: !1,
            index: null,
            linkedTo: null,
            group: "nav",
            padXAxis: !1,
            xAxis: "navigator-x-axis",
            yAxis: "navigator-y-axis",
            showInLegend: !1,
            stacking: void 0,
            isInternal: !0,
            states: {
              inactive: {
                opacity: 1
              }
            }
          },
          q = c.series = (c.series || []).filter(function (a) {
            var b = a.baseSeries;
            return 0 > f.indexOf(b) ? (b && (e(b, "updatedData", c.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;
          });
        f && f.length && f.forEach(function (a) {
          var e = a.navigatorSeries,
            x = v({
              color: a.color,
              visible: a.visible
            }, u(m) ? n.navigator.series : m);
          e && !1 === c.navigatorOptions.adaptToUpdatedData || (r.name = "Navigator " + f.length, h = a.options || {}, p = h.navigatorOptions || {}, x.dataLabels = g(x.dataLabels), k = w(h, r, x, p), k.pointRange = l(x.pointRange, p.pointRange, n.plotOptions[k.type || "line"].pointRange), x = p.data || x.data, c.hasNavigatorData = c.hasNavigatorData || !!x, k.data = x || h.data && h.data.slice(0), e && e.options ? e.update(k, b) : (a.navigatorSeries = d.initSeries(k), a.navigatorSeries.baseSeries = a, q.push(a.navigatorSeries)));
        });
        if (m.data && (!f || !f.length) || u(m)) c.hasNavigatorData = !1, m = g(m), m.forEach(function (a, b) {
          r.name = "Navigator " + (q.length + 1);
          k = w(n.navigator.series, {
            color: d.series[b] && !d.series[b].options.isInternal && d.series[b].color || d.options.colors[b] || d.options.colors[0]
          }, r, a);
          k.data = a.data;
          k.data && (c.hasNavigatorData = !0, q.push(d.initSeries(k)));
        });
        a && this.addBaseSeriesEvents();
      };
      f.prototype.addBaseSeriesEvents = function () {
        var a = this,
          b = a.baseSeries || [];
        b[0] && b[0].xAxis && b[0].eventsToUnbind.push(m(b[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
        b.forEach(function (b) {
          b.eventsToUnbind.push(m(b, "show", function () {
            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);
          }));
          b.eventsToUnbind.push(m(b, "hide", function () {
            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);
          }));
          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(m(b, "updatedData", this.updatedDataHandler));
          b.eventsToUnbind.push(m(b, "remove", function () {
            this.navigatorSeries && (K(a.series, this.navigatorSeries), I(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);
          }));
        }, this);
      };
      f.prototype.getBaseSeriesMin = function (a) {
        return this.baseSeries.reduce(function (a, b) {
          return Math.min(a, b.xData ? b.xData[0] : a);
        }, a);
      };
      f.prototype.modifyNavigatorAxisExtremes = function () {
        var a = this.xAxis,
          b;
        "undefined" !== typeof a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));
      };
      f.prototype.modifyBaseAxisExtremes = function () {
        var a = this.chart.navigator,
          b = this.getExtremes(),
          c = b.dataMin,
          d = b.dataMax;
        b = b.max - b.min;
        var e = a.stickToMin,
          f = a.stickToMax,
          g = l(this.options.overscroll, 0),
          h = a.series && a.series[0],
          m = !!this.setExtremes;
        if (!this.eventArgs || "rangeSelectorButton" !== this.eventArgs.trigger) {
          if (e) {
            var n = c;
            var p = n + b;
          }
          f && (p = d + g, e || (n = Math.max(c, p - b, a.getBaseSeriesMin(h && h.xData ? h.xData[0] : -Number.MAX_VALUE))));
          m && (e || f) && k(n) && (this.min = this.userMin = n, this.max = this.userMax = p);
        }
        a.stickToMin = a.stickToMax = null;
      };
      f.prototype.updatedDataHandler = function () {
        var a = this.chart.navigator,
          b = this.navigatorSeries;
        a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);
        a.stickToMin = a.shouldStickToMin(this, a);
        b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));
      };
      f.prototype.shouldStickToMin = function (a, b) {
        b = b.getBaseSeriesMin(a.xData[0]);
        var c = a.xAxis;
        a = c.max;
        var d = c.min;
        c = c.options.range;
        return k(a) && k(d) ? c && 0 < a - b ? a - b < c : d <= b : !1;
      };
      f.prototype.addChartEvents = function () {
        this.eventsToUnbind || (this.eventsToUnbind = []);
        this.eventsToUnbind.push(m(this.chart, "redraw", function () {
          var a = this.navigator,
            b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);
          b && a.render(b.min, b.max);
        }), m(this.chart, "getMargins", function () {
          var a = this.navigator,
            b = a.opposite ? "plotTop" : "marginBottom";
          this.inverted && (b = a.opposite ? "marginRight" : "plotLeft");
          this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;
        }));
      };
      f.prototype.destroy = function () {
        this.removeEvents();
        this.xAxis && (K(this.chart.xAxis, this.xAxis), K(this.chart.axes, this.xAxis));
        this.yAxis && (K(this.chart.yAxis, this.yAxis), K(this.chart.axes, this.yAxis));
        (this.series || []).forEach(function (a) {
          a.destroy && a.destroy();
        });
        "series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" ").forEach(function (a) {
          this[a] && this[a].destroy && this[a].destroy();
          this[a] = null;
        }, this);
        [this.handles].forEach(function (a) {
          L(a);
        }, this);
      };
      return f;
    }();
    F.Navigator || (F.Navigator = B, t.compose(d), m(h, "beforeShowResetZoom", function () {
      var b = this.options,
        c = b.navigator,
        d = b.rangeSelector;
      if ((c && c.enabled || d && d.enabled) && (!a && "x" === b.chart.zoomType || a && "x" === b.chart.pinchType)) return !1;
    }), m(h, "beforeRender", function () {
      var a = this.options;
      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new B(this);
    }), m(h, "afterSetChartSize", function () {
      var a = this.legend,
        b = this.navigator;
      if (b) {
        var c = a && a.options;
        var d = b.xAxis;
        var e = b.yAxis;
        var f = b.scrollbarHeight;
        this.inverted ? (b.left = b.opposite ? this.chartWidth - f - b.height : this.spacing[3] + f, b.top = this.plotTop + f) : (b.left = l(d.left, this.plotLeft + f), b.top = b.navigatorOptions.top || this.chartHeight - b.height - f - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && "bottom" === c.verticalAlign && "proximate" !== c.layout && c.enabled && !c.floating ? a.legendHeight + l(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));
        d && e && (this.inverted ? d.options.left = e.options.left = b.left : d.options.top = e.options.top = b.top, d.setAxisSize(), e.setAxisSize());
      }
    }), m(h, "update", function (a) {
      var b = a.options.navigator || {},
        c = a.options.scrollbar || {};
      this.navigator || this.scroller || !b.enabled && !c.enabled || (w(!0, this.options.navigator, b), w(!0, this.options.scrollbar, c), delete a.options.navigator, delete a.options.scrollbar);
    }), m(h, "afterUpdate", function (a) {
      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new B(this), l(a.redraw, !0) && this.redraw(a.animation));
    }), m(h, "afterAddSeries", function () {
      this.navigator && this.navigator.setBaseSeries(null, !1);
    }), m(q, "afterUpdate", function () {
      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);
    }), h.prototype.callbacks.push(function (a) {
      var b = a.navigator;
      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));
    }));
    F.Navigator = B;
    return F.Navigator;
  });
  N(h, "Extensions/RangeSelector.js", [h["Core/Axis/Axis.js"], h["Core/Chart/Chart.js"], h["Core/Globals.js"], h["Core/DefaultOptions.js"], h["Core/Renderer/SVG/SVGElement.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G) {
    function E(a) {
      if (-1 !== a.indexOf("%L")) return "text";
      var b = "aAdewbBmoyY".split("").some(function (b) {
          return -1 !== a.indexOf("%" + b);
        }),
        c = "HkIlMS".split("").some(function (b) {
          return -1 !== a.indexOf("%" + b);
        });
      return b && c ? "datetime-local" : b ? "date" : c ? "time" : "text";
    }
    var y = F.defaultOptions,
      q = G.addEvent,
      p = G.createElement,
      f = G.css,
      c = G.defined,
      a = G.destroyObjectProperties,
      n = G.discardElement,
      m = G.extend,
      D = G.find,
      C = G.fireEvent,
      I = G.isNumber,
      L = G.merge,
      K = G.objectEach,
      v = G.pad,
      z = G.pick,
      u = G.pInt,
      k = G.splat;
    m(y, {
      rangeSelector: {
        allButtonsEnabled: !1,
        buttons: void 0,
        buttonSpacing: 5,
        dropdown: "responsive",
        enabled: void 0,
        verticalAlign: "top",
        buttonTheme: {
          width: 28,
          height: 18,
          padding: 2,
          zIndex: 7
        },
        floating: !1,
        x: 0,
        y: 0,
        height: void 0,
        inputBoxBorderColor: "none",
        inputBoxHeight: 17,
        inputBoxWidth: void 0,
        inputDateFormat: "%b %e, %Y",
        inputDateParser: void 0,
        inputEditDateFormat: "%Y-%m-%d",
        inputEnabled: !0,
        inputPosition: {
          align: "right",
          x: 0,
          y: 0
        },
        inputSpacing: 5,
        selected: void 0,
        buttonPosition: {
          align: "left",
          x: 0,
          y: 0
        },
        inputStyle: {
          color: "#335cad",
          cursor: "pointer"
        },
        labelStyle: {
          color: "#666666"
        }
      }
    });
    m(y.lang, {
      rangeSelectorZoom: "Zoom",
      rangeSelectorFrom: "",
      rangeSelectorTo: "\u2192"
    });
    var w = function () {
      function e(a) {
        this.buttons = void 0;
        this.buttonOptions = e.prototype.defaultButtons;
        this.initialButtonGroupWidth = 0;
        this.options = void 0;
        this.chart = a;
        this.init(a);
      }
      e.prototype.clickButton = function (a, e) {
        var b = this.chart,
          f = this.buttonOptions[a],
          g = b.xAxis[0],
          h = b.scroller && b.scroller.getUnionExtremes() || g || {},
          l = h.dataMin,
          m = h.dataMax,
          n = g && Math.round(Math.min(g.max, z(m, g.max))),
          p = f.type;
        h = f._range;
        var u,
          B = f.dataGrouping;
        if (null !== l && null !== m) {
          b.fixedRange = h;
          this.setSelected(a);
          B && (this.forcedDataGrouping = !0, d.prototype.setDataGrouping.call(g || {
            chart: this.chart
          }, B, !1), this.frozenStates = f.preserveDataGrouping);
          if ("month" === p || "year" === p) {
            if (g) {
              p = {
                range: f,
                max: n,
                chart: b,
                dataMin: l,
                dataMax: m
              };
              var w = g.minFromRange.call(p);
              I(p.newMax) && (n = p.newMax);
            } else h = f;
          } else if (h) w = Math.max(n - h, l), n = Math.min(w + h, m);else if ("ytd" === p) {
            if (g) "undefined" === typeof m && (l = Number.MAX_VALUE, m = Number.MIN_VALUE, b.series.forEach(function (a) {
              a = a.xData;
              l = Math.min(a[0], l);
              m = Math.max(a[a.length - 1], m);
            }), e = !1), n = this.getYTDExtremes(m, l, b.time.useUTC), w = u = n.min, n = n.max;else {
              this.deferredYTDClick = a;
              return;
            }
          } else "all" === p && g && (b.navigator && b.navigator.baseSeries[0] && (b.navigator.baseSeries[0].xAxis.options.range = void 0), w = l, n = m);
          c(w) && (w += f._offsetMin);
          c(n) && (n += f._offsetMax);
          this.dropdown && (this.dropdown.selectedIndex = a + 1);
          if (g) g.setExtremes(w, n, z(e, !0), void 0, {
            trigger: "rangeSelectorButton",
            rangeSelectorButton: f
          });else {
            var t = k(b.options.xAxis)[0];
            var v = t.range;
            t.range = h;
            var y = t.min;
            t.min = u;
            q(b, "load", function () {
              t.range = v;
              t.min = y;
            });
          }
          C(this, "afterBtnClick");
        }
      };
      e.prototype.setSelected = function (a) {
        this.selected = this.options.selected = a;
      };
      e.prototype.init = function (a) {
        var b = this,
          c = a.options.rangeSelector,
          e = c.buttons || b.defaultButtons.slice(),
          d = c.selected,
          f = function () {
            var a = b.minInput,
              c = b.maxInput;
            a && a.blur && C(a, "blur");
            c && c.blur && C(c, "blur");
          };
        b.chart = a;
        b.options = c;
        b.buttons = [];
        b.buttonOptions = e;
        this.eventsToUnbind = [];
        this.eventsToUnbind.push(q(a.container, "mousedown", f));
        this.eventsToUnbind.push(q(a, "resize", f));
        e.forEach(b.computeButtonRange);
        "undefined" !== typeof d && e[d] && this.clickButton(d, !1);
        this.eventsToUnbind.push(q(a, "load", function () {
          a.xAxis && a.xAxis[0] && q(a.xAxis[0], "setExtremes", function (c) {
            this.max - this.min !== a.fixedRange && "rangeSelectorButton" !== c.trigger && "updatedData" !== c.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);
          });
        }));
      };
      e.prototype.updateButtonStates = function () {
        var a = this,
          c = this.chart,
          e = this.dropdown,
          d = c.xAxis[0],
          f = Math.round(d.max - d.min),
          g = !d.hasVisibleSeries,
          h = c.scroller && c.scroller.getUnionExtremes() || d,
          k = h.dataMin,
          l = h.dataMax;
        c = a.getYTDExtremes(l, k, c.time.useUTC);
        var m = c.min,
          n = c.max,
          p = a.selected,
          q = I(p),
          u = a.options.allButtonsEnabled,
          w = a.buttons;
        a.buttonOptions.forEach(function (b, c) {
          var h = b._range,
            r = b.type,
            x = b.count || 1,
            t = w[c],
            B = 0,
            v = b._offsetMax - b._offsetMin;
          b = c === p;
          var z = h > l - k,
            y = h < d.minRange,
            A = !1,
            J = !1;
          h = h === f;
          ("month" === r || "year" === r) && f + 36E5 >= 864E5 * {
            month: 28,
            year: 365
          }[r] * x - v && f - 36E5 <= 864E5 * {
            month: 31,
            year: 366
          }[r] * x + v ? h = !0 : "ytd" === r ? (h = n - m + v === f, A = !b) : "all" === r && (h = d.max - d.min >= l - k, J = !b && q && h);
          r = !u && (z || y || J || g);
          x = b && h || h && !q && !A || b && a.frozenStates;
          r ? B = 3 : x && (q = !0, B = 2);
          t.state !== B && (t.setState(B), e && (e.options[c + 1].disabled = r, 2 === B && (e.selectedIndex = c + 1)), 0 === B && p === c && a.setSelected());
        });
      };
      e.prototype.computeButtonRange = function (a) {
        var b = a.type,
          c = a.count || 1,
          e = {
            millisecond: 1,
            second: 1E3,
            minute: 6E4,
            hour: 36E5,
            day: 864E5,
            week: 6048E5
          };
        if (e[b]) a._range = e[b] * c;else if ("month" === b || "year" === b) a._range = 864E5 * {
          month: 30,
          year: 365
        }[b] * c;
        a._offsetMin = z(a.offsetMin, 0);
        a._offsetMax = z(a.offsetMax, 0);
        a._range += a._offsetMax - a._offsetMin;
      };
      e.prototype.getInputValue = function (a) {
        a = "min" === a ? this.minInput : this.maxInput;
        var b = this.chart.options.rangeSelector,
          c = this.chart.time;
        return a ? ("text" === a.type && b.inputDateParser || this.defaultInputDateParser)(a.value, c.useUTC, c) : 0;
      };
      e.prototype.setInputValue = function (a, e) {
        var b = this.options,
          d = this.chart.time,
          f = "min" === a ? this.minInput : this.maxInput;
        a = "min" === a ? this.minDateBox : this.maxDateBox;
        if (f) {
          var g = f.getAttribute("data-hc-time");
          g = c(g) ? Number(g) : void 0;
          c(e) && (c(g) && f.setAttribute("data-hc-time-previous", g), f.setAttribute("data-hc-time", e), g = e);
          f.value = d.dateFormat(this.inputTypeFormats[f.type] || b.inputEditDateFormat, g);
          a && a.attr({
            text: d.dateFormat(b.inputDateFormat, g)
          });
        }
      };
      e.prototype.setInputExtremes = function (a, c, e) {
        if (a = "min" === a ? this.minInput : this.maxInput) {
          var b = this.inputTypeFormats[a.type],
            d = this.chart.time;
          b && (c = d.dateFormat(b, c), a.min !== c && (a.min = c), e = d.dateFormat(b, e), a.max !== e && (a.max = e));
        }
      };
      e.prototype.showInput = function (a) {
        var b = "min" === a ? this.minDateBox : this.maxDateBox;
        if ((a = "min" === a ? this.minInput : this.maxInput) && b && this.inputGroup) {
          var c = "text" === a.type,
            e = this.inputGroup,
            d = e.translateX;
          e = e.translateY;
          var g = this.options.inputBoxWidth;
          f(a, {
            width: c ? b.width + (g ? -2 : 20) + "px" : "auto",
            height: c ? b.height - 2 + "px" : "auto",
            border: "2px solid silver"
          });
          c && g ? f(a, {
            left: d + b.x + "px",
            top: e + "px"
          }) : f(a, {
            left: Math.min(Math.round(b.x + d - (a.offsetWidth - b.width) / 2), this.chart.chartWidth - a.offsetWidth) + "px",
            top: e - (a.offsetHeight - b.height) / 2 + "px"
          });
        }
      };
      e.prototype.hideInput = function (a) {
        (a = "min" === a ? this.minInput : this.maxInput) && f(a, {
          top: "-9999em",
          border: 0,
          width: "1px",
          height: "1px"
        });
      };
      e.prototype.defaultInputDateParser = function (a, c, e) {
        var b = a.split("/").join("-").split(" ").join("T");
        -1 === b.indexOf("T") && (b += "T00:00");
        if (c) b += "Z";else {
          var d;
          if (d = A.isSafari) d = b, d = !(6 < d.length && (d.lastIndexOf("-") === d.length - 6 || d.lastIndexOf("+") === d.length - 6));
          d && (d = new Date(b).getTimezoneOffset() / 60, b += 0 >= d ? "+" + v(-d) + ":00" : "-" + v(d) + ":00");
        }
        b = Date.parse(b);
        I(b) || (a = a.split("-"), b = Date.UTC(u(a[0]), u(a[1]) - 1, u(a[2])));
        e && c && I(b) && (b += e.getTimezoneOffset(b));
        return b;
      };
      e.prototype.drawInput = function (a) {
        function b() {
          var b = g.getInputValue(a),
            e = c.xAxis[0],
            d = c.scroller && c.scroller.xAxis ? c.scroller.xAxis : e,
            f = d.dataMin;
          d = d.dataMax;
          var h = g.maxInput,
            k = g.minInput;
          b !== Number(u.getAttribute("data-hc-time-previous")) && I(b) && (u.setAttribute("data-hc-time-previous", b), n && h && I(f) ? b > Number(h.getAttribute("data-hc-time")) ? b = void 0 : b < f && (b = f) : k && I(d) && (b < Number(k.getAttribute("data-hc-time")) ? b = void 0 : b > d && (b = d)), "undefined" !== typeof b && e.setExtremes(n ? b : e.min, n ? e.max : b, void 0, void 0, {
            trigger: "rangeSelectorInput"
          }));
        }
        var c = this.chart,
          e = this.div,
          d = this.inputGroup,
          g = this,
          h = c.renderer.style || {},
          k = c.renderer,
          l = c.options.rangeSelector,
          n = "min" === a,
          q = y.lang[n ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
        q = k.label(q, 0).addClass("highcharts-range-label").attr({
          padding: q ? 2 : 0,
          height: q ? l.inputBoxHeight : 0
        }).add(d);
        k = k.label("", 0).addClass("highcharts-range-input").attr({
          padding: 2,
          width: l.inputBoxWidth,
          height: l.inputBoxHeight,
          "text-align": "center"
        }).on("click", function () {
          g.showInput(a);
          g[a + "Input"].focus();
        });
        c.styledMode || k.attr({
          stroke: l.inputBoxBorderColor,
          "stroke-width": 1
        });
        k.add(d);
        var u = p("input", {
          name: a,
          className: "highcharts-range-selector"
        }, void 0, e);
        u.setAttribute("type", E(l.inputDateFormat || "%b %e, %Y"));
        c.styledMode || (q.css(L(h, l.labelStyle)), k.css(L({
          color: "#333333"
        }, h, l.inputStyle)), f(u, m({
          position: "absolute",
          border: 0,
          boxShadow: "0 0 15px rgba(0,0,0,0.3)",
          width: "1px",
          height: "1px",
          padding: 0,
          textAlign: "center",
          fontSize: h.fontSize,
          fontFamily: h.fontFamily,
          top: "-9999em"
        }, l.inputStyle)));
        u.onfocus = function () {
          g.showInput(a);
        };
        u.onblur = function () {
          u === A.doc.activeElement && b();
          g.hideInput(a);
          g.setInputValue(a);
          u.blur();
        };
        var w = !1;
        u.onchange = function () {
          w || (b(), g.hideInput(a), u.blur());
        };
        u.onkeypress = function (a) {
          13 === a.keyCode && b();
        };
        u.onkeydown = function (a) {
          w = !0;
          38 !== a.keyCode && 40 !== a.keyCode || b();
        };
        u.onkeyup = function () {
          w = !1;
        };
        return {
          dateBox: k,
          input: u,
          label: q
        };
      };
      e.prototype.getPosition = function () {
        var a = this.chart,
          c = a.options.rangeSelector;
        a = "top" === c.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;
        return {
          buttonTop: a + c.buttonPosition.y,
          inputTop: a + c.inputPosition.y - 10
        };
      };
      e.prototype.getYTDExtremes = function (a, c, e) {
        var b = this.chart.time,
          d = new b.Date(a),
          f = b.get("FullYear", d);
        e = e ? b.Date.UTC(f, 0, 1) : +new b.Date(f, 0, 1);
        c = Math.max(c, e);
        d = d.getTime();
        return {
          max: Math.min(a || d, d),
          min: c
        };
      };
      e.prototype.render = function (a, e) {
        var b = this.chart,
          d = b.renderer,
          f = b.container,
          g = b.options,
          h = g.rangeSelector,
          k = z(g.chart.style && g.chart.style.zIndex, 0) + 1;
        g = h.inputEnabled;
        if (!1 !== h.enabled) {
          this.rendered || (this.group = d.g("range-selector-group").attr({
            zIndex: 7
          }).add(), this.div = p("div", void 0, {
            position: "relative",
            height: 0,
            zIndex: k
          }), this.buttonOptions.length && this.renderButtons(), f.parentNode && f.parentNode.insertBefore(this.div, f), g && (this.inputGroup = d.g("input-group").add(this.group), d = this.drawInput("min"), this.minDateBox = d.dateBox, this.minLabel = d.label, this.minInput = d.input, d = this.drawInput("max"), this.maxDateBox = d.dateBox, this.maxLabel = d.label, this.maxInput = d.input));
          if (g && (this.setInputValue("min", a), this.setInputValue("max", e), a = b.scroller && b.scroller.getUnionExtremes() || b.xAxis[0] || {}, c(a.dataMin) && c(a.dataMax) && (b = b.xAxis[0].minRange || 0, this.setInputExtremes("min", a.dataMin, Math.min(a.dataMax, this.getInputValue("max")) - b), this.setInputExtremes("max", Math.max(a.dataMin, this.getInputValue("min")) + b, a.dataMax)), this.inputGroup)) {
            var l = 0;
            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {
              if (a) {
                var b = a.getBBox().width;
                b && (a.attr({
                  x: l
                }), l += b + h.inputSpacing);
              }
            });
          }
          this.alignElements();
          this.rendered = !0;
        }
      };
      e.prototype.renderButtons = function () {
        var a = this,
          c = this.buttons,
          d = this.options,
          e = y.lang,
          f = this.chart.renderer,
          g = L(d.buttonTheme),
          h = g && g.states,
          k = g.width || 28;
        delete g.width;
        delete g.states;
        this.buttonGroup = f.g("range-selector-buttons").add(this.group);
        var l = this.dropdown = p("select", void 0, {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: 0,
          border: 0,
          top: "-9999em",
          cursor: "pointer",
          opacity: .0001
        }, this.div);
        q(l, "touchstart", function () {
          l.style.fontSize = "16px";
        });
        [[A.isMS ? "mouseover" : "mouseenter"], [A.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(function (b) {
          var d = b[0],
            e = b[1];
          q(l, d, function () {
            var b = c[a.currentButtonIndex()];
            b && C(b.element, e || d);
          });
        });
        this.zoomText = f.label(e && e.rangeSelectorZoom || "", 0).attr({
          padding: d.buttonTheme.padding,
          height: d.buttonTheme.height,
          paddingLeft: 0,
          paddingRight: 0
        }).add(this.buttonGroup);
        this.chart.styledMode || (this.zoomText.css(d.labelStyle), g["stroke-width"] = z(g["stroke-width"], 0));
        p("option", {
          textContent: this.zoomText.textStr,
          disabled: !0
        }, void 0, l);
        this.buttonOptions.forEach(function (b, d) {
          p("option", {
            textContent: b.title || b.text
          }, void 0, l);
          c[d] = f.button(b.text, 0, 0, function (c) {
            var e = b.events && b.events.click,
              f;
            e && (f = e.call(b, c));
            !1 !== f && a.clickButton(d);
            a.isActive = !0;
          }, g, h && h.hover, h && h.select, h && h.disabled).attr({
            "text-align": "center",
            width: k
          }).add(a.buttonGroup);
          b.title && c[d].attr("title", b.title);
        });
      };
      e.prototype.alignElements = function () {
        var a = this,
          c = this.buttonGroup,
          d = this.buttons,
          e = this.chart,
          f = this.group,
          g = this.inputGroup,
          h = this.options,
          k = this.zoomText,
          l = e.options,
          m = l.exporting && !1 !== l.exporting.enabled && l.navigation && l.navigation.buttonOptions;
        l = h.buttonPosition;
        var n = h.inputPosition,
          p = h.verticalAlign,
          q = function (b, c) {
            return m && a.titleCollision(e) && "top" === p && "right" === c.align && c.y - b.getBBox().height - 12 < (m.y || 0) + (m.height || 0) + e.spacing[0] ? -40 : 0;
          },
          u = e.plotLeft;
        if (f && l && n) {
          var w = l.x - e.spacing[3];
          if (c) {
            this.positionButtons();
            if (!this.initialButtonGroupWidth) {
              var t = 0;
              k && (t += k.getBBox().width + 5);
              d.forEach(function (a, b) {
                t += a.width;
                b !== d.length - 1 && (t += h.buttonSpacing);
              });
              this.initialButtonGroupWidth = t;
            }
            u -= e.spacing[3];
            this.updateButtonStates();
            k = q(c, l);
            this.alignButtonGroup(k);
            f.placed = c.placed = e.hasLoaded;
          }
          c = 0;
          g && (c = q(g, n), "left" === n.align ? w = u : "right" === n.align && (w = -Math.max(e.axisOffset[1], -c)), g.align({
            y: n.y,
            width: g.getBBox().width,
            align: n.align,
            x: n.x + w - 2
          }, !0, e.spacingBox), g.placed = e.hasLoaded);
          this.handleCollision(c);
          f.align({
            verticalAlign: p
          }, !0, e.spacingBox);
          g = f.alignAttr.translateY;
          c = f.getBBox().height + 20;
          q = 0;
          "bottom" === p && (q = (q = e.legend && e.legend.options) && "bottom" === q.verticalAlign && q.enabled && !q.floating ? e.legend.legendHeight + z(q.margin, 10) : 0, c = c + q - 20, q = g - c - (h.floating ? 0 : h.y) - (e.titleOffset ? e.titleOffset[2] : 0) - 10);
          if ("top" === p) h.floating && (q = 0), e.titleOffset && e.titleOffset[0] && (q = e.titleOffset[0]), q += e.margin[0] - e.spacing[0] || 0;else if ("middle" === p) if (n.y === l.y) q = g;else if (n.y || l.y) q = 0 > n.y || 0 > l.y ? q - Math.min(n.y, l.y) : g - c;
          f.translate(h.x, h.y + Math.floor(q));
          l = this.minInput;
          n = this.maxInput;
          g = this.dropdown;
          h.inputEnabled && l && n && (l.style.marginTop = f.translateY + "px", n.style.marginTop = f.translateY + "px");
          g && (g.style.marginTop = f.translateY + "px");
        }
      };
      e.prototype.alignButtonGroup = function (a, c) {
        var b = this.chart,
          e = this.buttonGroup,
          d = this.options.buttonPosition,
          f = b.plotLeft - b.spacing[3],
          g = d.x - b.spacing[3];
        "right" === d.align ? g += a - f : "center" === d.align && (g -= f / 2);
        e && e.align({
          y: d.y,
          width: z(c, this.initialButtonGroupWidth),
          align: d.align,
          x: g
        }, !0, b.spacingBox);
      };
      e.prototype.positionButtons = function () {
        var a = this.buttons,
          c = this.chart,
          e = this.options,
          d = this.zoomText,
          f = c.hasLoaded ? "animate" : "attr",
          g = e.buttonPosition,
          h = c.plotLeft,
          k = h;
        d && "hidden" !== d.visibility && (d[f]({
          x: z(h + g.x, h)
        }), k += g.x + d.getBBox().width + 5);
        this.buttonOptions.forEach(function (b, c) {
          if ("hidden" !== a[c].visibility) a[c][f]({
            x: k
          }), k += a[c].width + e.buttonSpacing;else a[c][f]({
            x: h
          });
        });
      };
      e.prototype.handleCollision = function (a) {
        var b = this,
          c = this.chart,
          e = this.buttonGroup,
          d = this.inputGroup,
          f = this.options,
          g = f.buttonPosition,
          h = f.dropdown,
          k = f.inputPosition;
        f = function () {
          var a = 0;
          b.buttons.forEach(function (b) {
            b = b.getBBox();
            b.width > a && (a = b.width);
          });
          return a;
        };
        var l = function (b) {
            if (d && e) {
              var c = d.alignAttr.translateX + d.alignOptions.x - a + d.getBBox().x + 2,
                f = d.alignOptions.width,
                h = e.alignAttr.translateX + e.getBBox().x;
              return h + b > c && c + f > h && g.y < k.y + d.getBBox().height;
            }
            return !1;
          },
          m = function () {
            d && e && d.attr({
              translateX: d.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),
              translateY: d.alignAttr.translateY + e.getBBox().height + 10
            });
          };
        if (e) {
          if ("always" === h) {
            this.collapseButtons(a);
            l(f()) && m();
            return;
          }
          "never" === h && this.expandButtons();
        }
        d && e ? k.align === g.align || l(this.initialButtonGroupWidth + 20) ? "responsive" === h ? (this.collapseButtons(a), l(f()) && m()) : m() : "responsive" === h && this.expandButtons() : e && "responsive" === h && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());
      };
      e.prototype.collapseButtons = function (a) {
        var b = this.buttons,
          c = this.buttonOptions,
          e = this.chart,
          d = this.dropdown,
          f = this.options,
          g = this.zoomText,
          h = e.userOptions.rangeSelector && e.userOptions.rangeSelector.buttonTheme || {},
          k = function (a) {
            return {
              text: a ? a + " \u25be" : "\u25be",
              width: "auto",
              paddingLeft: z(f.buttonTheme.paddingLeft, h.padding, 8),
              paddingRight: z(f.buttonTheme.paddingRight, h.padding, 8)
            };
          };
        g && g.hide();
        var l = !1;
        c.forEach(function (a, c) {
          c = b[c];
          2 !== c.state ? c.hide() : (c.show(), c.attr(k(a.text)), l = !0);
        });
        l || (d && (d.selectedIndex = 0), b[0].show(), b[0].attr(k(this.zoomText && this.zoomText.textStr)));
        c = f.buttonPosition.align;
        this.positionButtons();
        "right" !== c && "center" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);
        this.showDropdown();
      };
      e.prototype.expandButtons = function () {
        var a = this.buttons,
          c = this.buttonOptions,
          e = this.options,
          d = this.zoomText;
        this.hideDropdown();
        d && d.show();
        c.forEach(function (b, c) {
          c = a[c];
          c.show();
          c.attr({
            text: b.text,
            width: e.buttonTheme.width || 28,
            paddingLeft: z(e.buttonTheme.paddingLeft, "unset"),
            paddingRight: z(e.buttonTheme.paddingRight, "unset")
          });
          2 > c.state && c.setState(0);
        });
        this.positionButtons();
      };
      e.prototype.currentButtonIndex = function () {
        var a = this.dropdown;
        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;
      };
      e.prototype.showDropdown = function () {
        var a = this.buttonGroup,
          c = this.buttons,
          e = this.chart,
          d = this.dropdown;
        if (a && d) {
          var g = a.translateX;
          a = a.translateY;
          c = c[this.currentButtonIndex()].getBBox();
          f(d, {
            left: e.plotLeft + g + "px",
            top: a + .5 + "px",
            width: c.width + "px",
            height: c.height + "px"
          });
          this.hasVisibleDropdown = !0;
        }
      };
      e.prototype.hideDropdown = function () {
        var a = this.dropdown;
        a && (f(a, {
          top: "-9999em",
          width: "1px",
          height: "1px"
        }), this.hasVisibleDropdown = !1);
      };
      e.prototype.getHeight = function () {
        var a = this.options,
          c = this.group,
          e = a.y,
          d = a.buttonPosition.y,
          f = a.inputPosition.y;
        if (a.height) return a.height;
        this.alignElements();
        a = c ? c.getBBox(!0).height + 13 + e : 0;
        c = Math.min(f, d);
        if (0 > f && 0 > d || 0 < f && 0 < d) a += Math.abs(c);
        return a;
      };
      e.prototype.titleCollision = function (a) {
        return !(a.options.title.text || a.options.subtitle.text);
      };
      e.prototype.update = function (a) {
        var b = this.chart;
        L(!0, b.options.rangeSelector, a);
        this.destroy();
        this.init(b);
        this.render();
      };
      e.prototype.destroy = function () {
        var b = this,
          c = b.minInput,
          d = b.maxInput;
        b.eventsToUnbind && (b.eventsToUnbind.forEach(function (a) {
          return a();
        }), b.eventsToUnbind = void 0);
        a(b.buttons);
        c && (c.onfocus = c.onblur = c.onchange = null);
        d && (d.onfocus = d.onblur = d.onchange = null);
        K(b, function (a, c) {
          a && "chart" !== c && (a instanceof t ? a.destroy() : a instanceof window.HTMLElement && n(a));
          a !== e.prototype[c] && (b[c] = null);
        }, this);
      };
      return e;
    }();
    w.prototype.defaultButtons = [{
      type: "month",
      count: 1,
      text: "1m",
      title: "View 1 month"
    }, {
      type: "month",
      count: 3,
      text: "3m",
      title: "View 3 months"
    }, {
      type: "month",
      count: 6,
      text: "6m",
      title: "View 6 months"
    }, {
      type: "ytd",
      text: "YTD",
      title: "View year to date"
    }, {
      type: "year",
      count: 1,
      text: "1y",
      title: "View 1 year"
    }, {
      type: "all",
      text: "All",
      title: "View all"
    }];
    w.prototype.inputTypeFormats = {
      "datetime-local": "%Y-%m-%dT%H:%M:%S",
      date: "%Y-%m-%d",
      time: "%H:%M:%S"
    };
    d.prototype.minFromRange = function () {
      var a = this.range,
        b = a.type,
        c = this.max,
        d = this.chart.time,
        e = function (a, c) {
          var e = "year" === b ? "FullYear" : "Month",
            f = new d.Date(a),
            g = d.get(e, f);
          d.set(e, f, g + c);
          g === d.get(e, f) && d.set("Date", f, 0);
          return f.getTime() - a;
        };
      if (I(a)) {
        var f = c - a;
        var h = a;
      } else f = c + e(c, -a.count), this.chart && (this.chart.fixedRange = c - f);
      var k = z(this.dataMin, Number.MIN_VALUE);
      I(f) || (f = k);
      f <= k && (f = k, "undefined" === typeof h && (h = e(f, a.count)), this.newMax = Math.min(f + h, this.dataMax));
      I(c) || (f = void 0);
      return f;
    };
    if (!A.RangeSelector) {
      var l = [],
        e = function (a) {
          function b() {
            e && (c = a.xAxis[0].getExtremes(), d = a.legend, g = e && e.options.verticalAlign, I(c.min) && e.render(c.min, c.max), d.display && "top" === g && g === d.options.verticalAlign && (f = L(a.spacingBox), f.y = "vertical" === d.options.layout ? a.plotTop : f.y + e.getHeight(), d.group.placed = !1, d.align(f)));
          }
          var c,
            e = a.rangeSelector,
            d,
            f,
            g;
          e && (D(l, function (b) {
            return b[0] === a;
          }) || l.push([a, [q(a.xAxis[0], "afterSetExtremes", function (a) {
            e && e.render(a.min, a.max);
          }), q(a, "redraw", b)]]), b());
        };
      q(h, "afterGetContainer", function () {
        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new w(this));
      });
      q(h, "beforeRender", function () {
        var a = this.axes,
          b = this.rangeSelector;
        b && (I(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {
          a.updateNames();
          a.setScale();
        }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || ("bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0)));
      });
      q(h, "update", function (a) {
        var b = a.options.rangeSelector;
        a = this.rangeSelector;
        var d = this.extraBottomMargin,
          f = this.extraTopMargin;
        b && b.enabled && !c(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new w(this));
        this.extraTopMargin = this.extraBottomMargin = !1;
        a && (e(this), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || ("bottom" === b ? this.extraBottomMargin = !0 : "middle" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== d || this.extraTopMargin !== f) && (this.isDirtyBox = !0);
      });
      q(h, "render", function () {
        var a = this.rangeSelector;
        a && !a.options.floating && (a.render(), a = a.options.verticalAlign, "bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0));
      });
      q(h, "getMargins", function () {
        var a = this.rangeSelector;
        a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));
      });
      h.prototype.callbacks.push(e);
      q(h, "destroy", function () {
        for (var a = 0; a < l.length; a++) {
          var b = l[a];
          if (b[0] === this) {
            b[1].forEach(function (a) {
              return a();
            });
            l.splice(a, 1);
            break;
          }
        }
      });
      A.RangeSelector = w;
    }
    return w;
  });
  N(h, "Core/Chart/StockChart.js", [h["Core/Animation/AnimationUtilities.js"], h["Core/Axis/Axis.js"], h["Core/Chart/Chart.js"], h["Core/FormatUtilities.js"], h["Core/DefaultOptions.js"], h["Core/Series/Series.js"], h["Core/Renderer/SVG/SVGRenderer.js"], h["Core/Utilities.js"]], function (d, h, A, F, t, G, H, y) {
    function q(a, c) {
      return "xAxis" === a ? {
        minPadding: 0,
        maxPadding: 0,
        overscroll: 0,
        ordinal: !0,
        title: {
          text: null
        },
        labels: {
          overflow: "justify"
        },
        showLastLabel: !0
      } : "yAxis" === a ? {
        labels: {
          y: -2
        },
        opposite: v(c.opposite, !0),
        showLastLabel: !(!c.categories && "category" !== c.type),
        title: {
          text: null
        }
      } : {};
    }
    function p(c, d) {
      if ("xAxis" === c) {
        c = a();
        var f = {
          type: "datetime",
          categories: void 0
        };
        v(d.navigator && d.navigator.enabled, c.navigator.enabled, !0) && (f.startOnTick = !1, f.endOnTick = !1);
        return f;
      }
      return {};
    }
    var f = this && this.__extends || function () {
        var a = function (c, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var d in c) c.hasOwnProperty(d) && (a[d] = c[d]);
          };
          return a(c, d);
        };
        return function (c, d) {
          function f() {
            this.constructor = c;
          }
          a(c, d);
          c.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());
        };
      }(),
      c = F.format,
      a = t.getOptions;
    d = y.addEvent;
    var n = y.clamp,
      m = y.defined,
      E = y.extend,
      C = y.find,
      I = y.isNumber,
      L = y.isString,
      K = y.merge,
      v = y.pick,
      z = y.splat;
    y = function (c) {
      function d() {
        return null !== c && c.apply(this, arguments) || this;
      }
      f(d, c);
      d.prototype.init = function (d, f) {
        var e = a(),
          g = d.xAxis,
          b = d.yAxis,
          h = v(d.navigator && d.navigator.enabled, e.navigator.enabled, !0);
        d.xAxis = d.yAxis = void 0;
        h = K({
          chart: {
            panning: {
              enabled: !0,
              type: "x"
            },
            pinchType: "x"
          },
          navigator: {
            enabled: h
          },
          scrollbar: {
            enabled: v(e.scrollbar && e.scrollbar.enabled, !0)
          },
          rangeSelector: {
            enabled: v(e.rangeSelector.enabled, !0)
          },
          title: {
            text: null
          },
          tooltip: {
            split: v(e.tooltip.split, !0),
            crosshairs: !0
          },
          legend: {
            enabled: !1
          }
        }, d, {
          isStock: !0
        });
        d.xAxis = g;
        d.yAxis = b;
        h.xAxis = z(d.xAxis || {}).map(function (a, b) {
          return K(q("xAxis", a), e.xAxis, e.xAxis && e.xAxis[b], a, p("xAxis", d));
        });
        h.yAxis = z(d.yAxis || {}).map(function (a, b) {
          return K(q("yAxis", a), e.yAxis, e.yAxis && e.yAxis[b], a);
        });
        c.prototype.init.call(this, h, f);
      };
      d.prototype.createAxis = function (a, d) {
        d.axis = K(q(a, d.axis), d.axis, p(a, this.userOptions));
        return c.prototype.createAxis.call(this, a, d);
      };
      return d;
    }(A);
    (function (a) {
      a.stockChart = function (c, d, f) {
        return new a(c, d, f);
      };
    })(y || (y = {}));
    d(G, "setOptions", function (a) {
      var c;
      this.chart.options.isStock && (this.is("column") || this.is("columnrange") ? c = {
        borderWidth: 0,
        shadow: !1
      } : this.is("scatter") || this.is("sma") || (c = {
        marker: {
          enabled: !1,
          radius: 2
        }
      }), c && (a.plotOptions[this.type] = K(a.plotOptions[this.type], c)));
    });
    d(h, "autoLabelAlign", function (a) {
      var c = this.chart,
        d = this.options;
      c = c._labelPanes = c._labelPanes || {};
      var f = this.options.labels;
      this.chart.options.isStock && "yAxis" === this.coll && (d = d.top + "," + d.height, !c[d] && f.enabled && (15 === f.x && (f.x = 0), "undefined" === typeof f.align && (f.align = "right"), c[d] = this, a.align = "right", a.preventDefault()));
    });
    d(h, "destroy", function () {
      var a = this.chart,
        c = this.options && this.options.top + "," + this.options.height;
      c && a._labelPanes && a._labelPanes[c] === this && delete a._labelPanes[c];
    });
    d(h, "getPlotLinePath", function (a) {
      function c(a) {
        var b = "xAxis" === a ? "yAxis" : "xAxis";
        a = d.options[b];
        return I(a) ? [e[b][a]] : L(a) ? [e.get(a)] : f.map(function (a) {
          return a[b];
        });
      }
      var d = this,
        f = this.isLinked && !this.series ? this.linkedParent.series : this.series,
        e = d.chart,
        g = e.renderer,
        b = d.left,
        h = d.top,
        p,
        q,
        u,
        t,
        z = [],
        y = [],
        A = a.translatedValue,
        E = a.value,
        D = a.force;
      if (e.options.isStock && !1 !== a.acrossPanes && "xAxis" === d.coll || "yAxis" === d.coll) {
        a.preventDefault();
        y = c(d.coll);
        var F = d.isXAxis ? e.yAxis : e.xAxis;
        F.forEach(function (a) {
          if (m(a.options.id) ? -1 === a.options.id.indexOf("navigator") : 1) {
            var b = a.isXAxis ? "yAxis" : "xAxis";
            b = m(a.options[b]) ? e[b][a.options[b]] : e[b][0];
            d === b && y.push(a);
          }
        });
        var G = y.length ? [] : [d.isXAxis ? e.yAxis[0] : e.xAxis[0]];
        y.forEach(function (a) {
          -1 !== G.indexOf(a) || C(G, function (b) {
            return b.pos === a.pos && b.len === a.len;
          }) || G.push(a);
        });
        var H = v(A, d.translate(E, null, null, a.old));
        I(H) && (d.horiz ? G.forEach(function (a) {
          var c;
          q = a.pos;
          t = q + a.len;
          p = u = Math.round(H + d.transB);
          "pass" !== D && (p < b || p > b + d.width) && (D ? p = u = n(p, b, b + d.width) : c = !0);
          c || z.push(["M", p, q], ["L", u, t]);
        }) : G.forEach(function (a) {
          var b;
          p = a.pos;
          u = p + a.len;
          q = t = Math.round(h + d.height - H);
          "pass" !== D && (q < h || q > h + d.height) && (D ? q = t = n(q, h, h + d.height) : b = !0);
          b || z.push(["M", p, q], ["L", u, t]);
        }));
        a.path = 0 < z.length ? g.crispPolyLine(z, a.lineWidth || 1) : null;
      }
    });
    H.prototype.crispPolyLine = function (a, c) {
      for (var d = 0; d < a.length; d += 2) {
        var f = a[d],
          e = a[d + 1];
        f[1] === e[1] && (f[1] = e[1] = Math.round(f[1]) - c % 2 / 2);
        f[2] === e[2] && (f[2] = e[2] = Math.round(f[2]) + c % 2 / 2);
      }
      return a;
    };
    d(h, "afterHideCrosshair", function () {
      this.crossLabel && (this.crossLabel = this.crossLabel.hide());
    });
    d(h, "afterDrawCrosshair", function (a) {
      var d, f;
      if (this.crosshair && this.crosshair.label && this.crosshair.label.enabled && this.cross && I(this.min) && I(this.max)) {
        var h = this.chart,
          e = this.logarithmic,
          g = this.crosshair.label,
          b = this.horiz,
          m = this.opposite,
          n = this.left,
          p = this.top,
          q = this.crossLabel,
          u = g.format,
          t = "",
          z = "inside" === this.options.tickPosition,
          y = !1 !== this.crosshair.snap,
          A = 0,
          C = a.e || this.cross && this.cross.e;
        a = a.point;
        var D = this.min,
          F = this.max;
        e && (D = e.lin2log(D), F = e.lin2log(F));
        e = b ? "center" : m ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";
        q || (q = this.crossLabel = h.renderer.label("", 0, void 0, g.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (a ? a.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({
          align: g.align || e,
          padding: v(g.padding, 8),
          r: v(g.borderRadius, 3),
          zIndex: 2
        }).add(this.labelGroup), h.styledMode || q.attr({
          fill: g.backgroundColor || a && a.series && a.series.color || "#666666",
          stroke: g.borderColor || "",
          "stroke-width": g.borderWidth || 0
        }).css(E({
          color: "#ffffff",
          fontWeight: "normal",
          fontSize: "11px",
          textAlign: "center"
        }, g.style || {})));
        b ? (e = y ? (a.plotX || 0) + n : C.chartX, p += m ? 0 : this.height) : (e = m ? this.width + n : 0, p = y ? (a.plotY || 0) + p : C.chartY);
        u || g.formatter || (this.dateTime && (t = "%b %d, %Y"), u = "{value" + (t ? ":" + t : "") + "}");
        t = y ? this.isXAxis ? a.x : a.y : this.toValue(b ? C.chartX : C.chartY);
        y = a ? a.series.isPointInside(a) : I(t) && t > D && t < F;
        C = "";
        u ? C = c(u, {
          value: t
        }, h) : g.formatter && I(t) && (C = g.formatter.call(this, t));
        q.attr({
          text: C,
          x: e,
          y: p,
          visibility: y ? "visible" : "hidden"
        });
        g = q.getBBox();
        if (I(q.y)) if (b) {
          if (z && !m || !z && m) p = q.y - g.height;
        } else p = q.y - g.height / 2;
        b ? (d = n - g.x, f = n + this.width - g.x) : (d = "left" === this.labelAlign ? n : 0, f = "right" === this.labelAlign ? n + this.width : h.chartWidth);
        q.translateX < d && (A = d - q.translateX);
        q.translateX + g.width >= f && (A = -(q.translateX + g.width - f));
        q.attr({
          x: e + A,
          y: p,
          anchorX: b ? e : this.opposite ? 0 : h.chartWidth,
          anchorY: b ? this.opposite ? h.chartHeight : 0 : p + g.height / 2
        });
      }
    });
    G.prototype.forceCropping = function () {
      var a = this.chart,
        c = this.options.dataGrouping;
      return !1 !== this.allowDG && c && v(c.enabled, a.options.isStock);
    };
    d(A, "update", function (a) {
      a = a.options;
      "scrollbar" in a && this.navigator && (K(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}, !1), delete a.scrollbar);
    });
    return y;
  });
  N(h, "masters/modules/stock.src.js", [h["Core/Globals.js"], h["Core/Axis/OrdinalAxis.js"], h["Series/DataModifyComposition.js"], h["Core/Scrollbar.js"], h["Core/Chart/StockChart.js"]], function (d, h, A, F, t) {
    d.Scrollbar = F;
    d.StockChart = d.stockChart = t.stockChart;
    F.compose(d.Axis);
    h.compose(d.Axis, d.Series, d.Chart);
    A.compose(d.Series, d.Axis, d.Point);
  });
  N(h, "masters/highstock.src.js", [h["masters/highcharts.src.js"]], function (d) {
    d.product = "Highstock";
    return d;
  });
  h["masters/highstock.src.js"]._modules = h;
  return h["masters/highstock.src.js"];
});
//# sourceMappingURL=highstock.js.map

/***/ }),

/***/ 92185:
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/_esm2015/internal/AsyncSubject.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsyncSubject": () => (/* binding */ AsyncSubject)
/* harmony export */ });
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Subject */ 8929);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subscription */ 24096);


class AsyncSubject extends _Subject__WEBPACK_IMPORTED_MODULE_0__.Subject {
  constructor() {
    super(...arguments);
    this.value = null;
    this.hasNext = false;
    this.hasCompleted = false;
  }
  _subscribe(subscriber) {
    if (this.hasError) {
      subscriber.error(this.thrownError);
      return _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription.EMPTY;
    } else if (this.hasCompleted && this.hasNext) {
      subscriber.next(this.value);
      subscriber.complete();
      return _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription.EMPTY;
    }
    return super._subscribe(subscriber);
  }
  next(value) {
    if (!this.hasCompleted) {
      this.value = value;
      this.hasNext = true;
    }
  }
  error(error) {
    if (!this.hasCompleted) {
      super.error(error);
    }
  }
  complete() {
    this.hasCompleted = true;
    if (this.hasNext) {
      super.next(this.value);
    }
    super.complete();
  }
}
//# sourceMappingURL=AsyncSubject.js.map

/***/ }),

/***/ 34120:
/*!*************************************************************************!*\
  !*** ./node_modules/angular-highcharts/fesm2020/angular-highcharts.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

var highcharts__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
var highcharts_highstock__WEBPACK_IMPORTED_MODULE_2___namespace_cache;
var highcharts_highmaps__WEBPACK_IMPORTED_MODULE_1___namespace_cache;
var highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_3___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Chart": () => (/* binding */ Chart),
/* harmony export */   "ChartDirective": () => (/* binding */ ChartDirective),
/* harmony export */   "ChartModule": () => (/* binding */ ChartModule),
/* harmony export */   "HIGHCHARTS_MODULES": () => (/* binding */ HIGHCHARTS_MODULES),
/* harmony export */   "HighchartsGantt": () => (/* binding */ HighchartsGantt),
/* harmony export */   "MapChart": () => (/* binding */ MapChart),
/* harmony export */   "StockChart": () => (/* binding */ StockChart)
/* harmony export */ });
/* harmony import */ var highcharts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! highcharts */ 93470);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 92185);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/core */ 94650);
/* harmony import */ var highcharts_highmaps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! highcharts/highmaps */ 81220);
/* harmony import */ var highcharts_highstock__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! highcharts/highstock */ 16150);
/* harmony import */ var highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! highcharts/highcharts-gantt */ 21700);







class Chart {
  constructor(options = {
    series: []
  }) {
    this.options = options;
    this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
    this.ref$ = this.refSubject.asObservable();
  }
  /**
   * Add Point
   * @param point         Highcharts.DataPoint, number touple or number
   * @param serieIndex    Index position of series. This defaults to 0.
   * @param redraw        Flag whether or not to redraw point. This defaults to true.
   * @param shift         Shift point to the start of series. This defaults to false.
   */
  addPoint(point, serieIndex = 0, redraw = true, shift = false) {
    this.ref$.subscribe(chart => {
      if (chart.series.length > serieIndex) {
        chart.series[serieIndex].addPoint(point, redraw, shift);
      }
    });
  }
  /**
   * Add Series
   * @param series        Series Configuration
   * @param redraw        Flag whether or not to redraw series. This defaults to true.
   * @param animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
   */
  addSeries(series, redraw = true, animation) {
    this.ref$.subscribe(chart => {
      chart.addSeries(series, redraw, animation);
    });
  }
  /**
   * Remove Point
   * @param pointIndex    Index of Point
   * @param serieIndex    Specified Index of Series. Defaults to 0.
   */
  removePoint(pointIndex, serieIndex = 0) {
    this.ref$.subscribe(chart => {
      if (chart.series.length > serieIndex && chart.series[serieIndex].data.length > pointIndex) {
        chart.series[serieIndex].removePoint(pointIndex, true);
      }
    });
  }
  /**
   * Remove Series
   * @param seriesIndex    Index position of series to remove.
   */
  removeSeries(seriesIndex) {
    this.ref$.subscribe(chart => {
      if (chart.series.length > seriesIndex) {
        chart.series[seriesIndex].remove(true);
      }
    });
  }
  init(el) {
    if (!this.ref) {
      highcharts__WEBPACK_IMPORTED_MODULE_0__.chart(el.nativeElement, this.options, chart => {
        if (!this.ref) {
          // TODO: workaround for doubled callbacks on exporting charts: issue #238
          this.refSubject.next(chart);
          this.ref = chart;
          this.refSubject.complete();
        }
      });
    }
  }
  destroy() {
    if (this.ref) {
      this.options = this.ref.options;
      this.ref.destroy();
      this.ref = undefined;
      // new init subject
      this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
      this.ref$ = this.refSubject.asObservable();
    }
  }
}

// import * as Highcharts from 'highcharts';
/**
 * @license
 * Copyright Felix Itzenplitz. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at
 * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
 */
class MapChart {
  constructor(options = {
    series: []
  }) {
    this.options = options;
    this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
    this.ref$ = this.refSubject.asObservable();
  }
  init(el) {
    if (!this.ref) {
      highcharts_highmaps__WEBPACK_IMPORTED_MODULE_1__.mapChart(el.nativeElement, this.options, chart => {
        if (!this.ref) {
          // TODO: workaround for doubled callbacks on exporting charts: issue #238
          this.refSubject.next(chart);
          this.ref = chart;
          this.refSubject.complete();
        }
      });
    }
  }
  destroy() {
    if (this.ref) {
      this.options = this.ref.options;
      this.ref.destroy();
      this.ref = undefined;
      // new init subject
      this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
      this.ref$ = this.refSubject.asObservable();
    }
  }
}

//import * as Highcharts from 'highcharts';
/**
 * @license
 * Copyright Felix Itzenplitz. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at
 * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
 *
 * @author Felix Itzenplitz
 * @author Timothy A. Perez (contributor)
 */
class StockChart {
  constructor(options = {
    series: []
  }) {
    this.options = options;
    this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
    this.ref$ = this.refSubject.asObservable();
  }
  init(el) {
    if (!this.ref) {
      highcharts_highstock__WEBPACK_IMPORTED_MODULE_2__.stockChart(el.nativeElement, this.options, chart => {
        if (!this.ref) {
          // TODO: workaround for doubled callbacks on exporting charts: issue #238
          this.refSubject.next(chart);
          this.ref = chart;
          this.refSubject.complete();
        }
      });
    }
  }
  destroy() {
    if (this.ref) {
      this.options = this.ref.options;
      this.ref.destroy();
      this.ref = undefined;
      // new init subject
      this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
      this.ref$ = this.refSubject.asObservable();
    }
  }
}

/**
 * @license
 * Copyright Felix Itzenplitz. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at
 * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
 */
class HighchartsGantt {
  constructor(options = {
    series: []
  }) {
    this.options = options;
    this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
    this.ref$ = this.refSubject.asObservable();
  }
  init(el) {
    if (!this.ref) {
      highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_3__.ganttChart(el.nativeElement, this.options, chart => {
        if (!this.ref) {
          // TODO: workaround for doubled callbacks on exporting charts: issue #238
          this.refSubject.next(chart);
          this.ref = chart;
          this.refSubject.complete();
        }
      });
    }
  }
  destroy() {
    if (this.ref) {
      this.options = this.ref.options;
      this.ref.destroy();
      this.ref = undefined;
      // new init subject
      this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
      this.ref$ = this.refSubject.asObservable();
    }
  }
}

/**
 * @license
 * Copyright Felix Itzenplitz. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at
 * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
 */
class ChartDirective {
  constructor(el) {
    this.el = el;
  }
  ngOnChanges(changes) {
    if (!changes.chart.isFirstChange()) {
      this.destroy();
      this.init();
    }
  }
  ngOnInit() {
    this.init();
  }
  ngOnDestroy() {
    this.destroy();
  }
  init() {
    if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart || this.chart instanceof HighchartsGantt) {
      this.chart.init(this.el);
    }
  }
  destroy() {
    if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart || this.chart instanceof HighchartsGantt) {
      this.chart.destroy();
    }
  }
}
/** @nocollapse */ /** @nocollapse */
ChartDirective.ɵfac = function ChartDirective_Factory(t) {
  return new (t || ChartDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_5__.ElementRef));
};
/** @nocollapse */ /** @nocollapse */
ChartDirective.ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineDirective"]({
  type: ChartDirective,
  selectors: [["", "chart", ""]],
  inputs: {
    chart: "chart"
  },
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵNgOnChangesFeature"]]
});
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵsetClassMetadata"](ChartDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Directive,
    args: [{
      selector: '[chart]'
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.ElementRef
    }];
  }, {
    chart: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input
    }]
  });
})();

/**
 * @license
 * Copyright Felix Itzenplitz. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at
 * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
 */
let HIGHCHARTS_MODULES = new _angular_core__WEBPACK_IMPORTED_MODULE_5__.InjectionToken('HighchartsModules');
class ChartService {
  constructor(chartModules) {
    this.chartModules = chartModules;
  }
  initModules() {
    this.chartModules.forEach(chartModule => {
      [/*#__PURE__*/ (highcharts__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (highcharts__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(highcharts__WEBPACK_IMPORTED_MODULE_0__, 2))), /*#__PURE__*/ (highcharts_highstock__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (highcharts_highstock__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(highcharts_highstock__WEBPACK_IMPORTED_MODULE_2__, 2))), /*#__PURE__*/ (highcharts_highmaps__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (highcharts_highmaps__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(highcharts_highmaps__WEBPACK_IMPORTED_MODULE_1__, 2))), /*#__PURE__*/ (highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_3___namespace_cache || (highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_3___namespace_cache = __webpack_require__.t(highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_3__, 2)))].forEach(chartModule);
    });
  }
}
/** @nocollapse */ /** @nocollapse */
ChartService.ɵfac = function ChartService_Factory(t) {
  return new (t || ChartService)(_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵinject"](HIGHCHARTS_MODULES));
};
/** @nocollapse */ /** @nocollapse */
ChartService.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineInjectable"]({
  token: ChartService,
  factory: ChartService.ɵfac
});
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵsetClassMetadata"](ChartService, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Injectable
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Inject,
        args: [HIGHCHARTS_MODULES]
      }]
    }];
  }, null);
})();

/**
 * @license
 * Copyright Felix Itzenplitz. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at
 * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
 */
class ChartModule {
  constructor(cs) {
    this.cs = cs;
    this.cs.initModules();
  }
}
/** @nocollapse */ /** @nocollapse */
ChartModule.ɵfac = function ChartModule_Factory(t) {
  return new (t || ChartModule)(_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵinject"](ChartService));
};
/** @nocollapse */ /** @nocollapse */
ChartModule.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineNgModule"]({
  type: ChartModule
});
/** @nocollapse */ /** @nocollapse */
ChartModule.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineInjector"]({
  providers: [{
    provide: HIGHCHARTS_MODULES,
    useValue: []
  }, ChartService]
});
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵsetClassMetadata"](ChartModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.NgModule,
    args: [{
      exports: [ChartDirective],
      declarations: [ChartDirective],
      providers: [{
        provide: HIGHCHARTS_MODULES,
        useValue: []
      }, ChartService]
    }]
  }], function () {
    return [{
      type: ChartService
    }];
  }, null);
})();

/*
 * Public API Surface of angular-highcharts
 */

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=angular-highcharts.mjs.map

/***/ })

}]);